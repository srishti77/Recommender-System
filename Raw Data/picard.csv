ProjectName,methodName,methodBody
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AbstractWgsMetricsCollector.java,AbstractWgsMetricsCollector," (CollectWgsMetrics collectWgsMetrics final int coverageCap final IntervalList intervals){ if (coverageCap <= 0) { throw new IllegalArgumentException(""Coverage cap must be positive.""); } this.collectWgsMetrics=collectWgsMetrics; unfilteredDepthHistogramArray=new long[coverageCap + 1]; highQualityDepthHistogramArray=new long[coverageCap + 1]; unfilteredBaseQHistogramArray=new long[Byte.MAX_VALUE]; this.coverageCap=coverageCap; this.intervals=intervals; this.usingStopAfter=collectWgsMetrics.STOP_AFTER > 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AbstractWgsMetricsCollector.java,addBaseQHistogram,protected void  (final MetricsFile<CollectWgsMetrics.WgsMetrics Integer> file){ file.addHistogram(getUnfilteredBaseQHistogram()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AdapterUtility.java,AdapterUtility,public  (final List<String> adapterSequence){ adapterKmers=prepareAdapterSequences(adapterSequence); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AdapterUtility.java,isAdapterSequence,public boolean  (final byte[] read){ if (read.length < ADAPTER_MATCH_LENGTH) return false; for ( final byte[] adapter : adapterKmers) { int errors=0; for (int i=0; i < adapter.length; ++i) { if (read[i] != adapter[i] && ++errors > MAX_ADAPTER_ERRORS) { break; } } if (errors <= MAX_ADAPTER_ERRORS) return true; } return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AdapterUtility.java,prepareAdapterSequences,private static byte[][]  (final List<String> adapterSequence){ final Set<String> kmers=new HashSet<>(); for ( final String seq : adapterSequence) { for (int i=0; i <= seq.length() - ADAPTER_MATCH_LENGTH; ++i) { final String kmer=seq.substring(i i + ADAPTER_MATCH_LENGTH).toUpperCase(); int ns=0; for ( final char ch : kmer.toCharArray()) if (ch == 'N') ++ns; if (ns <= MAX_ADAPTER_ERRORS) { kmers.add(kmer); kmers.add(SequenceUtil.reverseComplement(kmer)); } } } final byte[][] adapterKmers=new byte[kmers.size()][]; int i=0; for ( final String kmer : kmers) { adapterKmers[i++]=StringUtil.stringToBytes(kmer); } return adapterKmers; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AlignmentSummaryMetricsCollector.java,AlignmentSummaryMetricsCollector,public  (final Set<MetricAccumulationLevel> accumulationLevels final List<SAMReadGroupRecord> samRgRecords final boolean doRefMetrics final List<String> adapterSequence final int maxInsertSize final Set<PairOrientation> expectedOrientations final boolean isBisulfiteSequenced){ this.doRefMetrics=doRefMetrics; this.adapterUtility=new AdapterUtility(adapterSequence); this.maxInsertSize=maxInsertSize; this.expectedOrientations=expectedOrientations; this.isBisulfiteSequenced=isBisulfiteSequenced; setup(accumulationLevels samRgRecords); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AlignmentSummaryMetricsCollector.java,GroupAlignmentSummaryMetricsPerUnitMetricCollector,public  (final String sample final String library final String readGroup){ this.sample=sample; this.library=library; this.readGroup=readGroup; unpairedCollector=new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED sample library readGroup); firstOfPairCollector=new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR sample library readGroup); secondOfPairCollector=new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR sample library readGroup); pairCollector=new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR sample library readGroup); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AlignmentSummaryMetricsCollector.java,IndividualAlignmentSummaryMetricsCollector,public  (final AlignmentSummaryMetrics.Category pairingCategory final String sample final String library final String readGroup){ metrics=new AlignmentSummaryMetrics(); metrics.CATEGORY=pairingCategory; metrics.SAMPLE=sample; metrics.LIBRARY=library; metrics.READ_GROUP=readGroup; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AlignmentSummaryMetricsCollector.java,acceptRecord,public void  (final SAMRecordAndReference args){ final SAMRecord rec=args.getSamRecord(); final ReferenceSequence ref=args.getReferenceSequence(); if (rec.getReadPairedFlag()) { if (rec.getFirstOfPairFlag()) { firstOfPairCollector.addRecord(rec ref); } else { secondOfPairCollector.addRecord(rec ref); } pairCollector.addRecord(rec ref); } else { unpairedCollector.addRecord(rec ref); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AlignmentSummaryMetricsCollector.java,addMetricsToFile,@Override public void  (final MetricsFile<AlignmentSummaryMetrics Comparable<?>> file){ if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) { pairCollector.getMetrics().BAD_CYCLES=firstOfPairCollector.getMetrics().BAD_CYCLES + secondOfPairCollector.get
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AlignmentSummaryMetricsCollector.java,addRecord,public void  (final SAMRecord record final ReferenceSequence ref){ if (record.getNotPrimaryAlignmentFlag()) { return; } collectReadData(record); collectQualityData(record ref); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AlignmentSummaryMetricsCollector.java,collectQualityData,private void  (final SAMRecord record final ReferenceSequence reference){ if (record.getReadUnmappedFlag() || record.getReadFailsVendorQualityCheckFlag() || !doRefMetrics) { final byte[] readBases=record.getReadBases(); for (int i=0; i < readBases.length; i++) { if (SequenceUtil.isNoCall(readBases[i])) { badCycleHistogram.increment(CoordMath.getCycle(record.getReadNegativeStrandFlag() readBases.length i)); } } } else if (!record.getReadFailsVendorQualityCheckFlag()) { final boolean highQualityMapping=isHighQualityMapping(record); if (highQualityMapping && !record.getSupplementaryAlignmentFlag()) metrics.PF_HQ_ALIGNED_READS++; final byte[] readBases=record.getReadBases(); final byte[] refBases=reference.getBases(); final byte[] qualities=record.getBaseQualities(); final int refLength=refBases.length; long mismatchCount=0; long hqMismatchCount=0; for ( final AlignmentBlock alignmentBlock : record.getAlignmentBlocks()) { final int readIndex=alignmentBlock.getReadStart() - 1; final int refIndex=alignmentBlock.getReferenceStart() - 1; final int length=alignmentBlock.getLength(); for (int i=0; i < length && refIndex + i < refLength; ++i) { final int readBaseIndex=readIndex + i; boolean mismatch=!SequenceUtil.basesEqual(readBases[readBaseIndex] refBases[refIndex + i]); final boolean bisulfiteMatch=isBisulfiteSequenced && SequenceUtil.bisulfiteBasesEqual(record.getReadNegativeStrandFlag() readBases[readBaseIndex] refBases[readBaseIndex]); final boolean bisulfiteBase=mismatch && bisulfiteMatch; mismatch=mismatch && !bisulfiteMatch; if (mismatch) mismatchCount++; metrics.PF_ALIGNED_BASES++; if (!bisulfiteBase) nonBisulfiteAlignedBases++; if (highQualityMapping) { metrics.PF_HQ_ALIGNED_BASES++; if (!bisulfiteBase) hqNonBisulfiteAlignedBases++; if (qualities[readBaseIndex] >= BASE_QUALITY_THRESHOLD) metrics.PF_HQ_ALIGNED_Q20_BASES++; if (mismatch) hqMismatchCount++; } if (mismatch || SequenceUtil.isNoCall(readBases[readBaseIndex])) { badCycleHistogram.increment(CoordMath.getCycle(record.getReadNegativeStrandFlag() readBases.length i)); } } } mismatchHistogram.increment(mismatchCount); hqMismatchHistogram.increment(hqMismatchCount); for ( final CigarElement elem : record.getCigar().getCigarElements()) { final CigarOperator op=elem.getOperator(); if (op == CigarOperator.INSERTION || op == CigarOperator.DELETION) ++this.indels; } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AlignmentSummaryMetricsCollector.java,collectReadData,private void  (final SAMRecord record){ if (record.getSupplementaryAlignmentFlag()) return; metrics.TOTAL_READS++; readLengthHistogram.increment(record.getReadBases().length); if (!record.getReadFailsVendorQualityCheckFlag()) { metrics.PF_READS++; if (isNoiseRead(record)) metrics.PF_NOISE_READS++; if (record.getReadUnmappedFlag()) { final byte[] readBases=record.getReadBases(); if (!(record instanceof BAMRecord)) StringUtil.toUpperCase(readBases); if (adapterUtility.isAdapterSequence(readBases)) { this.adapterReads++; } } else if (doRefMetrics) { metrics.PF_READS_ALIGNED++; if (record.getReadPairedFlag() && !record.getProperPairFlag()) metrics.PF_READS_IMPROPER_PAIRS++; if (!record.getReadNegativeStrandFlag()) numPositiveStrand++; if (record.getReadPairedFlag() && !record.getMateUnmappedFlag()) { metrics.READS_ALIGNED_IN_PAIRS++; final Integer mateMq=record.getIntegerAttribute(SAMTag.MQ.toString()); if (mateMq == null || mateMq >= MAPPING_QUALITY_THRESHOLD && record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD) { ++this.chimerasDenominator; if (ChimeraUtil.isChimeric(record maxInsertSize expectedOrientations)) { ++this.chimeras; } } } else { if (record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD) { ++this.chimerasDenominator; if (record.getAttribute(SAMTag.SA.toString()) != null) ++this.chimeras; } } } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AlignmentSummaryMetricsCollector.java,finish,@Override public void  (){ unpairedCollector.onComplete(); firstOfPairCollector.onComplete(); secondOfPairCollector.onComplete(); pairCollector.onComplete(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AlignmentSummaryMetricsCollector.java,getMetrics,public AlignmentSummaryMetrics  (){ return this.metrics; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AlignmentSummaryMetricsCollector.java,isHighQualityMapping,private boolean  (final SAMRecord record){ return !record.getReadFailsVendorQualityCheckFlag() && record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AlignmentSummaryMetricsCollector.java,isNoiseRead,private boolean  (final SAMRecord record){ final Object noiseAttribute=record.getAttribute(ReservedTagConstants.XN); return (noiseAttribute != null && noiseAttribute.equals(1)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AlignmentSummaryMetricsCollector.java,makeChildCollector,@Override protected PerUnitMetricCollector<AlignmentSummaryMetrics Comparable<?> SAMRecordAndReference>  (String sample String library String readGroup){ return new GroupAlignmentSummaryMetricsPerUnitMetricCollector(sample library readGroup); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\AlignmentSummaryMetricsCollector.java,onComplete,public void  (){ if (metrics.TOTAL_READS > 0) { metrics.PCT_PF_READS=(double)metrics.PF_READS / (double)metrics.TOTAL_READS; metrics.PCT_ADAPTER=this.adapterReads / (double)metrics.PF_READS; metrics.MEAN_READ_LENGTH=readLengthHistogram.getMean(); metrics.BAD_CYCLES=0; for ( final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) { final double badCyclePercentage=cycleBin.getValue() / metrics.TOTAL_READS; if (badCyclePercentage >= 0.8) { metrics.BAD_CYCLES++; } } if (doRefMetrics) { if (metrics.PF_READS > 0) metrics.PCT_PF_READS_ALIGNED=(double)metrics.PF_READS_ALIGNED / (double)metrics.PF_READS; if (metrics.PF_READS_ALIGNED > 0) metrics.PCT_READS_ALIGNED_IN_PAIRS=(double)metrics.READS_ALIGNED_IN_PAIRS / (double)metrics.PF_READS_ALIGNED; if (metrics.PF_READS_ALIGNED > 0) metrics.PCT_PF_READS_IMPROPER_PAIRS=(double)metrics.PF_READS_IMPROPER_PAIRS / (double)metrics.PF_READS_ALIGNED; if (metrics.PF_READS_ALIGNED > 0) metrics.STRAND_BALANCE=numPositiveStrand / (double)metrics.PF_READS_ALIGNED; if (this.chimerasDenominator > 0) metrics.PCT_CHIMERAS=this.chimeras / (double)this.chimerasDenominator; if (nonBisulfiteAlignedBases > 0) metrics.PF_MISMATCH_RATE=mismatchHistogram.getSum() / (double)nonBisulfiteAlignedBases; metrics.PF_HQ_MEDIAN_MISMATCHES=hqMismatchHistogram.getMedian(); if (hqNonBisulfiteAlignedBases > 0) metrics.PF_HQ_ERROR_RATE=hqMismatchHistogram.getSum() / (double)hqNonBisulfiteAlignedBases; if (metrics.PF_ALIGNED_BASES > 0) metrics.PF_INDEL_RATE=this.indels / (double)metrics.PF_ALIGNED_BASES; } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ContextAccumulator.java,ContextAccumulator,"public  (final Set<String> contexts final boolean expectedTandemReads){ this.expectedTandemReads=expectedTandemReads; this.artifactMap=new HashMap<>(); for ( final String context : contexts) { if ((context.length() & 1) == 0) throw new PicardException(""Contexts cannot have an even number of bases: "" + context); final AlignmentAccumulator[] accumulators=new AlignmentAccumulator[Transition.Base.values().length]; for (int i=0; i < Transition.Base.values().length; i++) { accumulators[i]=new AlignmentAccumulator(); } this.artifactMap.put(context accumulators); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ContextAccumulator.java,calculateMetrics,"public ListMap<Transition DetailPair>  (final String sampleAlias final String library){ final ListMap<Transition DetailPair> detailMetricsMap=new ListMap<>(); for ( final String context : new TreeSet<>(artifactMap.keySet())) { if ((context.length() & 1) == 0) throw new PicardException(""Contexts cannot have an even number of bases: "" + context + "". This should never happen here!""); final char refBase=context.charAt(context.length() / 2); for ( final Transition.Base altBase : Transition.Base.values()) { final Transition transition=Transition.transitionOf(refBase (char)altBase.base); final PreAdapterDetailMetrics preAdapterDetailMetrics=new PreAdapterDetailMetrics(); final BaitBiasDetailMetrics baitBiasDetailMetrics=new BaitBiasDetailMetrics(); preAdapterDetailMetrics.SAMPLE_ALIAS=sampleAlias; preAdapterDetailMetrics.LIBRARY=library; preAdapterDetailMetrics.CONTEXT=context; preAdapterDetailMetrics.REF_BASE=transition.ref(); preAdapterDetailMetrics.ALT_BASE=transition.call(); baitBiasDetailMetrics.SAMPLE_ALIAS=sampleAlias; baitBiasDetailMetrics.LIBRARY=library; baitBiasDetailMetrics.CONTEXT=context; baitBiasDetailMetrics.REF_BASE=transition.ref(); baitBiasDetailMetrics.ALT_BASE=transition.call(); final AlignmentAccumulator[] accumulators=artifactMap.get(context); final AlignmentAccumulator[] reverseCompAccumulators=artifactMap.get(SequenceUtil.reverseComplement(context)); final AlignmentAccumulator fwdRefAlignments=accumulators[Transition.baseIndexMap[transition.ref()]]; final AlignmentAccumulator fwdAltAlignments=accumulators[Transition.baseIndexMap[transition.call()]]; final AlignmentAccumulator revRefAlignments=reverseCompAccumulators[Transition.baseIndexMap[transition.complement().ref()]]; final AlignmentAccumulator revAltAlignments=reverseCompAccumulators[Transition.baseIndexMap[transition.complement().call()]]; if (expectedTandemReads) { preAdapterDetailMetrics.PRO_REF_BASES=fwdRefAlignments.R1_POS + fwdRefAlignments.R2_POS + revRefAlignments.R1_NEG+ revRefAlignments.R2_NEG; preAdapterDetailMetrics.PRO_ALT_BASES=fwdAltAlignments.R1_POS + fwdAltAlignments.R2_POS + revAltAlignments.R1_NEG+ revAltAlignments.R2_NEG; preAdapterDetailMetrics.CON_REF_BASES=fwdRefAlignments.R1_NEG + fwdRefAlignments.R2_NEG + revRefAlignments.R1_POS+ revRefAlignments.R2_POS; preAdapterDetailMetrics.CON_ALT_BASES=fwdAltAlignments.R1_NEG + fwdAltAlignments.R2_NEG + revAltAlignments.R1_POS+ revAltAlignments.R2_POS; } else { preAdapterDetailMetrics.PRO_REF_BASES=fwdRefAlignments.R1_POS + fwdRefAlignments.R2_NEG + revRefAlignments.R1_NEG+ revRefAlignments.R2_POS; preAdapterDetailMetrics.PRO_ALT_BASES=fwdAltAlignments.R1_POS + fwdAltAlignments.R2_NEG + revAltAlignments.R1_NEG+ revAltAlignments.R2_POS; preAdapterDetailMetrics.CON_REF_BASES=fwdRefAlignments.R1_NEG + fwdRefAlignments.R2_POS + revRefAlignments.R1_POS+ revRefAlignments.R2_NEG; preAdapterDetailMetrics.CON_ALT_BASES=fwdAltAlignments.R1_NEG + fwdAltAlignments.R2_POS + revAltAlignments.R1_POS+ revAltAlignments.R2_NEG; } baitBiasDetailMetrics.FWD_CXT_REF_BASES=fwdRefAlignments.R1_POS + fwdRefAlignments.R1_NEG + fwdRefAlignments.R2_POS+ fwdRefAlignments.R2_NEG; baitBiasDetailMetrics.FWD_CXT_ALT_BASES=fwdAltAlignments.R1_POS + fwdAltAlignments.R1_NEG + fwdAltAlignments.R2_POS+ fwdAltAlignments.R2_NEG; baitBiasDetailMetrics.REV_CXT_REF_BASES=revRefAlignments.R1_POS + revRefAlignments.R1_NEG + revRefAlignments.R2_POS+ revRefAlignments.R2_NEG; baitBiasDetailMetrics.REV_CXT_ALT_BASES=revAltAlignments.R1_POS + revAltAlignments.R1_NEG + revAltAlignments.R2_POS+ revAltAlignments.R2_NEG; preAdapterDetailMetrics.calculateDerivedStatistics(); baitBiasDetailMetrics.calculateDerivedStatistics(); detailMetricsMap.add(transition new DetailPair(preAdapterDetailMetrics baitBiasDetailMetrics)); } } return detailMetricsMap; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ContextAccumulator.java,countRecord,private void  (final SAMRecord rec){ final boolean isNegativeStrand=rec.getReadNegativeStrandFlag(); final boolean isReadTwo=rec.getReadPairedFlag() && rec.getSecondOfPairFlag(); if (isReadTwo) { if (isNegativeStrand) this.R2_NEG++; else this.R2_POS++; } else { if (isNegativeStrand) this.R1_NEG++; else this.R1_POS++; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ContextAccumulator.java,fillHalfRecords,public void  (final ContextAccumulator fullContextAccumulator final int contextSize){ final String padding=StringUtil.repeatCharNTimes('N' contextSize); for ( Map.Entry<String AlignmentAccumulator[]> fullContext : fullContextAccumulator.artifactMap.entrySet()) { final String fullContextKey=fullContext.getKey(); final char centralBase=fullContextKey.charAt(contextSize); final String leadingContextKey=fullContextKey.substring(0 contextSize) + centralBase + padding; final String trailingContextKey=padding + centralBase + fullContextKey.substring(contextSize + 1 fullContextKey.length()); final AlignmentAccumulator[] trailingAlignmentAccumulators=this.artifactMap.get(trailingContextKey); final AlignmentAccumulator[] leadingAlignmentAccumulators=this.artifactMap.get(leadingContextKey); final AlignmentAccumulator[] fullAlignmentAccumulators=fullContext.getValue(); for (int i=0; i < fullAlignmentAccumulators.length; i++) { trailingAlignmentAccumulators[i].merge(fullAlignmentAccumulators[i]); leadingAlignmentAccumulators[i].merge(fullAlignmentAccumulators[i]); } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ContextAccumulator.java,fillZeroRecords,public void  (final ContextAccumulator fullContextAccumulator final int contextSize){ final String padding=StringUtil.repeatCharNTimes('N' contextSize); for ( Map.Entry<String AlignmentAccumulator[]> fullContext : fullContextAccumulator.artifactMap.entrySet()) { final String fullContextKey=fullContext.getKey(); final char centralBase=fullContextKey.charAt(contextSize); final String zeroContextKey=padding + centralBase + padding; final AlignmentAccumulator[] zeroAlignmentAccumulators=this.artifactMap.get(zeroContextKey); final AlignmentAccumulator[] fullAlignmentAccumulators=fullContext.getValue(); for (int i=0; i < fullAlignmentAccumulators.length; i++) { zeroAlignmentAccumulators[i].merge(fullAlignmentAccumulators[i]); } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ContextAccumulator.java,merge,private void  (final AlignmentAccumulator other){ this.R1_POS=this.R1_POS + other.R1_POS; this.R2_POS=this.R2_POS + other.R2_POS; this.R1_NEG=this.R1_NEG + other.R1_NEG; this.R2_NEG=this.R2_NEG + other.R2_NEG; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ConvertSequencingArtifactToOxoG.java,doWork,@Override protected int  (){ if (OUTPUT_BASE == null) { OUTPUT_BASE=INPUT_BASE; } final File PRE_ADAPTER_IN=new File(INPUT_BASE + SequencingArtifactMetrics.PRE_ADAPTER_DETAILS_EXT); final File BAIT_BIAS_IN=new File(INPUT_BASE + SequencingArtifactMetrics.B
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ConvertSequencingArtifactToOxoG.java,isOxoG,private boolean  (final Transition t){ return t.equals(Transition.CtoA) || t.equals(Transition.GtoT); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ArtifactCounter.java,ArtifactCounter,public  (final String sampleAlias final String library final int contextSize final boolean expectedTandemReads){ this.sampleAlias=sampleAlias; this.library=library; this.contextSize=contextSize; final HashSet<String> fullContexts=new HashSet<>(); for ( final byte[] kmer : SequenceUtil.generateAllKmers(2 * contextSize + 1)) { fullContexts.add(StringUtil.bytesToString(kmer)); } final Set<String> zeroContexts=new HashSet<>(); final String padding=StringUtil.repeatCharNTimes('N' contextSize); for ( final String context : fullContexts) { final char centralBase=context.charAt(contextSize); final String leading=context.substring(0 contextSize) + centralBase + padding; final String trailing=padding + centralBase + context.substring(contextSize + 1 context.length()); final String zero=padding + centralBase + padding; contextMap.put(context new RefContext(context leading trailing zero)); leadingContexts.add(leading); trailingContexts.add(trailing); zeroContexts.add(zero); } final Set<String> halfContexts=new HashSet<>(leadingContexts); halfContexts.addAll(trailingContexts); this.fullContextAccumulator=new ContextAccumulator(fullContexts expectedTandemReads); this.halfContextAccumulator=new ContextAccumulator(halfContexts expectedTandemReads); this.zeroContextAccumulator=new ContextAccumulator(zeroContexts expectedTandemReads); preAdapterSummaryMetricsList=new ArrayList<PreAdapterSummaryMetrics>(); preAdapterDetailMetricsList=new ArrayList<PreAdapterDetailMetrics>(); baitBiasSummaryMetricsList=new ArrayList<BaitBiasSummaryMetrics>(); baitBiasDetailMetricsList=new ArrayList<BaitBiasDetailMetrics>(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ArtifactCounter.java,RefContext,public  (final String ref final String leading final String trailing final String zero){ this.ref=ref; this.leading=leading; this.trailing=trailing; this.zero=zero; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ArtifactCounter.java,countRecord,public void  (final String refContext final char calledBase final SAMRecord rec){ this.fullContextAccumulator.countRecord(refContext calledBase rec); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ArtifactCounter.java,finish,public void  (){ final ListMap<Transition DetailPair> allDetailMetrics=getDetailMetrics(); final Map<Transition SummaryPair> allSummaryMetrics=getSummaryMetrics(); for ( final Transition transition : Transition.altValues()) { final SummaryPair summary=allSummaryMetrics.get(transition); final List<DetailPair> details=allDetailMetrics.get(transition); preAdapterSummaryMetricsList.add(summary.preAdapterMetrics); baitBiasSummaryMetricsList.add(summary.baitBiasMetrics); for ( final DetailPair detail : details) { preAdapterDetailMetricsList.add(detail.preAdapterMetrics); baitBiasDetailMetricsList.add(detail.baitBiasMetrics); } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ArtifactCounter.java,getBaitBiasDetailMetrics,public List<BaitBiasDetailMetrics>  (){ return baitBiasDetailMetricsList; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ArtifactCounter.java,getBaitBiasSummaryMetrics,public List<BaitBiasSummaryMetrics>  (){ return baitBiasSummaryMetricsList; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ArtifactCounter.java,getDetailMetrics,private ListMap<Transition DetailPair>  (){ return this.fullContextAccumulator.calculateMetrics(this.sampleAlias this.library); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ArtifactCounter.java,getPreAdapterDetailMetrics,public List<PreAdapterDetailMetrics>  (){ return preAdapterDetailMetricsList; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ArtifactCounter.java,getPreAdapterSummaryMetrics,public List<PreAdapterSummaryMetrics>  (){ return preAdapterSummaryMetricsList; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ArtifactCounter.java,getSummaryMetrics,"private Map<Transition SummaryPair>  (){ final Map<Transition SummaryPair> summaryMetricsMap=new EnumMap<Transition SummaryPair>(Transition.class); final ListMap<Transition DetailPair> fullMetrics=this.fullContextAccumulator.calculateMetrics(sampleAlias library); this.halfContextAccumulator.fillHalfRecords(this.fullContextAccumulator contextSize); final ListMap<Transition DetailPair> halfMetrics=this.halfContextAccumulator.calculateMetrics(sampleAlias library); this.zeroContextAccumulator.fillZeroRecords(this.fullContextAccumulator contextSize); final ListMap<Transition DetailPair> zeroMetrics=this.zeroContextAccumulator.calculateMetrics(sampleAlias library); for ( final Transition transition : Transition.altValues()) { final List<DetailPair> fullMetricsForTransition=fullMetrics.get(transition); final List<DetailPair> zeroMetricsForTransition=zeroMetrics.get(transition); if (zeroMetricsForTransition.size() != 1) { throw new PicardException(""Should have exactly one context-free metric pair for transition: "" + transition); } final List<DetailPair> leadingMetricsForTransition=new ArrayList<DetailPair>(); final List<DetailPair> trailingMetricsForTransition=new ArrayList<DetailPair>(); for ( final DetailPair metrics : halfMetrics.get(transition)) { if (!metrics.preAdapterMetrics.CONTEXT.equals(metrics.baitBiasMetrics.CONTEXT)) { throw new PicardException(""Input detail metrics are not matched up properly - contexts differ.""); } final boolean isLeading=leadingContexts.contains(metrics.preAdapterMetrics.CONTEXT); final boolean isTrailing=trailingContexts.contains(metrics.preAdapterMetrics.CONTEXT); if (isLeading) leadingMetricsForTransition.add(metrics); if (isTrailing) trailingMetricsForTransition.add(metrics); } final DetailPair totalMetric=zeroMetricsForTransition.get(0); final DetailPair worstFullMetric=getWorstMetrics(fullMetricsForTransition); final DetailPair worstLeadingMetric=getWorstMetrics(leadingMetricsForTransition); final DetailPair worstTrailingMetric=getWorstMetrics(trailingMetricsForTransition); final PreAdapterSummaryMetrics preAdapterSummaryMetrics=new PreAdapterSummaryMetrics(); final BaitBiasSummaryMetrics baitBiasSummaryMetrics=new BaitBiasSummaryMetrics(); preAdapterSummaryMetrics.SAMPLE_ALIAS=this.sampleAlias; preAdapterSummaryMetrics.LIBRARY=this.library; preAdapterSummaryMetrics.REF_BASE=transition.ref(); preAdapterSummaryMetrics.ALT_BASE=transition.call(); preAdapterSummaryMetrics.TOTAL_QSCORE=totalMetric.preAdapterMetrics.QSCORE; preAdapterSummaryMetrics.WORST_CXT=worstFullMetric.preAdapterMetrics.CONTEXT; preAdapterSummaryMetrics.WORST_CXT_QSCORE=worstFullMetric.preAdapterMetrics.QSCORE; preAdapterSummaryMetrics.WORST_PRE_CXT=worstLeadingMetric.preAdapterMetrics.CONTEXT; preAdapterSummaryMetrics.WORST_PRE_CXT_QSCORE=worstLeadingMetric.preAdapterMetrics.QSCORE; preAdapterSummaryMetrics.WORST_POST_CXT=worstTrailingMetric.preAdapterMetrics.CONTEXT; preAdapterSummaryMetrics.WORST_POST_CXT_QSCORE=worstTrailingMetric.preAdapterMetrics.QSCORE; preAdapterSummaryMetrics.inferArtifactName(); baitBiasSummaryMetrics.SAMPLE_ALIAS=this.sampleAlias; baitBiasSummaryMetrics.LIBRARY=this.library; baitBiasSummaryMetrics.REF_BASE=transition.ref(); baitBiasSummaryMetrics.ALT_BASE=transition.call(); baitBiasSummaryMetrics.TOTAL_QSCORE=totalMetric.baitBiasMetrics.QSCORE; baitBiasSummaryMetrics.WORST_CXT=worstFullMetric.baitBiasMetrics.CONTEXT; baitBiasSummaryMetrics.WORST_CXT_QSCORE=worstFullMetric.baitBiasMetrics.QSCORE; baitBiasSummaryMetrics.WORST_PRE_CXT=worstLeadingMetric.baitBiasMetrics.CONTEXT; baitBiasSummaryMetrics.WORST_PRE_CXT_QSCORE=worstLeadingMetric.baitBiasMetrics.QSCORE; baitBiasSummaryMetrics.WORST_POST_CXT=worstTrailingMetric.baitBiasMetrics.CONTEXT; baitBiasSummaryMetrics.WORST_POST_CXT_QSCORE=worstTrailingMetric.baitBiasMetrics.QSCORE; baitBiasSummaryMetrics.inferArtifactName(); summaryMetricsMap.put(transition new SummaryPair(preAdapterSummaryMetrics baitBiasSummaryMetrics)); } return summaryMetricsMap; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ArtifactCounter.java,getWorstMetrics,private DetailPair  (final List<DetailPair> metrics){ PreAdapterDetailMetrics worstPreAdapterMetrics=null; BaitBiasDetailMetrics worstBaitBiasMetrics=null; for ( final DetailPair m : metrics) { if (worstPreAdapterMetrics == null || m.preAdapterMetrics.compareTo(worstPreAdapterMetrics) < 0) worstPreAdapterMetrics=m.preAdapterMetrics; if (worstBaitBiasMetrics == null || m.baitBiasMetrics.compareTo(worstBaitBiasMetrics) < 0) worstBaitBiasMetrics=m.baitBiasMetrics; } return new DetailPair(worstPreAdapterMetrics worstBaitBiasMetrics); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\CollectSequencingArtifactMetrics.java,acceptRead,@Override protected void  (final SAMRecord rec final ReferenceSequence ref){ if (recordFilter.filterOut(rec)) return; final String library=(rec.getReadGroup() == null) ? UNKNOWN_LIBRARY : getOrElse(rec.getReadGroup().getLibrary() UNKNOWN_LIBRARY); if (!li
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\CollectSequencingArtifactMetrics.java,customCommandLineValidation,"@Override protected String[]  (){ final List<String> messages=new ArrayList<>(); final int contextFullLength=2 * CONTEXT_SIZE + 1; if (CONTEXT_SIZE < 0) messages.add(""CONTEXT_SIZE cannot be negative""); for ( final String context : CONTEXTS_TO_PRINT) { if "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\CollectSequencingArtifactMetrics.java,finish,@Override protected void  (){ final MetricsFile<PreAdapterSummaryMetrics Integer> preAdapterSummaryMetricsFile=getMetricsFile(); final MetricsFile<PreAdapterDetailMetrics Integer> preAdapterDetailMetricsFile=getMetricsFile(); final MetricsFile<BaitBiasSum
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\CollectSequencingArtifactMetrics.java,getRefContext,private String  (final ReferenceSequence ref final int contextStartIndex final int contextFullLength){ if (currentRefIndex != ref.getContigIndex()) { currentRefString=new String(ref.getBases()).toUpperCase(); currentRefIndex=ref.getContigIndex(); } return currentRefString.substring(contextStartIndex contextStartIndex + contextFullLength); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\CollectSequencingArtifactMetrics.java,requiresReference,@Override protected boolean  (){ return true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\CollectSequencingArtifactMetrics.java,setup,"@Override protected void  (final SAMFileHeader header final File samFile){ final String outext=(null != FILE_EXTENSION) ? FILE_EXTENSION : """"; preAdapterSummaryOut=new File(OUTPUT + SequencingArtifactMetrics.PRE_ADAPTER_SUMMARY_EXT + outext); preAdapterDe"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\CollectSequencingArtifactMetrics.java,usesNoRefReads,@Override protected boolean  (){ return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\ErrorSummaryMetrics.java,calculateDerivedFields,@Override public void  (){ final double total=REF_COUNT + ALT_COUNT; this.SUBSTITUTION_RATE=(total == 0) ? 0 : ALT_COUNT / total; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\SequencingArtifactMetrics.java,DetailPair, (final PreAdapterDetailMetrics preAdapterMetrics final BaitBiasDetailMetrics baitBiasMetrics){ this.preAdapterMetrics=preAdapterMetrics; this.baitBiasMetrics=baitBiasMetrics; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\SequencingArtifactMetrics.java,SummaryPair, (final PreAdapterSummaryMetrics preAdapterMetrics final BaitBiasSummaryMetrics baitBiasMetrics){ this.preAdapterMetrics=preAdapterMetrics; this.baitBiasMetrics=baitBiasMetrics; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\SequencingArtifactMetrics.java,calculateDerivedStatistics,public void  (){ this.FWD_ERROR_RATE=MIN_ERROR; final long fwdBases=this.FWD_CXT_REF_BASES + this.FWD_CXT_ALT_BASES; if (fwdBases > 0) { final double fwdErr=this.FWD_CXT_ALT_BASES / (double)fwdBases; this.FWD_ERROR_RATE=Math.max(MIN_ERROR fwdErr); } this.REV_ERROR_RATE=MIN_ERROR; final long revBases=this.REV_CXT_REF_BASES + this.REV_CXT_ALT_BASES; if (revBases > 0) { final double revErr=this.REV_CXT_ALT_BASES / (double)revBases; this.REV_ERROR_RATE=Math.max(MIN_ERROR revErr); } this.ERROR_RATE=Math.max(MIN_ERROR this.FWD_ERROR_RATE - this.REV_ERROR_RATE); this.QSCORE=QualityUtil.getPhredScoreFromErrorProbability(this.ERROR_RATE); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\SequencingArtifactMetrics.java,compareTo,public int  (final BaitBiasDetailMetrics o){ int retval=Double.compare(QSCORE o.QSCORE); if (retval != 0) return retval; retval=REF_BASE - o.REF_BASE; if (retval != 0) return retval; retval=ALT_BASE - o.ALT_BASE; if (retval != 0) return retval; retval=CONTEXT.compareTo(o.CONTEXT); return retval; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\SequencingArtifactMetrics.java,inferArtifactName,"public void  (){ if (this.REF_BASE == 'G' && this.ALT_BASE == 'T') this.ARTIFACT_NAME=""Gref""; else if (this.REF_BASE == 'C' && this.ALT_BASE == 'A') this.ARTIFACT_NAME=""Cref""; else this.ARTIFACT_NAME=""NA""; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\Transition.java,Base,private  (final char base){ this.base=(byte)base; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\Transition.java,Transition, (final char ref final char call){ this.ref=ref; this.call=call; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\Transition.java,altValues,public static Transition[]  (){ return ALT_VALUES; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\Transition.java,call,public char  (){ return this.call; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\Transition.java,complement,public Transition  (){ return transitionOf((char)SequenceUtil.complement((byte)this.ref) (char)SequenceUtil.complement((byte)this.call)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\Transition.java,ref,public char  (){ return this.ref; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\Transition.java,toString,"@Override public String  (){ return this.ref + "">"" + this.call; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\artifacts\Transition.java,transitionOf,"public static Transition  (final char ref final char call){ try { return transitionIndexMap[baseIndexMap[ref]][baseIndexMap[call]]; } catch ( IndexOutOfBoundsException e) { throw new IllegalArgumentException(String.format(""Base params should be one of {A  C  T  G} but ref=%s and call=%s"" ref call)); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\ChimeraUtil.java,isChimeric,public static boolean  (final SAMRecord r1 final SAMRecord r2 final int maxInsertSize final Set<PairOrientation> expectedOrientations){ return isMappedPair(r1) && (Math.abs(r1.getInferredInsertSize()) > maxInsertSize || !r1.getReferenceIndex().equals(r2.getReferenceIndex()) || !matchesExpectedOrientations(r1 expectedOrientations) || r2.getAttribute(SAMTag.SA.toString()) != null); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\ChimeraUtil.java,isMappedPair,private static boolean  (final SAMRecord rec){ return rec.getReadPairedFlag() && !rec.getReadUnmappedFlag() && !rec.getMateUnmappedFlag(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\ChimeraUtil.java,matchesExpectedOrientations,private static boolean  (final SAMRecord rec final Set<PairOrientation> expectedOrientations){ return expectedOrientations.contains(SamPairUtil.getPairOrientation(rec)) && rec.getAttribute(SAMTag.SA.toString()) == null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectAlignmentSummaryMetrics.java,acceptRead,@Override protected void  (final SAMRecord rec final ReferenceSequence ref){ collector.acceptRecord(rec ref); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectAlignmentSummaryMetrics.java,finish,@Override protected void  (){ collector.finish(); final MetricsFile<AlignmentSummaryMetrics Comparable<?>> file=getMetricsFile(); collector.addAllLevelsToFile(file); file.write(OUTPUT); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectAlignmentSummaryMetrics.java,getReferenceFile,@Override public File  (){ return REFERENCE_SEQUENCE; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectAlignmentSummaryMetrics.java,main,public static void  (final String[] argv){ new CollectAlignmentSummaryMetrics().instanceMainWithExit(argv); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectAlignmentSummaryMetrics.java,makeReferenceArgumentCollection,@Override protected ReferenceArgumentCollection  (){ return new CollectAlignmentRefArgCollection(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectAlignmentSummaryMetrics.java,setup,"@Override protected void  (final SAMFileHeader header final File samFile){ IOUtil.assertFileIsWritable(OUTPUT); if (header.getSequenceDictionary().isEmpty()) { log.warn(INPUT.getAbsoluteFile() + "" has no sequence dictionary. If any reads "" + ""in the file "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectAlignmentSummaryMetrics.java,testDoWork,protected final int  (){ return doWork(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectGcBiasMetrics.java,acceptRead,@Override protected void  (final SAMRecord rec final ReferenceSequence ref){ multiCollector.acceptRecord(rec ref); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectGcBiasMetrics.java,finish,@Override protected void  (){ multiCollector.finish(); writeResultsToFiles(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectGcBiasMetrics.java,main,public static void  (final String[] args){ System.exit(new CollectGcBiasMetrics().instanceMain(args)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectGcBiasMetrics.java,setup,@Override protected void  (final SAMFileHeader header final File samFile){ IOUtil.assertFileIsWritable(CHART_OUTPUT); IOUtil.assertFileIsWritable(SUMMARY_OUTPUT); IOUtil.assertFileIsReadable(REFERENCE_SEQUENCE); final int[] windowsByGc=GcBiasUtils.calcula
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectGcBiasMetrics.java,writeResultsToFiles,private void  (){ final MetricsFile<GcBiasMetrics Integer> file=getMetricsFile(); final MetricsFile<GcBiasDetailMetrics ?> detailMetricsFile=getMetricsFile(); final MetricsFile<GcBiasSummaryMetrics ?> summaryMetricsFile=getMetricsFile(); multiCollector.addAllLevelsToFile(file); final List<GcBiasMetrics> gcBiasMetricsList=file.getMetrics(); for ( final GcBiasMetrics gcbm : gcBiasMetricsList) { final List<GcBiasDetailMetrics> gcDetailList=gcbm.DETAILS.getMetrics(); for ( final GcBiasDetailMetrics d : gcDetailList) { detailMetricsFile.addMetric(d); } summaryMetricsFile.addMetric(gcbm.SUMMARY); } detailMetricsFile.write(OUTPUT); summaryMetricsFile.write(SUMMARY_OUTPUT); final NumberFormat fmt=NumberFormat.getIntegerInstance(); fmt.setGroupingUsed(true); RExecutor.executeFromClasspath(R_SCRIPT OUTPUT.getAbsolutePath() SUMMARY_OUTPUT.getAbsolutePath() CHART_OUTPUT.getAbsolutePath() String.valueOf(SCAN_WINDOW_SIZE)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectBaseDistributionByCycle.java,acceptRead,@Override protected void  (final SAMRecord rec final ReferenceSequence ref){ if ((PF_READS_ONLY) && (rec.getReadFailsVendorQualityCheckFlag())) { return; } if ((ALIGNED_READS_ONLY) && (rec.getReadUnmappedFlag())) { return; } if (rec.isSecondaryOrSupplemen
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectBaseDistributionByCycle.java,addRecord,void  (final SAMRecord rec){ final byte[] bases=rec.getReadBases(); if (bases == null) { return; } final int length=bases.length; final boolean rc=rec.getReadNegativeStrandFlag(); ensureArraysBigEnough(length + 1); if ((rec.getReadPairedFlag()) && (rec.getSecondOfPairFlag())) { seenSecondEnd=true; for (int i=0; i < length; i++) { final int cycle=rc ? length - i : i + 1; secondReadTotalsByCycle[baseToInt(bases[i])][cycle]+=1; secondReadCountsByCycle[cycle]+=1; } } else { for (int i=0; i < length; i++) { final int cycle=rc ? length - i : i + 1; firstReadTotalsByCycle[baseToInt(bases[i])][cycle]+=1; firstReadCountsByCycle[cycle]+=1; } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectBaseDistributionByCycle.java,addToMetricsFile,public void  (final MetricsFile<BaseDistributionByCycleMetrics ?> metrics){ int firstReadLength=0; for (int i=0; i < maxLengthSoFar; i++) { if (0 != firstReadCountsByCycle[i]) { final BaseDistributionByCycleMetrics metric=new BaseDistributionByCycleMetrics(); metric.READ_END=1; metric.CYCLE=i; metric.PCT_A=(100.0 * firstReadTotalsByCycle[0][i] / firstReadCountsByCycle[i]); metric.PCT_C=(100.0 * firstReadTotalsByCycle[1][i] / firstReadCountsByCycle[i]); metric.PCT_G=(100.0 * firstReadTotalsByCycle[2][i] / firstReadCountsByCycle[i]); metric.PCT_T=(100.0 * firstReadTotalsByCycle[3][i] / firstReadCountsByCycle[i]); metric.PCT_N=(100.0 * firstReadTotalsByCycle[4][i] / firstReadCountsByCycle[i]); metrics.addMetric(metric); firstReadLength=i; } } if (seenSecondEnd) { for (int i=0; i < maxLengthSoFar; i++) { if (0 != secondReadCountsByCycle[i]) { final BaseDistributionByCycleMetrics metric=new BaseDistributionByCycleMetrics(); metric.READ_END=2; metric.CYCLE=(i + firstReadLength); metric.PCT_A=(100.0 * secondReadTotalsByCycle[0][i] / secondReadCountsByCycle[i]); metric.PCT_C=(100.0 * secondReadTotalsByCycle[1][i] / secondReadCountsByCycle[i]); metric.PCT_G=(100.0 * secondReadTotalsByCycle[2][i] / secondReadCountsByCycle[i]); metric.PCT_T=(100.0 * secondReadTotalsByCycle[3][i] / secondReadCountsByCycle[i]); metric.PCT_N=(100.0 * secondReadTotalsByCycle[4][i] / secondReadCountsByCycle[i]); metrics.addMetric(metric); } } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectBaseDistributionByCycle.java,baseToInt,private int  (final byte base){ switch (base) { case 'A': case 'a': return 0; case 'C': case 'c': return 1; case 'G': case 'g': return 2; case 'T': case 't': return 3; } return 4; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectBaseDistributionByCycle.java,ensureArraysBigEnough,private void  (final int length){ if (length > maxLengthSoFar) { for (int i=0; i < 5; i++) { firstReadTotalsByCycle[i]=Arrays.copyOf(firstReadTotalsByCycle[i] length); secondReadTotalsByCycle[i]=Arrays.copyOf(secondReadTotalsByCycle[i] length); } firstReadCountsByCycle=Arrays.copyOf(firstReadCountsByCycle length); secondReadCountsByCycle=Arrays.copyOf(secondReadCountsByCycle length); maxLengthSoFar=length; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectBaseDistributionByCycle.java,finish,"@Override protected void  (){ final MetricsFile<BaseDistributionByCycleMetrics ?> metrics=getMetricsFile(); hist.addToMetricsFile(metrics); metrics.write(OUTPUT); if (hist.isEmpty()) { log.warn(""No valid bases found in input file. No plot will be produced"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectBaseDistributionByCycle.java,isEmpty,boolean  (){ return maxLengthSoFar == 0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectBaseDistributionByCycle.java,main,public static void  (String[] args){ System.exit(new CollectBaseDistributionByCycle().instanceMain(args)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectBaseDistributionByCycle.java,setup,@Override protected void  (final SAMFileHeader header final File samFile){ IOUtil.assertFileIsWritable(CHART_OUTPUT); final List<SAMReadGroupRecord> readGroups=header.getReadGroups(); if (readGroups.size() == 1) { plotSubtitle=StringUtil.asEmptyIfNull(rea
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectInsertSizeMetrics.java,acceptRead,@Override protected void  (final SAMRecord record final ReferenceSequence ref){ multiCollector.acceptRecord(record ref); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectInsertSizeMetrics.java,customCommandLineValidation,"@Override protected String[]  (){ if (MINIMUM_PCT < 0 || MINIMUM_PCT > 0.5) { return new String[]{""MINIMUM_PCT was set to "" + MINIMUM_PCT + "". It must be between 0 and 0.5 so all data categories don't get discarded.""}; } return super.customCommandLineVali"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectInsertSizeMetrics.java,finish,"@Override protected void  (){ multiCollector.finish(); final MetricsFile<InsertSizeMetrics Integer> file=getMetricsFile(); multiCollector.addAllLevelsToFile(file); if (file.getNumHistograms() == 0) { log.warn(""All data categories were discarded because th"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectInsertSizeMetrics.java,main,public static void  (final String[] argv){ new CollectInsertSizeMetrics().instanceMainWithExit(argv); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectInsertSizeMetrics.java,setup,@Override protected void  (final SAMFileHeader header final File samFile){ IOUtil.assertFileIsWritable(OUTPUT); IOUtil.assertFileIsWritable(Histogram_FILE); multiCollector=new InsertSizeMetricsCollector(METRIC_ACCUMULATION_LEVEL header.getReadGroups() MIN
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectInsertSizeMetrics.java,usesNoRefReads,@Override protected boolean  (){ return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectJumpingLibraryMetrics.java,doWork,"protected int  (){ for ( File f : INPUT) { IOUtil.assertFileIsReadable(f); } IOUtil.assertFileIsWritable(OUTPUT); Histogram<Integer> innieHistogram=new Histogram<Integer>(); Histogram<Integer> outieHistogram=new Histogram<Integer>(); int fragments=0; int innies=0; int outies=0; int innieDupes=0; int outieDupes=0; int crossChromPairs=0; int superSized=0; int tandemPairs=0; double chimeraSizeMinimum=Math.max(getOutieMode() (double)CHIMERA_KB_MIN); for ( File f : INPUT) { SamReader reader=SamReaderFactory.makeDefault().open(f); if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.coordinate) { throw new PicardException(""SAM file must "" + f.getName() + "" must be sorted in coordintate order""); } for ( SAMRecord sam : reader) { if (!sam.getFirstOfPairFlag()) { continue; } if (sam.getReadUnmappedFlag()) { if (!sam.getMateUnmappedFlag()) { fragments++; continue; } if (sam.getReferenceIndex() == SAMRecord.NO_ALIGNMENT_REFERENCE_INDEX) { break; } continue; } if (sam.getMateUnmappedFlag()) { fragments++; continue; } if ((sam.getAttribute(SAMTag.MQ.name()) != null && sam.getIntegerAttribute(SAMTag.MQ.name()) < MINIMUM_MAPPING_QUALITY) || sam.getMappingQuality() < MINIMUM_MAPPING_QUALITY) { continue; } final int absInsertSize=Math.abs(sam.getInferredInsertSize()); if (absInsertSize > chimeraSizeMinimum) { superSized++; } else if (sam.getMateNegativeStrandFlag() == sam.getReadNegativeStrandFlag()) { tandemPairs++; } else if (!sam.getMateReferenceIndex().equals(sam.getReferenceIndex())) { crossChromPairs++; } else { final PairOrientation pairOrientation=SamPairUtil.getPairOrientation(sam); if (pairOrientation == PairOrientation.RF) { outieHistogram.increment(absInsertSize); outies++; if (sam.getDuplicateReadFlag()) { outieDupes++; } } else if (pairOrientation == PairOrientation.FR) { innieHistogram.increment(absInsertSize); innies++; if (sam.getDuplicateReadFlag()) { innieDupes++; } } else { throw new IllegalStateException(""This should never happen""); } } } CloserUtil.close(reader); } MetricsFile<JumpingLibraryMetrics Integer> metricsFile=getMetricsFile(); JumpingLibraryMetrics metrics=new JumpingLibraryMetrics(); metrics.JUMP_PAIRS=outies; metrics.JUMP_DUPLICATE_PAIRS=outieDupes; metrics.JUMP_DUPLICATE_PCT=outies != 0 ? outieDupes / (double)outies : 0; metrics.JUMP_LIBRARY_SIZE=(outies > 0 && outieDupes > 0) ? DuplicationMetrics.estimateLibrarySize(outies outies - outieDupes) : 0; outieHistogram.trimByTailLimit(TAIL_LIMIT); metrics.JUMP_MEAN_INSERT_SIZE=outieHistogram.getMean(); metrics.JUMP_STDEV_INSERT_SIZE=outieHistogram.getStandardDeviation(); metrics.NONJUMP_PAIRS=innies; metrics.NONJUMP_DUPLICATE_PAIRS=innieDupes; metrics.NONJUMP_DUPLICATE_PCT=innies != 0 ? innieDupes / (double)innies : 0; metrics.NONJUMP_LIBRARY_SIZE=(innies > 0 && innieDupes > 0) ? DuplicationMetrics.estimateLibrarySize(innies innies - innieDupes) : 0; innieHistogram.trimByTailLimit(TAIL_LIMIT); metrics.NONJUMP_MEAN_INSERT_SIZE=innieHistogram.getMean(); metrics.NONJUMP_STDEV_INSERT_SIZE=innieHistogram.getStandardDeviation(); metrics.CHIMERIC_PAIRS=crossChromPairs + superSized + tandemPairs; metrics.FRAGMENTS=fragments; double totalPairs=outies + innies + metrics.CHIMERIC_PAIRS; metrics.PCT_JUMPS=totalPairs != 0 ? outies / totalPairs : 0; metrics.PCT_NONJUMPS=totalPairs != 0 ? innies / totalPairs : 0; metrics.PCT_CHIMERAS=totalPairs != 0 ? metrics.CHIMERIC_PAIRS / totalPairs : 0; metricsFile.addMetric(metrics); metricsFile.write(OUTPUT); return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectJumpingLibraryMetrics.java,getOutieMode,private double  (){ int samplePerFile=SAMPLE_FOR_MODE / INPUT.size(); Histogram<Integer> histo=new Histogram<Integer>(); for ( File f : INPUT) { SamReader reader=SamReaderFactory.makeDefault().open(f); int sampled=0; for (Iterator<SAMRecord> it=reader.iterator(); it.hasNext() && sampled < samplePerFile; ) { SAMRecord sam=it.next(); if (!sam.getFirstOfPairFlag()) { continue; } if (sam.getReadUnmappedFlag() && sam.getReferenceIndex() == SAMRecord.NO_ALIGNMENT_REFERENCE_INDEX) { break; } else if (sam.getReadUnmappedFlag() || sam.getMateUnmappedFlag()) { continue; } else if ((sam.getAttribute(SAMTag.MQ.name()) == null || sam.getIntegerAttribute(SAMTag.MQ.name()) >= MINIMUM_MAPPING_QUALITY) && sam.getMappingQuality() >= MINIMUM_MAPPING_QUALITY && sam.getMateNegativeStrandFlag() != sam.getReadNegativeStrandFlag() && sam.getMateReferenceIndex().equals(sam.getReferenceIndex()) && SamPairUtil.getPairOrientation(sam) == PairOrientation.RF) { histo.increment(Math.abs(sam.getInferredInsertSize())); sampled++; } } CloserUtil.close(reader); } return histo.size() > 0 ? histo.getMode() : 0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectJumpingLibraryMetrics.java,main,public static void  (String[] args){ System.exit(new CollectJumpingLibraryMetrics().instanceMain(args)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectMultipleMetrics.java,customCommandLineValidation,"@Override protected String[]  (){ if (PROGRAM.isEmpty()) { return new String[]{""No programs specified with PROGRAM""}; } programsToRun=new LinkedHashSet<>(PROGRAM); return super.customCommandLineValidation(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectMultipleMetrics.java,doWork,"@Override public int  (){ if (OUTPUT.endsWith(""."")) { OUTPUT=OUTPUT.substring(0 OUTPUT.length() - 1); } final List<SinglePassSamProgram> programs=new ArrayList<>(); for ( final ProgramInterface program : programsToRun) { if (program.needsReferenceSequence"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectMultipleMetrics.java,main,public static void  (final String[] args){ new CollectMultipleMetrics().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectMultipleMetrics.java,makeInstance,@Override public SinglePassSamProgram  (final String outbase final String outext final File input final File reference final Set<MetricAccumulationLevel> metricAccumulationLevel final File dbSnp final File intervals){ final CollectQualityYieldMetrics prog
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectMultipleMetrics.java,needsReferenceSequence,@Override public boolean  (){ return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectMultipleMetrics.java,setProgramsToRun,public void  (final Collection<ProgramInterface> programsToRun){ this.programsToRun.clear(); this.programsToRun.addAll(programsToRun); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectMultipleMetrics.java,supportsMetricAccumulationLevel,@Override public boolean  (){ return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectOxoGMetrics.java,Calculator, (final String library final String context){ this.library=library; this.context=context; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectOxoGMetrics.java,accept,"void  (final SamLocusIterator.LocusInfo info final byte refBase){ final Counts counts=computeAlleleFraction(info refBase); if (counts.total() > 0) { this.sites++; if (refBase == 'C') { this.refCcontrolA+=counts.controlA; this.refCoxidatedA+=counts.oxidatedA; this.refCcontrolC+=counts.controlC; this.refCoxidatedC+=counts.oxidatedC; } else if (refBase == 'G') { this.refGcontrolA+=counts.controlA; this.refGoxidatedA+=counts.oxidatedA; this.refGcontrolC+=counts.controlC; this.refGoxidatedC+=counts.oxidatedC; } else { throw new IllegalStateException(""Reference bases other than G and C not supported.""); } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectOxoGMetrics.java,computeAlleleFraction,private Counts  (final SamLocusIterator.LocusInfo info final byte refBase){ final Counts counts=new Counts(); final byte altBase=(refBase == 'C') ? (byte)'A' : (byte)'T'; for ( final SamLocusIterator.RecordAndOffset rec : info.getRecordAndOffsets()) { final byte qual; final SAMRecord samrec=rec.getRecord(); if (USE_OQ) { final byte[] oqs=samrec.getOriginalBaseQualities(); if (oqs != null) qual=oqs[rec.getOffset()]; else qual=rec.getBaseQuality(); } else { qual=rec.getBaseQuality(); } if (qual < MINIMUM_QUALITY_SCORE) continue; if (!this.library.equals(Optional.ofNullable(samrec.getReadGroup().getLibrary()).orElse(UNKNOWN_LIBRARY))) continue; final byte base=rec.getReadBase(); final byte baseAsRead=samrec.getReadNegativeStrandFlag() ? SequenceUtil.complement(base) : base; final int read=samrec.getReadPairedFlag() && samrec.getSecondOfPairFlag() ? 2 : 1; if (base == refBase) { if (baseAsRead == 'G' && read == 1) ++counts.oxidatedC; else if (baseAsRead == 'G' && read == 2) ++counts.controlC; else if (baseAsRead == 'C' && read == 1) ++counts.controlC; else if (baseAsRead == 'C' && read == 2) ++counts.oxidatedC; } else if (base == altBase) { if (baseAsRead == 'T' && read == 1) ++counts.oxidatedA; else if (baseAsRead == 'T' && read == 2) ++counts.controlA; else if (baseAsRead == 'A' && read == 1) ++counts.controlA; else if (baseAsRead == 'A' && read == 2) ++counts.oxidatedA; } } return counts; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectOxoGMetrics.java,customCommandLineValidation,"@Override protected String[]  (){ final int size=1 + 2 * CONTEXT_SIZE; final List<String> messages=new ArrayList<>(); for ( final String ctx : CONTEXTS) { if (ctx.length() != size) { messages.add(""Context "" + ctx + "" is not ""+ size+ "" long as implied by C"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectOxoGMetrics.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); if (INTERVALS != null) IOUtil.assertFileIsReadable(INTERVALS); IOUtil.assertFileIsReadable(REFERENCE_SEQUENCE); final ReferenceSequenceFileWalker refWalk
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectOxoGMetrics.java,finish,CpcgMetrics  (){ final CpcgMetrics m=new CpcgMetrics(); m.LIBRARY=this.library; m.CONTEXT=this.context; m.TOTAL_SITES=this.sites; m.TOTAL_BASES=this.refCcontrolC + this.refCoxidatedC + this.refCcontrolA+ this.refCoxidatedA+ this.refGcontrolC+ this.refGoxidatedC+ this.refGcontrolA+ this.refGoxidatedA; m.REF_OXO_BASES=this.refCoxidatedC + refGoxidatedC; m.REF_NONOXO_BASES=this.refCcontrolC + this.refGcontrolC; m.REF_TOTAL_BASES=m.REF_OXO_BASES + m.REF_NONOXO_BASES; m.ALT_NONOXO_BASES=this.refCcontrolA + this.refGcontrolA; m.ALT_OXO_BASES=this.refCoxidatedA + this.refGoxidatedA; m.OXIDATION_ERROR_RATE=Math.max(m.ALT_OXO_BASES - m.ALT_NONOXO_BASES 1) / (double)m.TOTAL_BASES; m.OXIDATION_Q=-10 * Math.log10(m.OXIDATION_ERROR_RATE); m.C_REF_REF_BASES=this.refCcontrolC + this.refCoxidatedC; m.G_REF_REF_BASES=this.refGcontrolC + this.refGoxidatedC; m.C_REF_ALT_BASES=this.refCcontrolA + this.refCoxidatedA; m.G_REF_ALT_BASES=this.refGcontrolA + this.refGoxidatedA; final double cRefErrorRate=m.C_REF_ALT_BASES / (double)(m.C_REF_ALT_BASES + m.C_REF_REF_BASES); final double gRefErrorRate=m.G_REF_ALT_BASES / (double)(m.G_REF_ALT_BASES + m.G_REF_REF_BASES); m.C_REF_OXO_ERROR_RATE=Math.max(cRefErrorRate - gRefErrorRate 1e-10); m.G_REF_OXO_ERROR_RATE=Math.max(gRefErrorRate - cRefErrorRate 1e-10); m.C_REF_OXO_Q=-10 * Math.log10(m.C_REF_OXO_ERROR_RATE); m.G_REF_OXO_Q=-10 * Math.log10(m.G_REF_OXO_ERROR_RATE); return m; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectOxoGMetrics.java,makeContextStrings,"private Set<String>  (final int contextSize){ final Set<String> contexts=new HashSet<>(); for ( final byte[] kmer : SequenceUtil.generateAllKmers(2 * contextSize + 1)) { if (kmer[contextSize] == 'C') { contexts.add(StringUtil.bytesToString(kmer)); } } log.info(""Generated "" + contexts.size() + "" context strings.""); return contexts; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectOxoGMetrics.java,requiresReference,@Override protected boolean  (){ return true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectOxoGMetrics.java,total,int  (){ return controlC + oxidatedC + controlA+ oxidatedA; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectRawWgsMetrics.java,CollectRawWgsMetrics,public  (){ MINIMUM_MAPPING_QUALITY=0; MINIMUM_BASE_QUALITY=3; COVERAGE_CAP=100000; LOCUS_ACCUMULATION_CAP=200000; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectRawWgsMetrics.java,RawWgsMetrics,public  (final IntervalList intervals final Histogram<Integer> highQualityDepthHistogram final Histogram<Integer> unfilteredDepthHistogram final double pctExcludedByMapq final double pctExcludedByDupes final double pctExcludedByPairing final double pctExcludedByBaseq final double pctExcludedByOverlap final double pctExcludedByCapping final double pctTotal final int coverageCap final Histogram<Integer> unfilteredBaseQHistogram final int sampleSize){ super(intervals highQualityDepthHistogram unfilteredDepthHistogram pctExcludedByMapq pctExcludedByDupes pctExcludedByPairing pctExcludedByBaseq pctExcludedByOverlap pctExcludedByCapping pctTotal coverageCap unfilteredBaseQHistogram sampleSize); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectRawWgsMetrics.java,generateWgsMetrics,@Override protected WgsMetrics  (final IntervalList intervals final Histogram<Integer> highQualityDepthHistogram final Histogram<Integer> unfilteredDepthHistogram final double pctExcludedByMapq final double pctExcludedByDupes final double pctExcludedByPai
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectQualityYieldMetrics.java,QualityYieldMetricsCollector,public  (final boolean useOriginalQualities final boolean includeSecondaryAlignments final boolean includeSupplementalAlignments){ this.useOriginalQualities=useOriginalQualities; this.includeSecondaryAlignments=includeSecondaryAlignments; this.includeSupplementalAlignments=includeSupplementalAlignments; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectQualityYieldMetrics.java,acceptRead,@Override protected void  (final SAMRecord rec final ReferenceSequence ref){ this.collector.acceptRecord(rec ref); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectQualityYieldMetrics.java,acceptRecord,public void  (final SAMRecord rec final ReferenceSequence ref){ if (!this.includeSecondaryAlignments && rec.getNotPrimaryAlignmentFlag()) return; if (!this.includeSupplementalAlignments && rec.getSupplementaryAlignmentFlag()) return; final int length=rec.getReadLength(); metrics.TOTAL_READS++; metrics.TOTAL_BASES+=length; final boolean isPfRead=!rec.getReadFailsVendorQualityCheckFlag(); if (isPfRead) { metrics.PF_READS++; metrics.PF_BASES+=length; } final byte[] quals; if (this.useOriginalQualities) { byte[] tmp=rec.getOriginalBaseQualities(); if (tmp == null) tmp=rec.getBaseQualities(); quals=tmp; } else { quals=rec.getBaseQualities(); } for ( final int qual : quals) { metrics.Q20_EQUIVALENT_YIELD+=qual; if (qual >= 30) { metrics.Q20_BASES++; metrics.Q30_BASES++; } else if (qual >= 20) { metrics.Q20_BASES++; } if (isPfRead) { metrics.PF_Q20_EQUIVALENT_YIELD+=qual; if (qual >= 30) { metrics.PF_Q20_BASES++; metrics.PF_Q30_BASES++; } else if (qual >= 20) { metrics.PF_Q20_BASES++; } } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectQualityYieldMetrics.java,addMetricsToFile,public void  (final MetricsFile<QualityYieldMetrics Integer> metricsFile){ metricsFile.addMetric(metrics); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectQualityYieldMetrics.java,finish,public void  (){ metrics.READ_LENGTH=metrics.TOTAL_READS == 0 ? 0 : (int)(metrics.TOTAL_BASES / metrics.TOTAL_READS); metrics.Q20_EQUIVALENT_YIELD=metrics.Q20_EQUIVALENT_YIELD / 20; metrics.PF_Q20_EQUIVALENT_YIELD=metrics.PF_Q20_EQUIVALENT_YIELD / 20; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectQualityYieldMetrics.java,setup,@Override protected void  (final SAMFileHeader header final File samFile){ IOUtil.assertFileIsWritable(OUTPUT); this.collector=new QualityYieldMetricsCollector(USE_ORIGINAL_QUALITIES INCLUDE_SECONDARY_ALIGNMENTS INCLUDE_SUPPLEMENTAL_ALIGNMENTS); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectQualityYieldMetrics.java,usesNoRefReads,@Override protected boolean  (){ return true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectRnaSeqMetrics.java,acceptRead,@Override protected void  (final SAMRecord rec final ReferenceSequence refSeq){ collector.acceptRecord(rec refSeq); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectRnaSeqMetrics.java,customCommandLineValidation,"@Override protected String[]  (){ if (RIBOSOMAL_INTERVALS == null && RRNA_FRAGMENT_PERCENTAGE == 0) { throw new PicardException(""Must use a RIBOSOMAL_INTERVALS file if RRNA_FRAGMENT_PERCENTAGE = 0.0""); } return super.customCommandLineValidation(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectRnaSeqMetrics.java,finish,@Override protected void  (){ collector.finish(); final MetricsFile<RnaSeqMetrics Integer> file=getMetricsFile(); collector.addAllLevelsToFile(file); file.write(OUTPUT); boolean atLeastOneHistogram=false; for ( final Histogram<Integer> histo : file.getAll
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectRnaSeqMetrics.java,main,public static void  (final String[] argv){ new CollectRnaSeqMetrics().instanceMainWithExit(argv); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectRnaSeqMetrics.java,setup,@Override protected void  (final SAMFileHeader header final File samFile){ if (CHART_OUTPUT != null) IOUtil.assertFileIsWritable(CHART_OUTPUT); final OverlapDetector<Gene> geneOverlapDetector=GeneAnnotationReader.loadRefFlat(REF_FLAT header.getSequenceDic
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CompareMetrics.java,doWork,@Override protected int  (){ IOUtil.assertFilesAreReadable(metricsFiles); final MetricsFile<? ?> metricsA=new MetricsFile(); final MetricsFile<? ?> metricsB=new MetricsFile(); try { metricsA.read(new FileReader(metricsFiles.get(0))); metricsB.read(new Fil
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CompareMetrics.java,main,public static void  (String[] argv){ new CompareMetrics().instanceMainWithExit(argv); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectRrbsMetrics.java,assertIoFiles,private void  (final File summaryFile final File detailsFile final File plotsFile){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsReadable(REFERENCE_SEQUENCE); IOUtil.assertFileIsWritable(summaryFile); IOUtil.assertFileIsWritable(detailsFile); IOUtil.assertFileIsWritable(plotsFile); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectRrbsMetrics.java,customCommandLineValidation,"@Override protected String[]  (){ final List<String> errorMsgs=new ArrayList<String>(); if (MAX_MISMATCH_RATE < 0 || MAX_MISMATCH_RATE > 1) { errorMsgs.add(""MAX_MISMATCH_RATE must be in the range of 0-1""); } if (C_QUALITY_THRESHOLD < 0) { errorMsgs.add(""C"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectRrbsMetrics.java,doWork,"@Override protected int  (){ if (!METRICS_FILE_PREFIX.endsWith(""."")) { METRICS_FILE_PREFIX=METRICS_FILE_PREFIX + "".""; } final File SUMMARY_OUT=new File(METRICS_FILE_PREFIX + SUMMARY_FILE_EXTENSION); final File DETAILS_OUT=new File(METRICS_FILE_PREFIX + DE"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectRrbsMetrics.java,getReferenceFile,@Override public File  (){ return REFERENCE; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectRrbsMetrics.java,isSequenceFiltered,private boolean  (final String sequenceName){ return (SEQUENCE_NAMES != null) && (!SEQUENCE_NAMES.isEmpty()) && (!SEQUENCE_NAMES.contains(sequenceName)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectRrbsMetrics.java,main,public static void  (final String[] args){ new CollectRrbsMetrics().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectRrbsMetrics.java,makeReferenceArgumentCollection,@Override protected ReferenceArgumentCollection  (){ return new CollectRrbsMetricsReferenceArgumentCollection(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetrics.java,WgsMetrics,public  (final IntervalList intervals final Histogram<Integer> highQualityDepthHistogram final Histogram<Integer> unfilteredDepthHistogram final double pctExcludedByMapq final double pctExcludedByDupes final double pctExcludedByPairing final double pctExcludedByBaseq final double pctExcludedByOverlap final double pctExcludedByCapping final double pctExcludeTotal final int coverageCap final Histogram<Integer> unfilteredBaseQHistogram final int theoreticalHetSensitivitySampleSize){ this.intervals=intervals.uniqued(); this.highQualityDepthHistogram=highQualityDepthHistogram; this.unfilteredDepthHistogram=unfilteredDepthHistogram; this.unfilteredBaseQHistogram=unfilteredBaseQHistogram; this.coverageCap=coverageCap; this.theoreticalHetSensitivitySampleSize=theoreticalHetSensitivitySampleSize; PCT_EXC_MAPQ=pctExcludedByMapq; PCT_EXC_DUPE=pctExcludedByDupes; PCT_EXC_UNPAIRED=pctExcludedByPairing; PCT_EXC_BASEQ=pctExcludedByBaseq; PCT_EXC_OVERLAP=pctExcludedByOverlap; PCT_EXC_CAPPED=pctExcludedByCapping; PCT_EXC_TOTAL=pctExcludeTotal; calculateDerivedFields(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetrics.java,WgsMetricsCollector,public  (final CollectWgsMetrics metrics final int coverageCap final IntervalList intervals){ super(metrics coverageCap intervals); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetrics.java,addInfo,@Override public void  (final AbstractLocusInfo<SamLocusIterator.RecordAndOffset> info final ReferenceSequence ref boolean referenceBaseN){ if (referenceBaseN) { return; } final HashSet<String> readNames=new HashSet<>(info.getRecordAndOffsets().size()); i
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetrics.java,calculateDerivedFields,"@Override public void  (){ if (highQualityDepthHistogram == null || unfilteredDepthHistogram == null) throw new PicardException(""Depth histogram is required when deriving metrics.""); if (unfilteredBaseQHistogram != null && theoreticalHetSensitivitySampleS"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetrics.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); IOUtil.assertFileIsReadable(REFERENCE_SEQUENCE); INTERVALS=intervalArugmentCollection.getIntervalFile(); if (INTERVALS != null) { IOUtil.assertFileIsRead
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetrics.java,generateWgsMetrics,WgsMetrics  (final IntervalList intervals final Histogram<Integer> highQualityDepthHistogram final Histogram<Integer> unfilteredDepthHistogram final long basesExcludedByMapq final long basesExcludedByDupes final long basesExcludedByPairing final long basesExcludedByBaseq final long basesExcludedByOverlap final long basesExcludedByCapping final int coverageCap final Histogram<Integer> unfilteredBaseQHistogram final int theoreticalHetSensitivitySampleSize){ final double total=highQualityDepthHistogram.getSum(); final double totalWithExcludes=total + basesExcludedByDupes + basesExcludedByMapq+ basesExcludedByPairing+ basesExcludedByBaseq+ basesExcludedByOverlap+ basesExcludedByCapping; final double pctExcludedByMapq=totalWithExcludes == 0 ? 0 : basesExcludedByMapq / totalWithExcludes; final double pctExcludedByDupes=totalWithExcludes == 0 ? 0 : basesExcludedByDupes / totalWithExcludes; final double pctExcludedByPairing=totalWithExcludes == 0 ? 0 : basesExcludedByPairing / totalWithExcludes; final double pctExcludedByBaseq=totalWithExcludes == 0 ? 0 : basesExcludedByBaseq / totalWithExcludes; final double pctExcludedByOverlap=totalWithExcludes == 0 ? 0 : basesExcludedByOverlap / totalWithExcludes; final double pctExcludedByCapping=totalWithExcludes == 0 ? 0 : basesExcludedByCapping / totalWithExcludes; final double pctTotal=totalWithExcludes == 0 ? 0 : (totalWithExcludes - total) / totalWithExcludes; return generateWgsMetrics(intervals highQualityDepthHistogram unfilteredDepthHistogram pctExcludedByMapq pctExcludedByDupes pctExcludedByPairing pctExcludedByBaseq pctExcludedByOverlap pctExcludedByCapping pctTotal coverageCap unfilteredBaseQHistogram theoreticalHetSensitivitySampleSize); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetrics.java,getBasesExcludedBy,protected long  (final CountingFilter filter){ return filter.getFilteredBases(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetrics.java,getCollector,protected AbstractWgsMetricsCollector  (final int coverageCap final IntervalList intervals){ return USE_FAST_ALGORITHM ? new FastWgsMetricsCollector(this coverageCap intervals) : new WgsMetricsCollector(this coverageCap intervals); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetrics.java,getIntervalFile,public File  (){ return INTERVALS; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetrics.java,getIntervalsToExamine,protected IntervalList  (){ final IntervalList intervals; if (INTERVALS != null) { IOUtil.assertFileIsReadable(INTERVALS); intervals=IntervalList.fromFile(INTERVALS); } else { intervals=new IntervalList(this.header); for ( final SAMSequenceRecord rec : this.header.getSequenceDictionary().getSequences()) { final Interval interval=new Interval(rec.getSequenceName() 1 rec.getSequenceLength()); intervals.add(interval); } } return intervals; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetrics.java,getLocusIterator,protected AbstractLocusIterator  (final SamReader in){ if (USE_FAST_ALGORITHM) { return (INTERVALS != null) ? new EdgeReadIterator(in IntervalList.fromFile(INTERVALS)) : new EdgeReadIterator(in); } SamLocusIterator iterator=(INTERVALS != null) ? new SamLocusIterator(in IntervalList.fromFile(INTERVALS)) : new SamLocusIterator(in); iterator.setMaxReadsToAccumulatePerLocus(LOCUS_ACCUMULATION_CAP); iterator.setEmitUncoveredLoci(true); iterator.setQualityScoreCutoff(0); return iterator; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetrics.java,getSamFileHeader,"protected SAMFileHeader  (){ if (this.header == null) throw new IllegalStateException(""getSamFileHeader() was called but this.header is null""); return this.header; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetrics.java,getSamReader,protected SamReader  (){ final SamReader in=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT); this.header=in.getFileHeader(); return in; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetrics.java,getWgsMetricsProcessor,private <T extends AbstractRecordAndOffset>WgsMetricsProcessorImpl<T>  (ProgressLogger progress ReferenceSequenceFileWalker refWalker AbstractLocusIterator<T AbstractLocusInfo<T>> iterator AbstractWgsMetricsCollector<T> collector){ return new WgsMetricsProcessorImpl<>(iterator refWalker collector progress); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetrics.java,main,public static void  (final String[] args){ new CollectWgsMetrics().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetrics.java,makeIntervalArgumentCollection,protected IntervalArgumentCollection  (){ return new CollectWgsMetricsIntervalArgumentCollection(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetrics.java,merge,@Override public MergeableMetricBase  (final MergeableMetricBase other){ final WgsMetrics otherMetric=(WgsMetrics)other; if (highQualityDepthHistogram == null || otherMetric.highQualityDepthHistogram == null || unfilteredDepthHistogram == null || otherMet
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetrics.java,requiresReference,@Override protected boolean  (){ return true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetricsWithNonZeroCoverage.java,WgsMetricsWithNonZeroCoverage,public  (final IntervalList intervals final Histogram<Integer> highQualityDepthHistogram final Histogram<Integer> unfilteredDepthHistogram final double pctExcludedByMapq final double pctExcludedByDupes final double pctExcludedByPairing final double pctExcludedByBaseq final double pctExcludedByOverlap final double pctExcludedByCapping final double pctTotal final int coverageCap final Histogram<Integer> unfilteredBaseQHistogram final int sampleSize){ super(intervals highQualityDepthHistogram unfilteredDepthHistogram pctExcludedByMapq pctExcludedByDupes pctExcludedByPairing pctExcludedByBaseq pctExcludedByOverlap pctExcludedByCapping pctTotal coverageCap unfilteredBaseQHistogram sampleSize); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetricsWithNonZeroCoverage.java,WgsMetricsWithNonZeroCoverageCollector,public  (final CollectWgsMetricsWithNonZeroCoverage metrics final int coverageCap final IntervalList intervals){ super(metrics coverageCap intervals); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetricsWithNonZeroCoverage.java,addToMetricsFile,@Override public void  (final MetricsFile<WgsMetrics Integer> file final boolean includeBQHistogram final CountingFilter dupeFilter final CountingFilter mapqFilter final CountingPairedFilter pairFilter){ highQualityDepthHistogram=getDepthHistogram(); high
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetricsWithNonZeroCoverage.java,areHistogramsEmpty,public boolean  (){ return (highQualityDepthHistogram.isEmpty() || highQualityDepthHistogramNonZero.isEmpty()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetricsWithNonZeroCoverage.java,doWork,@Override protected int  (){ IOUtil.assertFileIsWritable(CHART_OUTPUT); IOUtil.assertFileIsReadable(INPUT); getSamReader(); this.collector=new WgsMetricsWithNonZeroCoverageCollector(this COVERAGE_CAP getIntervalsToExamine()); super.doWork(); final List<SA
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetricsWithNonZeroCoverage.java,generateWgsMetrics,@Override protected WgsMetrics  (final IntervalList intervals final Histogram<Integer> highQualityDepthHistogram final Histogram<Integer> unfilteredDepthHistogram final double pctExcludedByMapq final double pctExcludedByDupes final double pctExcludedByPai
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetricsWithNonZeroCoverage.java,getCollector,@Override protected WgsMetricsCollector  (final int coverageCap final IntervalList intervals){ assert (coverageCap == this.collector.coverageCap); return this.collector; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetricsWithNonZeroCoverage.java,getDepthHistogram,"protected Histogram<Integer>  (){ return getHistogram(highQualityDepthHistogramArray ""coverage"" ""count_WHOLE_GENOME""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetricsWithNonZeroCoverage.java,getDepthHistogramNonZero,"private Histogram<Integer>  (){ final Histogram<Integer> depthHistogram=new Histogram<>(""coverage"" ""count_NON_ZERO_REGIONS""); for (int i=1; i < highQualityDepthHistogramArray.length; ++i) { depthHistogram.increment(i highQualityDepthHistogramArray[i]); } return depthHistogram; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetricsWithNonZeroCoverage.java,getSamReader,@Override protected SamReader  (){ if (this.samReader == null) { this.samReader=super.getSamReader(); } return this.samReader; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CollectWgsMetricsWithNonZeroCoverage.java,main,public static void  (final String[] args){ new CollectWgsMetrics().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CounterManager.java,Counter,private  (int arrayLength){ array=new int[arrayLength]; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CounterManager.java,CounterManager,public  (final int arrayLength int readLength){ this.arrayLength=arrayLength; this.readLength=readLength; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CounterManager.java,checkIndex,"private void  (int index){ if ((index - offset) < 0 || (index - offset) >= array.length) { throw new ArrayIndexOutOfBoundsException(""The requested index "" + index + "" is out of counter bounds. ""+ ""Possible cause of exception can be wrong READ_LENGTH parameter (much smaller than actual read length)""); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CounterManager.java,checkOutOfBounds,public void  (int locusPosition){ if (locusPosition - offset + readLength >= arrayLength) { if (locusPosition - offset < arrayLength) { rebase(locusPosition); } else { clear(); offset=locusPosition; } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CounterManager.java,clear,public void  (){ for ( Counter counter : arrays) { final int[] array=counter.array; Arrays.fill(array 0); } offset=0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CounterManager.java,get,public int  (int index){ checkIndex(index); return array[index - offset]; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CounterManager.java,getOffset,int  (){ return offset; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CounterManager.java,increment,public void  (int index){ checkIndex(index); array[index - offset]++; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CounterManager.java,newCounter,public Counter  (){ final Counter counter=new Counter(arrayLength); arrays.add(counter); return counter; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CounterManager.java,rebase,"private void  (int locusPosition){ if (locusPosition < offset) { throw new IllegalArgumentException(""Position in the reference sequence is lesser than offset.""); } for ( Counter counter : arrays) { final int[] array=counter.array; final int skipLength=locusPosition - offset; System.arraycopy(array skipLength array 0 arrayLength - skipLength); Arrays.fill(array arrayLength - skipLength arrayLength 0); } offset=locusPosition; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\CounterManager.java,setOffset,void  (int offset){ this.offset=offset; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\CollectTargetedPcrMetrics.java,getProbeIntervals,@Override protected IntervalList  (){ return IntervalList.fromFile(AMPLICON_INTERVALS); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\CollectTargetedPcrMetrics.java,getProbeSetName,@Override protected String  (){ return CUSTOM_AMPLICON_SET_NAME != null ? CUSTOM_AMPLICON_SET_NAME : CollectTargetedMetrics.renderProbeNameFromFile(AMPLICON_INTERVALS); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\CollectTargetedPcrMetrics.java,main,public static void  (final String[] argv){ System.exit(new CollectTargetedPcrMetrics().instanceMain(argv)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\CollectTargetedPcrMetrics.java,makeCollector,@Override protected TargetedPcrMetricsCollector  (final Set<MetricAccumulationLevel> accumulationLevels final List<SAMReadGroupRecord> samRgRecords final ReferenceSequenceFile refFile final File perTargetCoverage final File perBaseCoverage final IntervalL
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\CollectTargetedMetrics.java,customCommandLineValidation,"protected String[]  (){ if (PER_TARGET_COVERAGE != null && (METRIC_ACCUMULATION_LEVEL.size() != 1 || METRIC_ACCUMULATION_LEVEL.iterator().next() != MetricAccumulationLevel.ALL_READS)) { return new String[]{""PER_TARGET_COVERAGE can be specified only when METRIC_ACCUMULATION_LEVEL is set "" + ""to ALL_READS.""}; } if (PER_TARGET_COVERAGE != null && REFERENCE_SEQUENCE == null) { return new String[]{""Must supply REFERENCE_SEQUENCE when supplying PER_TARGET_COVERAGE""}; } return super.customCommandLineValidation(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\CollectTargetedMetrics.java,doWork,protected int  (){ for ( final File targetInterval : TARGET_INTERVALS) IOUtil.assertFileIsReadable(targetInterval); IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); if (PER_TARGET_COVERAGE != null) IOUtil.assertFileIsWritable(PER_TARGET_COVERAGE); final SamReader reader=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT); final IntervalList targetIntervals=IntervalList.fromFiles(TARGET_INTERVALS); SequenceUtil.assertSequenceDictionariesEqual(reader.getFileHeader().getSequenceDictionary() targetIntervals.getHeader().getSequenceDictionary()); SequenceUtil.assertSequenceDictionariesEqual(reader.getFileHeader().getSequenceDictionary() getProbeIntervals().getHeader().getSequenceDictionary()); ReferenceSequenceFile ref=null; if (REFERENCE_SEQUENCE != null) { IOUtil.assertFileIsReadable(REFERENCE_SEQUENCE); ref=ReferenceSequenceFileFactory.getReferenceSequenceFile(REFERENCE_SEQUENCE); SequenceUtil.assertSequenceDictionariesEqual(reader.getFileHeader().getSequenceDictionary() ref.getSequenceDictionary() INPUT REFERENCE_SEQUENCE); } final COLLECTOR collector=makeCollector(METRIC_ACCUMULATION_LEVEL reader.getFileHeader().getReadGroups() ref PER_TARGET_COVERAGE PER_BASE_COVERAGE targetIntervals getProbeIntervals() getProbeSetName() NEAR_DISTANCE); final ProgressLogger progress=new ProgressLogger(log); for ( final SAMRecord record : reader) { collector.acceptRecord(record null); progress.record(record); } final MetricsFile<METRIC Integer> metrics=getMetricsFile(); collector.finish(); collector.addAllLevelsToFile(metrics); metrics.write(OUTPUT); CloserUtil.close(reader); return 0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\CollectHsMetrics.java,CollectHsMetrics,public  (){ MINIMUM_MAPPING_QUALITY=20; MINIMUM_BASE_QUALITY=20; CLIP_OVERLAPPING_READS=true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\CollectHsMetrics.java,getProbeIntervals,@Override protected IntervalList  (){ for ( final File file : BAIT_INTERVALS) IOUtil.assertFileIsReadable(file); return IntervalList.fromFiles(BAIT_INTERVALS); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\CollectHsMetrics.java,getProbeSetName,@Override protected String  (){ if (BAIT_SET_NAME != null) { return BAIT_SET_NAME; } else { final SortedSet<String> baitSetNames=new TreeSet<String>(); for ( final File file : BAIT_INTERVALS) { baitSetNames.add(CollectTargetedMetrics.renderProbeNameFromFi
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\CollectHsMetrics.java,main,public static void  (final String[] argv){ System.exit(new CollectHsMetrics().instanceMain(argv)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\CollectHsMetrics.java,makeCollector,@Override protected HsMetricCollector  (final Set<MetricAccumulationLevel> accumulationLevels final List<SAMReadGroupRecord> samRgRecords final ReferenceSequenceFile refFile final File perTargetCoverage final File perBaseCoverage final IntervalList target
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\HsMetricCollector.java,HsMetricCollector,public  (final Set<MetricAccumulationLevel> accumulationLevels final List<SAMReadGroupRecord> samRgRecords final ReferenceSequenceFile refFile final File perTargetCoverage final File perBaseCoverage final IntervalList targetIntervals final IntervalList probeIntervals final String probeSetName final int nearProbeDistance final int minimumMappingQuality final int minimumBaseQuality final boolean clipOverlappingReads final boolean noSideEffects final int coverageCap final int sampleSize){ super(accumulationLevels samRgRecords refFile perTargetCoverage perBaseCoverage targetIntervals probeIntervals probeSetName nearProbeDistance minimumMappingQuality minimumBaseQuality clipOverlappingReads noSideEffects coverageCap sampleSize); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\HsMetricCollector.java,calculateHsPenalty,private double  (final Long librarySize final TargetMetrics targetMetrics final int coverageGoal){ if (librarySize == null) return 0; final double meanCoverage=targetMetrics.ON_TARGET_FROM_PAIR_BASES / (double)targetMetrics.TARGET_TERRITORY; final double fold80=targetMetrics.FOLD_80_BASE_PENALTY; final long pairs=targetMetrics.PF_SELECTED_PAIRS; final long uniquePairs=targetMetrics.PF_SELECTED_UNIQUE_PAIRS; final double onTargetPct=(double)targetMetrics.ON_TARGET_BASES / (double)targetMetrics.PF_UQ_BASES_ALIGNED; final double uniquePairGoalMultiplier=(coverageGoal / meanCoverage) * fold80; double pairMultiplier=uniquePairGoalMultiplier; double increment=1; boolean goingUp=uniquePairGoalMultiplier >= 1; double finalPairMultiplier=-1; for (int i=0; i < 10000; ++i) { final double uniquePairMultiplier=DuplicationMetrics.estimateRoi(librarySize pairMultiplier pairs uniquePairs); if (Math.abs(uniquePairMultiplier - uniquePairGoalMultiplier) / uniquePairGoalMultiplier <= 0.001) { finalPairMultiplier=pairMultiplier; break; } else if ((uniquePairMultiplier > uniquePairGoalMultiplier && goingUp) || (uniquePairMultiplier < uniquePairGoalMultiplier && !goingUp)) { increment/=2; goingUp=!goingUp; } pairMultiplier+=(goingUp ? increment : -increment); } if (finalPairMultiplier == -1) { return -1; } else { final double uniqueFraction=(uniquePairs * uniquePairGoalMultiplier) / (pairs * finalPairMultiplier); return (1 / uniqueFraction) * fold80 * (1 / onTargetPct); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\HsMetricCollector.java,convertMetric,"@Override public HsMetrics  (final TargetMetrics targetMetrics){ final HsMetrics hsMetrics=new HsMetrics(); TargetMetricsCollector.reflectiveCopy(targetMetrics hsMetrics new String[]{""PROBE_SET"" ""PROBE_TERRITORY"" ""ON_PROBE_BASES"" ""NEAR_PROBE_BASES"" ""OFF_P"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\InsertSizeMetricsCollector.java,InsertSizeCollectorArgs,public  (final int insertSize final SamPairUtil.PairOrientation po){ this.insertSize=insertSize; this.po=po; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\InsertSizeMetricsCollector.java,InsertSizeMetricsCollector,public  (final Set<MetricAccumulationLevel> accumulationLevels final List<SAMReadGroupRecord> samRgRecords final double minimumPct final Integer histogramWidth final double deviations final boolean includeDuplicates){ this.minimumPct=minimumPct; this.histogramWidth=histogramWidth; this.deviations=deviations; this.includeDuplicates=includeDuplicates; setup(accumulationLevels samRgRecords); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\InsertSizeMetricsCollector.java,PerUnitInsertSizeMetricsCollector,"public  (final String sample final String library final String readGroup){ this.sample=sample; this.library=library; this.readGroup=readGroup; String prefix=null; if (this.readGroup != null) { prefix=this.readGroup + "".""; } else if (this.library != null) { prefix=this.library + "".""; } else if (this.sample != null) { prefix=this.sample + "".""; } else { prefix=""All_Reads.""; } histograms.put(SamPairUtil.PairOrientation.FR new Histogram<Integer>(""insert_size"" prefix + ""fr_count"")); histograms.put(SamPairUtil.PairOrientation.TANDEM new Histogram<Integer>(""insert_size"" prefix + ""tandem_count"")); histograms.put(SamPairUtil.PairOrientation.RF new Histogram<Integer>(""insert_size"" prefix + ""rf_count"")); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\InsertSizeMetricsCollector.java,acceptRecord,public void  (final InsertSizeCollectorArgs args){ histograms.get(args.getPairOrientation()).increment(args.getInsertSize()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\InsertSizeMetricsCollector.java,addMetricsToFile,public void  (final MetricsFile<InsertSizeMetrics Integer> file){ for ( final Histogram<Integer> h : this.histograms.values()) { totalInserts+=h.getCount(); } if (0 == totalInserts) return; for ( final Map.Entry<SamPairUtil.PairOrientation Histogram<Integer>> entry : histograms.entrySet()) { final SamPairUtil.PairOrientation pairOrientation=entry.getKey(); final Histogram<Integer> histogram=entry.getValue(); final double total=histogram.getCount(); if (total >= totalInserts * minimumPct) { final InsertSizeMetrics metrics=new InsertSizeMetrics(); metrics.SAMPLE=this.sample; metrics.LIBRARY=this.library; metrics.READ_GROUP=this.readGroup; metrics.PAIR_ORIENTATION=pairOrientation; if (!histogram.isEmpty()) { metrics.READ_PAIRS=(long)total; metrics.MAX_INSERT_SIZE=(int)histogram.getMax(); metrics.MIN_INSERT_SIZE=(int)histogram.getMin(); metrics.MEDIAN_INSERT_SIZE=histogram.getMedian(); metrics.MODE_INSERT_SIZE=histogram.getMode(); metrics.MEDIAN_ABSOLUTE_DEVIATION=histogram.getMedianAbsoluteDeviation(); final double median=histogram.getMedian(); double covered=0; double low=median; double high=median; while (low >= histogram.getMin() - 1 || high <= histogram.getMax() + 1) { final Histogram.Bin<Integer> lowBin=histogram.get((int)low); if (lowBin != null) covered+=lowBin.getValue(); if (low != high) { final Histogram.Bin<Integer> highBin=histogram.get((int)high); if (highBin != null) covered+=highBin.getValue(); } final double percentCovered=covered / total; final int distance=(int)(high - low) + 1; if (percentCovered >= 0.1 && metrics.WIDTH_OF_10_PERCENT == 0) metrics.WIDTH_OF_10_PERCENT=distance; if (percentCovered >= 0.2 && metrics.WIDTH_OF_20_PERCENT == 0) metrics.WIDTH_OF_20_PERCENT=distance; if (percentCovered >= 0.3 && metrics.WIDTH_OF_30_PERCENT == 0) metrics.WIDTH_OF_30_PERCENT=distance; if (percentCovered >= 0.4 && metrics.WIDTH_OF_40_PERCENT == 0) metrics.WIDTH_OF_40_PERCENT=distance; if (percentCovered >= 0.5 && metrics.WIDTH_OF_50_PERCENT == 0) metrics.WIDTH_OF_50_PERCENT=distance; if (percentCovered >= 0.6 && metrics.WIDTH_OF_60_PERCENT == 0) metrics.WIDTH_OF_60_PERCENT=distance; if (percentCovered >= 0.7 && metrics.WIDTH_OF_70_PERCENT == 0) metrics.WIDTH_OF_70_PERCENT=distance; if (percentCovered >= 0.8 && metrics.WIDTH_OF_80_PERCENT == 0) metrics.WIDTH_OF_80_PERCENT=distance; if (percentCovered >= 0.9 && metrics.WIDTH_OF_90_PERCENT == 0) metrics.WIDTH_OF_90_PERCENT=distance; if (percentCovered >= 0.95 && metrics.WIDTH_OF_95_PERCENT == 0) metrics.WIDTH_OF_95_PERCENT=distance; if (percentCovered >= 0.99 && metrics.WIDTH_OF_99_PERCENT == 0) metrics.WIDTH_OF_99_PERCENT=distance; --low; ++high; } } final Histogram<Integer> trimmedHistogram=histogram; trimmedHistogram.trimByWidth(getWidthToTrimTo(metrics)); if (!trimmedHistogram.isEmpty()) { metrics.MEAN_INSERT_SIZE=trimmedHistogram.getMean(); metrics.STANDARD_DEVIATION=trimmedHistogram.getStandardDeviation(); } file.addHistogram(trimmedHistogram); file.addMetric(metrics); } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\InsertSizeMetricsCollector.java,getInsertSize,public int  (){ return insertSize; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\InsertSizeMetricsCollector.java,getPairOrientation,public SamPairUtil.PairOrientation  (){ return po; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\InsertSizeMetricsCollector.java,getTotalInserts,public double  (){ return totalInserts; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\InsertSizeMetricsCollector.java,getWidthToTrimTo,private int  (InsertSizeMetrics metrics){ if (histogramWidth == null) { return (int)(metrics.MEDIAN_INSERT_SIZE + (deviations * metrics.MEDIAN_ABSOLUTE_DEVIATION)); } else { return histogramWidth; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\InsertSizeMetricsCollector.java,makeArg,@Override protected InsertSizeCollectorArgs  (SAMRecord samRecord ReferenceSequence refSeq){ final int insertSize=Math.abs(samRecord.getInferredInsertSize()); final SamPairUtil.PairOrientation orientation=SamPairUtil.getPairOrientation(samRecord); return 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\InsertSizeMetricsCollector.java,makeChildCollector,@Override protected PerUnitMetricCollector<InsertSizeMetrics Integer InsertSizeCollectorArgs>  (final String sample final String library final String readGroup){ return new PerUnitInsertSizeMetricsCollector(sample library readGroup); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\FastWgsMetricsCollector.java,FastWgsMetricsCollector,public  (CollectWgsMetrics collectWgsMetrics int coverageCap final IntervalList intervals){ super(collectWgsMetrics coverageCap intervals); this.previousSequenceIndex=-1; this.counterManager=new CounterManager(collectWgsMetrics.READ_LENGTH * ARRAY_SIZE_PER_READ_LENGTH collectWgsMetrics.READ_LENGTH); this.pileupSize=counterManager.newCounter(); this.unfilteredDepthSize=counterManager.newCounter(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\FastWgsMetricsCollector.java,addInfo,@Override public void  (final AbstractLocusInfo<EdgingRecordAndOffset> info final ReferenceSequence ref boolean referenceBaseN){ prepareCollector(info); for ( final EdgingRecordAndOffset record : info.getRecordAndOffsets()) { final String readName=record.
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\FastWgsMetricsCollector.java,excludeByQuality,private int  (final Set<EdgingRecordAndOffset> setForName int position){ int bsq=0; for ( EdgingRecordAndOffset recordAndOffset : setForName) { if (position - recordAndOffset.getRefPos() >= recordAndOffset.getLength() || recordAndOffset.getBaseQuality(position) < collectWgsMetrics.MINIMUM_BASE_QUALITY) { bsq++; } } return bsq; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\FastWgsMetricsCollector.java,prepareCollector,private void  (AbstractLocusInfo<EdgingRecordAndOffset> info){ if (readsNames == null) { readsNames=new HashMap<>(); } if (previousSequenceIndex != info.getSequenceIndex()) { readsNames.clear(); counterManager.clear(); previousSequenceIndex=info.getSequenceIndex(); } counterManager.checkOutOfBounds(info.getPosition()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\FastWgsMetricsCollector.java,processRecord,private void  (int position ReferenceSequence ref EdgingRecordAndOffset record Set<EdgingRecordAndOffset> recordsAndOffsetsForName){ long processedLoci=counter; readsNames.put(record.getReadName() recordsAndOffsetsForName); final byte[] qualities=record.getBaseQualities(); final byte[] bases=record.getRecord().getReadBases(); for (int i=0; i < record.getLength(); i++) { final int index=i + position; if (isReferenceBaseN(index ref)) { continue; } final byte quality=qualities[i + record.getOffset()]; if (quality <= 2) { basesExcludedByBaseq++; } else { if (unfilteredDepthSize.get(index) < coverageCap) { unfilteredBaseQHistogramArray[quality]++; unfilteredDepthSize.increment(index); } if (quality < collectWgsMetrics.MINIMUM_BASE_QUALITY || SequenceUtil.isNoCall(bases[i + record.getOffset()])) { basesExcludedByBaseq++; } else { final int bsq=excludeByQuality(recordsAndOffsetsForName index); if (recordsAndOffsetsForName.size() - bsq > 0) { basesExcludedByOverlap++; } else { pileupSize.increment(index); } } } if (isTimeToStop(++processedLoci)) { break; } } recordsAndOffsetsForName.add(record); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\FastWgsMetricsCollector.java,removeRecordFromMap,private void  (EdgingRecordAndOffset record Set<EdgingRecordAndOffset> recordsAndOffsetsForName){ if (recordsAndOffsetsForName.size() == 1) { readsNames.remove(record.getReadName()); } else { recordsAndOffsetsForName.remove(record.getStart()); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\TargetedPcrMetricsCollector.java,TargetedPcrMetricsCollector,public  (final Set<MetricAccumulationLevel> accumulationLevels final List<SAMReadGroupRecord> samRgRecords final ReferenceSequenceFile refFile final File perTargetCoverage final File perBaseCoverage final IntervalList targetIntervals final IntervalList probeIntervals final String probeSetName final int nearProbeDistance final int minimumMappingQuality final int minimumBaseQuality final boolean clipOverlappingReads final boolean noSideEffects final int coverageCap final int sampleSize){ super(accumulationLevels samRgRecords refFile perTargetCoverage perBaseCoverage targetIntervals probeIntervals probeSetName nearProbeDistance minimumMappingQuality minimumBaseQuality clipOverlappingReads noSideEffects coverageCap sampleSize); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\TargetedPcrMetricsCollector.java,convertMetric,"@Override public TargetedPcrMetrics  (final TargetMetrics targetMetrics){ final TargetedPcrMetrics pcrMetrics=new TargetedPcrMetrics(); TargetMetricsCollector.reflectiveCopy(targetMetrics pcrMetrics new String[]{""PROBE_SET"" ""PROBE_TERRITORY"" ""ON_PROBE_BAS"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\TargetMetricsCollector.java,Coverage,public  (final Interval i final int padding){ this.interval=i; this.depths=new int[interval.length() + 2 * padding]; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\TargetMetricsCollector.java,PerUnitTargetMetricCollector,public  (final String probeSetName final Set<Interval> coverageTargets final String sample final String library final String readGroup final long probeTerritory final long targetTerritory final long genomeSize final Map<Interval Double> intervalToGc final int minimumMappingQuality final int minimumBaseQuality final boolean clipOverlappingReads){ this.metrics.SAMPLE=sample; this.metrics.LIBRARY=library; this.metrics.READ_GROUP=readGroup; this.metrics.PROBE_SET=probeSetName; metrics.PROBE_TERRITORY=probeTerritory; metrics.TARGET_TERRITORY=targetTerritory; metrics.GENOME_SIZE=genomeSize; highQualityCoverageByTarget=new LinkedHashMap<>(coverageTargets.size() * 2 0.5f); unfilteredCoverageByTarget=new LinkedHashMap<>(coverageTargets.size() * 2 0.5f); for ( final Interval target : coverageTargets) { highQualityCoverageByTarget.put(target new Coverage(target 0)); unfilteredCoverageByTarget.put(target new Coverage(target 0)); } this.mapQFilter=new CountingMapQFilter(minimumMappingQuality); this.minimumBaseQuality=minimumBaseQuality; this.intervalToGc=intervalToGc; this.clipOverlappingReads=clipOverlappingReads; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\TargetMetricsCollector.java,TargetMetricsCollector,public  (final Set<MetricAccumulationLevel> accumulationLevels final List<SAMReadGroupRecord> samRgRecords final ReferenceSequenceFile refFile final File perTargetCoverage final File perBaseCoverage final IntervalList targetIntervals final IntervalList probeIntervals final String probeSetName final int nearProbeDistance final int minimumMappingQuality final int minimumBaseQuality final boolean clipOverlappingReads final boolean noSideEffects final int coverageCap final int sampleSize){ this.perTargetCoverage=perTargetCoverage; this.perBaseCoverage=perBaseCoverage; this.probeSetName=probeSetName; this.nearProbeDistance=nearProbeDistance; this.allProbes=probeIntervals; this.allTargets=targetIntervals; this.coverageCap=coverageCap; this.sampleSize=sampleSize; final List<Interval> uniqueBaits=this.allProbes.uniqued().getIntervals(); this.probeDetector=new OverlapDetector<Interval>(-this.nearProbeDistance 0); this.probeDetector.addAll(uniqueBaits uniqueBaits); this.probeTerritory=Interval.countBases(uniqueBaits); final List<Interval> uniqueTargets=this.allTargets.uniqued().getIntervals(); targetDetector=new OverlapDetector<Interval>(0 0); this.targetDetector.addAll(uniqueTargets uniqueTargets); this.targetTerritory=Interval.countBases(uniqueTargets); int i=0; cov=new Coverage[uniqueTargets.size()]; this.coverageByTargetForRead=new LinkedHashMap<Interval Coverage>(uniqueTargets.size() * 2 0.5f); for ( final Interval target : uniqueTargets) { final Coverage coverage=new Coverage(target 0); this.coverageByTargetForRead.put(target coverage); cov[i++]=coverage; } long genomeSizeAccumulator=0; for ( final SAMSequenceRecord seq : this.allProbes.getHeader().getSequenceDictionary().getSequences()) { genomeSizeAccumulator+=seq.getSequenceLength(); } this.genomeSize=genomeSizeAccumulator; if (refFile != null) { intervalToGc=new HashMap<Interval Double>(); for ( final Interval target : uniqueTargets) { final ReferenceSequence rs=refFile.getSubsequenceAt(target.getContig() target.getStart() target.getEnd()); intervalToGc.put(target SequenceUtil.calculateGc(rs.getBases())); } } this.minimumMappingQuality=minimumMappingQuality; this.minimumBaseQuality=minimumBaseQuality; this.clipOverlappingReads=clipOverlappingReads; this.noSideEffects=noSideEffects; setup(accumulationLevels samRgRecords); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\TargetMetricsCollector.java,acceptRecord,public void  (final SAMRecord record){ if (record.getNotPrimaryAlignmentFlag()) return; final boolean mappedInPair=record.getReadPairedFlag() && !record.getReadUnmappedFlag() && !record.getMateUnmappedFlag()&& !record.getSupplementaryAlignmentFlag(); final byte[] baseQualities=record.getBaseQualities(); int basesAlignedInRecord=0; if (!record.getReadUnmappedFlag()) { for ( final AlignmentBlock block : record.getAlignmentBlocks()) { basesAlignedInRecord+=block.getLength(); } } if (!record.getSupplementaryAlignmentFlag()) { this.metrics.TOTAL_READS++; if (!record.getReadFailsVendorQualityCheckFlag()) { this.metrics.PF_READS++; if (!record.getDuplicateReadFlag()) { this.metrics.PF_UNIQUE_READS++; if (!record.getReadUnmappedFlag()) { this.metrics.PF_UQ_READS_ALIGNED++; } } } } if (record.getReadFailsVendorQualityCheckFlag()) return; if (!record.getSupplementaryAlignmentFlag()) this.metrics.PF_BASES+=record.getReadLength(); if (!record.getReadUnmappedFlag()) { this.metrics.PF_BASES_ALIGNED+=basesAlignedInRecord; if (!record.getDuplicateReadFlag()) { this.metrics.PF_UQ_BASES_ALIGNED+=basesAlignedInRecord; } } if (record.getReadUnmappedFlag()) return; final Interval read=new Interval(record.getReferenceName() record.getAlignmentStart() record.getAlignmentEnd()); final Collection<Interval> targets=targetDetector.getOverlaps(read); final Collection<Interval> probes=probeDetector.getOverlaps(read); if (!record.getSupplementaryAlignmentFlag() && record.getReadPairedFlag() && record.getFirstOfPairFlag()&& !record.getReadUnmappedFlag()&& !record.getMateUnmappedFlag()&& !probes.isEmpty()) { ++this.metrics.PF_SELECTED_PAIRS; if (!record.getDuplicateReadFlag()) ++this.metrics.PF_SELECTED_UNIQUE_PAIRS; } { final int mappedBases=basesAlignedInRecord; int onBaitBases=0; if (!probes.isEmpty()) { for ( final Interval bait : probes) { for ( final AlignmentBlock block : record.getAlignmentBlocks()) { final int end=CoordMath.getEnd(block.getReferenceStart() block.getLength()); for (int pos=block.getReferenceStart(); pos <= end; ++pos) { if (pos >= bait.getStart() && pos <= bait.getEnd()) ++onBaitBases; } } } this.metrics.ON_PROBE_BASES+=onBaitBases; this.metrics.NEAR_PROBE_BASES+=(mappedBases - onBaitBases); } else { this.metrics.OFF_PROBE_BASES+=mappedBases; } } if (record.getDuplicateReadFlag()) { this.metrics.PCT_EXC_DUPE+=basesAlignedInRecord; return; } if (this.mapQFilter.filterOut(record)) return; final SAMRecord rec; if (clipOverlappingReads) { final int numOverlappingBasesToClip=SAMUtils.getNumOverlappingAlignedBasesToClip(record); rec=SAMUtils.clipOverlappingAlignedBases(record numOverlappingBasesToClip noSideEffects); metrics.PCT_EXC_OVERLAP+=numOverlappingBasesToClip; if (rec.getReadUnmappedFlag()) return; } else { rec=record; } final Set<Interval> coveredTargets=new HashSet<>(); for ( final AlignmentBlock block : rec.getAlignmentBlocks()) { final int length=block.getLength(); final int refStart=block.getReferenceStart(); final int readStart=block.getReadStart(); for (int offset=0; offset < length; ++offset) { final int refPos=refStart + offset; final int readPos=readStart + offset; final int qual=baseQualities[readPos - 1]; if (qual <= 2) { metrics.PCT_EXC_BASEQ++; continue; } boolean isOnTarget=false; for ( final Interval target : targets) { if (refPos >= target.getStart() && refPos <= target.getEnd()) { final int targetOffset=refPos - target.getStart(); if (qual >= minimumBaseQuality) { ++metrics.ON_TARGET_BASES; if (mappedInPair) ++metrics.ON_TARGET_FROM_PAIR_BASES; final Coverage highQualityCoverage=highQualityCoverageByTarget.get(target); highQualityCoverage.addBase(targetOffset); if (!coveredTargets.contains(target)) { highQualityCoverage.incrementReadCount(); coveredTargets.add(target); isOnTarget=true; } } else { this.metrics.PCT_EXC_BASEQ++; } unfilteredCoverageByTarget.get(target).addBase(targetOffset); if (unfilteredCoverageByTarget.get(target).getDepths()[targetOffset] <= coverageCap) { baseQHistogramArray[qual]++; } } } if (!isOnTarget) this.metrics.PCT_EXC_OFF_TARGET++; } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\TargetMetricsCollector.java,addBase,public void  (final int offset final int depth){ if (offset >= 0 && offset < this.depths.length && this.depths[offset] < Integer.MAX_VALUE - depth) { this.depths[offset]+=depth; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\TargetMetricsCollector.java,addMetricsToFile,@Override public void  (final MetricsFile<METRIC_TYPE Integer> hsMetricsComparableMetricsFile){ hsMetricsComparableMetricsFile.addMetric(convertMetric(this.metrics)); hsMetricsComparableMetricsFile.addHistogram(highQualityDepthHistogram); hsMetricsCompara
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\TargetMetricsCollector.java,calculateGcMetrics,"private void  (){ if (this.intervalToGc != null) { log.info(""Calculating GC metrics""); final FormatUtil fmt=new FormatUtil(); final PrintWriter out; try { if (perTargetOutput != null) { out=new PrintWriter(perTargetOutput); out.println(""chrom\tstart\tend\tlength\tname\t%gc\tmean_coverage\tnormalized_coverage\tmin_normalized_coverage\tmax_normalized_coverage\tmin_coverage\tmax_coverage\tpct_0x\tread_count""); } else { out=null; } } catch ( final IOException ioe) { throw new RuntimeIOException(ioe); } final int bins=101; final long[] targetBasesByGc=new long[bins]; final long[] alignedBasesByGc=new long[bins]; for ( final Map.Entry<Interval Coverage> entry : this.highQualityCoverageByTarget.entrySet()) { final Interval interval=entry.getKey(); final Coverage cov=entry.getValue(); if (interval.length() <= 0) { log.warn(""interval of length zero found: "" + interval + "" skipped.""); continue; } final double gcDouble=this.intervalToGc.get(interval); final int gc=(int)Math.round(gcDouble * 100); targetBasesByGc[gc]+=interval.length(); alignedBasesByGc[gc]+=cov.getTotal(); if (out != null) { final double coverage=cov.getTotal() / (double)interval.length(); double min=Integer.MAX_VALUE; double max=Integer.MIN_VALUE; double targetBasesAt0x=0.0; for ( final int d : cov.getDepths()) { if (0 == d) targetBasesAt0x++; if (d < min) min=d; if (max < d) max=d; } out.println(interval.getContig() + ""\t"" + interval.getStart()+ ""\t""+ interval.getEnd()+ ""\t""+ interval.length()+ ""\t""+ interval.getName()+ ""\t""+ fmt.format(gcDouble)+ ""\t""+ fmt.format(coverage)+ ""\t""+ fmt.format(coverage / this.metrics.MEAN_TARGET_COVERAGE)+ ""\t""+ fmt.format(min / this.metrics.MEAN_TARGET_COVERAGE)+ ""\t""+ fmt.format(max / this.metrics.MEAN_TARGET_COVERAGE)+ ""\t""+ fmt.format(min)+ ""\t""+ fmt.format(max)+ ""\t""+ fmt.format(targetBasesAt0x / interval.length())+ ""\t""+ fmt.format(cov.readCount)); } } if (out != null) out.close(); long totalTarget=0; long totalBases=0; for (int i=0; i < targetBasesByGc.length; ++i) { totalTarget+=targetBasesByGc[i]; totalBases+=alignedBasesByGc[i]; } for (int i=0; i < targetBasesByGc.length; ++i) { final double targetPct=targetBasesByGc[i] / (double)totalTarget; final double alignedPct=alignedBasesByGc[i] / (double)totalBases; double dropout=(alignedPct - targetPct) * 100d; if (dropout < 0) { dropout=Math.abs(dropout); if (i <= 50) this.metrics.AT_DROPOUT+=dropout; if (i >= 50) this.metrics.GC_DROPOUT+=dropout; } } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\TargetMetricsCollector.java,calculateTargetCoverageMetrics,"private void  (){ final long[] highQualityCoverageHistogramArray=new long[coverageCap + 1]; int zeroCoverageTargets=0; long totalCoverage=0; long maxDepth=0; final int[] targetBasesDepth={0 1 2 10 20 30 40 50 100}; final int[] targetBases=new int[targetBasesDepth.length]; for ( final Coverage c : this.highQualityCoverageByTarget.values()) { if (!c.hasCoverage()) { zeroCoverageTargets++; highQualityCoverageHistogramArray[0]+=c.interval.length(); targetBases[0]+=c.interval.length(); continue; } for ( final int depth : c.getDepths()) { totalCoverage+=depth; highQualityCoverageHistogramArray[Math.min(depth coverageCap)]++; maxDepth=Math.max(maxDepth depth); for (int i=0; i < targetBasesDepth.length; i++) { if (depth >= targetBasesDepth[i]) targetBases[i]++; else break; } } } if (targetBases[0] != highQualityCoverageByTarget.keySet().stream().mapToInt(Interval::length).sum()) { throw new PicardException(""the number of target bases with at least 0x coverage does not equal the number of target bases""); } for (int i=0; i < highQualityCoverageHistogramArray.length; ++i) { highQualityDepthHistogram.increment(i highQualityCoverageHistogramArray[i]); } metrics.MEAN_TARGET_COVERAGE=(double)totalCoverage / metrics.TARGET_TERRITORY; metrics.MEDIAN_TARGET_COVERAGE=highQualityDepthHistogram.getMedian(); metrics.MAX_TARGET_COVERAGE=maxDepth; metrics.FOLD_80_BASE_PENALTY=metrics.MEAN_TARGET_COVERAGE / highQualityDepthHistogram.getPercentile(0.2); metrics.ZERO_CVG_TARGETS_PCT=zeroCoverageTargets / (double)allTargets.getIntervals().size(); metrics.PCT_TARGET_BASES_1X=(double)targetBases[1] / (double)targetBases[0]; metrics.PCT_TARGET_BASES_2X=(double)targetBases[2] / (double)targetBases[0]; metrics.PCT_TARGET_BASES_10X=(double)targetBases[3] / (double)targetBases[0]; metrics.PCT_TARGET_BASES_20X=(double)targetBases[4] / (double)targetBases[0]; metrics.PCT_TARGET_BASES_30X=(double)targetBases[5] / (double)targetBases[0]; metrics.PCT_TARGET_BASES_40X=(double)targetBases[6] / (double)targetBases[0]; metrics.PCT_TARGET_BASES_50X=(double)targetBases[7] / (double)targetBases[0]; metrics.PCT_TARGET_BASES_100X=(double)targetBases[8] / (double)targetBases[0]; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\TargetMetricsCollector.java,calculateTheoreticalHetSensitivity,"private void  (){ final long[] unfilteredDepthHistogramArray=new long[coverageCap + 1]; for ( final Coverage c : this.unfilteredCoverageByTarget.values()) { if (!c.hasCoverage()) { unfilteredDepthHistogramArray[0]+=c.interval.length(); continue; } for ( final int depth : c.getDepths()) { unfilteredDepthHistogramArray[Math.min(depth coverageCap)]++; } } if (LongStream.of(baseQHistogramArray).sum() != LongStream.rangeClosed(0 coverageCap).map(i -> i * unfilteredDepthHistogramArray[(int)i]).sum()) { throw new PicardException(""numbers of bases in the base quality histogram and the coverage histogram are not equal""); } for (int i=0; i < baseQHistogramArray.length; ++i) { unfilteredBaseQHistogram.increment(i baseQHistogramArray[i]); } for (int i=0; i < unfilteredDepthHistogramArray.length; i++) { unfilteredDepthHistogram.increment(i unfilteredDepthHistogramArray[i]); } final double[] depthDoubleArray=TheoreticalSensitivity.normalizeHistogram(unfilteredDepthHistogram); final double[] baseQDoubleArray=TheoreticalSensitivity.normalizeHistogram(unfilteredBaseQHistogram); metrics.HET_SNP_SENSITIVITY=TheoreticalSensitivity.hetSNPSensitivity(depthDoubleArray baseQDoubleArray sampleSize LOG_ODDS_THRESHOLD); metrics.HET_SNP_Q=QualityUtil.getPhredScoreFromErrorProbability((1 - metrics.HET_SNP_SENSITIVITY)); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasUtils.java,calculateAllGcs,public static byte[]  (final byte[] refBases final int lastWindowStart final int windowSize){ final CalculateGcState state=new GcBiasUtils().new CalculateGcState(); final int refLength=refBases.length; final byte[] gc=new byte[refLength + 1]; for (int i=1; i < lastWindowStart; ++i) { final int windowEnd=i + windowSize; final int windowGc=calculateGc(refBases i windowEnd state); gc[i]=(byte)windowGc; } return gc; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasUtils.java,calculateGc,public static int  (final byte[] bases final int startIndex final int endIndex final CalculateGcState state){ if (state.init) { state.init=false; state.gcCount=0; state.nCount=0; for (int i=startIndex; i < endIndex; ++i) { final byte base=bases[i]; if (SequenceUtil.basesEqual(base (byte)'G') || SequenceUtil.basesEqual(base (byte)'C')) ++state.gcCount; else if (SequenceUtil.basesEqual(base (byte)'N')) ++state.nCount; } } else { final byte newBase=bases[endIndex - 1]; if (SequenceUtil.basesEqual(newBase (byte)'G') || SequenceUtil.basesEqual(newBase (byte)'C')) ++state.gcCount; else if (newBase == 'N') ++state.nCount; if (SequenceUtil.basesEqual(state.priorBase (byte)'G') || SequenceUtil.basesEqual(state.priorBase (byte)'C')) --state.gcCount; else if (SequenceUtil.basesEqual(state.priorBase (byte)'N')) --state.nCount; } state.priorBase=bases[startIndex]; if (state.nCount > 4) return -1; else return (state.gcCount * 100) / (endIndex - startIndex); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasUtils.java,calculateRefWindowsByGc,public static int[]  (final int windows final File referenceSequence final int windowSize){ final ReferenceSequenceFile refFile=ReferenceSequenceFileFactory.getReferenceSequenceFile(referenceSequence); ReferenceSequence ref; final int[] windowsByGc=new int[windows]; while ((ref=refFile.nextSequence()) != null) { final byte[] refBases=ref.getBases(); StringUtil.toUpperCase(refBases); final int refLength=refBases.length; final int lastWindowStart=refLength - windowSize; final CalculateGcState state=new GcBiasUtils().new CalculateGcState(); for (int i=1; i < lastWindowStart; ++i) { final int windowEnd=i + windowSize; final int gcBin=calculateGc(refBases i windowEnd state); if (gcBin != -1) windowsByGc[gcBin]++; } } return windowsByGc; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\RnaSeqMetricsCollector.java,PerUnitRnaSeqMetricsCollector,public  (final String sample final String library final String readGroup final Long ribosomalBasesInitialValue){ this(new RnaSeqMetrics() sample library readGroup ribosomalBasesInitialValue); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\RnaSeqMetricsCollector.java,RnaSeqMetricsCollector,public  (final Set<MetricAccumulationLevel> accumulationLevels final List<SAMReadGroupRecord> samRgRecords final Long ribosomalBasesInitialValue OverlapDetector<Gene> geneOverlapDetector OverlapDetector<Interval> ribosomalSequenceOverlapDetector final HashSet<Integer> ignoredSequenceIndices final int minimumLength final StrandSpecificity strandSpecificity final double rrnaFragmentPercentage boolean collectCoverageStatistics){ this.ribosomalInitialValue=ribosomalBasesInitialValue; this.ignoredSequenceIndices=ignoredSequenceIndices; this.geneOverlapDetector=geneOverlapDetector; this.ribosomalSequenceOverlapDetector=ribosomalSequenceOverlapDetector; this.minimumLength=minimumLength; this.strandSpecificity=strandSpecificity; this.rrnaFragmentPercentage=rrnaFragmentPercentage; this.collectCoverageStatistics=collectCoverageStatistics; setup(accumulationLevels samRgRecords); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\RnaSeqMetricsCollector.java,acceptRecord,public void  (SAMRecord rec){ if (rec.getReadFailsVendorQualityCheckFlag()) return; if (!rec.getNotPrimaryAlignmentFlag()) this.metrics.PF_BASES+=rec.getReadLength(); if (!rec.getReadUnmappedFlag() && !rec.getNotPrimaryAlignmentFlag() && ignoredSequenceIndices.contains(rec.getReferenceIndex())) { ++this.metrics.IGNORED_READS; return; } if (rec.getNotPrimaryAlignmentFlag() || rec.getReadUnmappedFlag()) return; final Interval readInterval=new Interval(rec.getReferenceName() rec.getAlignmentStart() rec.getAlignmentEnd()); final Interval fragmentInterval; if (!rec.getReadPairedFlag()) { fragmentInterval=readInterval; } else if (rec.getMateUnmappedFlag() || rec.getReferenceIndex() != rec.getMateReferenceIndex()) { fragmentInterval=null; } else { final int fragmentStart=Math.min(rec.getAlignmentStart() rec.getMateAlignmentStart()); final int fragmentEnd=CoordMath.getEnd(fragmentStart Math.abs(rec.getInferredInsertSize())); fragmentInterval=new Interval(rec.getReferenceName() fragmentStart fragmentEnd); } if (fragmentInterval != null) { final Collection<Interval> overlappingRibosomalIntervals=ribosomalSequenceOverlapDetector.getOverlaps(fragmentInterval); int intersectionLength=0; for ( final Interval overlappingInterval : overlappingRibosomalIntervals) { final int thisIntersectionLength=overlappingInterval.getIntersectionLength(fragmentInterval); intersectionLength=Math.max(intersectionLength thisIntersectionLength); } if (intersectionLength / (double)fragmentInterval.length() >= rrnaFragmentPercentage) { metrics.RIBOSOMAL_BASES+=rec.getReadLength(); metrics.PF_ALIGNED_BASES+=getNumAlignedBases(rec); return; } } final Collection<Gene> overlappingGenes=geneOverlapDetector.getOverlaps(readInterval); final List<AlignmentBlock> alignmentBlocks=rec.getAlignmentBlocks(); boolean overlapsExon=false; for ( final AlignmentBlock alignmentBlock : alignmentBlocks) { final LocusFunction[] locusFunctions=new LocusFunction[alignmentBlock.getLength()]; Arrays.fill(locusFunctions 0 locusFunctions.length LocusFunction.INTERGENIC); for ( final Gene gene : overlappingGenes) { for ( final Gene.Transcript transcript : gene) { transcript.assignLocusFunctionForRange(alignmentBlock.getReferenceStart() locusFunctions); if (collectCoverageStatistics) { int[] coverage=this.coverageByTranscript.get(transcript); if (coverage == null) { coverage=new int[transcript.length()]; this.coverageByTranscript.put(transcript coverage); } transcript.addCoverageCounts(alignmentBlock.getReferenceStart() CoordMath.getEnd(alignmentBlock.getReferenceStart() alignmentBlock.getLength()) coverage); } } } for ( final LocusFunction locusFunction : locusFunctions) { ++metrics.PF_ALIGNED_BASES; switch (locusFunction) { case INTERGENIC: ++metrics.INTERGENIC_BASES; break; case INTRONIC: ++metrics.INTRONIC_BASES; break; case UTR: ++metrics.UTR_BASES; overlapsExon=true; break; case CODING: ++metrics.CODING_BASES; overlapsExon=true; break; case RIBOSOMAL: ++metrics.RIBOSOMAL_BASES; break; } } } if (!rec.getSupplementaryAlignmentFlag() && overlapsExon && overlappingGenes.size() == 1) { final Gene gene=overlappingGenes.iterator().next(); final boolean negativeTranscriptionStrand=gene.isNegativeStrand(); final boolean readOneOrUnpaired=!rec.getReadPairedFlag() || rec.getFirstOfPairFlag(); final boolean negativeReadStrand=rec.getReadNegativeStrandFlag(); if (strandSpecificity != StrandSpecificity.NONE) { final boolean readAndTranscriptStrandsAgree=negativeReadStrand == negativeTranscriptionStrand; final boolean firstReadExpectedToAgree=strandSpecificity == StrandSpecificity.FIRST_READ_TRANSCRIPTION_STRAND; final boolean thisReadExpectedToAgree=readOneOrUnpaired == firstReadExpectedToAgree; if (readAndTranscriptStrandsAgree == thisReadExpectedToAgree) { ++metrics.CORRECT_STRAND_READS; } else { ++metrics.INCORRECT_STRAND_READS; } } if (readOneOrUnpaired) { final boolean properOrientation; final int leftMostAlignedBase  rightMostAlignedBase; if (rec.getReadPairedFlag()) { if (rec.getMateUnmappedFlag()) { properOrientation=false; leftMostAlignedBase=rightMostAlignedBase=0; } else { final Cigar mateCigar=SAMUtils.getMateCigar(rec); final int mateReferenceLength=(mateCigar == null) ? rec.getReadLength() : mateCigar.getReferenceLength(); final int mateAlignmentEnd=CoordMath.getEnd(rec.getMateAlignmentStart() mateReferenceLength); properOrientation=SamPairUtil.getPairOrientation(rec) == SamPairUtil.PairOrientation.FR; leftMostAlignedBase=Math.min(rec.getAlignmentStart() rec.getMateAlignmentStart()); rightMostAlignedBase=Math.max(rec.getAlignmentEnd() mateAlignmentEnd); } } else { properOrientation=true; leftMostAlignedBase=rec.getAlignmentStart(); rightMostAlignedBase=rec.getAlignmentEnd(); } if (properOrientation && CoordMath.encloses(gene.getStart() gene.getEnd() leftMostAlignedBase rightMostAlignedBase)) { if (negativeReadStrand == negativeTranscriptionStrand) { ++metrics.NUM_R1_TRANSCRIPT_STRAND_READS; } else { ++metrics.NUM_R2_TRANSCRIPT_STRAND_READS; } } else { ++metrics.NUM_UNEXPLAINED_READS; } } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\RnaSeqMetricsCollector.java,addMetricsToFile,@Override public void  (final MetricsFile<RnaSeqMetrics Integer> file){ final Histogram<Integer> normalizedCovByPos=computeCoverageMetrics(); file.addMetric(metrics); file.addHistogram(normalizedCovByPos); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\RnaSeqMetricsCollector.java,computeCoverageMetrics,"private Histogram<Integer>  (){ final Histogram<Double> cvs=new Histogram<Double>(); final Histogram<Double> fivePrimeSkews=new Histogram<Double>(); final Histogram<Double> threePrimeSkews=new Histogram<Double>(); final Histogram<Double> gapBasesPerKb=new Histogram<Double>(); final Histogram<Double> fiveToThreeSkews=new Histogram<Double>(); String prefix=null; if (this.metrics.READ_GROUP != null) { prefix=this.metrics.READ_GROUP + "".""; } else if (this.metrics.LIBRARY != null) { prefix=this.metrics.LIBRARY + "".""; } else if (this.metrics.SAMPLE != null) { prefix=this.metrics.SAMPLE + "".""; } else { prefix=""All_Reads.""; } final Histogram<Integer> normalizedCoverageByNormalizedPosition=new Histogram<Integer>(""normalized_position"" prefix + ""normalized_coverage""); final Map<Gene.Transcript int[]> transcripts=pickTranscripts(coverageByTranscript); final double transcriptCount=transcripts.size(); for ( final Map.Entry<Gene.Transcript int[]> entry : transcripts.entrySet()) { final Gene.Transcript tx=entry.getKey(); final double[] coverage; { final double[] tmp=MathUtil.promote(entry.getValue()); if (tx.getGene().isPositiveStrand()) coverage=tmp; else coverage=copyAndReverse(tmp); } final double mean=MathUtil.mean(coverage 0 coverage.length); final double stdev=MathUtil.stddev(coverage 0 coverage.length mean); final double cv=stdev / mean; cvs.increment(cv); { final int PRIME_BASES=100; final double fivePrimeCoverage=MathUtil.mean(coverage 0 PRIME_BASES); final double threePrimeCoverage=MathUtil.mean(coverage coverage.length - PRIME_BASES coverage.length); fivePrimeSkews.increment(fivePrimeCoverage / mean); threePrimeSkews.increment(threePrimeCoverage / mean); fiveToThreeSkews.increment(MathUtil.divide(fivePrimeCoverage threePrimeCoverage)); } { final int lastIndex=coverage.length - 1; for (int percent=0; percent <= 100; ++percent) { final double p=percent / 100d; final int start=(int)Math.max(0 lastIndex * (p - 0.005)); final int end=(int)Math.min(lastIndex lastIndex * (p + 0.005)); final int length=end - start + 1; double sum=0; for (int i=start; i <= end; ++i) sum+=coverage[i]; final double normalized=(sum / length) / mean; normalizedCoverageByNormalizedPosition.increment(percent normalized / transcriptCount); } } } this.metrics.MEDIAN_CV_COVERAGE=cvs.getMedian(); this.metrics.MEDIAN_5PRIME_BIAS=fivePrimeSkews.getMedian(); this.metrics.MEDIAN_3PRIME_BIAS=threePrimeSkews.getMedian(); this.metrics.MEDIAN_5PRIME_TO_3PRIME_BIAS=fiveToThreeSkews.getMedian(); return normalizedCoverageByNormalizedPosition; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\RnaSeqMetricsCollector.java,copyAndReverse,private double[]  (final double[] in){ final double[] out=new double[in.length]; for (int i=0  j=in.length - 1; i < in.length; ++i  --j) out[j]=in[i]; return out; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\RnaSeqMetricsCollector.java,finish,public void  (){ if (metrics.PF_ALIGNED_BASES > 0) { if (metrics.RIBOSOMAL_BASES != null) { metrics.PCT_RIBOSOMAL_BASES=metrics.RIBOSOMAL_BASES / (double)metrics.PF_ALIGNED_BASES; } metrics.PCT_CODING_BASES=metrics.CODING_BASES / (double)metrics.PF_ALIGNED_BASES; metrics.PCT_UTR_BASES=metrics.UTR_BASES / (double)metrics.PF_ALIGNED_BASES; metrics.PCT_INTRONIC_BASES=metrics.INTRONIC_BASES / (double)metrics.PF_ALIGNED_BASES; metrics.PCT_INTERGENIC_BASES=metrics.INTERGENIC_BASES / (double)metrics.PF_ALIGNED_BASES; metrics.PCT_MRNA_BASES=metrics.PCT_CODING_BASES + metrics.PCT_UTR_BASES; metrics.PCT_USABLE_BASES=(metrics.CODING_BASES + metrics.UTR_BASES) / (double)metrics.PF_BASES; } if (metrics.CORRECT_STRAND_READS > 0 || metrics.INCORRECT_STRAND_READS > 0) { metrics.PCT_CORRECT_STRAND_READS=metrics.CORRECT_STRAND_READS / (double)(metrics.CORRECT_STRAND_READS + metrics.INCORRECT_STRAND_READS); } final long readsExamined=metrics.NUM_R1_TRANSCRIPT_STRAND_READS + metrics.NUM_R2_TRANSCRIPT_STRAND_READS; if (0 < readsExamined) { metrics.PCT_R1_TRANSCRIPT_STRAND_READS=metrics.NUM_R1_TRANSCRIPT_STRAND_READS / (double)readsExamined; metrics.PCT_R2_TRANSCRIPT_STRAND_READS=metrics.NUM_R2_TRANSCRIPT_STRAND_READS / (double)readsExamined; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\RnaSeqMetricsCollector.java,getGenesForPickTranscripts,protected Set<Gene>  (){ return geneOverlapDetector.getAll(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\RnaSeqMetricsCollector.java,getGenesWithTranscripts,private Set<Gene>  (Collection<Gene.Transcript> transcripts){ final Set<Gene> genesWithTranscripts=new HashSet<>(); final Set<Gene> genesForPickTranscripts=getGenesForPickTranscripts(); for ( final Gene.Transcript transcript : transcripts) { if (genesForPickTranscripts.contains(transcript.getGene())) { genesWithTranscripts.add(transcript.getGene()); } } return genesWithTranscripts; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\RnaSeqMetricsCollector.java,getNumAlignedBases,protected int  (SAMRecord rec){ int numAlignedBases=0; for ( final AlignmentBlock alignmentBlock : rec.getAlignmentBlocks()) { numAlignedBases+=alignmentBlock.getLength(); } return numAlignedBases; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\RnaSeqMetricsCollector.java,makeChildCollector,@Override protected PerUnitMetricCollector<RnaSeqMetrics Integer SAMRecord>  (final String sample final String library final String readGroup){ return new PerUnitRnaSeqMetricsCollector(sample library readGroup ribosomalInitialValue); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\RnaSeqMetricsCollector.java,makeIgnoredSequenceIndicesSet,"public static HashSet<Integer>  (final SAMFileHeader header final Set<String> ignoredSequence){ final HashSet<Integer> ignoredSequenceIndices=new HashSet<Integer>(); for ( final String sequenceName : ignoredSequence) { final SAMSequenceRecord sequenceRecord=header.getSequence(sequenceName); if (sequenceRecord == null) { throw new PicardException(""Unrecognized sequence "" + sequenceName + "" passed as argument to IGNORE_SEQUENCE""); } ignoredSequenceIndices.add(sequenceRecord.getSequenceIndex()); } return ignoredSequenceIndices; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\RnaSeqMetricsCollector.java,makeOverlapDetector,"public static OverlapDetector<Interval>  (final File samFile final SAMFileHeader header final File ribosomalIntervalsFile final Log log){ final OverlapDetector<Interval> ribosomalSequenceOverlapDetector=new OverlapDetector<Interval>(0 0); if (ribosomalIntervalsFile != null) { final IntervalList ribosomalIntervals=IntervalList.fromFile(ribosomalIntervalsFile); if (ribosomalIntervals.size() == 0) { log.warn(""The RIBOSOMAL_INTERVALS file  "" + ribosomalIntervalsFile.getAbsolutePath() + "" does not contain intervals""); } try { SequenceUtil.assertSequenceDictionariesEqual(header.getSequenceDictionary() ribosomalIntervals.getHeader().getSequenceDictionary()); } catch ( SequenceUtil.SequenceListsDifferException e) { throw new PicardException(""Sequence dictionaries differ in "" + samFile.getAbsolutePath() + "" and ""+ ribosomalIntervalsFile.getAbsolutePath() e); } final IntervalList uniquedRibosomalIntervals=ribosomalIntervals.uniqued(); final List<Interval> intervals=uniquedRibosomalIntervals.getIntervals(); ribosomalSequenceOverlapDetector.addAll(intervals intervals); } return ribosomalSequenceOverlapDetector; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\directed\RnaSeqMetricsCollector.java,pickTranscripts,public Map<Gene.Transcript int[]>  (final Map<Gene.Transcript int[]> transcriptCoverage){ final Set<Gene> genesWithTranscripts=getGenesWithTranscripts(transcriptCoverage.keySet()); final Map<Gene.Transcript Double> bestPerGene=new HashMap<Gene.Transcript Double>(); for ( final Gene gene : genesWithTranscripts) { Gene.Transcript best=null; double bestMean=0; for ( final Gene.Transcript tx : gene) { final int[] cov=transcriptCoverage.get(tx); if (tx.length() < Math.max(minimumLength 100)) continue; final double mean=MathUtil.mean(MathUtil.promote(cov) 0 cov.length); if (mean < 1d) continue; if (best == null || mean > bestMean) { best=tx; bestMean=mean; } } if (best != null) bestPerGene.put(best bestMean); } final double[] coverages=new double[bestPerGene.size()]; int i=0; for ( final double d : bestPerGene.values()) coverages[i++]=d; Arrays.sort(coverages); final double min=coverages.length == 0 ? 0 : coverages[Math.max(0 coverages.length - 1001)]; final Map<Gene.Transcript int[]> retval=new HashMap<Gene.Transcript int[]>(); for ( final Map.Entry<Gene.Transcript Double> entry : bestPerGene.entrySet()) { final Gene.Transcript tx=entry.getKey(); final double coverage=entry.getValue(); if (coverage >= min) { retval.put(tx transcriptCoverage.get(tx)); } } return retval; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasMetricsCollector.java,GcBiasCollectorArgs,public  (final SAMRecord rec final ReferenceSequence ref){ this.rec=rec; this.ref=ref; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasMetricsCollector.java,GcBiasMetricsCollector,public  (final Set<MetricAccumulationLevel> accumulationLevels final int[] windowsByGc final List<SAMReadGroupRecord> samRgRecords final int scanWindowSize final boolean bisulfite final boolean ignoreDuplicates){ this.scanWindowSize=scanWindowSize; this.bisulfite=bisulfite; this.windowsByGc=windowsByGc; this.ignoreDuplicates=ignoreDuplicates; setup(accumulationLevels samRgRecords); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasMetricsCollector.java,PerUnitGcBiasMetricsCollector,public  (final String sample final String library final String readGroup){ this.sample=sample; this.library=library; this.readGroup=readGroup; this.gcData=prepareGcData(); if (ignoreDuplicates) { this.gcDataNonDups=prepareGcData(); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasMetricsCollector.java,acceptRecord,"@Override public void  (final GcBiasCollectorArgs args){ final SAMRecord rec=args.getRec(); if (logCounter < 100 && rec.getReadBases().length == 0) { log.warn(""Omitting read "" + rec.getReadName() + "" with '*' in SEQ field.""); if (++logCounter == 100) { lo"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasMetricsCollector.java,addGcDataToFile,private void  (final MetricsFile<GcBiasMetrics Integer> file final Map<String GcObject> gcData final boolean includeDuplicates){ for ( final Map.Entry<String GcObject> entry : gcData.entrySet()) { final GcObject gcCur=entry.getValue(); final String gcType=entry.getKey(); final int[] readsByGc=gcCur.readsByGc; final long[] errorsByGc=gcCur.errorsByGc; final long[] basesByGc=gcCur.basesByGc; final long totalClusters=gcCur.totalClusters; final long totalAlignedReads=gcCur.totalAlignedReads; final String group=gcCur.group; final GcBiasMetrics metrics=new GcBiasMetrics(); final double totalWindows=sum(windowsByGc); final double totalReads=sum(readsByGc); final double meanReadsPerWindow=totalReads / totalWindows; if (totalAlignedReads > 0) { for (int i=0; i < windowsByGc.length; ++i) { final GcBiasDetailMetrics detail=new GcBiasDetailMetrics(); detail.GC=i; detail.WINDOWS=windowsByGc[i]; detail.READ_STARTS=readsByGc[i]; if (errorsByGc[i] > 0) { detail.MEAN_BASE_QUALITY=QualityUtil.getPhredScoreFromObsAndErrors(basesByGc[i] errorsByGc[i]); } if (windowsByGc[i] != 0) { detail.NORMALIZED_COVERAGE=(detail.READ_STARTS / (double)detail.WINDOWS) / meanReadsPerWindow; detail.ERROR_BAR_WIDTH=(Math.sqrt(detail.READ_STARTS) / (double)detail.WINDOWS) / meanReadsPerWindow; } else { detail.NORMALIZED_COVERAGE=0; detail.ERROR_BAR_WIDTH=0; } detail.ACCUMULATION_LEVEL=group; if (group.equals(ACCUMULATION_LEVEL_READ_GROUP)) { detail.READ_GROUP=gcType; } else if (group.equals(ACCUMULATION_LEVEL_SAMPLE)) { detail.SAMPLE=gcType; } else if (group.equals(ACCUMULATION_LEVEL_LIBRARY)) { detail.LIBRARY=gcType; } detail.READS_USED=includeDuplicates ? READS_USED_ALL : READS_USED_UNIQUE; metrics.DETAILS.addMetric(detail); } final GcBiasSummaryMetrics summary=new GcBiasSummaryMetrics(); if (group.equals(ACCUMULATION_LEVEL_READ_GROUP)) { summary.READ_GROUP=gcType; } else if (group.equals(ACCUMULATION_LEVEL_SAMPLE)) { summary.SAMPLE=gcType; } else if (group.equals(ACCUMULATION_LEVEL_LIBRARY)) { summary.LIBRARY=gcType; } summary.READS_USED=includeDuplicates ? READS_USED_ALL : READS_USED_UNIQUE; summary.ACCUMULATION_LEVEL=group; summary.WINDOW_SIZE=scanWindowSize; summary.TOTAL_CLUSTERS=totalClusters; summary.ALIGNED_READS=totalAlignedReads; summary.GC_NC_0_19=calculateGcNormCoverage(meanReadsPerWindow readsByGc 0 19); summary.GC_NC_20_39=calculateGcNormCoverage(meanReadsPerWindow readsByGc 20 39); summary.GC_NC_40_59=calculateGcNormCoverage(meanReadsPerWindow readsByGc 40 59); summary.GC_NC_60_79=calculateGcNormCoverage(meanReadsPerWindow readsByGc 60 79); summary.GC_NC_80_100=calculateGcNormCoverage(meanReadsPerWindow readsByGc 80 100); calculateDropoutMetrics(metrics.DETAILS.getMetrics() summary); metrics.SUMMARY=summary; file.addMetric(metrics); } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasMetricsCollector.java,addMetricsToFile,@Override public void  (final MetricsFile<GcBiasMetrics Integer> file){ addGcDataToFile(file this.gcData true); if (ignoreDuplicates) { addGcDataToFile(file this.gcDataNonDups false); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasMetricsCollector.java,addRead,private void  (final GcObject gcObj final SAMRecord rec final String group final byte[] gc final byte[] refBases){ if (!rec.getReadPairedFlag() || rec.getFirstOfPairFlag()) ++gcObj.totalClusters; final int pos=rec.getReadNegativeStrandFlag() ? rec.getAlignmentEnd() - scanWindowSize : rec.getAlignmentStart(); ++gcObj.totalAlignedReads; if (pos > 0) { final int windowGc=gc[pos]; if (windowGc >= 0) { ++gcObj.readsByGc[windowGc]; gcObj.basesByGc[windowGc]+=rec.getReadLength(); gcObj.errorsByGc[windowGc]+=SequenceUtil.countMismatches(rec refBases bisulfite) + SequenceUtil.countInsertedBases(rec) + SequenceUtil.countDeletedBases(rec); } } if (gcObj.group == null) { gcObj.group=group; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasMetricsCollector.java,addReadToGcData,private void  (final SAMRecord rec final Map<String GcObject> gcData){ final String type; String group; if (this.readGroup != null) { type=this.readGroup; group=ACCUMULATION_LEVEL_READ_GROUP; } else if (this.library != null) { type=this.library; group=ACCUMULATION_LEVEL_LIBRARY; } else if (this.sample != null) { type=this.sample; group=ACCUMULATION_LEVEL_SAMPLE; } else { type=allReads; group=ACCUMULATION_LEVEL_ALL_READS; } addRead(gcData.get(type) rec group gc refBases); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasMetricsCollector.java,calculateDropoutMetrics,private void  (final Collection<GcBiasDetailMetrics> details final GcBiasSummaryMetrics summary){ double totalReads=0; double totalWindows=0; for ( final GcBiasDetailMetrics detail : details) { totalReads+=detail.READ_STARTS; totalWindows+=detail.WINDOWS; } double atDropout=0; double gcDropout=0; for ( final GcBiasDetailMetrics detail : details) { final double relativeReads=detail.READ_STARTS / totalReads; final double relativeWindows=detail.WINDOWS / totalWindows; final double dropout=(relativeWindows - relativeReads) * 100; if (dropout > 0) { if (detail.GC <= 50) atDropout+=dropout; else { gcDropout+=dropout; } } } summary.AT_DROPOUT=atDropout; summary.GC_DROPOUT=gcDropout; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasMetricsCollector.java,calculateGcNormCoverage,private double  (final double meanReadsPerWindow final int[] readsByGc final int start final int end){ int windowsTotal=0; double sum=0.0; for (int i=start; i <= end; i++) { if (windowsByGc[i] != 0) { sum+=(double)readsByGc[i]; windowsTotal+=windowsByGc[i]; } } if (windowsTotal == 0) { return 0.0; } else { return (sum / (windowsTotal * meanReadsPerWindow)); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasMetricsCollector.java,getRec,public SAMRecord  (){ return rec; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasMetricsCollector.java,getRef,public ReferenceSequence  (){ return ref; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasMetricsCollector.java,makeArg,@Override protected GcBiasCollectorArgs  (final SAMRecord rec final ReferenceSequence ref){ return new GcBiasCollectorArgs(rec ref); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasMetricsCollector.java,makeChildCollector,@Override protected PerUnitMetricCollector<GcBiasMetrics Integer GcBiasCollectorArgs>  (final String sample final String library final String readGroup){ return new PerUnitGcBiasMetricsCollector(sample library readGroup); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasMetricsCollector.java,prepareGcData,private Map<String GcObject>  (){ final String prefix; final Map<String GcObject> gcData=new HashMap<>(); if (this.readGroup != null) { prefix=this.readGroup; } else if (this.library != null) { prefix=this.library; } else if (this.sample != null) { prefix=this.sample; } else { prefix=allReads; } gcData.put(prefix new GcObject()); return gcData; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasMetricsCollector.java,sum,private double  (final int[] values){ final int length=values.length; double total=0; for (int i=0; i < length; i++) { total+=values[i]; } return total; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\GcBiasMetricsCollector.java,updateTotalClusters,private void  (final SAMRecord rec final Map<String GcObject> gcData){ for ( final Map.Entry<String GcObject> entry : gcData.entrySet()) { final GcObject gcCur=entry.getValue(); if (!rec.getReadPairedFlag() || rec.getFirstOfPairFlag()) ++gcCur.totalClusters; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\MeanQualityByCycle.java,HistogramGenerator,private  (final boolean useOriginalQualities){ this.useOriginalQualities=useOriginalQualities; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\MeanQualityByCycle.java,acceptRead,@Override protected void  (final SAMRecord rec final ReferenceSequence ref){ if (PF_READS_ONLY && rec.getReadFailsVendorQualityCheckFlag()) return; if (ALIGNED_READS_ONLY && rec.getReadUnmappedFlag()) return; if (rec.isSecondaryOrSupplementary()) return; 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\QualityScoreDistribution.java,acceptRead,@Override protected void  (final SAMRecord rec final ReferenceSequence ref){ if (PF_READS_ONLY && rec.getReadFailsVendorQualityCheckFlag()) return; if (ALIGNED_READS_ONLY && rec.getReadUnmappedFlag()) return; if (rec.isSecondaryOrSupplementary()) return; 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\QualityScoreDistribution.java,finish,"@Override protected void  (){ final Histogram<Byte> qHisto=new Histogram<Byte>(""QUALITY"" ""COUNT_OF_Q""); final Histogram<Byte> oqHisto=new Histogram<Byte>(""QUALITY"" ""COUNT_OF_OQ""); for (int i=0; i < qCounts.length; ++i) { if (qCounts[i] > 0) qHisto.increme"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\QualityScoreDistribution.java,main,public static void  (final String[] args){ System.exit(new QualityScoreDistribution().instanceMain(args)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\QualityScoreDistribution.java,setup,@Override protected void  (final SAMFileHeader header final File samFile){ IOUtil.assertFileIsWritable(OUTPUT); IOUtil.assertFileIsWritable(CHART_OUTPUT); final List<SAMReadGroupRecord> readGroups=header.getReadGroups(); if (readGroups.size() == 1) { this
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\MeanQualityByCycle.java,addRecord,void  (final SAMRecord rec){ final byte[] quals=(useOriginalQualities ? rec.getOriginalBaseQualities() : rec.getBaseQualities()); if (quals == null) return; final int length=quals.length; final boolean rc=rec.getReadNegativeStrandFlag(); ensureArraysBigEnough(length + 1); for (int i=0; i < length; ++i) { final int cycle=rc ? length - i : i + 1; if (rec.getReadPairedFlag() && rec.getSecondOfPairFlag()) { secondReadTotalsByCycle[cycle]+=quals[i]; secondReadCountsByCycle[cycle]+=1; } else { firstReadTotalsByCycle[cycle]+=quals[i]; firstReadCountsByCycle[cycle]+=1; } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\MeanQualityByCycle.java,ensureArraysBigEnough,private void  (final int length){ if (length > maxLengthSoFar) { firstReadTotalsByCycle=Arrays.copyOf(firstReadTotalsByCycle length); firstReadCountsByCycle=Arrays.copyOf(firstReadCountsByCycle length); secondReadTotalsByCycle=Arrays.copyOf(secondReadTotalsByCycle length); secondReadCountsByCycle=Arrays.copyOf(secondReadCountsByCycle length); maxLengthSoFar=length; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\MeanQualityByCycle.java,finish,@Override protected void  (){ final MetricsFile<? Integer> metrics=getMetricsFile(); metrics.addHistogram(q.getMeanQualityHistogram()); if (!oq.isEmpty()) metrics.addHistogram(oq.getMeanQualityHistogram()); metrics.write(OUTPUT); if (q.isEmpty() && oq.isE
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\MeanQualityByCycle.java,getMeanQualityHistogram,"Histogram<Integer>  (){ final String label=useOriginalQualities ? ""MEAN_ORIGINAL_QUALITY"" : ""MEAN_QUALITY""; final Histogram<Integer> meanQualities=new Histogram<Integer>(""CYCLE"" label); int firstReadLength=0; for (int cycle=0; cycle < firstReadTotalsByCycle.length; ++cycle) { if (firstReadTotalsByCycle[cycle] > 0) { meanQualities.increment(cycle firstReadTotalsByCycle[cycle] / firstReadCountsByCycle[cycle]); firstReadLength=cycle; } } for (int i=0; i < secondReadTotalsByCycle.length; ++i) { if (secondReadCountsByCycle[i] > 0) { final int cycle=firstReadLength + i; meanQualities.increment(cycle secondReadTotalsByCycle[i] / secondReadCountsByCycle[i]); } } return meanQualities; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\MeanQualityByCycle.java,isEmpty,boolean  (){ return maxLengthSoFar == 0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\MeanQualityByCycle.java,main,public static void  (String[] args){ System.exit(new MeanQualityByCycle().instanceMain(args)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\MeanQualityByCycle.java,setup,@Override protected void  (final SAMFileHeader header final File samFile){ IOUtil.assertFileIsWritable(CHART_OUTPUT); final List<SAMReadGroupRecord> readGroups=header.getReadGroups(); if (readGroups.size() == 1) { plotSubtitle=StringUtil.asEmptyIfNull(rea
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\MergeableMetricBase.java,canMerge,public boolean  (final MergeableMetricBase other){ try { for ( final Field field : this.getClass().getDeclaredFields()) { if (field.isSynthetic()) continue; field.get(other); final Annotation[] equalAnnotations=field.getAnnotationsByType(MergeByAssertEquals.class); if (equalAnnotations.length != 0) { if (field.get(this) == null) return true; if (field.get(other) == null) return true; if (!field.get(this).equals(field.get(other))) return false; } } } catch ( final Exception e) { return false; } return true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\MergeableMetricBase.java,getAllFields,private static List<Field>  (Class clazz){ final List<Field> fields=new ArrayList<>(); fields.addAll(Arrays.asList(clazz.getDeclaredFields())); final Class superClass=clazz.getSuperclass(); if (superClass != null) fields.addAll(getAllFields(superClass)); return fields; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\MergeableMetricBase.java,merge,"public MergeableMetricBase  (final MergeableMetricBase other){ for ( final Field field : getAllFields(this.getClass())) { if (field.isSynthetic()) continue; if (field.getAnnotationsByType(MergeByAdding.class).length + field.getAnnotationsByType(MergeByAssertEquals.class).length + field.getAnnotationsByType(NoMergingIsDerived.class).length+ field.getAnnotationsByType(MergingIsManual.class).length+ field.getAnnotationsByType(NoMergingKeepsValue.class).length == 0) { throw new IllegalStateException(""All fields of this class must be annotated with @MergeByAdding  @NoMergingIsDerived  or @MergeByAssertEquals. "" + ""Field "" + field.getName() + "" isn't annotated.""); } final Annotation[] summableAnnotations=field.getAnnotationsByType(MergeByAdding.class); field.setAccessible(true); if (summableAnnotations.length != 0) { try { if (field.getType() == Integer.class) { field.set(this (Integer)field.get(this) + (Integer)field.get(other)); } else if (field.getType() == int.class) { field.set(this (int)field.get(this) + (int)field.get(other)); } else if (field.getType() == Float.class) { field.set(this (Float)field.get(this) + (Float)field.get(other)); } else if (field.getType() == float.class) { field.set(this (float)field.get(this) + (float)field.get(other)); } else if (field.getType() == Double.class) { field.set(this (Double)field.get(this) + (Double)field.get(other)); } else if (field.getType() == double.class) { field.set(this (double)field.get(this) + (double)field.get(other)); } else if (field.getType() == Long.class) { field.set(this (Long)field.get(this) + (Long)field.get(other)); } else if (field.getType() == long.class) { field.set(this (long)field.get(this) + (long)field.get(other)); } else if (field.getType() == Byte.class) { final Integer result=(Byte)field.get(this) + (Byte)field.get(other); if (result > Byte.MAX_VALUE) throw new IllegalArgumentException(""Overflow detected in adding "" + field.get(this) + "" to ""+ field.get(other)); field.set(this (byte)(int)result); } else if (field.getType() == byte.class) { final int result=(byte)field.get(this) + (byte)field.get(other); if (result > Byte.MAX_VALUE) throw new IllegalArgumentException(""Overflow detected in adding "" + field.get(this) + "" to ""+ field.get(other)); field.set(this (byte)result); } else if (field.getType() == Short.class) { final Integer result=(Short)field.get(this) + (Short)field.get(other); if (result > Short.MAX_VALUE) throw new IllegalArgumentException(""Overflow detected in adding "" + field.get(this) + "" to ""+ field.get(other)); field.set(this (Short)(short)(int)result); } else if (field.getType() == short.class) { final Integer result=(short)field.get(this) + (short)field.get(other); if (result > Short.MAX_VALUE) throw new IllegalArgumentException(""Overflow detected in adding "" + field.get(this) + "" to ""+ field.get(other)); field.set(this (short)(int)result); } else throw new IllegalArgumentException(""I don't know how to MergeByAdding type "" + field.getDeclaringClass().getCanonicalName() + "" of field ""+ field.getName()+ ""please teach me!""); } catch ( IllegalAccessException e) { e.printStackTrace(); } } final Annotation[] equalAnnotations=field.getAnnotationsByType(MergeByAssertEquals.class); if (equalAnnotations.length != 0) { try { if (field.get(this) == null) { field.set(this field.get(other)); } else if (field.get(other) != null && !field.get(this).equals(field.get(other))) { throw new IllegalStateException(""Field "" + field.getName() + "" is annotated as @MergeByAssertEquals  but found two different values: ""+ field.get(this)+ "" & ""+ field.get(other)); } } catch ( IllegalAccessException e) { e.printStackTrace(); } } } return this; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\MergeableMetricBase.java,mergeIfCan,public boolean  (final MergeableMetricBase other){ if (canMerge(other)) { merge(other); return true; } else { return false; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\replicates\CollectIndependentReplicateMetrics.java,calculateEditDistance,private static byte  (final String lhs final String rhs){ assert (lhs.length() == rhs.length()); byte tmp=0; for (int i=0; i < rhs.length(); ++i) { if (rhs.charAt(i) != lhs.charAt(i)) ++tmp; } return tmp; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\replicates\CollectIndependentReplicateMetrics.java,classifySet,"private static SetClassification  (final int nRef final int nAlt final int nOther){ if (nOther != 0) return SetClassification.MISMATCHING_ALLELE; if (nAlt > 0 && nRef > 0) return SetClassification.DIFFERENT_ALLELES; if (nRef == 0) return SetClassification.ALTERNATE_ALLELE; if (nAlt == 0) return SetClassification.REFERENCE_ALLELE; throw new IllegalAccessError(""shouldn't be here!""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\replicates\CollectIndependentReplicateMetrics.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(VCF); IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); if (MATRIX_OUTPUT != null) IOUtil.assertFileIsWritable(MATRIX_OUTPUT); final VCFFileReader vcf=new VCFFileReader(VCF fa
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\replicates\CollectIndependentReplicateMetrics.java,getQueryIntervalsMap,private SortedMap<QueryInterval List<Allele>>  (final File vcf){ final Map<String Integer> contigIndexMap=new HashMap<>(); final VCFFileReader vcfReader=new VCFFileReader(vcf false); final CompoundFilter compoundFilter=new CompoundFilter(true); compoundFilter.add(new SnpFilter()); compoundFilter.add(new PassingVariantFilter()); compoundFilter.add(new GenotypeQualityFilter(MINIMUM_GQ SAMPLE)); compoundFilter.add(new HeterozygosityFilter(true SAMPLE)); final Iterator<VariantContext> hetIterator=new FilteringVariantContextIterator(vcfReader.iterator() compoundFilter); for ( final VCFContigHeaderLine vcfContig : vcfReader.getFileHeader().getContigLines()) { contigIndexMap.put(vcfContig.getID() vcfContig.getContigIndex()); } final SortedMap<QueryInterval List<Allele>> map=new TreeMap<>(); while (hetIterator.hasNext()) { final VariantContext vc=hetIterator.next(); map.put(new QueryInterval(contigIndexMap.get(vc.getContig()) vc.getStart() vc.getEnd()) vc.getGenotype(SAMPLE).getAlleles()); } vcfReader.close(); return map; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\replicates\CollectIndependentReplicateMetrics.java,isCleanlyBefore,private static boolean  (final QueryInterval lhs final QueryInterval rhs){ return !lhs.overlaps(rhs) && lhs.compareTo(rhs) < 0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\replicates\CollectIndependentReplicateMetrics.java,queryIntervalFromSamRecord,private static QueryInterval  (final SAMRecord samRecord){ return new QueryInterval(samRecord.getReferenceIndex() samRecord.getStart() samRecord.getEnd()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\replicates\IndependentReplicateMetric.java,calculateDerivedFields,@Override public void  (){ biSiteHeterogeneityRate=nDifferentAllelesBiDups / (double)(nDifferentAllelesBiDups + nAlternateAllelesBiDups + nReferenceAllelesBiDups); biSiteHomogeneityRate=1 - biSiteHeterogeneityRate; this.independentReplicationRateFromBiDup
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetrics.java,RrbsMetrics,public  (final RrbsSummaryMetrics summaryMetrics final List<RrbsCpgDetailMetrics> detailMetrics){ this.summaryMetrics=summaryMetrics; this.detailMetrics=detailMetrics; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetrics.java,getDetailMetrics,public List<RrbsCpgDetailMetrics>  (){ return detailMetrics; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetrics.java,getSummaryMetrics,public RrbsSummaryMetrics  (){ return summaryMetrics; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,CpgLocation,public  (final String sequence final int position){ this.sequence=sequence; this.position=position; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,PerUnitRrbsMetricsCollector,public  (final String sample final String library final String readGroup){ this.sample=sample; this.library=library; this.readGroup=readGroup; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,RrbsMetricsCollector,public  (final Set<MetricAccumulationLevel> accumulationLevels final List<SAMReadGroupRecord> samRgRecords final int cQualityThreshold final int nextBaseQualityThreshold final int minReadLength final double maxMismatchRate){ this.cQualityThreshold=cQualityThreshold; this.nextBaseQualityThreshold=nextBaseQualityThreshold; this.minReadLength=minReadLength; this.maxMismatchRate=maxMismatchRate; setup(accumulationLevels samRgRecords); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,acceptRecord,public void  (final SAMRecordAndReference args){ mappedRecordCount++; final SAMRecord samRecord=args.getSamRecord(); final ReferenceSequence referenceSequence=args.getReferenceSequence(); final byte[] readBases=samRecord.getReadBases(); final byte[] readQualities=samRecord.getBaseQualities(); final byte[] refBases=referenceSequence.getBases(); if (samRecord.getReadLength() < minReadLength) { smallReadCount++; return; } else if (SequenceUtil.countMismatches(samRecord refBases true) > Math.round(samRecord.getReadLength() * maxMismatchRate)) { mismatchCount++; return; } int recordCpgs=0; for ( final AlignmentBlock alignmentBlock : samRecord.getAlignmentBlocks()) { final int blockLength=alignmentBlock.getLength(); final int refFragmentStart=alignmentBlock.getReferenceStart() - 1; final int readFragmentStart=alignmentBlock.getReadStart() - 1; final byte[] refFragment=getFragment(refBases refFragmentStart blockLength); final byte[] readFragment=getFragment(readBases readFragmentStart blockLength); final byte[] readQualityFragment=getFragment(readQualities readFragmentStart blockLength); if (samRecord.getReadNegativeStrandFlag()) { SequenceUtil.reverseComplement(refFragment); SequenceUtil.reverseComplement(readFragment); SequenceUtil.reverseQualities(readQualityFragment); } for (int i=0; i < blockLength - 1; i++) { final int curRefIndex=getCurRefIndex(refFragmentStart blockLength i samRecord.getReadNegativeStrandFlag()); if ((SequenceUtil.basesEqual(refFragment[i] SequenceUtil.C)) && (SequenceUtil.basesEqual(refFragment[i + 1] SequenceUtil.G))) { if (isValidCpg(refFragment readFragment readQualityFragment i)) { recordCpgs++; final CpgLocation curLocation=new CpgLocation(samRecord.getReferenceName() curRefIndex); cpgTotal.increment(curLocation); if (SequenceUtil.isBisulfiteConverted(readFragment[i] refFragment[i])) { cpgConverted.increment(curLocation); } } i++; } else if (isC(refFragment[i] readFragment[i]) && isAboveCytoQcThreshold(readQualities i) && SequenceUtil.bisulfiteBasesEqual(false readFragment[i + 1] refFragment[i + 1])) { nCytoTotal++; if (SequenceUtil.isBisulfiteConverted(readFragment[i] refFragment[i])) { nCytoConverted++; } } } } if (recordCpgs == 0) { noCpgCount++; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,addMetricsToFile,@Override public void  (final MetricsFile<RrbsMetrics Comparable<?>> metricsFile){ final RrbsSummaryMetrics summaryMetrics=buildSummaryMetrics(); final List<RrbsCpgDetailMetrics> detailMetrics=buildDetailMetrics(); final RrbsMetrics rrbsMetrics=new RrbsMe
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,buildDetailMetrics,private List<RrbsCpgDetailMetrics>  (){ final List<RrbsCpgDetailMetrics> detailMetrics=new ArrayList<RrbsCpgDetailMetrics>(); for ( final CpgLocation key : cpgTotal.keySet()) { final RrbsCpgDetailMetrics cpgMetric=new RrbsCpgDetailMetrics(); cpgMetric.SAMPLE=sample; cpgMetric.READ_GROUP=readGroup; cpgMetric.LIBRARY=library; cpgMetric.SEQUENCE_NAME=key.getSequence(); cpgMetric.POSITION=key.getPosition(); cpgMetric.TOTAL_SITES=(int)cpgTotal.get(key).getValue(); cpgMetric.CONVERTED_SITES=cpgConverted.containsKey(key) ? (int)cpgConverted.get(key).getValue() : 0; cpgMetric.PCT_CONVERTED=cpgMetric.CONVERTED_SITES == 0 ? 0 : cpgMetric.CONVERTED_SITES / (double)cpgMetric.TOTAL_SITES; detailMetrics.add(cpgMetric); } return detailMetrics; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,buildSummaryMetrics,private RrbsSummaryMetrics  (){ final RrbsSummaryMetrics summaryMetrics=new RrbsSummaryMetrics(); summaryMetrics.SAMPLE=sample; summaryMetrics.READ_GROUP=readGroup; summaryMetrics.LIBRARY=library; summaryMetrics.READS_ALIGNED=mappedRecordCount; summaryMetrics.NON_CPG_BASES=nCytoTotal; summaryMetrics.NON_CPG_CONVERTED_BASES=nCytoConverted; summaryMetrics.PCT_NON_CPG_BASES_CONVERTED=cytoConversionRate; summaryMetrics.CPG_BASES_SEEN=nCpgSeen; summaryMetrics.CPG_BASES_CONVERTED=nCpgConverted; summaryMetrics.PCT_CPG_BASES_CONVERTED=cpgConversionRate; summaryMetrics.MEAN_CPG_COVERAGE=coverageMean; summaryMetrics.MEDIAN_CPG_COVERAGE=coverageMedian; summaryMetrics.READS_IGNORED_SHORT=smallReadCount; summaryMetrics.READS_WITH_NO_CPG=noCpgCount; summaryMetrics.READS_IGNORED_MISMATCHES=mismatchCount; return summaryMetrics; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,compareTo,@Override public int  (final CpgLocation other){ final int seqComp=sequence.compareTo(other.sequence); return seqComp == 0 ? position.compareTo(other.position) : seqComp; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,equals,@Override public boolean  (final Object other){ if (this == other) { return true; } if (other == null || getClass() != other.getClass()) { return false; } final CpgLocation that=(CpgLocation)other; return (sequence.equals(that.sequence)) && (position.equa
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,finish,public void  (){ cytoConversionRate=nCytoTotal == 0 ? 0 : nCytoConverted / (double)nCytoTotal; nCpgSeen=(int)cpgTotal.getSumOfValues(); nCpgConverted=(int)cpgConverted.getSumOfValues(); cpgConversionRate=nCpgSeen == 0 ? 0 : nCpgConverted / (double)nCpgSeen; coverageMean=cpgTotal.getMeanBinSize(); coverageMedian=(int)cpgTotal.getMedianBinSize(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,getCurRefIndex,private int  (final int refStart final int blockLength final int idx final boolean isNegative){ return isNegative ? refStart + (blockLength - 1) - idx - 1 : refStart + idx; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,getFragment,private byte[]  (final byte[] fullArray final int fragmentStart final int length){ return Arrays.copyOfRange(fullArray fragmentStart fragmentStart + length); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,getPosition,public Integer  (){ return position; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,getSequence,public String  (){ return sequence; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,hashCode,@Override public int  (){ int result=sequence.hashCode(); result=31 * result + position; return result; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,isAboveCytoQcThreshold,private boolean  (final byte[] readQualities final int index){ return ((index < readQualities.length - 1) && (readQualities[index] >= cQualityThreshold) && (readQualities[index + 1] >= nextBaseQualityThreshold)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,isC,private boolean  (final byte refBase final byte readBase){ return (SequenceUtil.basesEqual(refBase SequenceUtil.C) && SequenceUtil.bisulfiteBasesEqual(readBase refBase)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,isValidCpg,private boolean  (final byte[] refBases final byte[] readBases final byte[] readQualities final int index){ return isC(refBases[index] readBases[index]) && SequenceUtil.basesEqual(refBases[index + 1] readBases[index + 1]) && isAboveCytoQcThreshold(readQualities index); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\RrbsMetricsCollector.java,makeChildCollector,@Override protected PerUnitMetricCollector<RrbsMetrics Comparable<?> SAMRecordAndReference>  (final String sample final String library final String readGroup){ return new PerUnitRrbsMetricsCollector(sample library readGroup); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\AnnotationException.java,AnnotationException,public  (String message Throwable throwable){ super(message throwable); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,Exon,public  (final int start final int end){ this.start=start; this.end=end; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,Gene,public  (final String sequence final int start final int end final boolean negative final String name){ super(sequence start end negative name); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,Transcript,public  (final String name final int transcriptionStart final int transcriptionEnd final int codingStart final int codingEnd final int numExons){ this.name=name; this.transcriptionStart=transcriptionStart; this.transcriptionEnd=transcriptionEnd; this.codingStart=codingStart; this.codingEnd=codingEnd; this.exons=new Exon[numExons]; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,addCoverageCounts,public void  (final int genomeStart final int genomeEnd final int[] coverage){ for (int i=genomeStart; i < genomeEnd; ++i) { final int txBase=getTranscriptCoordinate(i); if (txBase > 0) coverage[txBase - 1]++; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,addExon,"public Exon  (final int start final int end){ for (int i=0; i < this.exons.length; ++i) { if (exons[i] == null) { exons[i]=new Exon(start end); this.length+=CoordMath.getLength(start end); return exons[i]; } } throw new IllegalStateException(""Attempting to add more exons that exist for transcript.""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,addTranscript,"public Transcript  (final String name final int transcriptionStart final int transcriptionEnd final int codingStart final int codingEnd final int numExons){ if (transcripts.containsKey(name)) { throw new AnnotationException(""Transcript "" + name + "" for gene ""+ this.getName()+ "" appears more than once""); } else { final Transcript tx=new Transcript(name transcriptionStart transcriptionEnd codingStart codingEnd numExons); transcripts.put(name tx); return tx; } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,assignLocusFunctionForRange,public void  (final int start final LocusFunction[] locusFunctions){ for (int i=Math.max(start transcriptionStart); i <= Math.min(transcriptionEnd CoordMath.getEnd(start locusFunctions.length)); ++i) { if (locusFunctions[i - start].ordinal() > LocusFunction.CODING.ordinal()) continue; final LocusFunction locusFunction; if (inExon(i)) { if (utr(i)) locusFunction=LocusFunction.UTR; else locusFunction=LocusFunction.CODING; } else locusFunction=LocusFunction.INTRONIC; if (locusFunction.ordinal() > locusFunctions[i - start].ordinal()) { locusFunctions[i - start]=locusFunction; } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,compareTo,public int  (final Gene that){ final int ret=super.compareTo(that); if (ret != 0) return ret; return Boolean.valueOf(this.isPositiveStrand()).compareTo(that.isPositiveStrand()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,end,public int  (){ return exons[exons.length - 1].end; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,equals,@Override public boolean  (final Object o){ if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; final Transcript that=(Transcript)o; if (codingEnd != that.codingEnd) return false; if (codingStart != that.codingStart) ret
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,getGene,public Gene  (){ return Gene.this; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,getTranscriptCoordinate,public int  (final int genomeCoordinate){ int exonOffset=0; for ( final Exon e : exons) { if (genomeCoordinate >= e.start && genomeCoordinate <= e.end) { return (genomeCoordinate - e.start + 1) + exonOffset; } else { exonOffset+=CoordMath.getLength(e.start e.end); } } return -1; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,hashCode,@Override public int  (){ int result=name.hashCode(); result=31 * result + transcriptionStart; result=31 * result + transcriptionEnd; result=31 * result + codingStart; result=31 * result + codingEnd; return result; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,inExon,private boolean  (final int locus){ for (int i=0; i < exons.length; ++i) { final Exon exon=exons[i]; if (exon.start > locus) return false; if (inRange(exon.start exon.end locus)) return true; } return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,inRange,private boolean  (final int start final int end final int locus){ return (locus >= start && locus <= end); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,isSoloTranscript,public boolean  (){ return Gene.this.transcripts.size() == 1; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,iterator,public Iterator<Transcript>  (){ return transcripts.values().iterator(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,length,public int  (){ return this.length; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,start,public int  (){ return exons[0].start; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\Gene.java,utr,private boolean  (final int locus){ return locus < codingStart || locus > codingEnd; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\TheoreticalSensitivity.java,RouletteWheel," (final double[] weights){ rng=new Random(51); N=weights.length; probabilities=new ArrayList<>(); final double wMax=MathUtil.max(weights); if (wMax == 0) { throw new PicardException(""Quality score distribution is empty.""); } for ( final double w : weights) { probabilities.add(w / wMax); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\TheoreticalSensitivity.java,draw,public int  (){ while (true) { final int n=(int)(N * rng.nextDouble()); count++; if (rng.nextDouble() < probabilities.get(n)) { count=0; return n; } else if (count >= SAMPLING_MAX) { count=0; return 0; } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\TheoreticalSensitivity.java,hetAltDepthDistribution,public static List<ArrayList<Double>>  (final int N){ final List<ArrayList<Double>> table=new ArrayList<>(); for (int n=0; n < N; n++) { final ArrayList<Double> nthRow=new ArrayList<>(); nthRow.add(Math.pow(0.5 n)); for (int m=1; m < n; m++) nthRow.add((n * 0.5 / m) * table.get(n - 1).get(m - 1)); if (n > 0) nthRow.add(nthRow.get(0)); table.add(nthRow); } return table; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\TheoreticalSensitivity.java,hetSNPSensitivity,"public static double  (final double[] depthDistribution final double[] qualityDistribution final int sampleSize final double logOddsThreshold final boolean withLogging){ final int N=Math.min(depthDistribution.length MAX_CONSIDERED_DEPTH + 1); if (withLogging) log.info(""Creating Roulette Wheel""); final RouletteWheel qualitySampler=new RouletteWheel(qualityDistribution); if (withLogging) log.info(""Calculating quality sums from quality sampler""); final List<ArrayList<Integer>> qualitySums=qualitySampler.sampleCumulativeSums(N sampleSize withLogging); final ArrayList<Double> qualitySumThresholds=new ArrayList<>(N); final double LOG_10=Math.log10(2); for (int n=0; n < N; n++) qualitySumThresholds.add(10 * (n * LOG_10 + logOddsThreshold)); if (withLogging) log.info(""Calculating theoretical het sensitivity""); final List<ArrayList<Double>> probabilityToExceedThreshold=proportionsAboveThresholds(qualitySums qualitySumThresholds); final List<ArrayList<Double>> altDepthDistribution=hetAltDepthDistribution(N); double result=0.0; for (int n=0; n < N; n++) { for (int m=0; m <= n; m++) { result+=depthDistribution[n] * altDepthDistribution.get(n).get(m) * probabilityToExceedThreshold.get(m).get(n); } } return result; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\TheoreticalSensitivity.java,normalizeHistogram,"public static double[]  (final Histogram<Integer> histogram){ if (histogram == null) throw new PicardException(""Histogram is null and cannot be normalized""); final double histogramSumOfValues=histogram.getSumOfValues(); final double[] normalizedHistogram=new double[histogram.size()]; for (int i=0; i < histogram.size(); i++) { if (histogram.get(i) != null) { normalizedHistogram[i]=histogram.get(i).getValue() / histogramSumOfValues; } } return normalizedHistogram; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\TheoreticalSensitivity.java,proportionsAboveThresholds,public static List<ArrayList<Double>>  (final List<ArrayList<Integer>> lists final List<Double> thresholds){ final ArrayList<ArrayList<Double>> result=new ArrayList<>(); for ( final ArrayList<Integer> list : lists) { final ArrayList<Double> newRow=new ArrayList<>(Collections.nCopies(thresholds.size() 0.0)); Collections.sort(list); int n=0; int j=0; while (n < thresholds.size() && j < list.size()) { if (thresholds.get(n) > list.get(j)) j++; else newRow.set(n++ (double)(list.size() - j) / list.size()); } result.add(newRow); } return result; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\TheoreticalSensitivity.java,sampleCumulativeSums,"public List<ArrayList<Integer>>  (final int maxNumberOfSummands final int sampleSize final boolean withLogging){ final List<ArrayList<Integer>> result=new ArrayList<>(); for (int m=0; m < maxNumberOfSummands; m++) result.add(new ArrayList<>()); for (int iteration=0; iteration < sampleSize; iteration++) { int cumulativeSum=0; for (int m=0; m < maxNumberOfSummands; m++) { result.get(m).add(cumulativeSum); cumulativeSum+=draw(); } if (withLogging && iteration % 1000 == 0) { log.info(iteration + "" sampling iterations completed""); } } return result; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\GeneAnnotationReader.java,loadRefFlat,public static OverlapDetector<Gene>  (File refFlatFile SAMSequenceDictionary sequenceDictionary){ return RefFlatReader.load(refFlatFile sequenceDictionary); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\WgsMetricsProcessorImpl.java,WgsMetricsProcessorImpl,public  (AbstractLocusIterator<T AbstractLocusInfo<T>> iterator ReferenceSequenceFileWalker refWalker AbstractWgsMetricsCollector<T> collector ProgressLogger progress){ this.iterator=iterator; this.collector=collector; this.refWalker=refWalker; this.progress=progress; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\WgsMetricsProcessorImpl.java,addToMetricsFile,@Override public void  (MetricsFile<CollectWgsMetrics.WgsMetrics Integer> file boolean includeBQHistogram CountingFilter dupeFilter CountingFilter mapqFilter CountingPairedFilter pairFilter){ collector.addToMetricsFile(file includeBQHistogram dupeFilter m
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\analysis\WgsMetricsProcessorImpl.java,processFile,@Override public void  (){ long counter=0; while (iterator.hasNext()) { final AbstractLocusInfo<T> info=iterator.next(); final ReferenceSequence ref=refWalker.get(info.getSequenceIndex()); boolean referenceBaseN=collector.isReferenceBaseN(info.getPosition
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\argumentcollections\RequiredReferenceArgumentCollection.java,getReferenceFile,public File  (){ return REFERENCE_SEQUENCE; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\argumentcollections\OptionalReferenceArgumentCollection.java,getReferenceFile,@Override public File  (){ return REFERENCE_SEQUENCE; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\RefFlatReader.java,RefFlatReader, (final File refFlatFile final SAMSequenceDictionary sequenceDictionary){ this.refFlatFile=refFlatFile; this.sequenceDictionary=sequenceDictionary; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\RefFlatReader.java,isSequenceRecognized,private boolean  (final String sequence){ return (sequenceDictionary.getSequence(sequence) != null); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\RefFlatReader.java,load,"OverlapDetector<Gene>  (){ final OverlapDetector<Gene> overlapDetector=new OverlapDetector<Gene>(0 0); final int expectedColumns=RefFlatColumns.values().length; final TabbedTextFileWithHeaderParser parser=new TabbedTextFileWithHeaderParser(refFlatFile RefFlatColumnLabels); final Map<String List<TabbedTextFileWithHeaderParser.Row>> refFlatLinesByGene=new HashMap<String List<TabbedTextFileWithHeaderParser.Row>>(); for ( final TabbedTextFileWithHeaderParser.Row row : parser) { final int lineNumber=parser.getCurrentLineNumber(); if (row.getFields().length != expectedColumns) { throw new AnnotationException(""Wrong number of fields in refFlat file "" + refFlatFile + "" at line ""+ lineNumber); } final String geneName=row.getField(RefFlatColumns.GENE_NAME.name()); final String transcriptName=row.getField(RefFlatColumns.TRANSCRIPT_NAME.name()); final String transcriptDescription=geneName + "":"" + transcriptName; final String chromosome=row.getField(RefFlatColumns.CHROMOSOME.name()); if (!isSequenceRecognized(chromosome)) { LOG.debug(""Skipping "" + transcriptDescription + "" due to unrecognized sequence ""+ chromosome); } else { List<TabbedTextFileWithHeaderParser.Row> transcriptLines=refFlatLinesByGene.get(geneName); if (transcriptLines == null) { transcriptLines=new ArrayList<TabbedTextFileWithHeaderParser.Row>(); refFlatLinesByGene.put(geneName transcriptLines); } transcriptLines.add(row); } } int longestInterval=0; int numIntervalsOver1MB=0; for ( final List<TabbedTextFileWithHeaderParser.Row> transcriptLines : refFlatLinesByGene.values()) { try { final Gene gene=makeGeneFromRefFlatLines(transcriptLines); overlapDetector.addLhs(gene gene); if (gene.length() > longestInterval) longestInterval=gene.length(); if (gene.length() > 1000000) ++numIntervalsOver1MB; } catch ( AnnotationException e) { LOG.debug(e.getMessage() + "" -- skipping""); } } LOG.debug(""Longest gene: "" + longestInterval + ""; number of genes > 1MB: ""+ numIntervalsOver1MB); return overlapDetector; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\RefFlatReader.java,makeGeneFromRefFlatLines,"private Gene  (final List<TabbedTextFileWithHeaderParser.Row> transcriptLines){ final String geneName=transcriptLines.get(0).getField(RefFlatColumns.GENE_NAME.name()); final String strandStr=transcriptLines.get(0).getField(RefFlatColumns.STRAND.name()); final boolean negative=strandStr.equals(""-""); final String chromosome=transcriptLines.get(0).getField(RefFlatColumns.CHROMOSOME.name()); int start=Integer.MAX_VALUE; int end=Integer.MIN_VALUE; for ( final TabbedTextFileWithHeaderParser.Row row : transcriptLines) { start=Math.min(start row.getIntegerField(RefFlatColumns.TX_START.name()) + 1); end=Math.max(end row.getIntegerField(RefFlatColumns.TX_END.name())); } final Gene gene=new Gene(chromosome start end negative geneName); for ( final TabbedTextFileWithHeaderParser.Row row : transcriptLines) { if (!strandStr.equals(row.getField(RefFlatColumns.STRAND.name()))) { throw new AnnotationException(""Strand disagreement in refFlat file for gene "" + geneName); } if (!chromosome.equals(row.getField(RefFlatColumns.CHROMOSOME.name()))) { throw new AnnotationException(""Chromosome disagreement("" + chromosome + "" != ""+ row.getField(RefFlatColumns.CHROMOSOME.name())+ "") in refFlat file for gene ""+ geneName); } final Transcript tx=makeTranscriptFromRefFlatLine(gene row); } return gene; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\annotation\RefFlatReader.java,makeTranscriptFromRefFlatLine,"private Gene.Transcript  (final Gene gene final TabbedTextFileWithHeaderParser.Row row){ final String geneName=row.getField(RefFlatColumns.GENE_NAME.name()); final String transcriptName=row.getField(RefFlatColumns.TRANSCRIPT_NAME.name()); final String transcriptDescription=geneName + "":"" + transcriptName; final int exonCount=Integer.parseInt(row.getField(RefFlatColumns.EXON_COUNT.name())); final String[] exonStarts=row.getField(RefFlatColumns.EXON_STARTS.name()).split("" ""); final String[] exonEnds=row.getField(RefFlatColumns.EXON_ENDS.name()).split("" ""); if (exonCount != exonStarts.length) { throw new AnnotationException(""Number of exon starts does not agree with number of exons for "" + transcriptDescription); } if (exonCount != exonEnds.length) { throw new AnnotationException(""Number of exon ends does not agree with number of exons for "" + transcriptDescription); } final int transcriptionStart=row.getIntegerField(RefFlatColumns.TX_START.name()) + 1; final int transcriptionEnd=row.getIntegerField(RefFlatColumns.TX_END.name()); final int codingStart=row.getIntegerField(RefFlatColumns.CDS_START.name()) + 1; final int codingEnd=row.getIntegerField(RefFlatColumns.CDS_END.name()); final Transcript tx=gene.addTranscript(transcriptName transcriptionStart transcriptionEnd codingStart codingEnd exonCount); for (int i=0; i < exonCount; ++i) { final Exon e=tx.addExon(Integer.parseInt(exonStarts[i]) + 1 Integer.parseInt(exonEnds[i])); if (e.start > e.end) { throw new AnnotationException(""Exon has 0 or negative extent for "" + transcriptDescription); } if (i > 0 && tx.exons[i - 1].end >= tx.exons[i].start) { throw new AnnotationException(""Exons overlap for "" + transcriptDescription); } } return tx; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\CommandLineDefaults.java,getBooleanProperty,private static boolean  (final String name final boolean def){ final String value=getStringProperty(name String.valueOf(def)); return Boolean.parseBoolean(value); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\CommandLineDefaults.java,getFileProperty,private static File  (final String name final String def){ final String value=getStringProperty(name def); return (null == value) ? null : new File(value); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\CommandLineDefaults.java,getIntProperty,private static int  (final String name final int def){ final String value=getStringProperty(name String.valueOf(def)); return Integer.parseInt(value); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\CommandLineDefaults.java,getStringProperty,"private static String  (final String name final String def){ return System.getProperty(""picard.cmdline."" + name def); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\ClassFinder.java,ClassFinder,public  (final File jarFile) throws IOException { jarPath=jarFile.getCanonicalPath(); final URL[] urls={new File(jarPath).toURI().toURL()}; loader=new URLClassLoader(urls Thread.currentThread().getContextClassLoader()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\ClassFinder.java,find,"public void  (String packageName final Class<?> parentType){ this.parentType=parentType; packageName=packageName.replace('.' '/'); final Enumeration<URL> urls; try { urls=loader.getResources(packageName); } catch ( IOException ioe) { log.warn(""Could not read package: "" + packageName ioe); return; } while (urls.hasMoreElements()) { try { String urlPath=urls.nextElement().getFile(); try { URI uri=new URI(urlPath); urlPath=uri.getPath(); } catch ( URISyntaxException e) { log.warn(""Cannot convert to URI the "" + urlPath + "" URL""); } if (urlPath.indexOf('!') > 0) { urlPath=urlPath.substring(0 urlPath.indexOf('!')); } if (jarPath != null && !jarPath.equals(urlPath)) { continue; } final File file=new File(urlPath); if (file.isDirectory()) { scanDir(file packageName); } else { scanJar(file packageName); } } catch ( IOException ioe) { log.warn(""could not read entries"" ioe); } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\ClassFinder.java,getClasses,public Set<Class<?>>  (){ return this.classes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\ClassFinder.java,handleItem,"protected void  (final String name){ if (name.endsWith("".class"")) { final String classname=toClassName(name); try { final Class<?> type=loader.loadClass(classname); if (parentType.isAssignableFrom(type)) { this.classes.add(type); } } catch ( Throwable t) { log.debug(""could not load class: "" + classname t); } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\ClassFinder.java,scanDir,protected void  (final File file final String path){ for ( final File child : file.listFiles()) { final String newPath=(path == null ? child.getName() : path + '/' + child.getName()); if (child.isDirectory()) { scanDir(child newPath); } else { handleItem(newPath); } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\ClassFinder.java,scanJar,protected void  (final File file final String packagePath) throws IOException { final ZipFile zip=new ZipFile(file); final Enumeration<? extends ZipEntry> entries=zip.entries(); while (entries.hasMoreElements()) { final ZipEntry entry=entries.nextElement(); final String name=entry.getName(); if (name.startsWith(packagePath)) { handleItem(name); } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\ClassFinder.java,toClassName,"public String  (final String filename){ return filename.substring(0 filename.lastIndexOf("".class"")).replace('/' '.').replace('\\' '.'); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\CommandLineSyntaxTranslater.java,translatePicardStyleToPosixStyle,"public static String[]  (final String argv[]){ final List<String> convertedArgs=Arrays.stream(argv).flatMap(originalArgPair -> { final String[] splitArgPair=originalArgPair.split(""="" -1); if (splitArgPair.length == 1) { return Arrays.stream(new String[]{originalArgPair}); } else if (splitArgPair.length == 2) { return Arrays.stream(new String[]{""-"" + splitArgPair[0] splitArgPair[1]}); } else { throw new RuntimeException(""Argument syntax conversion failed. Too many \""=\"" separated tokens to translate: "" + originalArgPair); } } ).collect(Collectors.toList()); return convertedArgs.toArray(new String[convertedArgs.size()]); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\CommandLineProgram.java,customCommandLineValidation,protected String[]  (){ return null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\DiagnosticsAndQCProgramGroup.java,getDescription,@Override public String  (){ return HelpConstants.DOC_CAT_DIAGNOSTICS_AND_QC_SUMMARY; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\DiagnosticsAndQCProgramGroup.java,getName,@Override public String  (){ return HelpConstants.DOC_CAT_DIAGNOSTICS_AND_QC; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\PicardCommandLine.java,compare,@Override public int  (final Class aClass final Class bClass){ return aClass.getSimpleName().compareTo(bClass.getSimpleName()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\PicardCommandLine.java,extractCommandLineProgram,"private static CommandLineProgram  (final String[] args final List<String> packageList final String commandLineName){ final Map<String Class<?>> simpleNameToClass=new HashMap<>(); final List<String> missingAnnotationClasses=new ArrayList<>(); processAllCommandLinePrograms(packageList ( Class<CommandLineProgram> clazz  CommandLineProgramProperties clProperties) -> { if (null == clProperties) { missingAnnotationClasses.add(clazz.getSimpleName()); } else if (!clProperties.omitFromCommandLine()) { if (simpleNameToClass.containsKey(clazz.getSimpleName())) { throw new RuntimeException(""Simple class name collision: "" + clazz.getSimpleName()); } simpleNameToClass.put(clazz.getSimpleName() clazz); } } ); if (!missingAnnotationClasses.isEmpty()) { throw new RuntimeException(""The following classes are missing the required CommandLineProgramProperties annotation: "" + missingAnnotationClasses.stream().collect(Collectors.joining((""  "")))); } final Set<Class<?>> classes=new HashSet<>(); classes.addAll(simpleNameToClass.values()); if (args.length < 1) { printUsage(classes commandLineName); } else { if (args[0].equals(""-h"")) { printUsage(classes commandLineName); } else if (args[0].equals(""--list-commands"")) { printCommandList(classes); } else { if (simpleNameToClass.containsKey(args[0])) { final Class clazz=simpleNameToClass.get(args[0]); try { return (CommandLineProgram)clazz.newInstance(); } catch ( final InstantiationException e) { throw new RuntimeException(e); } catch ( final IllegalAccessException e) { throw new RuntimeException(e); } } printUsage(classes commandLineName); printUnknown(classes args[0]); } } return null; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\PicardCommandLine.java,getPackageList,"protected static List<String>  (){ final List<String> packageList=new ArrayList<String>(); packageList.add(""picard""); return packageList; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\PicardCommandLine.java,getProgramProperty,public static CommandLineProgramProperties  (Class clazz){ return (CommandLineProgramProperties)clazz.getAnnotation(CommandLineProgramProperties.class); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\PicardCommandLine.java,getToolSummaryPrefix,"private static String  (Class<?> clazz){ if (clazz.getAnnotation(ExperimentalFeature.class) != null) { return EXPERIMENTAL_PREFIX; } if (clazz.getAnnotation(BetaFeature.class) != null) { return BETA_PREFIX; } return """"; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\PicardCommandLine.java,initializeColor,"private static String  (final String color){ if (CommandLineDefaults.COLOR_STATUS) return color; else return """"; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\PicardCommandLine.java,instanceMain,protected int  (final String[] args){ return instanceMain(args getPackageList() COMMAND_LINE_NAME); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\PicardCommandLine.java,main,public static void  (final String[] args){ System.exit(new PicardCommandLine().instanceMain(args getPackageList() COMMAND_LINE_NAME)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\PicardCommandLine.java,printCommandList,private static void  (final Set<Class<?>> classes){ printUsage(classes null true true); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\PicardCommandLine.java,printUnknown,"public static void  (final Set<Class<?>> classes final String command){ final Map<Class Integer> distances=new HashMap<Class Integer>(); int bestDistance=Integer.MAX_VALUE; int bestN=0; for ( final Class clazz : classes) { final String name=clazz.getSimpleName(); final int distance; if (name.equals(command)) { throw new RuntimeException(""Command matches: "" + command); } if (name.startsWith(command) || (MINIMUM_SUBSTRING_LENGTH <= command.length() && name.contains(command))) { distance=0; } else { distance=StringUtil.levenshteinDistance(command name 0 2 1 4); } distances.put(clazz distance); if (distance < bestDistance) { bestDistance=distance; bestN=1; } else if (distance == bestDistance) { bestN++; } } if (0 == bestDistance && bestN == classes.size()) { bestDistance=HELP_SIMILARITY_FLOOR + 1; } System.err.println(String.format(""'%s' is not a valid command. See PicardCommandLine -h for more information."" command)); if (bestDistance < HELP_SIMILARITY_FLOOR) { System.err.println(String.format(""Did you mean %s?"" (bestN < 2) ? ""this"" : ""one of these"")); for ( final Class clazz : classes) { if (bestDistance == distances.get(clazz)) { System.err.println(String.format("" %s"" clazz.getSimpleName())); } } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\PicardCommandLine.java,printUsage,"private static void  (final Set<Class<?>> classes final String commandLineName boolean commandListOnly boolean toStdout){ final StringBuilder builder=new StringBuilder(); if (!commandListOnly) { builder.append(KBLDRED + ""USAGE: "" + commandLineName+ "" ""+ KGRN+ ""<program name>""+ KBLDRED+ "" [-h]\n\n""+ KNRM); builder.append(KBLDRED + ""Available Programs:\n"" + KNRM); } final Map<Class<? extends CommandLineProgramGroup> CommandLineProgramGroup> programGroupClassToProgramGroupInstance=new HashMap<Class<? extends CommandLineProgramGroup> CommandLineProgramGroup>(); final Map<CommandLineProgramGroup List<Class>> programsByGroup=new TreeMap<CommandLineProgramGroup List<Class>>(CommandLineProgramGroup.comparator); final Map<Class CommandLineProgramProperties> programsToProperty=new HashMap<Class CommandLineProgramProperties>(); for ( final Class clazz : classes) { final CommandLineProgramProperties property=getProgramProperty(clazz); if (null == property) { throw new RuntimeException(String.format(""The class '%s' is missing the required CommandLineProgramProperties annotation."" clazz.getSimpleName())); } programsToProperty.put(clazz property); CommandLineProgramGroup programGroup=programGroupClassToProgramGroupInstance.get(property.programGroup()); if (null == programGroup) { try { programGroup=property.programGroup().newInstance(); } catch ( final InstantiationException e) { throw new RuntimeException(e); } catch ( final IllegalAccessException e) { throw new RuntimeException(e); } programGroupClassToProgramGroupInstance.put(property.programGroup() programGroup); } List<Class> programs=programsByGroup.get(programGroup); if (null == programs) { programsByGroup.put(programGroup programs=new ArrayList<Class>()); } programs.add(clazz); } for ( Map.Entry<CommandLineProgramGroup List<Class>> entry : programsByGroup.entrySet()) { final CommandLineProgramGroup programGroup=entry.getKey(); if (!commandListOnly) { builder.append(KWHT + ""--------------------------------------------------------------------------------------\n"" + KNRM); builder.append(String.format(""%s%-48s %-45s%s\n"" KRED programGroup.getName() + "":"" programGroup.getDescription() KNRM)); } final List<Class> sortedClasses=new ArrayList<Class>(); sortedClasses.addAll(entry.getValue()); Collections.sort(sortedClasses new SimpleNameComparator()); for ( final Class clazz : sortedClasses) { final CommandLineProgramProperties property=programsToProperty.get(clazz); if (null == property) { throw new RuntimeException(String.format(""Unexpected error: did not find the CommandLineProgramProperties annotation for '%s'"" clazz.getSimpleName())); } if (!commandListOnly) { builder.append(String.format(clazz.getSimpleName().length() >= 45 ? ""%s %s %s%s%s%s%s\n"" : ""%s %-45s%s%s%s%s%s\n"" KGRN clazz.getSimpleName() KRED getToolSummaryPrefix(clazz) KCYN property.oneLineSummary() KNRM)); } else { builder.append(clazz.getSimpleName() + ""\n""); } } if (!commandListOnly) builder.append(String.format(""\n"")); } if (!commandListOnly) builder.append(KWHT + ""--------------------------------------------------------------------------------------\n\n"" + KNRM); if (toStdout) { System.out.print(builder.toString()); } else { System.err.print(builder.toString()); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\PicardCommandLine.java,processAllCommandLinePrograms,public static void  (final List<String> packageList final BiConsumer<Class<CommandLineProgram> CommandLineProgramProperties> clpClassProcessor){ final ClassFinder classFinder=new ClassFinder(); packageList.forEach(pkg -> classFinder.find(pkg CommandLineProgram.class)); for ( final Class clazz : classFinder.getClasses()) { if (!clazz.isInterface() && !clazz.isSynthetic() && !clazz.isPrimitive()&& !clazz.isLocalClass()&& !Modifier.isAbstract(clazz.getModifiers())) { clpClassProcessor.accept(clazz PicardCommandLine.getProgramProperty(clazz)); } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\BaseCallingProgramGroup.java,getDescription,@Override public String  (){ return HelpConstants.DOC_CAT_BASE_CALLING_SUMMARY; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\BaseCallingProgramGroup.java,getName,@Override public String  (){ return HelpConstants.DOC_CAT_BASE_CALLING; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\OtherProgramGroup.java,getDescription,@Override public String  (){ return HelpConstants.DOC_CAT_OTHER_SUMMARY; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\OtherProgramGroup.java,getName,@Override public String  (){ return HelpConstants.DOC_CAT_OTHER; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\ReadDataManipulationProgramGroup.java,getDescription,@Override public String  (){ return HelpConstants.DOC_CAT_READ_DATA_MANIPULATION_SUMMARY; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\ReadDataManipulationProgramGroup.java,getName,@Override public String  (){ return HelpConstants.DOC_CAT_READ_DATA_MANIPULATION; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\IntervalsManipulationProgramGroup.java,getDescription,@Override public String  (){ return HelpConstants.DOC_CAT_INTERVALS_MANIPULATION_SUMMARY; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\IntervalsManipulationProgramGroup.java,getName,@Override public String  (){ return HelpConstants.DOC_CAT_INTERVALS_MANIPULATION; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\VariantFilteringProgramGroup.java,getDescription,@Override public String  (){ return HelpConstants.DOC_CAT_VARIANT_FILTERING_SUMMARY; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\VariantFilteringProgramGroup.java,getName,@Override public String  (){ return HelpConstants.DOC_CAT_VARIANT_FILTERING; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\ReferenceProgramGroup.java,getDescription,@Override public String  (){ return HelpConstants.DOC_CAT_REFERENCE_SUMMARY; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\ReferenceProgramGroup.java,getName,@Override public String  (){ return HelpConstants.DOC_CAT_REFERENCE; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\Testing.java,getDescription,@Override public String  (){ return HelpConstants.DOC_CAT_TEST_SUMMARY; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\Testing.java,getName,@Override public String  (){ return HelpConstants.DOC_CAT_TEST; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\VariantManipulationProgramGroup.java,getDescription,@Override public String  (){ return HelpConstants.DOC_CAT_VARIANT_MANIPULATION_SUMMARY; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\VariantManipulationProgramGroup.java,getName,@Override public String  (){ return HelpConstants.DOC_CAT_VARIANT_MANIPULATION; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\VariantEvaluationProgramGroup.java,getDescription,@Override public String  (){ return HelpConstants.DOC_CAT_VARIANT_EVALUATION_SUMMARY; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\cmdline\programgroups\VariantEvaluationProgramGroup.java,getName,@Override public String  (){ return HelpConstants.DOC_CAT_VARIANT_EVALUATION; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\BamToBfqWriter.java,BamToBfqWriter,public  (final File bamFile final String outputPrefix final boolean pairedReads String namePrefix boolean includeNonPfReads){ this(bamFile outputPrefix null null pairedReads namePrefix includeNonPfReads true null); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\BamToBfqWriter.java,countWritableRecords,"private int  (){ int count=0; final SamReader reader=SamReaderFactory.makeDefault().open(this.bamFile); if (!reader.getFileHeader().getSortOrder().equals(SAMFileHeader.SortOrder.queryname)) { throw new PicardException(""Input file ("" + this.bamFile.getAbsolutePath() + "") needs to be sorted by queryname.""); } final PeekableIterator<SAMRecord> it=new PeekableIterator<SAMRecord>(reader.iterator()); if (!this.pairedReads) { final List<SamRecordFilter> filters=new ArrayList<SamRecordFilter>(); filters.add(new TagFilter(ReservedTagConstants.XN 1)); if (!this.includeNonPfReads) { filters.add(new FailsVendorReadQualityFilter()); } final FilteringSamIterator itr=new FilteringSamIterator(it new AggregateFilter(filters)); while (itr.hasNext()) { itr.next(); count++; } } else { while (it.hasNext()) { final SAMRecord first=it.next(); final SAMRecord second=it.next(); if (first.getAttribute(ReservedTagConstants.XN) != null && second.getAttribute(ReservedTagConstants.XN) != null) { } else if (!this.includeNonPfReads && (first.getReadFailsVendorQualityCheckFlag() || second.getReadFailsVendorQualityCheckFlag())) { } else { count++; } } } it.close(); CloserUtil.close(reader); return count; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\BamToBfqWriter.java,encodeBaseAndQuality,private byte  (int base int quality){ return (byte)((base << 6) | quality); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\BamToBfqWriter.java,encodeSeqsAndQuals,"private byte[]  (char[] seqs char[] quals int retainedLength){ final byte[] seqsAndQuals=new byte[basesToWrite == null ? seqs.length : basesToWrite]; int seedRegionNoCallFixes=0; for (int i=0; i < retainedLength && i < seqsAndQuals.length; i++) { int quality=Math.min(quals[i] - 33 63); final int base; switch (seqs[i]) { case 'A': case 'a': base=0; break; case 'C': case 'c': base=1; break; case 'G': case 'g': base=2; break; case 'T': case 't': base=3; break; case 'N': case 'n': case '.': base=0; if (i < SEED_REGION_LENGTH) { if (seedRegionNoCallFixes < MAX_SEED_REGION_NOCALL_FIXES) { quality=1; seedRegionNoCallFixes++; } else { quality=0; } } else { quality=1; } break; default : throw new PicardException(""Unknown base when writing bfq file: "" + seqs[i]); } seqsAndQuals[i]=encodeBaseAndQuality(base quality); } for (int i=retainedLength; i < seqsAndQuals.length; i++) { seqsAndQuals[i]=encodeBaseAndQuality(0 1); } return seqsAndQuals; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\BamToBfqWriter.java,getOutputFile,"private File  (final String outputPrefix final int read final int index){ final File result=new File(outputPrefix + index + "".""+ read+ "".bfq""); IOUtil.assertFileIsWritable(result); return result; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\BamToBfqWriter.java,initializeNextBfqFiles,"private void  (final int fileIndex){ if (codec1 != null) { codec1.close(); if (pairedReads) { codec2.close(); } } final File bfq1=getOutputFile(this.outputPrefix 1 fileIndex); codec1=new BinaryCodec(IOUtil.openFileForWriting(bfq1)); log.info(""Now writing to file "" + bfq1.getAbsolutePath()); if (pairedReads) { final File bfq2=getOutputFile(this.outputPrefix 2 fileIndex); codec2=new BinaryCodec(IOUtil.openFileForWriting(bfq2)); log.info(""Now writing to file "" + bfq2.getAbsolutePath()); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\BamToBfqWriter.java,writeBfqFiles,"public void  (){ final SamReader reader=SamReaderFactory.makeDefault().open(bamFile); final Iterator<SAMRecord> iterator=reader.iterator(); final TagFilter tagFilter=new TagFilter(ReservedTagConstants.XN 1); final FailsVendorReadQualityFilter qualityFilter=new FailsVendorReadQualityFilter(); final WholeReadClippedFilter clippedFilter=new WholeReadClippedFilter(); if (!pairedReads) { List<SamRecordFilter> filters=new ArrayList<SamRecordFilter>(); filters.add(tagFilter); filters.add(clippedFilter); if (!this.includeNonPfReads) { filters.add(qualityFilter); } writeSingleEndBfqs(iterator filters); codec1.close(); } else { writePairedEndBfqs(iterator tagFilter qualityFilter clippedFilter); codec1.close(); codec2.close(); } log.info(""Wrote "" + wrote + "" bfq records.""); CloserUtil.close(reader); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\BamToBfqWriter.java,writeFastqRecord,private void  (final BinaryCodec codec final SAMRecord rec){ String readName=rec.getReadName(); if (namePrefix != null && readName.startsWith(namePrefix)) { readName=readName.substring(nameTrim); } codec.writeString(readName true true); final char[] seqs=rec.getReadString().toCharArray(); final char[] quals=rec.getBaseQualityString().toCharArray(); int retainedLength=seqs.length; if (clipAdapters) { Integer trimPoint=rec.getIntegerAttribute(ReservedTagConstants.XT); if (trimPoint != null) { assert (rec.getReadLength() == seqs.length); retainedLength=Math.min(seqs.length Math.max(SEED_REGION_LENGTH trimPoint - 1)); } } codec.writeInt(basesToWrite != null ? basesToWrite : seqs.length); final byte[] seqsAndQuals=encodeSeqsAndQuals(seqs quals retainedLength); codec.writeBytes(seqsAndQuals); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\BamToBfqWriter.java,writePairedEndBfqs,"private void  (final Iterator<SAMRecord> iterator final TagFilter tagFilter final FailsVendorReadQualityFilter qualityFilter SamRecordFilter... otherFilters){ int fileIndex=0; initializeNextBfqFiles(fileIndex++); int records=0; RECORD_LOOP: while (iterator.hasNext()) { final SAMRecord first=iterator.next(); if (!iterator.hasNext()) { throw new PicardException(""Mismatched number of records in "" + this.bamFile.getAbsolutePath()); } final SAMRecord second=iterator.next(); if (!second.getReadName().equals(first.getReadName()) || first.getFirstOfPairFlag() == second.getFirstOfPairFlag()) { throw new PicardException(""Unmatched read pairs in "" + this.bamFile.getAbsolutePath() + "": ""+ first.getReadName()+ ""  ""+ second.getReadName()+ "".""); } if (tagFilter.filterOut(first) && tagFilter.filterOut(second)) { continue; } if (!includeNonPfReads && (qualityFilter.filterOut(first) || qualityFilter.filterOut(second))) { continue; } for ( SamRecordFilter filter : otherFilters) { if (filter.filterOut(first) || filter.filterOut(second)) { continue RECORD_LOOP; } } records++; if (records % increment == 0) { first.setReadName(first.getReadName() + ""/1""); writeFastqRecord(first.getFirstOfPairFlag() ? codec1 : codec2 first); second.setReadName(second.getReadName() + ""/2""); writeFastqRecord(second.getFirstOfPairFlag() ? codec1 : codec2 second); wrote++; if (wrote % 1000000 == 0) { log.info(wrote + "" records written.""); } if (chunk > 0 && wrote % chunk == 0) { initializeNextBfqFiles(fileIndex++); } } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\BamToBfqWriter.java,writeSingleEndBfqs,"private void  (final Iterator<SAMRecord> iterator final List<SamRecordFilter> filters){ int fileIndex=0; initializeNextBfqFiles(fileIndex++); int records=0; final FilteringSamIterator it=new FilteringSamIterator(iterator new AggregateFilter(filters)); while (it.hasNext()) { final SAMRecord record=it.next(); records++; if (records % increment == 0) { record.setReadName(record.getReadName() + ""/1""); writeFastqRecord(codec1 record); wrote++; if (wrote % 1000000 == 0) { log.info(wrote + "" records processed.""); } if (chunk > 0 && wrote % chunk == 0) { initializeNextBfqFiles(fileIndex++); } } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\BamToBfq.java,customCommandLineValidation,"protected String[]  (){ if (OUTPUT_FILE_PREFIX == null) { OUTPUT_FILE_PREFIX=FLOWCELL_BARCODE + ""."" + LANE; } if (READ_NAME_PREFIX == null) { READ_NAME_PREFIX=RUN_BARCODE + "":""; } return null; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\BamToBfq.java,doWork,"protected int  (){ String outputPrefix=ANALYSIS_DIR.getAbsolutePath(); if (!outputPrefix.endsWith(""/"")) { outputPrefix+=""/""; } outputPrefix+=OUTPUT_FILE_PREFIX + "".""; BamToBfqWriter writer=new BamToBfqWriter(INPUT outputPrefix READS_TO_ALIGN READ_CHUNK_SIZE PAIRED_RUN READ_NAME_PREFIX INCLUDE_NON_PF_READS CLIP_ADAPTERS BASES_TO_WRITE); writer.writeBfqFiles(); return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\BamToBfq.java,main,public static void  (String[] argv){ System.exit(new BamToBfq().instanceMain(argv)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\Casava18ReadNameEncoder.java,Casava18ReadNameEncoder,public  (final String instrumentName final String runId final String flowcellId){ this.runId=runId; this.instrumentName=instrumentName; this.flowcellId=flowcellId; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\Casava18ReadNameEncoder.java,generateReadName,"@Override public String  (final ClusterData cluster final Integer pairNumber){ return new StringBuilder().append(instrumentName).append("":"").append(runId).append("":"").append(flowcellId).append("":"").append(cluster.getLane()).append("":"").append(cluster.getT"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\Casava18ReadNameEncoder.java,get,static IsFilteredLabel  (final boolean passesFilter){ return passesFilter ? N : Y; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\filter\CountingDuplicateFilter.java,reallyFilterOut,@Override public boolean  (final SAMRecord record){ return record.getDuplicateReadFlag(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\IlluminaReadNameEncoder.java,IlluminaReadNameEncoder,public  (final String runBarcode){ this.runBarcode=runBarcode; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\IlluminaReadNameEncoder.java,generatePairNumberSuffix,"private static String  (final Integer pairNumber){ if (pairNumber == null) return """"; else return ""/"" + pairNumber; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fastq\IlluminaReadNameEncoder.java,generateReadName,"@Override public String  (final ClusterData cluster final Integer pairNumber){ return runBarcode + "":"" + cluster.getLane()+ "":""+ cluster.getTile()+ "":""+ cluster.getX()+ "":""+ cluster.getY()+ generatePairNumberSuffix(pairNumber); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\filter\CountingFilter.java,filterOut,@Override public boolean  (final SAMRecord first final SAMRecord second){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\filter\CountingFilter.java,getFilteredBases,public long  (){ return this.filteredBases; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\filter\CountingFilter.java,getFilteredRecords,public long  (){ return this.filteredRecords; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\filter\CountingMapQFilter.java,CountingMapQFilter,public  (final int minMapq){ this.minMapq=minMapq; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\filter\CountingMapQFilter.java,reallyFilterOut,@Override public boolean  (final SAMRecord record){ return record.getMappingQuality() < minMapq; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CheckFingerprint.java,customCommandLineValidation,"protected String[]  (){ try { final boolean isBamOrSamFile=isBamOrSam(IOUtil.getPath(INPUT)); if (!isBamOrSamFile && IGNORE_READ_GROUPS) { return new String[]{""The parameter IGNORE_READ_GROUPS can only be used with BAM/SAM inputs.""}; } if (isBamOrSamFile && OBSERVED_SAMPLE_ALIAS != null) { return new String[]{""The parameter OBSERVED_SAMPLE_ALIAS can only be used with a VCF input.""}; } } catch ( IOException e) { e.printStackTrace(); } return super.customCommandLineValidation(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CheckFingerprint.java,doWork,"@Override protected int  (){ final File outputDetailMetricsFile  outputSummaryMetricsFile; if (OUTPUT == null) { outputDetailMetricsFile=DETAIL_OUTPUT; outputSummaryMetricsFile=SUMMARY_OUTPUT; } else { if (!OUTPUT.endsWith(""."")) OUTPUT=OUTPUT + "".""; outpu"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CheckFingerprint.java,isBamOrSam,static boolean  (final Path p){ return (p.toUri().getRawPath().endsWith(BamFileIoUtils.BAM_FILE_EXTENSION) || p.toUri().getRawPath().endsWith(IOUtil.SAM_FILE_EXTENSION)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\filter\CountingPairedFilter.java,reallyFilterOut,@Override public boolean  (final SAMRecord record){ return !record.getReadPairedFlag() || record.getMateUnmappedFlag(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\ClusteredCrosscheckMetric.java,ClusteredCrosscheckMetric,public  (CrosscheckMetric metric){ super(); ReflectionUtil.copyFromBaseClass(metric this); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\ClusterCrosscheckMetrics.java,clusterMetrics,private MetricsFile<ClusteredCrosscheckMetric ?>  (final List<CrosscheckMetric> metrics){ final GraphUtils.Graph<String> graph=new GraphUtils.Graph<>(); metrics.stream().filter(metric -> metric.LOD_SCORE > LOD_THRESHOLD).forEach(metric -> { final String lhsBy=metric.LEFT_GROUP_VALUE; final String rhsBy=metric.RIGHT_GROUP_VALUE; graph.addEdge(lhsBy rhsBy); } ); final Map<String Integer> clusters=graph.cluster(); final Map<Integer Set<String>> collection=clusters.entrySet().stream().collect(Collectors.groupingBy(Map.Entry::getValue)).entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey entry -> entry.getValue().stream().map(Map.Entry::getKey).collect(Collectors.toSet()))); final MetricsFile<ClusteredCrosscheckMetric ?> clusteredMetrics=getMetricsFile(); for ( final Map.Entry<Integer Set<String>> cluster : collection.entrySet()) { clusteredMetrics.addAllMetrics(metrics.stream().filter(metric -> cluster.getValue().contains(metric.LEFT_GROUP_VALUE) && cluster.getValue().contains(metric.RIGHT_GROUP_VALUE)).map(metric -> { final ClusteredCrosscheckMetric clusteredCrosscheckMetric=new ClusteredCrosscheckMetric(metric); clusteredCrosscheckMetric.CLUSTER=cluster.getKey(); clusteredCrosscheckMetric.CLUSTER_SIZE=cluster.getValue().size(); return clusteredCrosscheckMetric; } ).collect(Collectors.toSet())); } return clusteredMetrics; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\ClusterCrosscheckMetrics.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); if (OUTPUT != null) IOUtil.assertFileIsWritable(OUTPUT); final MetricsFile<CrosscheckMetric ?> metricsFile=getMetricsFile(); try { metricsFile.read(new FileReader(INPUT)); } catch ( FileNotF
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CrosscheckMetric.java,FingerprintResult, (Boolean isExpected Boolean isMatch){ this.isExpected=isExpected; this.isMatch=isMatch; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CrosscheckMetric.java,isExpected,public Boolean  (){ return isExpected; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CrosscheckMetric.java,isMatch,public Boolean  (){ return isMatch; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\DiploidGenotype.java,DiploidGenotype,private  (final char allele1 final char allele2){ this.allele1=(byte)(allele1 & 0xff); this.allele2=(byte)(allele2 & 0xff); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\DiploidGenotype.java,fromBases,"public static DiploidGenotype  (final byte base1 final byte base2){ final byte first=StringUtil.toUpperCase(base1); final byte second=StringUtil.toUpperCase(base2); final DiploidGenotype genotype=genotypes.get(first + second); if (genotype == null) { throw new IllegalArgumentException(""Unknown genotype string ["" + StringUtil.bytesToString(new byte[]{base1 base2}) + ""]  any pair of ACTG case insensitive is acceptable""); } return genotype; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\DiploidGenotype.java,getAllele1,public byte  (){ return allele1; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\DiploidGenotype.java,getAllele2,public byte  (){ return allele2; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\DiploidGenotype.java,isHeterozygous,public boolean  (){ return this.allele1 != this.allele2; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\DiploidGenotype.java,isHomomozygous,public boolean  (){ return this.allele1 == this.allele2; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\DiploidGenotype.java,isValidBase,public static boolean  (final byte base){ switch (StringUtil.toUpperCase(base)) { case 'A': case 'C': case 'G': case 'T': return true; default : return false; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CrosscheckReadGroupFingerprints.java,customCommandLineValidation,"@Override protected String[]  (){ final List<String> errors=new ArrayList<>(); if (CROSSCHECK_BY != CrosscheckMetric.DataType.READGROUP) { errors.add(""When calling CrosscheckReadGroupFingerprints  please refrain from supplying a CROSSCHECK_BY argument. "" "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CrosscheckReadGroupFingerprints.java,doWork,"@Override protected int  (){ if (EXPECT_ALL_READ_GROUPS_TO_MATCH) { EXPECT_ALL_GROUPS_TO_MATCH=EXPECT_ALL_READ_GROUPS_TO_MATCH; } if (CROSSCHECK_LIBRARIES) { CROSSCHECK_BY=CrosscheckMetric.DataType.LIBRARY; MATRIX_OUTPUT=OUTPUT; OUTPUT=new File(""/dev/null"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Fingerprint.java,Fingerprint,public  (final String sample final Path source final String info){ this.sample=sample; this.source=source; this.info=info; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Fingerprint.java,add,public void  (final HaplotypeProbabilities h){ put(h.getHaplotype() h); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Fingerprint.java,filterSuspectSites,public void  (){ final Iterator<Map.Entry<HaplotypeBlock HaplotypeProbabilities>> iterator=entrySet().iterator(); while (iterator.hasNext()) { final Map.Entry<HaplotypeBlock HaplotypeProbabilities> entry=iterator.next(); final HaplotypeProbabilities p=entry.getValue(); if (p instanceof HaplotypeProbabilitiesFromSequence) { final HaplotypeProbabilitiesFromSequence probs=(HaplotypeProbabilitiesFromSequence)p; if (probs.getLodMostProbableGenotype() >= 3 && probs.getFractionUnexpectedAlleleObs() > 0.1) { iterator.remove(); } } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Fingerprint.java,getInfo,public String  (){ return info; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Fingerprint.java,getPrintableId,"public String  (){ return getSample() + ""@"" + (source == null ? """" : source.toUri().toString())+ (info == null ? """" : ("":"" + info)); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Fingerprint.java,getSample,public String  (){ return sample; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Fingerprint.java,getSource,public Path  (){ return source; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Fingerprint.java,merge,public void  (final Fingerprint other){ final Set<HaplotypeBlock> haps=new HashSet<>(); haps.addAll(keySet()); haps.addAll(other.keySet()); for ( final HaplotypeBlock haplotype : haps) { HaplotypeProbabilities probabilities=get(haplotype); final HaplotypeProbabilities otherProbabilities=other.get(haplotype); if (probabilities == null) { probabilities=otherProbabilities; put(haplotype probabilities); } else if (otherProbabilities != null) { probabilities.merge(otherProbabilities); } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintResults.java,FingerprintResults,public  (final Path inputFile final String readGroup final String sampleAlias){ this.inputFile=inputFile; this.readGroup=readGroup; this.sampleAlias=sampleAlias; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintResults.java,addResults,public void  (final MatchResults matchResults){ this.matchResults.add(matchResults); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintResults.java,getInputFile,public Path  (){ return inputFile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintResults.java,getMatchResults,public SortedSet<MatchResults>  (){ return matchResults; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintResults.java,getReadGroup,public String  (){ return readGroup; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintResults.java,getSampleAlias,public String  (){ return sampleAlias; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintIdDetails.java,FingerprintIdDetails,public  (final SAMReadGroupRecord rg final String file){ this(rg.getPlatformUnit() file); this.sample=rg.getSample(); this.library=rg.getLibrary(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintIdDetails.java,equalValueOrElse,static private <T>T  (final T lhs final T rhs final T orElse){ if (rhs == null) return lhs; if (lhs == null) return rhs; return lhs.equals(rhs) ? lhs : orElse; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintIdDetails.java,equals,@Override public boolean  (final Object o){ if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; final FingerprintIdDetails that=(FingerprintIdDetails)o; if (platformUnit != null ? !platformUnit.equals(that.platformUnit) 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintIdDetails.java,getPlatformUnit,public String  (){ return platformUnit; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintIdDetails.java,getPlatformUnitDetails,"private void  (final String puString){ this.runBarcode=""?""; this.runLane=-1; this.molecularBarcode=""?""; if (puString == null) return; final String[] tmp=puString.split(""\\.""); if ((tmp.length == 3) || (tmp.length == 2)) { this.runBarcode=tmp[0]; this.molecularBarcode=(tmp.length == 3) ? tmp[2] : """"; try { this.runLane=Integer.parseInt(tmp[1]); } catch ( final NumberFormatException e) { } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintIdDetails.java,getSample,public String  (){ return sample; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintIdDetails.java,hashCode,@Override public int  (){ int result=platformUnit != null ? platformUnit.hashCode() : 0; result=31 * result + (runBarcode != null ? runBarcode.hashCode() : 0); result=31 * result + (runLane != null ? runLane.hashCode() : 0); result=31 * result + (molecula
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintIdDetails.java,merge,public FingerprintIdDetails  (final FingerprintIdDetails other){ platformUnit=equalValueOrElse(platformUnit other.platformUnit multipleValuesString); runBarcode=equalValueOrElse(runBarcode other.runBarcode multipleValuesString); runLane=equalValueOrElse(runLane other.runLane Integer.MIN_VALUE); library=equalValueOrElse(library other.library multipleValuesString); file=equalValueOrElse(file other.file multipleValuesString); sample=equalValueOrElse(sample other.sample multipleValuesString); molecularBarcode=equalValueOrElse(molecularBarcode other.molecularBarcode multipleValuesString); return this; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeBlock.java,HaplotypeBlock,public  (final double maf){ this.maf=maf; final double majorAf=(1 - maf); this.haplotypeFrequencies[0]=majorAf * majorAf; this.haplotypeFrequencies[1]=majorAf * maf * 2; this.haplotypeFrequencies[2]=maf * maf; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeBlock.java,addSnp,"public void  (final Snp snp){ if (this.snpsByName.isEmpty()) { this.chrom=snp.getChrom(); this.start=snp.getPos(); this.end=snp.getPos(); this.firstSnp=snp; } else if (!this.chrom.equals(snp.getChrom())) { throw new PicardException(""Snp chromosome "" + snp.getChrom() + "" does not agree with chromosome of existing snp(s): ""+ this.chrom); } else { if (snp.getPos() < this.start) { this.start=snp.getPos(); this.firstSnp=snp; } if (snp.getPos() > this.end) { this.end=snp.getPos(); } } this.snpsByName.put(snp.getName() snp); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeBlock.java,compareTo,@Override public int  (final HaplotypeBlock that){ int retval=this.chrom.compareTo(that.chrom); if (retval == 0) retval=this.start - that.start; if (retval == 0) retval=this.end - that.end; return retval; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeBlock.java,contains,public boolean  (final Snp snp){ final Snp contained=this.snpsByName.get(snp.getName()); return contained != null && contained.getChrom().equals(snp.getChrom()) && contained.getPos() == snp.getPos(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeBlock.java,equals,@Override public boolean  (final Object o){ if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; else return this.compareTo((HaplotypeBlock)o) == 0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeBlock.java,getDiploidHaplotype,"public DiploidHaplotype  (final Snp snp final DiploidGenotype gt){ if (!contains(snp)) throw new IllegalArgumentException(""Snp is not part of haplotype "" + snp); return DiploidHaplotype.values()[snp.indexOf(gt)]; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeBlock.java,getFirstSnp,public Snp  (){ return this.firstSnp; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeBlock.java,getHaplotypeFrequencies,public double[]  (){ return this.haplotypeFrequencies; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeBlock.java,getHaplotypeFrequency,"public double  (final int i){ if (i < 0 || i > 2) throw new IllegalArgumentException(""Illegal haplotype index "" + i); else return this.haplotypeFrequencies[i]; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeBlock.java,getMaf,public double  (){ return this.maf; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeBlock.java,getSnp,public Snp  (final String name){ return this.snpsByName.get(name); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeBlock.java,getSnpGenotype,"public DiploidGenotype  (final Snp snp final DiploidHaplotype haplotype){ if (!contains(snp)) throw new IllegalArgumentException(""Snp is not part of haplotype "" + snp); return snp.getGenotype(haplotype); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeBlock.java,getSnps,public Collection<Snp>  (){ return Collections.unmodifiableCollection(this.snpsByName.values()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeBlock.java,hashCode,@Override public int  (){ return this.start; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeBlock.java,size,public int  (){ return snpsByName.size(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeBlock.java,toString,"@Override public String  (){ return this.chrom + ""["" + this.start+ ""-""+ this.end+ ""]""; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,FingerprintChecker,public  (final HaplotypeMap haplotypes){ this.haplotypes=haplotypes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,calculateMatchResults,public static MatchResults  (final Fingerprint observedFp final Fingerprint expectedFp){ return calculateMatchResults(observedFp expectedFp 0 0); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,checkFingerprints,"public List<FingerprintResults>  (final List<Path> samFiles final List<Path> genotypeFiles final String specificSample final boolean ignoreReadGroups){ final List<Fingerprint> expectedFingerprints=new LinkedList<>(); for ( final Path p : genotypeFiles) { expectedFingerprints.addAll(loadFingerprints(p specificSample).values()); } if (expectedFingerprints.isEmpty()) { throw new IllegalStateException(""Could not find any fingerprints in: "" + genotypeFiles); } final List<FingerprintResults> resultsList=new ArrayList<>(); final IntervalList intervals=getLociToGenotype(expectedFingerprints); for ( final Path p : samFiles) { final Map<FingerprintIdDetails Fingerprint> fingerprintsByReadGroup=fingerprintSamFile(p intervals); if (ignoreReadGroups) { final Fingerprint combinedFp=new Fingerprint(specificSample p null); fingerprintsByReadGroup.values().forEach(combinedFp::merge); final FingerprintResults results=new FingerprintResults(p null specificSample); for ( final Fingerprint expectedFp : expectedFingerprints) { final MatchResults result=calculateMatchResults(combinedFp expectedFp 0 pLossofHet); results.addResults(result); } resultsList.add(results); } else { for ( final FingerprintIdDetails rg : fingerprintsByReadGroup.keySet()) { final FingerprintResults results=new FingerprintResults(p rg.platformUnit rg.sample); for ( final Fingerprint expectedFp : expectedFingerprints) { final MatchResults result=calculateMatchResults(fingerprintsByReadGroup.get(rg) expectedFp 0 pLossofHet); results.addResults(result); } resultsList.add(results); } } } return resultsList; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,checkFingerprintsFromPaths,"public List<FingerprintResults>  (final List<Path> observedGenotypeFiles final List<Path> expectedGenotypeFiles final String observedSample final String expectedSample){ final List<Fingerprint> expectedFingerprints=new ArrayList<>(); for ( final Path p : expectedGenotypeFiles) { expectedFingerprints.addAll(loadFingerprints(p expectedSample).values()); } if (expectedFingerprints.isEmpty()) { throw new IllegalStateException(""Could not find any fingerprints in: "" + expectedGenotypeFiles); } final List<FingerprintResults> resultsList=new ArrayList<>(); for ( final Path p : observedGenotypeFiles) { final Map<String Fingerprint> observedFingerprintsBySample=loadFingerprints(p observedSample); if (observedFingerprintsBySample.isEmpty()) { throw new IllegalStateException(""Found no fingerprints in observed genotypes file: "" + observedGenotypeFiles); } for ( final String sample : observedFingerprintsBySample.keySet()) { final FingerprintResults results=new FingerprintResults(p null sample); for ( final Fingerprint expectedFp : expectedFingerprints) { final MatchResults result=calculateMatchResults(observedFingerprintsBySample.get(sample) expectedFp 0 pLossofHet); results.addResults(result); } resultsList.add(results); } } return resultsList; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,createUnknownFP,"private FingerprintIdDetails  (final Path samFile final SAMRecord rec){ final PicardException e=new PicardException(""Found read with no readgroup: "" + rec.getReadName() + "" in file: ""+ samFile); if (validationStringency != ValidationStringency.STRICT) { final SAMReadGroupRecord readGroupRecord=new SAMReadGroupRecord(""<UNKNOWN>:::"" + samFile.toUri().toString()); readGroupRecord.setLibrary(""<UNKNOWN>""); readGroupRecord.setSample(""<UNKNOWN>""); readGroupRecord.setPlatformUnit(""<UNKNOWN>.0.ZZZ""); if (validationStringency == ValidationStringency.LENIENT) { log.warn(e); log.warn(""further messages from this file will be suppressed""); } return new FingerprintIdDetails(readGroupRecord samFile.toUri().toString()); } else { log.error(e); throw e; } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,fingerprintFiles,"public Map<FingerprintIdDetails Fingerprint>  (final Collection<Path> files final int threads final int waitTime final TimeUnit waitTimeUnit){ final AtomicInteger filesRead=new AtomicInteger(0); final ExecutorService executor=new ThreadPoolExecutorWithExceptions(threads); final ExecutorCompletionService<Path> executorCompletionService=new ExecutorCompletionService<>(executor); final IntervalList intervals=this.haplotypes.getIntervalList(); final Map<FingerprintIdDetails Fingerprint> retval=new ConcurrentHashMap<>(); for ( final Path p : files) { executorCompletionService.submit(() -> { if (CheckFingerprint.isBamOrSam(p)) { retval.putAll(fingerprintSamFile(p intervals)); } else { retval.putAll(fingerprintVcf(p)); } log.debug(""Processed file: "" + p.toUri().toString() + "" (""+ filesRead.get()+ "")""); if (filesRead.incrementAndGet() % 100 == 0) { log.info(""Processed "" + filesRead.get() + "" out of ""+ files.size()); } }  p); } executor.shutdown(); try { executor.awaitTermination(waitTime waitTimeUnit); } catch ( final InterruptedException ie) { throw new PicardException(""Interrupted while waiting for executor to terminate."" ie); } for (int i=0; i < files.size(); i++) { try { executorCompletionService.take().get(); } catch ( InterruptedException|ExecutionException e) { throw new PicardException(""Failed to fingerprint"" e); } } return retval; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,fingerprintSamFile,"public Map<FingerprintIdDetails Fingerprint>  (final Path samFile final IntervalList loci){ final SamReader in=SamReaderFactory.makeDefault().enable(SamReaderFactory.Option.CACHE_FILE_BASED_INDEXES).open(samFile); SequenceUtil.assertSequenceDictionariesEqual(this.haplotypes.getHeader().getSequenceDictionary() in.getFileHeader().getSequenceDictionary()); final SamLocusIterator iterator=new SamLocusIterator(in loci in.hasIndex()); iterator.setEmitUncoveredLoci(true); iterator.setMappingQualityScoreCutoff(this.minimumMappingQuality); iterator.setQualityScoreCutoff(this.minimumBaseQuality); if (this.allowDuplicateReads) { final List<SamRecordFilter> filters=new ArrayList<>(1); filters.add(new SecondaryAlignmentFilter()); iterator.setSamFilters(filters); } final Map<SAMReadGroupRecord FingerprintIdDetails> fingerprintIdDetailsMap=new HashMap<>(); final Map<FingerprintIdDetails Fingerprint> fingerprintsByReadGroup=new HashMap<>(); for ( final SAMReadGroupRecord rg : in.getFileHeader().getReadGroups()) { final FingerprintIdDetails id=new FingerprintIdDetails(rg.getPlatformUnit() samFile.toUri().toString()); id.library=rg.getLibrary(); id.sample=rg.getSample(); fingerprintIdDetailsMap.put(rg id); final Fingerprint fingerprint=new Fingerprint(id.sample samFile id.platformUnit); fingerprintsByReadGroup.put(id fingerprint); for ( final HaplotypeBlock h : this.haplotypes.getHaplotypes()) { fingerprint.add(new HaplotypeProbabilitiesFromSequence(h)); } } final Set<String> usedReadNames=new HashSet<>(10000); for ( final SamLocusIterator.LocusInfo info : iterator) { final HaplotypeBlock haplotypeBlock=this.haplotypes.getHaplotype(info.getSequenceName() info.getPosition()); final Snp snp=this.haplotypes.getSnp(info.getSequenceName() info.getPosition()); for ( final SamLocusIterator.RecordAndOffset rec : info.getRecordAndOffsets()) { final SAMReadGroupRecord rg=rec.getRecord().getReadGroup(); final FingerprintIdDetails details; if (rg == null || !fingerprintIdDetailsMap.containsKey(rg)) { final FingerprintIdDetails unknownFPDetails=createUnknownFP(samFile rec.getRecord()); fingerprintIdDetailsMap.put(null unknownFPDetails); final Fingerprint fp=new Fingerprint(unknownFPDetails.sample samFile unknownFPDetails.platformUnit); fingerprintsByReadGroup.put(unknownFPDetails fp); for ( final HaplotypeBlock h : this.haplotypes.getHaplotypes()) { fp.add(new HaplotypeProbabilitiesFromSequence(h)); } } if (fingerprintIdDetailsMap.containsKey(rg)) { details=fingerprintIdDetailsMap.get(rg); final String readName=rec.getRecord().getReadName(); if (!usedReadNames.contains(readName)) { final HaplotypeProbabilitiesFromSequence probs=(HaplotypeProbabilitiesFromSequence)fingerprintsByReadGroup.get(details).get(haplotypeBlock); final byte base=StringUtil.toUpperCase(rec.getReadBase()); final byte qual=rec.getBaseQuality(); probs.addToProbs(snp base qual); usedReadNames.add(readName); } } else { final PicardException e=new PicardException(""Unknown read group: "" + rg + "" in file: ""+ samFile); log.error(e); throw e; } } } return fingerprintsByReadGroup; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,fingerprintVcf,public Map<FingerprintIdDetails Fingerprint>  (final Path vcfFile){ final Map<FingerprintIdDetails Fingerprint> fpIdMap=new HashMap<>(); final Map<String Fingerprint> sampleFpMap=loadFingerprints(vcfFile null); sampleFpMap.forEach((key value) -> { final FingerprintIdDetails fpId=new FingerprintIdDetails(); fpId.sample=key; fpId.file=vcfFile.toUri().toString(); fpIdMap.put(fpId value); } ); return fpIdMap; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,getFingerprintFromVc,"private void  (final Map<String Fingerprint> fingerprints final VariantContext ctx) throws IllegalArgumentException { final HaplotypeBlock h=this.haplotypes.getHaplotype(ctx.getContig() ctx.getStart()); if (h == null) return; final Snp snp=this.haplotypes.getSnp(ctx.getContig() ctx.getStart()); final VariantContext usableSnp=AlleleSubsettingUtils.subsetVCToMatchSnp(ctx snp); if (usableSnp == null) { return; } { boolean allelesOk=true; for ( final Allele allele : usableSnp.getAlleles()) { final byte[] bases=allele.getBases(); if (bases.length > 1 || (bases[0] != snp.getAllele1() && bases[0] != snp.getAllele2())) { allelesOk=false; } } if (!allelesOk) { log.warn(""Problem with genotype file: Alleles "" + usableSnp.getAlleles() + "" do not match to alleles for SNP ""+ snp+ "" with alleles ""+ snp.getAlleleString()); throw new IllegalArgumentException(""Alleles do not match between database and file""); } } for ( final String sample : fingerprints.keySet()) { final Fingerprint fp=fingerprints.get(sample); final Genotype genotype=usableSnp.getGenotype(sample); if (genotype == null) { throw new IllegalArgumentException(""Cannot find sample "" + sample + "" in provided file. ""); } if (genotype.hasPL()) { final HaplotypeProbabilitiesFromGenotypeLikelihoods hFp=new HaplotypeProbabilitiesFromGenotypeLikelihoods(h); final int[] pls=genotype.getPL(); final int[] newPLs=new int[pls.length]; for (int i=0; i < pls.length; i++) { newPLs[i]=Math.min(maximalPLDifference pls[i]); } hFp.addToLogLikelihoods(snp usableSnp.getAlleles() GenotypeLikelihoods.fromPLs(newPLs).getAsVector()); fp.add(hFp); } else { if (genotype.isNoCall()) continue; if (fp.containsKey(h)) continue; final boolean hom=genotype.isHom(); final byte allele=StringUtil.toUpperCase(genotype.getAllele(0).getBases()[0]); final double halfError=this.genotypingErrorRate / 2; final double accuracy=1 - this.genotypingErrorRate; final double[] probs=new double[]{(hom && allele == snp.getAllele1()) ? accuracy : halfError (!hom) ? accuracy : halfError (hom && allele == snp.getAllele2()) ? accuracy : halfError}; fp.add(new HaplotypeProbabilitiesFromGenotype(snp h probs[0] probs[1] probs[2])); } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,getHeader,public SAMFileHeader  (){ return haplotypes.getHeader(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,getLociToGenotype,public IntervalList  (final Collection<Fingerprint> fingerprints){ final IntervalList intervals=new IntervalList(this.haplotypes.getHeader()); for ( final Fingerprint fp : fingerprints) { for ( final HaplotypeProbabilities genotype : fp.values()) { final HaplotypeBlock h=genotype.getHaplotype(); for ( final Snp snp : h.getSnps()) { intervals.add(new Interval(snp.getChrom() snp.getPos() snp.getPos() false snp.getName())); } } } return intervals.uniqued(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,getValidationStringency,public ValidationStringency  (){ return validationStringency; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,identifyContaminant,"public Map<String Fingerprint>  (final Path samFile final double contamination final int locusMaxReads){ final Map<String Fingerprint> fingerprintsBySample=new HashMap<>(); try (final SamReader in=SamReaderFactory.makeDefault().enable(CACHE_FILE_BASED_INDEXES).open(samFile)){ SequenceUtil.assertSequenceDictionariesEqual(this.haplotypes.getHeader().getSequenceDictionary() in.getFileHeader().getSequenceDictionary()); final SamLocusIterator iterator=new SamLocusIterator(in haplotypes.getIntervalList() in.hasIndex()); iterator.setEmitUncoveredLoci(true); iterator.setMappingQualityScoreCutoff(this.minimumMappingQuality); iterator.setQualityScoreCutoff(this.minimumBaseQuality); if (this.allowDuplicateReads) { final List<SamRecordFilter> filters=new ArrayList<>(1); filters.add(new SecondaryAlignmentFilter()); iterator.setSamFilters(filters); } for ( final SAMReadGroupRecord rg : in.getFileHeader().getReadGroups()) { if (!fingerprintsBySample.containsKey(rg.getSample())) { final Fingerprint fingerprint=new Fingerprint(rg.getSample() samFile rg.getSample()); for ( final HaplotypeBlock h : this.haplotypes.getHaplotypes()) { fingerprint.add(new HaplotypeProbabilitiesFromContaminatorSequence(h contamination)); } fingerprintsBySample.put(rg.getSample() fingerprint); } } final Set<String> usedReadNames=new HashSet<>(10000); for ( final SamLocusIterator.LocusInfo info : iterator) { final HaplotypeBlock haplotypeBlock=this.haplotypes.getHaplotype(info.getSequenceName() info.getPosition()); final Snp snp=this.haplotypes.getSnp(info.getSequenceName() info.getPosition()); final List<SamLocusIterator.RecordAndOffset> recordAndOffsetList=randomSublist(info.getRecordAndPositions() locusMaxReads); for ( final SamLocusIterator.RecordAndOffset rec : recordAndOffsetList) { final SAMReadGroupRecord rg=rec.getRecord().getReadGroup(); if (rg == null || !fingerprintsBySample.containsKey(rg.getSample())) { final PicardException e=new PicardException(""Unknown sample: "" + (rg != null ? rg.getSample() : ""(null readgroup)"")); log.error(e); throw e; } else { final String readName=rec.getRecord().getReadName(); if (!usedReadNames.contains(readName)) { final HaplotypeProbabilitiesFromContaminatorSequence probs=(HaplotypeProbabilitiesFromContaminatorSequence)fingerprintsBySample.get(rg.getSample()).get(haplotypeBlock); final byte base=StringUtil.toUpperCase(rec.getReadBase()); final byte qual=rec.getBaseQuality(); probs.addToProbs(snp base qual); usedReadNames.add(readName); } } } } } catch ( IOException e) { log.error(""Unexpected Error while reading from "" + samFile + "". Trying to continue."" e.getMessage() e.getStackTrace()); } return fingerprintsBySample; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,loadFingerprints,"public Map<String Fingerprint>  (final Path fingerprintFile final String specificSample){ SequenceUtil.assertSequenceDictionariesEqual(this.haplotypes.getHeader().getSequenceDictionary() VCFFileReader.getSequenceDictionary(fingerprintFile)); final VCFFileReader reader=new VCFFileReader(fingerprintFile false); if (reader.isQueryable()) { return loadFingerprintsFromQueriableReader(reader specificSample fingerprintFile); } else { log.warn(""Couldn't find index for file "" + fingerprintFile + "" going to read through it all.""); return loadFingerprintsFromVariantContexts(reader specificSample fingerprintFile); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,loadFingerprintsFromIndexedVcf,public Map<String Fingerprint>  (final Path fingerprintFile final String specificSample){ final VCFFileReader reader=new VCFFileReader(fingerprintFile true); return loadFingerprintsFromQueriableReader(reader specificSample fingerprintFile); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,loadFingerprintsFromNonIndexedVcf,public Map<String Fingerprint>  (final Path fingerprintFile final String specificSample){ final VCFFileReader reader=new VCFFileReader(fingerprintFile false); SequenceUtil.assertSequenceDictionariesEqual(this.haplotypes.getHeader().getSequenceDictionary() SAMSequenceDictionaryExtractor.extractDictionary(fingerprintFile)); return loadFingerprintsFromVariantContexts(reader specificSample fingerprintFile); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,loadFingerprintsFromQueriableReader,public Map<String Fingerprint>  (final VCFFileReader reader final String specificSample final Path source){ SequenceUtil.assertSequenceDictionariesEqual(this.haplotypes.getHeader().getSequenceDictionary() reader.getFileHeader().getSequenceDictionary()); final SortedSet<Snp> snps=new TreeSet<>(haplotypes.getAllSnps()); return loadFingerprintsFromVariantContexts(() -> snps.stream().map(snp -> { try { return reader.query(snp.getChrom() snp.getPos() snp.getPos()).next(); } catch ( NoSuchElementException e) { return null; } } ).iterator() specificSample source); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,loadFingerprintsFromVariantContexts,"public Map<String Fingerprint>  (final Iterable<VariantContext> iterable final String specificSample final Path source){ final Map<String Fingerprint> fingerprints=new HashMap<>(); Set<String> samples=null; for ( final VariantContext ctx : iterable) { if (ctx == null) continue; if (samples == null) { if (specificSample != null) { samples=new HashSet<>(); samples.add(specificSample); } else { samples=ctx.getSampleNames(); if (samples == null) { log.warn(""No samples found in file: "" + source.toUri().toString() + "". Skipping.""); return Collections.emptyMap(); } } samples.forEach(s -> fingerprints.put(s new Fingerprint(s source null))); } try { getFingerprintFromVc(fingerprints ctx); } catch ( final IllegalArgumentException e) { log.warn(e ""There was a genotyping error in File: "" + source.toUri().toString() + ""\n""+ e.getMessage()); } } return fingerprints; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,randomSublist,protected static <T>List<T>  (final List<T> list final int n){ int availableElements=list.size(); if (availableElements <= n) return list; int stillNeeded=n; final Random rg=new Random(); final List<T> shortList=new ArrayList<>(n); for ( final T aList : list) { if (rg.nextDouble() < stillNeeded / (double)availableElements) { shortList.add(aList); stillNeeded--; } if (stillNeeded == 0) break; availableElements--; } return shortList; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,setAllowDuplicateReads,public void  (final boolean allowDuplicateReads){ this.allowDuplicateReads=allowDuplicateReads; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,setGenotypingErrorRate,public void  (final double genotypingErrorRate){ this.genotypingErrorRate=genotypingErrorRate; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,setMinimumBaseQuality,public void  (final int minimumBaseQuality){ this.minimumBaseQuality=minimumBaseQuality; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,setMinimumMappingQuality,public void  (final int minimumMappingQuality){ this.minimumMappingQuality=minimumMappingQuality; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,setValidationStringency,public void  (final ValidationStringency validationStringency){ this.validationStringency=validationStringency; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,setmaximalPLDifference,public void  (final int maximalPLDifference){ this.maximalPLDifference=maximalPLDifference; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintChecker.java,setpLossofHet,public void  (final double pLossofHet){ this.pLossofHet=pLossofHet; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintUtils.java,VariantContextSet, (final SAMSequenceDictionary dict){ super((lhs rhs) -> { final int lhsContig=dict.getSequenceIndex(lhs.getContig()); final int rhsContig=dict.getSequenceIndex(rhs.getContig()); final int retval=lhsContig - rhsContig; if (retval != 0) return retval; return lhs.getStart() - rhs.getStart(); } ); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintUtils.java,createVCSetFromFingerprint,"public static VariantContextSet  (final Fingerprint fingerPrint final ReferenceSequenceFile reference final String sample){ final VariantContextSet variantContexts=new VariantContextSet(reference.getSequenceDictionary()); fingerPrint.values().stream().map(hp -> hp.getRepresentativeSnp().getName()).filter(Objects::nonNull).filter(n -> !n.equals("""")).collect(Collectors.groupingBy(Function.identity() Collectors.counting())).entrySet().stream().filter(e -> e.getValue() > 1).findFirst().ifPresent(e -> { throw new IllegalArgumentException(""Found same SNP name twice ("" + e.getKey() + "") in fingerprint. Cannot create a VCF.""); } ); fingerPrint.values().stream().map(hp -> getVariantContext(reference sample hp)).forEach(variantContexts::add); return variantContexts; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintUtils.java,getVariantContext,"private static VariantContext  (final ReferenceSequenceFile reference final String sample final HaplotypeProbabilities haplotypeProbabilities){ final Snp snp=haplotypeProbabilities.getRepresentativeSnp(); final byte refAllele=StringUtil.toUpperCase(reference.getSubsequenceAt(snp.getChrom() snp.getPos() snp.getPos()).getBases()[0]); final Allele allele1=Allele.create(snp.getAllele1() snp.getAllele1() == refAllele); final Allele allele2=Allele.create(snp.getAllele2() snp.getAllele2() == refAllele); final List<Allele> alleles=Arrays.asList(allele1 allele2); final Genotype gt=new GenotypeBuilder().DP(haplotypeProbabilities.getTotalObs()).noAttributes().PL(haplotypeProbabilities.getLogLikelihoods()).AD(new int[]{haplotypeProbabilities.getObsAllele1() haplotypeProbabilities.getObsAllele2()}).name(sample).make(); try { return new VariantContextBuilder(snp.getName() snp.getChrom() snp.getPos() snp.getPos() alleles).log10PError(VariantContext.NO_LOG10_PERROR).genotypes(gt).unfiltered().make(); } catch ( IllegalArgumentException e) { throw new IllegalArgumentException(String.format(""Trouble creating variant at %s-%d"" snp.getChrom() snp.getPos()) e); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintUtils.java,getVariantContextWriter,"private static VariantContextWriter  (final File outputFile final File referenceSequenceFileName final String sample final String source final ReferenceSequenceFile ref){ final VariantContextWriter variantContextWriter=new VariantContextWriterBuilder().setReferenceDictionary(ref.getSequenceDictionary()).setOutputFile(outputFile).build(); final Set<VCFHeaderLine> lines=new LinkedHashSet<>(); lines.add(new VCFHeaderLine(""reference"" referenceSequenceFileName.getAbsolutePath())); lines.add(new VCFHeaderLine(""source"" source)); lines.add(new VCFHeaderLine(""fileDate"" new Date().toString())); lines.add(VCFStandardHeaderLines.getFormatLine(VCFConstants.GENOTYPE_PL_KEY)); lines.add(VCFStandardHeaderLines.getFormatLine(VCFConstants.GENOTYPE_ALLELE_DEPTHS)); lines.add(VCFStandardHeaderLines.getFormatLine(VCFConstants.DEPTH_KEY)); final VCFHeader header=new VCFHeader(lines Collections.singletonList(sample)); header.setSequenceDictionary(ref.getSequenceDictionary()); variantContextWriter.writeHeader(header); return variantContextWriter; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\FingerprintUtils.java,writeFingerPrint,public static void  (final Fingerprint fingerprint final File outputFile final File referenceSequenceFileName final String sample final String source) throws IOException { try (final ReferenceSequenceFile ref=ReferenceSequenceFileFactory.getReferenceSequenceFile(referenceSequenceFileName);final VariantContextWriter variantContextWriter=getVariantContextWriter(outputFile referenceSequenceFileName sample source ref)){ createVCSetFromFingerprint(fingerprint ref sample).forEach(variantContextWriter::add); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CrosscheckFingerprints.java,checkFingerprintsBySample,"private int  (final Map<FingerprintIdDetails Fingerprint> fingerprints1 final Map<FingerprintIdDetails Fingerprint> fingerprints2 final List<CrosscheckMetric> metrics){ int unexpectedResults=0; final Map<FingerprintIdDetails Fingerprint> fingerprints1BySample=mergeFingerprintsBy(fingerprints1 getFingerprintIdDetailsStringFunction(CrosscheckMetric.DataType.SAMPLE)); final Map<FingerprintIdDetails Fingerprint> fingerprints2BySample=mergeFingerprintsBy(fingerprints2 getFingerprintIdDetailsStringFunction(CrosscheckMetric.DataType.SAMPLE)); final Map<String FingerprintIdDetails> sampleToDetail1=fingerprints1BySample.keySet().stream().collect(Collectors.toMap(id -> id.group id -> id)); final Map<String FingerprintIdDetails> sampleToDetail2=fingerprints2BySample.keySet().stream().collect(Collectors.toMap(id -> id.group id -> id)); Set<String> samples=new HashSet<>(); samples.addAll(sampleToDetail1.keySet()); samples.addAll(sampleToDetail2.keySet()); for ( final String sample : samples) { final FingerprintIdDetails lhsID=sampleToDetail1.get(sample); final FingerprintIdDetails rhsID=sampleToDetail2.get(sample); if (lhsID == null || rhsID == null) { log.error(String.format(""sample %s is missing from %s group"" sample lhsID == null ? ""LEFT"" : ""RIGHT"")); unexpectedResults++; continue; } final MatchResults results=FingerprintChecker.calculateMatchResults(fingerprints1BySample.get(lhsID) fingerprints2BySample.get(rhsID) GENOTYPING_ERROR_RATE LOSS_OF_HET_RATE false CALCULATE_TUMOR_AWARE_RESULTS); final CrosscheckMetric.FingerprintResult result=getMatchResults(true results); if (!OUTPUT_ERRORS_ONLY || !result.isExpected()) { metrics.add(getMatchDetails(result results lhsID rhsID CrosscheckMetric.DataType.SAMPLE)); } if (result != FingerprintResult.INCONCLUSIVE && !result.isExpected()) unexpectedResults++; } return unexpectedResults; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CrosscheckFingerprints.java,crossCheckFingerprints,"private int  (final Map<FingerprintIdDetails Fingerprint> lhsFingerprints final Map<FingerprintIdDetails Fingerprint> rhsFingerprints final CrosscheckMetric.DataType type final List<CrosscheckMetric> metrics){ int unexpectedResults=0; long checksMade=0; final int logEvery=100_000; final List<FingerprintIdDetails> lhsFingerprintIdDetails=new ArrayList<>(lhsFingerprints.keySet()); final List<FingerprintIdDetails> rhsFingerprintIdDetails=new ArrayList<>(rhsFingerprints.keySet()); final long totalChecks=lhsFingerprintIdDetails.size() * ((long)rhsFingerprintIdDetails.size()); for (int row=0; row < lhsFingerprintIdDetails.size(); row++) { final FingerprintIdDetails lhsId=lhsFingerprintIdDetails.get(row); for (int col=0; col < rhsFingerprintIdDetails.size(); col++) { final FingerprintIdDetails rhsId=rhsFingerprintIdDetails.get(col); final boolean expectedToMatch=EXPECT_ALL_GROUPS_TO_MATCH || lhsId.sample.equals(rhsId.sample); final MatchResults results=FingerprintChecker.calculateMatchResults(lhsFingerprints.get(lhsId) rhsFingerprints.get(rhsId) GENOTYPING_ERROR_RATE LOSS_OF_HET_RATE false CALCULATE_TUMOR_AWARE_RESULTS); final FingerprintResult result=getMatchResults(expectedToMatch results); if (!OUTPUT_ERRORS_ONLY || result == FingerprintResult.INCONCLUSIVE || !result.isExpected()) { metrics.add(getMatchDetails(result results lhsId rhsId type)); } if (result != FingerprintResult.INCONCLUSIVE && !result.isExpected()) unexpectedResults++; if (crosscheckMatrix != null) { crosscheckMatrix[row][col]=results.getLOD(); } if (++checksMade % logEvery == 0) { log.info(""Compared "" + checksMade + "" of ""+ totalChecks); } } } return unexpectedResults; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CrosscheckFingerprints.java,crossCheckGrouped,private int  (final Map<FingerprintIdDetails Fingerprint> lhsFingerprints final Map<FingerprintIdDetails Fingerprint> rhsFingerprints final List<CrosscheckMetric> metrics final Function<FingerprintIdDetails String> by final CrosscheckMetric.DataType type){ final Map<FingerprintIdDetails Fingerprint> lhsFingerprintsByGroup=mergeFingerprintsBy(lhsFingerprints by); final Map<FingerprintIdDetails Fingerprint> rhsFingerprintsByGroup=mergeFingerprintsBy(rhsFingerprints by); if (MATRIX_OUTPUT != null) { crosscheckMatrix=new double[lhsFingerprintsByGroup.size()][]; for (int row=0; row < lhsFingerprintsByGroup.size(); row++) { crosscheckMatrix[row]=new double[rhsFingerprintsByGroup.size()]; } lhsFingerprintsByGroup.keySet().forEach(k -> lhsMatrixKeys.add(k.group)); rhsFingerprintsByGroup.keySet().forEach(k -> rhsMatrixKeys.add(k.group)); } return crossCheckFingerprints(lhsFingerprintsByGroup rhsFingerprintsByGroup type metrics); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CrosscheckFingerprints.java,customCommandLineValidation,"@Override protected String[]  (){ if (GENOTYPING_ERROR_RATE <= 0 || GENOTYPING_ERROR_RATE >= 1) { return new String[]{""Genotyping error must be strictly greater than 0 and less than 1  found "" + GENOTYPING_ERROR_RATE}; } if (SECOND_INPUT == null && INPUT_"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CrosscheckFingerprints.java,doWork,"@Override protected int  (){ IOUtil.assertFileIsReadable(HAPLOTYPE_MAP); if (OUTPUT != null) IOUtil.assertFileIsWritable(OUTPUT); if (!SECOND_INPUT.isEmpty() && CROSSCHECK_MODE == CHECK_SAME_SAMPLE) { log.info(""SECOND_INPUT is not empty  and CROSSCHECK_MO"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CrosscheckFingerprints.java,getFingerprintIdDetailsStringFunction,"public static Function<FingerprintIdDetails String>  (CrosscheckMetric.DataType CROSSCHECK_BY){ final Function<FingerprintIdDetails String> groupByTemp; switch (CROSSCHECK_BY) { case READGROUP: groupByTemp=details -> details.platformUnit; break; case LIBRARY: groupByTemp=details -> details.sample + ""::"" + details.library; break; case FILE: groupByTemp=details -> details.file + ""::"" + details.sample; break; case SAMPLE: groupByTemp=details -> details.sample; break; default : throw new PicardException(""unpossible""); } return key -> { final String temp=groupByTemp.apply(key); return temp == null ? Integer.toString(key.hashCode()) : temp; } ; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CrosscheckFingerprints.java,getHelpDoc,"@Override public String  (){ return ""In this mode  each sample in INPUT will be checked against all the samples in SECOND_INPUT.""; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CrosscheckFingerprints.java,getMatchDetails,private CrosscheckMetric  (final FingerprintResult matchResult final MatchResults results final FingerprintIdDetails leftPuDetails final FingerprintIdDetails rightPuDetails final CrosscheckMetric.DataType type){ final CrosscheckMetric metric=new CrosscheckMetric(); metric.LEFT_GROUP_VALUE=leftPuDetails.group; metric.RIGHT_GROUP_VALUE=rightPuDetails.group; metric.RESULT=matchResult; metric.LOD_SCORE=results.getLOD(); metric.LOD_SCORE_TUMOR_NORMAL=results.getLodTN(); metric.LOD_SCORE_NORMAL_TUMOR=results.getLodNT(); metric.DATA_TYPE=type; metric.LEFT_RUN_BARCODE=leftPuDetails.runBarcode; metric.LEFT_LANE=leftPuDetails.runLane; metric.LEFT_MOLECULAR_BARCODE_SEQUENCE=leftPuDetails.molecularBarcode; metric.LEFT_LIBRARY=leftPuDetails.library; metric.LEFT_SAMPLE=leftPuDetails.sample; metric.LEFT_FILE=leftPuDetails.file; metric.RIGHT_RUN_BARCODE=rightPuDetails.runBarcode; metric.RIGHT_LANE=rightPuDetails.runLane; metric.RIGHT_MOLECULAR_BARCODE_SEQUENCE=rightPuDetails.molecularBarcode; metric.RIGHT_LIBRARY=rightPuDetails.library; metric.RIGHT_SAMPLE=rightPuDetails.sample; metric.RIGHT_FILE=rightPuDetails.file; return metric; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CrosscheckFingerprints.java,getMatchResults,private FingerprintResult  (final boolean expectedToMatch final MatchResults results){ if (expectedToMatch) { if (results.getLOD() < LOD_THRESHOLD) { return FingerprintResult.UNEXPECTED_MISMATCH; } else if (results.getLOD() > -LOD_THRESHOLD) { return FingerprintResult.EXPECTED_MATCH; } else { return FingerprintResult.INCONCLUSIVE; } } else { if (results.getLOD() > -LOD_THRESHOLD) { return FingerprintResult.UNEXPECTED_MATCH; } else if (results.getLOD() < LOD_THRESHOLD) { return FingerprintResult.EXPECTED_MISMATCH; } else { return FingerprintResult.INCONCLUSIVE; } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CrosscheckFingerprints.java,mergeFingerprintsBy,public static Map<FingerprintIdDetails Fingerprint>  (final Map<FingerprintIdDetails Fingerprint> fingerprints final Function<FingerprintIdDetails String> by){ final Map<String List<Map.Entry<FingerprintIdDetails Fingerprint>>> collection=fingerprints.entrySet().stream().collect(Collectors.groupingBy(entry -> by.apply(entry.getKey()))); return collection.entrySet().stream().collect(Collectors.toMap(entry -> { final FingerprintIdDetails finalId=new FingerprintIdDetails(); entry.getValue().forEach(id -> finalId.merge(id.getKey())); finalId.group=entry.getKey(); return finalId; }  entry -> { final FingerprintIdDetails firstDetail=entry.getValue().get(0).getKey(); final Fingerprint sampleFp=new Fingerprint(firstDetail.sample null by.apply(firstDetail)); entry.getValue().stream().map(Map.Entry::getValue).collect(Collectors.toSet()).forEach(sampleFp::merge); return sampleFp; } )); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CrosscheckFingerprints.java,remapFingerprints,"private void  (final Map<FingerprintIdDetails Fingerprint> fpMap final File sampleMapFile final String inputFieldName){ final Map<String String> sampleMap=new HashMap<>(); final TabbedInputParser parser=new TabbedInputParser(false sampleMapFile); for ( final String[] strings : parser) { if (strings.length != 2) { throw new IllegalArgumentException(""Each line of the "" + inputFieldName + "" must have exactly two strings separated by a tab. ""+ ""Found: [""+ String.join("" "" Arrays.asList(strings))+ ""] right before [""+ parser.getCurrentLine()+ ""]  in ""+ sampleMapFile.getAbsolutePath()); } if (sampleMap.containsKey(strings[0])) { throw new IllegalArgumentException(""Strings in first column of the "" + inputFieldName + "" must be unique. found [""+ strings[0]+ ""] twice. Right before [""+ parser.getCurrentLine()+ ""] in ""+ sampleMapFile.getAbsolutePath()); } sampleMap.put(strings[0] strings[1]); } final Set<String> samplesInFpMap=fpMap.keySet().stream().map(id -> id.sample).collect(Collectors.toSet()); final Set<String> samplesNotInSampleMap=sampleMap.keySet().stream().filter(((Predicate<String>)samplesInFpMap::contains).negate()).collect(Collectors.toSet()); if (!samplesNotInSampleMap.isEmpty()) { log.warn(""Some samples in first column in the "" + inputFieldName + "" were not present as samples in fingerprinted file: [""+ String.join(""  "" samplesNotInSampleMap)+ ""].""); } final List<String> resultingSamples=new ArrayList<>(samplesInFpMap); sampleMap.keySet().forEach(s -> { if (resultingSamples.remove(s)) { resultingSamples.add(sampleMap.get(s)); } } ); if (CollectionUtil.makeSet(resultingSamples.toArray(new String[0])).size() != resultingSamples.size()) { final Set<String> duplicates=new HashSet<>(); final Set<String> unique=new HashSet<>(); resultingSamples.forEach(s -> { if (unique.add(s)) duplicates.add(s); } ); throw new IllegalArgumentException(""After applying the mapping found in the "" + inputFieldName + "" the resulting ""+ ""sample names must be unique when taken together with the remaining unmapped samples. ""+ ""Duplicates are: [""+ String.join("" "" duplicates)+ ""]  ""+ inputFieldName); } final Set<FingerprintIdDetails> ids=fpMap.keySet(); ids.forEach(id -> { if (!sampleMap.containsKey(id.sample)) return; final Fingerprint fingerprint=fpMap.remove(id); id.sample=sampleMap.get(id.sample); fpMap.put(id fingerprint); } ); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\CrosscheckFingerprints.java,writeMatrix,private void  (){ final NumberFormat format=NumberFormat.getInstance(); format.setMaximumFractionDigits(4); try (final OutputStream stream=new FileOutputStream(MATRIX_OUTPUT);final BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(stream))){ writer.write(CROSSCHECK_BY.name()); for (int col=0; col < rhsMatrixKeys.size(); col++) { writer.write('\t' + rhsMatrixKeys.get(col)); } writer.newLine(); for (int row=0; row < lhsMatrixKeys.size(); row++) { writer.write(lhsMatrixKeys.get(row)); for (int col=0; col < rhsMatrixKeys.size(); col++) { writer.write('\t' + format.format(crosscheckMatrix[col][row])); } writer.newLine(); } } catch ( IOException e) { throw new RuntimeException(e); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,HaplotypeMap,public  (final File file){ if (VcfUtils.isVariantFile(file)) { fromVcf(file); } else { fromHaplotypeDatabase(file); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,HaplotypeMapFileEntry,public  (final String chrom final int pos final String name final byte major final byte minor final double maf final String anchorSnp final List<String> fingerprintPanels){ this.chromosome=chrom; this.position=pos; this.snpName=name; this.majorAllele=major; this.minorAllele=minor; this.minorAlleleFrequency=maf; this.anchorSnp=anchorSnp; this.panels=new ArrayList<>(); if (fingerprintPanels != null) { this.panels.addAll(fingerprintPanels); Collections.sort(this.panels); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,addHaplotype,"public void  (final HaplotypeBlock haplotypeBlock){ this.haplotypeBlocks.add(haplotypeBlock); for ( final Snp snp : haplotypeBlock.getSnps()) { if (haplotypesBySnp.containsKey(snp)) { throw new IllegalStateException(""Same snp name cannot be used twice"" + snp.toString()); } this.haplotypesBySnp.put(snp haplotypeBlock); this.haplotypesBySnpName.put(snp.getName() haplotypeBlock); this.haplotypesBySnpLocus.put(toKey(snp.getChrom() snp.getPos()) haplotypeBlock); this.snpsByPosition.put(toKey(snp.getChrom() snp.getPos()) snp); this.intervals.add(new Interval(snp.getChrom() snp.getPos() snp.getPos() false snp.getName())); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,anchorFromVc,"static private String  (final VariantContext vc){ final Genotype genotype=vc.getGenotype(0); if (genotype == null || !genotype.hasExtendedAttribute(VCFConstants.PHASE_SET_KEY)) { return SYNTHETIC_PHASESET_PREFIX + ""_"" + vc.getContig()+ ""_""+ vc.getStart(); } else { return PHASESET_PREFIX + ""_"" + vc.getContig()+ ""_""+ genotype.getExtendedAttribute(VCFConstants.PHASE_SET_KEY); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,asVcf,"public Collection<VariantContext>  (final ReferenceSequenceFile ref){ final List<VariantContext> entries=new ArrayList<>(); final SortedSet<Snp> snps=new TreeSet<>(getAllSnps()); final Map<Snp Boolean> allele1MatchesReference=new HashMap<>(snps.size()); for ( final Snp snp : snps) { final ReferenceSequence seq=ref.getSubsequenceAt(snp.getChrom() snp.getPos() snp.getPos()); if (seq.getBases()[0] == snp.getAllele1()) { allele1MatchesReference.put(snp true); } else if (seq.getBases()[0] == snp.getAllele2()) { allele1MatchesReference.put(snp false); } else { throw new RuntimeException(""One of the two alleles should agree with the reference: "" + snp.toString()); } } for ( final HaplotypeBlock block : this.getHaplotypes()) { Snp anchorSnp=null; final SortedSet<Snp> blocksSnps=new TreeSet<>(block.getSnps()); for ( final Snp snp : blocksSnps) { if (anchorSnp == null) { anchorSnp=snp; } final String alleleString=snp.getAlleleString(); final boolean swap=allele1MatchesReference.get(snp); final String reference=!swap ? alleleString.substring(0 1) : alleleString.substring(1 2); final String alternate=swap ? alleleString.substring(0 1) : alleleString.substring(1 2); final double maf=!swap ? snp.getMaf() : 1 - snp.getMaf(); VariantContextBuilder builder=new VariantContextBuilder().chr(snp.getChrom()).start(snp.getPos()).stop(snp.getPos()).alleles(reference alternate).attribute(VCFConstants.ALLELE_FREQUENCY_KEY maf).id(snp.getName()); GenotypeBuilder genotypeBuilder=new GenotypeBuilder(HET_GENOTYPE_FOR_PHASING); if (blocksSnps.size() > 1 && swap) { genotypeBuilder.alleles(Arrays.asList(builder.getAlleles().get(1) builder.getAlleles().get(0))); } else { genotypeBuilder.alleles(builder.getAlleles()); } if (blocksSnps.size() > 1) { genotypeBuilder.phased(true); genotypeBuilder.attribute(VCFConstants.PHASE_SET_KEY anchorSnp.getPos()); } builder.genotypes(genotypeBuilder.make()); entries.add(builder.make()); } } return entries; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,compareTo,public int  (final Object o){ final HaplotypeMapFileEntry that=(HaplotypeMapFileEntry)o; int diff=header.getSequenceIndex(this.chromosome) - header.getSequenceIndex(that.chromosome); if (diff != 0) return diff; diff=this.position - that.position; if (diff != 0) return diff; diff=this.snpName.compareTo(that.snpName); if (diff != 0) return diff; diff=this.majorAllele - that.majorAllele; if (diff != 0) return diff; diff=this.minorAllele - that.minorAllele; if (diff != 0) return diff; diff=Double.compare(this.minorAlleleFrequency that.minorAlleleFrequency); if (diff != 0) return diff; if (this.anchorSnp != null) { if (that.anchorSnp != null) { diff=this.anchorSnp.compareTo(that.anchorSnp); } else { diff=1; } } else { if (that.anchorSnp != null) { diff=-1; } else { diff=0; } } if (diff != 0) return diff; final String p1=this.getPanels(); final String p2=that.getPanels(); if (p1 != null) { if (p2 != null) { return p1.compareTo(p2); } return 1; } else if (p2 != null) { return -1; } else { return 0; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,fromHaplotypeDatabase,"private void  (final File file){ BufferedReader in=null; try { in=new BufferedReader(new InputStreamReader(IOUtil.openFileForReading(file))); final StringBuilder builder=new StringBuilder(4096); String line=null; while ((line=in.readLine()) != null) { if (line.startsWith(""@"")) { builder.append(line).append('\n'); } else { break; } } if (builder.length() == 0) { throw new IllegalStateException(""Haplotype map file must contain header: "" + file.getAbsolutePath()); } final SAMFileHeader header=new SAMTextHeaderCodec().decode(new StringLineReader(builder.toString()) ""BufferedReader""); initialize(header); final FormatUtil format=new FormatUtil(); final List<HaplotypeMapFileEntry> entries=new ArrayList<>(); final Map<String HaplotypeBlock> anchorToHaplotype=new HashMap<>(); do { if (line.trim().isEmpty()) continue; if (line.startsWith(""#"")) continue; final String[] fields=line.split(""\\t""); if (fields.length < 6 || fields.length > 8) { throw new PicardException(""Invalid haplotype map record contains "" + fields.length + "" fields: ""+ line); } final String chrom=fields[0]; final int pos=format.parseInt(fields[1]); final String name=fields[2]; final byte major=(byte)fields[3].charAt(0); final byte minor=(byte)fields[4].charAt(0); final double maf=format.parseDouble(fields[5]); final String anchor=fields.length > 6 ? fields[6] : null; final String fpPanels=fields.length > 7 ? fields[7] : null; List<String> panels=null; if (fpPanels != null) { panels=new ArrayList<>(); for ( final String panel : fpPanels.split("" "")) { panels.add(panel); } } if (anchor == null || anchor.trim().equals("""") || name.equals(anchor)) { final HaplotypeBlock type=new HaplotypeBlock(maf); type.addSnp(new Snp(name chrom pos major minor maf panels)); anchorToHaplotype.put(name type); } else { final HaplotypeMapFileEntry entry=makeHaplotypeMapFileEntry(chrom pos name major minor maf anchor panels); entries.add(entry); } } while ((line=in.readLine()) != null); for ( final HaplotypeMapFileEntry entry : entries) { final HaplotypeBlock block=anchorToHaplotype.get(entry.anchorSnp); if (block == null) { throw new PicardException(""No haplotype found for anchor snp "" + entry.anchorSnp); } block.addSnp(new Snp(entry.snpName entry.chromosome entry.position entry.majorAllele entry.minorAllele entry.minorAlleleFrequency entry.panels)); } anchorToHaplotype.values().forEach(this::addHaplotype); } catch ( IOException ioe) { throw new PicardException(""Error parsing haplotype map."" ioe); } finally { if (in != null) { try { in.close(); } catch ( Exception e) { } } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,fromVcf,"private void  (final File file){ try (final VCFFileReader reader=new VCFFileReader(file false)){ final SAMSequenceDictionary dict=reader.getFileHeader().getSequenceDictionary(); if (dict == null || dict.getSequences().isEmpty()) { throw new IllegalStateException(""Haplotype map VCF file must contain header: "" + file.getAbsolutePath()); } initialize(new SAMFileHeader(dict)); final Map<String HaplotypeBlock> anchorToHaplotype=new HashMap<>(); for ( final VariantContext vc : reader) { if (vc.getNSamples() > 1) { throw new IllegalStateException(""Haplotype map VCF file must contain at most one sample: "" + file.getAbsolutePath()); } final Genotype gc=vc.getGenotype(0); final boolean hasGc=gc != null; if (vc.getAlternateAlleles().size() != 1) { throw new IllegalStateException(""Haplotype map VCF file must contain exactly one alternate allele per site: "" + vc.toString()); } if (!vc.isSNP()) { throw new IllegalStateException(""Haplotype map VCF file must contain only SNPs: "" + vc.toString()); } if (!vc.hasAttribute(VCFConstants.ALLELE_FREQUENCY_KEY)) { throw new IllegalStateException(""Haplotype map VCF Variants must have an '"" + VCFConstants.ALLELE_FREQUENCY_KEY + ""' INFO field: ""+ vc.toString()); } if (hasGc && gc.isPhased() && !gc.hasExtendedAttribute(VCFConstants.PHASE_SET_KEY)) { throw new IllegalStateException(""Haplotype map VCF Variants' genotypes that are phased must have a PhaseSet ("" + VCFConstants.PHASE_SET_KEY + "")""+ vc.toString()); } if (hasGc && gc.isPhased() && !gc.isHet()) { throw new IllegalStateException(""Haplotype map VCF Variants' genotypes that are phased must be HET"" + vc.toString()); } final String chrom=vc.getContig(); final int pos=vc.getStart(); final String name=vc.getID(); final byte ref=vc.getReference().getBases()[0]; final byte var=vc.getAlternateAllele(0).getBases()[0]; final double temp_maf=vc.getAttributeAsDouble(VCFConstants.ALLELE_FREQUENCY_KEY 0D); final boolean swapped=hasGc && !gc.getAllele(0).equals(vc.getReference()); final byte major  minor; final double maf; if (swapped) { major=var; minor=ref; maf=1 - temp_maf; } else { major=ref; minor=var; maf=temp_maf; } final String anchor=anchorFromVc(vc); if (!anchorToHaplotype.containsKey(anchor)) { final HaplotypeBlock newBlock=new HaplotypeBlock(maf); anchorToHaplotype.put(anchor newBlock); } final HaplotypeBlock block=anchorToHaplotype.get(anchor); block.addSnp(new Snp(name chrom pos major minor maf null)); } anchorToHaplotype.values().forEach(this::addHaplotype); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,getAllSnps,public Set<Snp>  (){ return Collections.unmodifiableSet(haplotypesBySnp.keySet()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,getHaplotype,public HaplotypeBlock  (final String chrom final int pos){ return this.haplotypesBySnpLocus.get(toKey(chrom pos)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,getHaplotypes,public List<HaplotypeBlock>  (){ return Collections.unmodifiableList(this.haplotypeBlocks); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,getHeader,public SAMFileHeader  (){ return header; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,getIntervalList,public IntervalList  (){ this.intervals=this.intervals.sorted(); return this.intervals; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,getPanels,"public String  (){ if (panels == null) return """"; final StringBuilder sb=new StringBuilder(); for ( final String panel : panels) { if (sb.length() > 0) sb.append(' '); sb.append(panel); } return sb.toString(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,getSnp,public Snp  (final String chrom final int pos){ return this.snpsByPosition.get(toKey(chrom pos)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,initialize,private void  (final SAMFileHeader header){ this.header=header; this.intervals=new IntervalList(header); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,makeHaplotypeMapFileEntry,private HaplotypeMapFileEntry  (final String chrom final int pos final String name final byte major final byte minor final double maf final String anchorSnp final List<String> fingerprintPanels){ return new HaplotypeMapFileEntry(chrom pos name major minor maf anchorSnp fingerprintPanels); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,toKey,"private String  (final String chrom final int pos){ return chrom + "":"" + pos; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,withoutChromosomes,public HaplotypeMap  (final Set<String> chroms){ final HaplotypeMap out=new HaplotypeMap(getHeader()); for ( final HaplotypeBlock block : this.haplotypeBlocks) { if (!chroms.contains(block.getFirstSnp().getChrom())) { out.addHaplotype(block); } } return out; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,writeAsVcf,"public void  (final File output final File refFile) throws FileNotFoundException { ReferenceSequenceFile ref=new IndexedFastaSequenceFile(refFile); try (VariantContextWriter writer=new VariantContextWriterBuilder().setOutputFile(output).setReferenceDictionary(ref.getSequenceDictionary()).build()){ final VCFHeader vcfHeader=new VCFHeader(VCFUtils.withUpdatedContigsAsLines(Collections.emptySet() refFile header.getSequenceDictionary() false) Collections.singleton(HET_GENOTYPE_FOR_PHASING)); VCFUtils.withUpdatedContigsAsLines(Collections.emptySet() refFile header.getSequenceDictionary() false); vcfHeader.addMetaDataLine(new VCFHeaderLine(VCFHeaderVersion.VCF4_2.getFormatString() VCFHeaderVersion.VCF4_2.getVersionString())); vcfHeader.addMetaDataLine(new VCFInfoHeaderLine(VCFConstants.ALLELE_FREQUENCY_KEY VCFHeaderLineCount.A VCFHeaderLineType.Float ""Allele Frequency  for each ALT allele  in the same order as listed"")); vcfHeader.addMetaDataLine(new VCFFormatHeaderLine(VCFConstants.GENOTYPE_KEY 1 VCFHeaderLineType.String ""Genotype"")); vcfHeader.addMetaDataLine(new VCFFormatHeaderLine(VCFConstants.PHASE_SET_KEY 1 VCFHeaderLineType.String ""Phase-set identifier for phased genotypes."")); vcfHeader.addMetaDataLine(new VCFHeaderLine(VCFHeader.SOURCE_KEY ""HaplotypeMap::writeAsVcf"")); vcfHeader.addMetaDataLine(new VCFHeaderLine(""reference"" ""HaplotypeMap::writeAsVcf"")); writer.writeHeader(vcfHeader); final LinkedList<VariantContext> variants=new LinkedList<>(this.asVcf(ref)); variants.sort(vcfHeader.getVCFRecordComparator()); variants.forEach(writer::add); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeMap.java,writeToFile,"public void  (final File file){ try { final BufferedWriter out=new BufferedWriter(new OutputStreamWriter(IOUtil.openFileForWriting(file))); final FormatUtil format=new FormatUtil(); if (this.header != null) { final SAMTextHeaderCodec codec=new SAMTextHeaderCodec(); codec.encode(out this.header); } out.write(""#CHROMOSOME\tPOSITION\tNAME\tMAJOR_ALLELE\tMINOR_ALLELE\tMAF\tANCHOR_SNP\tPANELS""); out.newLine(); final List<HaplotypeMapFileEntry> entries=new ArrayList<>(); for ( final HaplotypeBlock block : this.getHaplotypes()) { String anchor=null; final SortedSet<Snp> snps=new TreeSet<>(block.getSnps()); for ( final Snp snp : snps) { entries.add(new HaplotypeMapFileEntry(snp.getChrom() snp.getPos() snp.getName() snp.getAllele1() snp.getAllele2() snp.getMaf() anchor snp.getFingerprintPanels())); if (anchor == null) { anchor=snp.getName(); } } } Collections.sort(entries); for ( final HaplotypeMapFileEntry entry : entries) { out.write(entry.chromosome + ""\t""); out.write(format.format(entry.position) + ""\t""); out.write(entry.snpName + ""\t""); out.write((char)entry.majorAllele + ""\t""); out.write((char)entry.minorAllele + ""\t""); out.write(format.format(entry.minorAlleleFrequency) + ""\t""); if (entry.anchorSnp != null) { out.write(entry.anchorSnp); } out.write(""\t""); if (entry.getPanels() != null) { out.write(entry.getPanels()); } out.newLine(); } out.flush(); out.close(); } catch ( IOException ioe) { throw new PicardException(""Error writing out haplotype map to file: "" + file.getAbsolutePath() ioe); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromContaminatorSequence.java,HaplotypeProbabilitiesFromContaminatorSequence,public  (final HaplotypeBlock haplotypeBlock final double contamination){ super(haplotypeBlock); assert (contamination <= 1.0); assert (contamination >= 0.0); this.contamination=contamination; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromContaminatorSequence.java,addToProbs,public void  (final Snp snp final byte base final byte qual){ assertSnpPartOfHaplotype(snp); final boolean altAllele; if (base == snp.getAllele1()) { this.obsAllele1++; altAllele=false; } else if (base == snp.getAllele2()) { this.obsAllele2++; altAllele=true; } else { this.obsAlleleOther++; return; } final double pErr=QualityUtil.getErrorProbabilityFromPhredScore(qual); for ( final Genotype contGeno : Genotype.values()) { for ( final Genotype mainGeno : Genotype.values()) { final double theta=0.5 * ((1 - contamination) * mainGeno.v + contamination * contGeno.v); likelihoodMap[contGeno.v][mainGeno.v]*=((altAllele ? theta : (1 - theta)) * (1 - pErr) + (!altAllele ? theta : (1 - theta)) * pErr); } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromContaminatorSequence.java,getLogLikelihoods,@Override public double[]  (){ updateLikelihoods(); return super.getLogLikelihoods(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromContaminatorSequence.java,merge,"@Override public void  (final HaplotypeProbabilities other){ super.merge(other); if (!this.getHaplotype().equals(other.getHaplotype())) { throw new IllegalArgumentException(""Mismatched haplotypes in call to HaplotypeProbabilities.merge(): "" + getHaplotype"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromContaminatorSequence.java,updateLikelihoods,private void  (){ final double[] ll=new double[Genotype.values().length]; for ( final Genotype contGeno : Genotype.values()) { ll[contGeno.v]=log10(MathUtil.sum(MathUtil.multiply(this.getPriorProbablities() likelihoodMap[contGeno.v]))); } setLogLikelihoods(ll); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilities.java,Genotype, (final int v){ this.v=v; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilities.java,HaplotypeProbabilities,protected  (final HaplotypeBlock haplotypeBlock){ this.haplotypeBlock=haplotypeBlock; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilities.java,assertSnpPartOfHaplotype,"void  (final Snp snp){ if (!this.haplotypeBlock.contains(snp)) { throw new IllegalArgumentException(""Snp "" + snp + "" does not belong to haplotype ""+ this.haplotypeBlock); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilities.java,getHaplotype,public HaplotypeBlock  (){ return this.haplotypeBlock; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromGenotype.java,HaplotypeProbabilitiesFromGenotype,public  (final Snp snp final HaplotypeBlock haplotypeBlock final double AA final double Aa final double aa){ super(haplotypeBlock); this.snp=snp; this.likelihoods=new double[]{AA Aa aa}; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromGenotype.java,getLikelihoods,public double[]  (){ return likelihoods; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromGenotype.java,getRepresentativeSnp,@Override public Snp  (){ return snp; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromGenotype.java,merge,"@Override public void  (final HaplotypeProbabilities other){ if (!this.getHaplotype().equals(other.getHaplotype())) { throw new IllegalArgumentException(""Mismatched haplotypes in call to HaplotypeProbabilities.merge(): "" + getHaplotype() + ""  ""+ other.get"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromGenotypeLikelihoods.java,HaplotypeProbabilitiesFromGenotypeLikelihoods,public  (final HaplotypeBlock haplotypeBlock){ super(haplotypeBlock); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromGenotypeLikelihoods.java,addToLogLikelihoods,public void  (final Snp snp final List<Allele> alleles final double[] logGenotypeLikelihoods){ assertSnpPartOfHaplotype(snp); assert (logGenotypeLikelihoods.length == Genotype.values().length); assert (alleles.size() == 2); for (int i=0; i < 2; i++) { assert (alleles.get(i).getBases().length == 1); } final byte allele1=alleles.get(0).getBases()[0]; final byte allele2=alleles.get(1).getBases()[0]; if (snp.getAllele1() == allele1 && snp.getAllele2() == allele2) { setLogLikelihoods(MathUtil.sum(getLogLikelihoods() logGenotypeLikelihoods)); return; } if (snp.getAllele2() == allele1 && snp.getAllele1() == allele2) { final double[] ll=getLogLikelihoods(); ll[Genotype.HOM_ALLELE1.v]+=logGenotypeLikelihoods[Genotype.HOM_ALLELE2.v]; ll[Genotype.HET_ALLELE12.v]+=logGenotypeLikelihoods[Genotype.HET_ALLELE12.v]; ll[Genotype.HOM_ALLELE2.v]+=logGenotypeLikelihoods[Genotype.HOM_ALLELE1.v]; setLogLikelihoods(ll); return; } assert true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesUsingLogLikelihoods.java,HaplotypeProbabilitiesUsingLogLikelihoods,public  (final HaplotypeBlock haplotypeBlock){ super(haplotypeBlock); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesUsingLogLikelihoods.java,getLikelihoods,@Override public double[]  (){ updateDependentValues(); return likelihoods; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesUsingLogLikelihoods.java,getLikelihoods0,private double[]  (){ return MathUtil.pNormalizeLogProbability(getLogLikelihoods()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesUsingLogLikelihoods.java,getLodMostProbableGenotype,@Override public double  (){ final double[] logs=getShiftedLogPosterior(); double biggest=-Double.MAX_VALUE; double secondBiggest=biggest; for ( double prob : logs) { if (prob > biggest) { secondBiggest=biggest; biggest=prob; continue; } if (prob > second
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesUsingLogLikelihoods.java,getLogLikelihoods,@Override public double[]  (){ return this.loglikelihoods; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesUsingLogLikelihoods.java,getPosteriorProbabilities,public double[]  (){ updateDependentValues(); return posteriorProbabilities; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesUsingLogLikelihoods.java,getPosteriorProbabilities0,private double[]  (){ return MathUtil.pNormalizeLogProbability(getShiftedLogPosterior0()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesUsingLogLikelihoods.java,getRepresentativeSnp,@Override public Snp  (){ return getHaplotype().getFirstSnp(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesUsingLogLikelihoods.java,getShiftedLogPosterior,private double[]  (){ updateDependentValues(); return shiftedLogPosteriors; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesUsingLogLikelihoods.java,getShiftedLogPosterior0,private double[]  (){ final double[] ll=this.getLogLikelihoods(); final double[] shiftedLogPosterior=new double[Genotype.values().length]; final double[] haplotypeFrequencies=getPriorProbablities(); for ( final Genotype g : Genotype.values()) { shiftedLogPosterior[g.v]=ll[g.v] + log10(haplotypeFrequencies[g.v]); } return shiftedLogPosterior; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesUsingLogLikelihoods.java,hasEvidence,@Override public boolean  (){ final double[] ll=this.getLogLikelihoods(); return ll[Genotype.HOM_ALLELE1.v] != 0 || ll[Genotype.HET_ALLELE12.v] != 0 || ll[Genotype.HOM_ALLELE2.v] != 0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesUsingLogLikelihoods.java,merge,"@Override public void  (final HaplotypeProbabilities other){ if (!this.getHaplotype().equals(other.getHaplotype())) { throw new IllegalArgumentException(""Mismatched haplotypes in call to HaplotypeProbabilities.merge(): "" + getHaplotype() + ""  ""+ other.get"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesUsingLogLikelihoods.java,setLogLikelihoods,public void  (final double[] ll){ assert (ll.length == Genotype.values().length); System.arraycopy(ll 0 loglikelihoods 0 ll.length); likelihoodsNeedUpdating=true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesUsingLogLikelihoods.java,updateDependentValues,private void  (){ if (likelihoodsNeedUpdating) { likelihoods=getLikelihoods0(); posteriorProbabilities=getPosteriorProbabilities0(); shiftedLogPosteriors=getShiftedLogPosterior0(); likelihoodsNeedUpdating=false; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilityOfNormalGivenTumor.java,HaplotypeProbabilityOfNormalGivenTumor,public  (final HaplotypeProbabilities hpOfTumor final double pLoH){ super(hpOfTumor.getHaplotype()); transitionMatrix=transitionMatrixMap.get(pLoH).getTransitionMatrix(); this.hpOfTumor=hpOfTumor; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilityOfNormalGivenTumor.java,TransitionMatrix,public  (double pLoH){ transitionMatrix=new double[][]{{1 0 0} {pLoH / 2 1 - pLoH pLoH / 2} {0 0 1}}; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilityOfNormalGivenTumor.java,getLikelihoods,@Override public double[]  (){ final double[] normalHaplotypeLikelihoods=new double[3]; final double[] tumorHaplotypeLikelihoods=hpOfTumor.getLikelihoods(); for ( final Genotype g_n : Genotype.values()) { normalHaplotypeLikelihoods[g_n.v]=0D; for ( final 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilityOfNormalGivenTumor.java,getObsAllele1,@Override public int  (){ return hpOfTumor.getObsAllele1(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilityOfNormalGivenTumor.java,getObsAllele2,@Override public int  (){ return hpOfTumor.getObsAllele2(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilityOfNormalGivenTumor.java,getRepresentativeSnp,@Override public Snp  (){ return hpOfTumor.getRepresentativeSnp(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilityOfNormalGivenTumor.java,getTotalObs,@Override public int  (){ return hpOfTumor.getTotalObs(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilityOfNormalGivenTumor.java,getTransitionMatrix,public double[][]  (){ return transitionMatrix; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilityOfNormalGivenTumor.java,hasEvidence,@Override public boolean  (){ return hpOfTumor.hasEvidence(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilityOfNormalGivenTumor.java,merge,"@Override public void  (final HaplotypeProbabilities ignored){ throw new IllegalArgumentException(""Cannot merge HaplotypeProbabilityOfNormalGivenTumor. Merge the underlying object and create a new wrapper.""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\IdentifyContaminant.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsReadable(HAPLOTYPE_MAP); IOUtil.assertFileIsWritable(OUTPUT); IOUtil.assertFileIsReadable(REFERENCE_SEQUENCE); final FingerprintChecker checker=new FingerprintChecker(HAPL
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\IdentifyContaminant.java,getSampleToUse,"private String  (final String fpSample){ if (SAMPLE_ALIAS == null) { return String.format(""%s-%s"" fpSample EXTRACT_CONTAMINATED ? ""contaminated"" : ""contamination""); } else { return SAMPLE_ALIAS; } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\IdentifyContaminant.java,requiresReference,@Override protected boolean  (){ return true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromSequence.java,HaplotypeProbabilitiesFromSequence,public  (final HaplotypeBlock haplotypeBlock){ super(haplotypeBlock); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromSequence.java,addToProbs,public void  (final Snp snp final byte base final byte qual){ assertSnpPartOfHaplotype(snp); final double[] ll=getLogLikelihoods(); final double pError=QualityUtil.getErrorProbabilityFromPhredScore(qual); if (base == snp.getAllele1()) { obsAllele1++; for ( final Genotype g : Genotype.values()) { final double pAlt=g.v / 2d; ll[g.v]+=log10((1d - pAlt) * (1d - pError) + pAlt * pError); } } else if (base == snp.getAllele2()) { obsAllele2++; for ( final Genotype g : Genotype.values()) { final double pAlt=1 - g.v / 2d; ll[g.v]+=log10((1d - pAlt) * (1d - pError) + pAlt * pError); } } else { obsAlleleOther++; } setLogLikelihoods(ll); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromSequence.java,getFractionUnexpectedAlleleObs,public double  (){ return obsAlleleOther / (double)(getTotalObs()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromSequence.java,getObsAllele1,@Override public int  (){ return obsAllele1; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromSequence.java,getObsAllele2,@Override public int  (){ return obsAllele2; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromSequence.java,getTotalObs,@Override public int  (){ return obsAllele1 + obsAllele2 + obsAlleleOther; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromSequence.java,hasEvidence,@Override public boolean  (){ return super.hasEvidence() || obsAllele1 > 0 || obsAllele2 > 0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\HaplotypeProbabilitiesFromSequence.java,merge,"@Override public void  (final HaplotypeProbabilities other){ super.merge(other); if (!this.getHaplotype().equals(other.getHaplotype())) { throw new IllegalArgumentException(""Mismatched haplotypes in call to HaplotypeProbabilities.merge(): "" + getHaplotype"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,Snp,public  (final String name final String chrom final int pos final byte allele1 final byte allele2 final double maf final List<String> fingerprintPanels){ this.name=name; this.chrom=chrom; this.pos=pos; this.allele1=StringUtil.toUpperCase(allele1); this.allele2=StringUtil.toUpperCase(allele2); this.maf=maf; this.fingerprintPanels=fingerprintPanels == null ? new ArrayList<String>() : fingerprintPanels; this.genotypes[0]=DiploidGenotype.fromBases(allele1 allele1); this.genotypes[1]=DiploidGenotype.fromBases(allele1 allele2); this.genotypes[2]=DiploidGenotype.fromBases(allele2 allele2); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,compareTo,@Override public int  (final Snp that){ int retval=this.chrom.compareTo(that.chrom); if (retval == 0) retval=this.pos - that.pos; return retval; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,equals,@Override public boolean  (final Object o){ return (this == o) || ((o instanceof Snp) && compareTo((Snp)o) == 0); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,flip,public Snp  (){ return new Snp(name chrom pos allele2 allele1 1 - maf fingerprintPanels); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,getAllele1,public byte  (){ return allele1; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,getAllele2,public byte  (){ return allele2; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,getAlleleString,public String  (){ return StringUtil.bytesToString(new byte[]{allele1 StringUtil.toLowerCase(allele2)}); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,getChrom,public String  (){ return chrom; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,getFingerprintPanels,public List<String>  (){ return this.fingerprintPanels; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,getGenotype,DiploidGenotype  (final DiploidHaplotype haplotype){ return this.genotypes[haplotype.ordinal()]; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,getHeterogyzousGenotype,public DiploidGenotype  (){ return this.genotypes[1]; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,getHomozygousAllele1Genotype,public DiploidGenotype  (){ return this.genotypes[0]; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,getHomozygousAllele2Genotype,public DiploidGenotype  (){ return this.genotypes[2]; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,getMaf,public double  (){ return maf; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,getName,public String  (){ return name; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,getPos,public int  (){ return pos; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,hashCode,@Override public int  (){ int result=chrom.hashCode(); result=31 * result + pos; return result; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,indexOf,"int  (final DiploidGenotype gt){ for (int i=0; i < this.genotypes.length; ++i) { if (gt == this.genotypes[i]) return i; } throw new IllegalArgumentException(""Genotype "" + gt + "" is not valid for this SNP.""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\Snp.java,toString,"@Override public String  (){ return this.chrom + "":"" + this.pos; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\BasecallsConverter.java,BasecallsConverter, (final Map<String ? extends ConvertedClusterDataWriter<CLUSTER_OUTPUT_RECORD>> barcodeRecordWriterMap final int maxReadsInRamPerTile final List<File> tmpDirs final SortingCollection.Codec<CLUSTER_OUTPUT_RECORD> codecPrototype final boolean ignoreUnexpectedBarcodes final boolean demultiplex final Comparator<CLUSTER_OUTPUT_RECORD> outputRecordComparator final BclQualityEvaluationStrategy bclQualityEvaluationStrategy final Class<CLUSTER_OUTPUT_RECORD> outputRecordClass final int numProcessors final IlluminaDataProviderFactory factory){ this.barcodeRecordWriterMap=barcodeRecordWriterMap; this.maxReadsInRamPerTile=maxReadsInRamPerTile; this.tmpDirs=tmpDirs; this.codecPrototype=codecPrototype; this.ignoreUnexpectedBarcodes=ignoreUnexpectedBarcodes; this.demultiplex=demultiplex; this.outputRecordComparator=outputRecordComparator; this.bclQualityEvaluationStrategy=bclQualityEvaluationStrategy; this.outputRecordClass=outputRecordClass; this.factory=factory; if (numProcessors == 0) { this.numThreads=Runtime.getRuntime().availableProcessors(); } else if (numProcessors < 0) { this.numThreads=Runtime.getRuntime().availableProcessors() + numProcessors; } else { this.numThreads=numProcessors; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\MatchResults.java,MatchResults, (final Path fingerprintFile final String sample final double sampleLikelihood final double populationLikelihood final double lodTN final double lodNT final Collection<LocusResult> locusResults){ this.fingerprintFile=fingerprintFile; this.sample=sample; this.sampleLikelihood=sampleLikelihood; this.populationLikelihood=populationLikelihood; this.LOD=sampleLikelihood - populationLikelihood; this.lodTN=lodTN; this.lodNT=lodNT; if (locusResults != null) { this.locusResults=new TreeSet<>(locusResults); } else { this.locusResults=null; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\MatchResults.java,compareTo,@Override public int  (MatchResults that){ if (this.LOD != that.LOD) { return this.LOD > that.LOD ? -1 : 1; } else { return this.sample.compareTo(that.sample); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\MatchResults.java,getFingerprintFile,public Path  (){ return this.fingerprintFile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\MatchResults.java,getLOD,public double  (){ return LOD; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\MatchResults.java,getLocusResults,public SortedSet<LocusResult>  (){ return locusResults; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\MatchResults.java,getLodNT,public double  (){ return lodNT; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\MatchResults.java,getLodTN,public double  (){ return lodTN; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\MatchResults.java,getPopulationLikelihood,public double  (){ return populationLikelihood; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\MatchResults.java,getSample,public String  (){ return sample; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\MatchResults.java,getSampleLikelihood,public double  (){ return sampleLikelihood; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\LocusResult.java,LocusResult, (final Snp snp final DiploidGenotype expectedGenotype final DiploidGenotype mostLikelyGenotype final int allele1Count final int allele2Count final double lodGenotype final double lExpectedSample final double lRandomSample final double lodGenotypeTumorNormal final double lodGenotypeNormalTumor){ this.snp=snp; this.expectedGenotype=expectedGenotype; this.mostLikelyGenotype=mostLikelyGenotype; this.allele1Count=allele1Count; this.allele2Count=allele2Count; this.lodGenotype=lodGenotype; this.lExpectedSample=lExpectedSample; this.lRandomSample=lRandomSample; this.lodExpectedSampleTumorNormal=lodGenotypeTumorNormal; this.lodExpectedSampleNormalTumor=lodGenotypeNormalTumor; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\LocusResult.java,compareTo,@Override public int  (final LocusResult that){ return this.snp.compareTo(that.snp); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\LocusResult.java,getAllele1Count,public int  (){ return allele1Count; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\LocusResult.java,getAllele2Count,public int  (){ return allele2Count; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\LocusResult.java,getExpectedGenotype,public DiploidGenotype  (){ return expectedGenotype; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\LocusResult.java,getLodExpectedSampleNormalTumor,public double  (){ return lodExpectedSampleNormalTumor; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\LocusResult.java,getLodExpectedSampleTumorNormal,public double  (){ return lodExpectedSampleTumorNormal; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\LocusResult.java,getLodGenotype,public double  (){ return lodGenotype; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\LocusResult.java,getMostLikelyGenotype,public DiploidGenotype  (){ return mostLikelyGenotype; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\LocusResult.java,getSnp,public Snp  (){ return snp; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\LocusResult.java,lExpectedSample,public double  (){ return lExpectedSample; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\fingerprint\LocusResult.java,lRandomSample,public double  (){ return lRandomSample; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CheckIlluminaDirectory.java,createLocFileSymlinks,"private void  (final IlluminaFileUtil fileUtil final int lane){ final File baseFile=new File(BASECALLS_DIR.getParentFile().getAbsolutePath() + File.separator + AbstractIlluminaPositionFileReader.S_LOCS_FILE); final File newFileBase=new File(baseFile.getParent() + File.separator + IlluminaFileUtil.longLaneStr(lane)+ File.separator); if (baseFile.exists()) { boolean success=true; if (!newFileBase.exists()) { success=newFileBase.mkdirs(); } if (success) { for ( final Integer tile : fileUtil.getExpectedTiles()) { final String newName=newFileBase + File.separator + String.format(""s_%d_%d.locs"" lane tile); final ProcessExecutor.ExitStatusAndOutput output=ProcessExecutor.executeAndReturnInterleavedOutput(new String[]{""ln"" ""-fs"" baseFile.getAbsolutePath() newName}); if (output.exitStatus != 0) { throw new PicardException(""Could not create symlink: "" + output.stdout); } } } else { throw new PicardException(String.format(""Could not create lane directory: %s."" newFileBase.getAbsolutePath())); } } else { throw new PicardException(String.format(""Locations file %s does not exist."" baseFile.getAbsolutePath())); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CheckIlluminaDirectory.java,customCommandLineValidation,"@Override protected String[]  (){ IOUtil.assertDirectoryIsReadable(BASECALLS_DIR); final List<String> errors=new ArrayList<>(); for ( final Integer lane : LANES) { if (lane < 1) { errors.add(""LANES must be greater than or equal to 1. LANES passed in "" + S"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CheckIlluminaDirectory.java,doWork,@Override protected int  (){ final ReadStructure readStructure=new ReadStructure(READ_STRUCTURE); if (DATA_TYPES.isEmpty()) { DATA_TYPES.addAll(Arrays.asList(IlluminaBasecallsConverter.DATA_TYPES_NO_BARCODE)); } final List<Integer> failingLanes=new ArrayL
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CheckIlluminaDirectory.java,main,public static void  (final String[] argv){ new CheckIlluminaDirectory().instanceMainWithExit(argv); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CheckIlluminaDirectory.java,verifyLane,"private static int  (final IlluminaFileUtil fileUtil final List<Integer> expectedTiles final int[] cycles final Set<IlluminaDataType> dataTypes final boolean fakeFiles){ if (expectedTiles.isEmpty()) { throw new PicardException(""0 input tiles were specified! Check to make sure this lane is in the InterOp file!""); } if (cycles.length == 0) { throw new PicardException(""0 output cycles were specified!""); } int numFailures=0; final Map<IlluminaFileUtil.SupportedIlluminaFormat Set<IlluminaDataType>> formatToDataTypes=IlluminaDataProviderFactory.determineFormats(dataTypes fileUtil); final Set<IlluminaDataType> unmatchedDataTypes=IlluminaDataProviderFactory.findUnmatchedTypes(dataTypes formatToDataTypes); if (!unmatchedDataTypes.isEmpty()) { if (fakeFiles) { for ( final IlluminaDataType dataType : unmatchedDataTypes) { final IlluminaFileUtil.SupportedIlluminaFormat format=IlluminaDataProviderFactory.findPreferredFormat(dataType fileUtil); fileUtil.getUtil(format).fakeFiles(expectedTiles cycles format); } } log.info(""Could not find a format with available files for the following data types: "" + StringUtil.join(""  "" new ArrayList<>(unmatchedDataTypes))); numFailures+=unmatchedDataTypes.size(); } for ( final IlluminaFileUtil.SupportedIlluminaFormat format : formatToDataTypes.keySet()) { final ParameterizedFileUtil util=fileUtil.getUtil(format); util.setTilesForPerRunFile(expectedTiles); final List<String> failures=util.verify(expectedTiles cycles); if (!failures.isEmpty() && fakeFiles) { util.fakeFiles(expectedTiles cycles format); } numFailures+=failures.size(); for ( final String failure : failures) { log.info(failure); } } return numFailures; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CollectIlluminaLaneMetrics.java,calculateLaneDensityFromTiles,private static double  (final Collection<Tile> tiles){ double area=0; double clusters=0; for ( final Tile tile : tiles) { if (tile.getClusterDensity() > 0) area+=(tile.getClusterCount() / tile.getClusterDensity()); clusters+=tile.getClusterCount(); } return (area > 0) ? clusters / area : 0.0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CollectIlluminaLaneMetrics.java,collectLaneMetrics,public static void  (final File runDirectory final File outputDirectory final String outputPrefix final MetricsFile<MetricBase Comparable<?>> laneMetricsFile final MetricsFile<MetricBase Comparable<?>> phasingMetricsFile final ReadStructure readStructure final String fileExtension final ValidationStringency validationStringency final boolean isNovaSeq){ final Map<Integer ? extends Collection<Tile>> laneTiles=readLaneTiles(runDirectory readStructure validationStringency isNovaSeq); writeLaneMetrics(laneTiles outputDirectory outputPrefix laneMetricsFile fileExtension); writePhasingMetrics(laneTiles outputDirectory outputPrefix phasingMetricsFile fileExtension isNovaSeq); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CollectIlluminaLaneMetrics.java,doWork,@Override protected int  (){ final MetricsFile<MetricBase Comparable<?>> laneMetricsFile=this.getMetricsFile(); final MetricsFile<MetricBase Comparable<?>> phasingMetricsFile=this.getMetricsFile(); if (READ_STRUCTURE == null) { final File runInfo=new File
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CollectIlluminaLaneMetrics.java,main,public static void  (final String[] args){ new CollectIlluminaLaneMetrics().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CollectIlluminaLaneMetrics.java,readLaneTiles,"public static Map<Integer ? extends Collection<Tile>>  (final File illuminaRunDirectory final ReadStructure readStructure final ValidationStringency validationStringency final boolean isNovaSeq){ final Collection<Tile> tiles; try { File tileMetricsOutFile=TileMetricsUtil.renderTileMetricsFileFromBasecallingDirectory(illuminaRunDirectory readStructure.totalCycles isNovaSeq); if (isNovaSeq) { tiles=TileMetricsUtil.parseTileMetrics(tileMetricsOutFile TileMetricsUtil.renderPhasingMetricsFilesFromBasecallingDirectory(illuminaRunDirectory) readStructure validationStringency); } else { tiles=TileMetricsUtil.parseTileMetrics(tileMetricsOutFile readStructure validationStringency); } } catch ( final FileNotFoundException e) { throw new PicardException(""Unable to open laneMetrics file."" e); } return tiles.stream().filter(tile -> tile.getLaneNumber() > 0).collect(Collectors.groupingBy(Tile::getLaneNumber)); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CollectIlluminaLaneMetrics.java,writeLaneMetrics,public static File  (final Map<Integer ? extends Collection<Tile>> laneTiles final File outputDirectory final String outputPrefix final MetricsFile<MetricBase Comparable<?>> laneMetricsFile final String fileExtension){ laneTiles.entrySet().forEach(entry -> { final IlluminaLaneMetrics laneMetric=new IlluminaLaneMetrics(); laneMetric.LANE=entry.getKey().longValue(); laneMetric.CLUSTER_DENSITY=calculateLaneDensityFromTiles(entry.getValue()); laneMetricsFile.addMetric(laneMetric); } ); return writeMetrics(laneMetricsFile outputDirectory outputPrefix IlluminaLaneMetrics.getExtension() + fileExtension); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CollectIlluminaLaneMetrics.java,writeMetrics,"private static File  (final MetricsFile<MetricBase Comparable<?>> metricsFile final File outputDirectory final String outputPrefix final String outputExtension){ final File outputFile=new File(outputDirectory String.format(""%s.%s"" outputPrefix outputExtension)); LOG.info(String.format(""Writing %s lane metrics to %s ..."" metricsFile.getMetrics().size() outputFile)); metricsFile.write(outputFile); return outputFile; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CollectIlluminaLaneMetrics.java,writePhasingMetrics,public static File  (final Map<Integer ? extends Collection<Tile>> laneTiles final File outputDirectory final String outputPrefix final MetricsFile<MetricBase Comparable<?>> phasingMetricsFile final String fileExtension final boolean isNovaSeq){ laneTiles.forEach((key value) -> IlluminaPhasingMetrics.getPhasingMetricsForTiles(key.longValue() value !isNovaSeq).forEach(phasingMetricsFile::addMetric)); return writeMetrics(phasingMetricsFile outputDirectory outputPrefix IlluminaPhasingMetrics.getExtension() + fileExtension); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CustomAdapterPair.java,CustomAdapterPair, (final String fivePrime final String threePrime){ this.threePrime=threePrime; this.threePrimeBytes=StringUtil.stringToBytes(threePrime); this.fivePrime=fivePrime; this.fivePrimeReadOrder=SequenceUtil.reverseComplement(fivePrime); this.fivePrimeBytes=StringUtil.stringToBytes(fivePrime); this.fivePrimeReadOrderBytes=StringUtil.stringToBytes(fivePrimeReadOrder); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CustomAdapterPair.java,get3PrimeAdapter,public String  (){ return threePrime; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CustomAdapterPair.java,get3PrimeAdapterBytes,public byte[]  (){ return threePrimeBytes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CustomAdapterPair.java,get3PrimeAdapterBytesInReadOrder,public byte[]  (){ return threePrimeBytes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CustomAdapterPair.java,get3PrimeAdapterInReadOrder,public String  (){ return threePrime; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CustomAdapterPair.java,get5PrimeAdapter,public String  (){ return fivePrime; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CustomAdapterPair.java,get5PrimeAdapterBytes,public byte[]  (){ return fivePrimeBytes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CustomAdapterPair.java,get5PrimeAdapterBytesInReadOrder,public byte[]  (){ return fivePrimeReadOrderBytes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CustomAdapterPair.java,get5PrimeAdapterInReadOrder,public String  (){ return fivePrimeReadOrder; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CustomAdapterPair.java,getName,"public String  (){ return ""Custom adapter pair""; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ClusterDataToSamConverter.java,ClusterDataToSamConverter,public  (final String runBarcode final String readGroupId final ReadStructure readStructure final List<AdapterPair> adapters){ this.readGroupId=readGroupId; this.readNameEncoder=new IlluminaReadNameEncoder(runBarcode); this.isPairedEnd=readStructure.templates.length() == 2; this.hasSampleBarcode=!readStructure.sampleBarcodes.isEmpty(); this.hasMolecularBarcode=!readStructure.molecularBarcode.isEmpty(); if (adapters.isEmpty()) { this.adapterMarker=null; } else { this.adapterMarker=new AdapterMarker(adapters.toArray(new AdapterPair[adapters.size()])); } this.templateIndices=readStructure.templates.getIndices(); this.sampleBarcodeIndices=readStructure.sampleBarcodes.getIndices(); this.molecularBarcodeIndices=readStructure.molecularBarcode.getIndices(); this.outputRecordsPerCluster=readStructure.templates.length(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ClusterDataToSamConverter.java,convertClusterToOutputRecord,public IlluminaBasecallsToSam.SAMRecordsForCluster  (final ClusterData cluster){ final IlluminaBasecallsToSam.SAMRecordsForCluster ret=new IlluminaBasecallsToSam.SAMRecordsForCluster(outputRecordsPerCluster); final String readName=readNameEncoder.generateReadName(cluster null); String unmatchedBarcode=null; if (hasSampleBarcode && cluster.getMatchedBarcode() == null) { final byte[][] barcode=new byte[sampleBarcodeIndices.length][]; for (int i=0; i < sampleBarcodeIndices.length; i++) { barcode[i]=cluster.getRead(sampleBarcodeIndices[i]).getBases(); } unmatchedBarcode=IlluminaUtil.barcodeSeqsToString(barcode).replace('.' 'N'); } final List<String> molecularIndexes; final List<String> molecularIndexQualities; if (hasMolecularBarcode) { molecularIndexes=new ArrayList<>(); molecularIndexQualities=new ArrayList<>(); for (int i=0; i < molecularBarcodeIndices.length; i++) { molecularIndexes.add(new String(cluster.getRead(molecularBarcodeIndices[i]).getBases()).replace('.' 'N')); molecularIndexQualities.add(SAMUtils.phredToFastq(cluster.getRead(molecularBarcodeIndices[i]).getQualities())); } } else { molecularIndexes=Collections.emptyList(); molecularIndexQualities=Collections.emptyList(); } final SAMRecord firstOfPair=createSamRecord(cluster.getRead(templateIndices[0]) readName cluster.isPf() true unmatchedBarcode molecularIndexes molecularIndexQualities); ret.records[0]=firstOfPair; SAMRecord secondOfPair=null; if (isPairedEnd) { secondOfPair=createSamRecord(cluster.getRead(templateIndices[1]) readName cluster.isPf() false unmatchedBarcode molecularIndexes molecularIndexQualities); ret.records[1]=secondOfPair; } if (adapterMarker != null) { if (isPairedEnd) { adapterMarker.adapterTrimIlluminaPairedReads(firstOfPair secondOfPair); } else { adapterMarker.adapterTrimIlluminaSingleRead(firstOfPair); } } return ret; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ClusterDataToSamConverter.java,createSamRecord,"private SAMRecord  (final ReadData readData final String readName final boolean isPf final boolean firstOfPair final String unmatchedBarcode final List<String> molecularIndexes final List<String> molecularIndexQualities){ final SAMRecord sam=new SAMRecord(null); sam.setReadName(readName); sam.setReadBases(readData.getBases()); sam.setBaseQualities(readData.getQualities()); sam.setReadPairedFlag(isPairedEnd); sam.setReadUnmappedFlag(true); sam.setReadFailsVendorQualityCheckFlag(!isPf); if (isPairedEnd) { sam.setMateUnmappedFlag(true); sam.setFirstOfPairFlag(firstOfPair); sam.setSecondOfPairFlag(!firstOfPair); } if (filters.filterOut(sam)) { sam.setAttribute(ReservedTagConstants.XN 1); } if (this.readGroupId != null) { sam.setAttribute(SAMTag.RG.name() readGroupId); } if (unmatchedBarcode != null) { sam.setAttribute(SAMTag.BC.name() unmatchedBarcode); } if (!molecularIndexes.isEmpty()) { if (!this.molecularIndexTag.isEmpty()) { sam.setAttribute(this.molecularIndexTag String.join(molecularIndexDelimiter molecularIndexes)); } if (!this.molecularIndexQualityTag.isEmpty()) { sam.setAttribute(this.molecularIndexQualityTag String.join(molecularIndexDelimiter molecularIndexQualities)); } if (!this.tagPerMolecularIndex.isEmpty()) { if (tagPerMolecularIndex.size() != molecularIndexes.size()) { throw new PicardException(""Found "" + molecularIndexes.size() + "" molecular indexes but only ""+ tagPerMolecularIndex.size()+ "" SAM tags given.""); } for (int i=0; i < this.tagPerMolecularIndex.size(); i++) { sam.setAttribute(this.tagPerMolecularIndex.get(i) molecularIndexes.get(i)); } } } return sam; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ClusterDataToSamConverter.java,withMolecularIndexQualityTag,"public ClusterDataToSamConverter  (final String molecularIndexQualityTag){ if (molecularIndexQualityTag == null) throw new IllegalArgumentException(""Molecular index quality tag was null""); this.molecularIndexQualityTag=molecularIndexQualityTag; return this; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ClusterDataToSamConverter.java,withMolecularIndexTag,"public ClusterDataToSamConverter  (final String molecularIndexTag){ if (molecularIndexTag == null) throw new IllegalArgumentException(""Molecular index tag was null""); this.molecularIndexTag=molecularIndexTag; return this; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ClusterDataToSamConverter.java,withTagPerMolecularIndex,"public ClusterDataToSamConverter  (final List<String> tagPerMolecularIndex){ if (tagPerMolecularIndex == null) throw new IllegalArgumentException(""Null given for tagPerMolecularIndex""); this.tagPerMolecularIndex=tagPerMolecularIndex; return this; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallingMetrics.java,toString,"@Override public String  (){ return String.format(""IlluminaBasecallingMetric(Lane:%s Barcode:%s Name:%s MEAN_CLUSTERS_PER_TILE:%s SD_CLUSTERS_PER_TILE:%s "" + ""MEAN_PCT_PF_CLUSTERS_PER_TILE:%s SD_PCT_PF_CLUSTERS_STD_PER_TILE:%s "" + ""MEAN_PF_CLUSTERS_PER_TI"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CollectIlluminaBasecallingMetrics.java,CollectIlluminaBasecallingMetrics,public  (){ this.barcodeToMetricCounts=new TreeMap<>(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CollectIlluminaBasecallingMetrics.java,IlluminaMetricCounts,public  (final String barcode final String barcodeName final Integer laneNumber){ this.tileToClusterHistogram=new Histogram<>(); this.tileToPfClusterHistogram=new Histogram<>(); this.metrics=new IlluminaBasecallingMetrics(); this.metrics.MOLECULAR_BARCODE_SEQUENCE_1=barcode; this.metrics.MOLECULAR_BARCODE_NAME=barcodeName; this.metrics.LANE=Integer.toString(laneNumber); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CollectIlluminaBasecallingMetrics.java,addCluster,private void  (final ClusterData cluster){ String barcode=cluster.getMatchedBarcode(); if (barcode == null) barcode=unmatchedBarcode; IlluminaMetricCounts counters=barcodeToMetricCounts.get(barcode); if (counters == null) { counters=new IlluminaMetricCounts(barcode null LANE); barcodeToMetricCounts.put(barcode counters); } final int tileNumber=cluster.getTile(); counters.incrementClusterCount(tileNumber cluster.isPf()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CollectIlluminaBasecallingMetrics.java,addIlluminaMetricCounts,public void  (final IlluminaMetricCounts counts){ this.tileToClusterHistogram.addHistogram(counts.tileToClusterHistogram); this.tileToPfClusterHistogram.addHistogram(counts.tileToPfClusterHistogram); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CollectIlluminaBasecallingMetrics.java,addMetricsToFile,public void  (final MetricsFile<IlluminaBasecallingMetrics Comparable<?>> file){ onComplete(); file.addMetric(metrics); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CollectIlluminaBasecallingMetrics.java,doWork,"@Override protected int  (){ IOUtil.assertDirectoryIsReadable(BASECALLS_DIR); if (OUTPUT == null) OUTPUT=new File(BASECALLS_DIR String.format(""LANE%s_basecalling_metrics"" LANE)); IOUtil.assertFileIsWritable(OUTPUT); final IlluminaDataProviderFactory facto"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CollectIlluminaBasecallingMetrics.java,incrementClusterCount,public void  (final Integer tileNumber final double incrementAmount final double pfIncrementAmount){ tileToClusterHistogram.increment(tileNumber incrementAmount); tileToPfClusterHistogram.increment(tileNumber pfIncrementAmount); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CollectIlluminaBasecallingMetrics.java,main,public static void  (final String[] argv){ new CollectIlluminaBasecallingMetrics().instanceMainWithExit(argv); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CollectIlluminaBasecallingMetrics.java,onComplete,"private void  (){ final double meanClustersPerTile=tileToClusterHistogram.getMeanBinSize(); metrics.MEAN_CLUSTERS_PER_TILE=Math.round(meanClustersPerTile); metrics.SD_CLUSTERS_PER_TILE=Math.round(tileToClusterHistogram.getStandardDeviationBinSize(meanClustersPerTile)); final double meanPfClustersPerTile=tileToPfClusterHistogram.getMeanBinSize(); metrics.MEAN_PF_CLUSTERS_PER_TILE=Math.round(meanPfClustersPerTile); metrics.SD_PF_CLUSTERS_PER_TILE=Math.round(tileToPfClusterHistogram.getStandardDeviationBinSize(meanPfClustersPerTile)); final DecimalFormat decFormat=new DecimalFormat(""#.##""); final Histogram<Integer> laneToPctPfClusterHistogram=tileToPfClusterHistogram.divideByHistogram(tileToClusterHistogram); final double meanPctPfClustersPerTile=laneToPctPfClusterHistogram.getMeanBinSize(); metrics.MEAN_PCT_PF_CLUSTERS_PER_TILE=(Double.isNaN(meanPctPfClustersPerTile) ? 0 : Double.valueOf(decFormat.format(meanPctPfClustersPerTile * 100))); metrics.SD_PCT_PF_CLUSTERS_PER_TILE=Double.valueOf(decFormat.format(laneToPctPfClusterHistogram.getStandardDeviationBinSize(meanPctPfClustersPerTile) * 100)); metrics.TOTAL_CLUSTERS=(long)this.tileToClusterHistogram.getSumOfValues(); metrics.PF_CLUSTERS=(long)this.tileToPfClusterHistogram.getSumOfValues(); final ReadStructure readStructure=new ReadStructure(READ_STRUCTURE); int templateBaseCountPerCluster=0; for (int i=0; i < readStructure.templates.length(); i++) { templateBaseCountPerCluster+=readStructure.templates.get(i).length; } metrics.TOTAL_READS=metrics.TOTAL_CLUSTERS * readStructure.templates.length(); metrics.PF_READS=metrics.PF_CLUSTERS * readStructure.templates.length(); metrics.TOTAL_BASES=metrics.TOTAL_CLUSTERS * templateBaseCountPerCluster; metrics.PF_BASES=metrics.PF_CLUSTERS * templateBaseCountPerCluster; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\CollectIlluminaBasecallingMetrics.java,setupNewDataProvider,"private void  (final IlluminaDataProviderFactory factory){ if (BARCODES_DIR == null) BARCODES_DIR=BASECALLS_DIR; final File laneDir=new File(BASECALLS_DIR IlluminaFileUtil.longLaneStr(LANE)); final File[] cycleDirs=IOUtil.getFilesMatchingRegexp(laneDir IlluminaFileUtil.CYCLE_SUBDIRECTORY_PATTERN); final List<File> cbcls=Arrays.stream(cycleDirs).flatMap(cycleDir -> Arrays.stream(IOUtil.getFilesMatchingRegexp(cycleDir ""^"" + IlluminaFileUtil.longLaneStr(LANE) + ""_(\\d{1 5}).cbcl$""))).collect(Collectors.toList()); if (cbcls.size() == 0) { throw new PicardException(""No CBCL files found.""); } IOUtil.assertFilesAreReadable(cbcls); final List<AbstractIlluminaPositionFileReader.PositionInfo> locs=new ArrayList<>(); final File locsFile=new File(BASECALLS_DIR.getParentFile() AbstractIlluminaPositionFileReader.S_LOCS_FILE); IOUtil.assertFileIsReadable(locsFile); try (LocsFileReader locsFileReader=new LocsFileReader(locsFile)){ while (locsFileReader.hasNext()) { locs.add(locsFileReader.next()); } } final Pattern laneTileRegex=Pattern.compile(ParameterizedFileUtil.escapePeriods(ParameterizedFileUtil.makeLaneTileRegex("".filter"" LANE))); final File[] filterFiles=NewIlluminaBasecallsConverter.getTiledFiles(laneDir laneTileRegex); IOUtil.assertFilesAreReadable(Arrays.asList(filterFiles)); final Pattern barcodeRegex=Pattern.compile(ParameterizedFileUtil.escapePeriods(ParameterizedFileUtil.makeBarcodeRegex(LANE))); final Map<Integer File> barcodesFiles=new HashMap<>(); for ( final File barcodeFile : NewIlluminaBasecallsConverter.getTiledFiles(BARCODES_DIR barcodeRegex)) { final Matcher tileMatcher=barcodeRegex.matcher(barcodeFile.getName()); if (tileMatcher.matches()) { IOUtil.assertFileIsReadable(barcodeFile); barcodesFiles.put(Integer.valueOf(tileMatcher.group(1)) barcodeFile); } } factory.getAvailableTiles().forEach(tile -> { final File barcodeFile=barcodesFiles.get(tile); final BaseIlluminaDataProvider provider=factory.makeDataProvider(cbcls locs filterFiles tile barcodeFile); while (provider.hasNext()) { addCluster(provider.next()); } } ); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,IlluminaBasecallsConverter,"public  (final File basecallsDir final File barcodesDir final int lane final ReadStructure readStructure final Map<String ? extends ConvertedClusterDataWriter<CLUSTER_OUTPUT_RECORD>> barcodeRecordWriterMap final boolean demultiplex final int maxReadsInRamPerTile final List<File> tmpDirs final int numProcessors final boolean forceGc final Integer firstTile final Integer tileLimit final Comparator<CLUSTER_OUTPUT_RECORD> outputRecordComparator final SortingCollection.Codec<CLUSTER_OUTPUT_RECORD> codecPrototype final Class<CLUSTER_OUTPUT_RECORD> outputRecordClass final BclQualityEvaluationStrategy bclQualityEvaluationStrategy final boolean applyEamssFiltering final boolean includeNonPfReads final boolean ignoreUnexpectedBarcodes){ super(barcodeRecordWriterMap maxReadsInRamPerTile tmpDirs codecPrototype ignoreUnexpectedBarcodes demultiplex outputRecordComparator bclQualityEvaluationStrategy outputRecordClass numProcessors new IlluminaDataProviderFactory(basecallsDir barcodesDir lane readStructure bclQualityEvaluationStrategy getDataTypesFromReadStructure(readStructure demultiplex))); this.includeNonPfReads=includeNonPfReads; this.tiles=factory.getAvailableTiles(); tiles.sort(TILE_NUMBER_COMPARATOR); setTileLimits(firstTile tileLimit); this.numThreads=Math.max(1 Math.min(this.numThreads tiles.size())); if (forceGc) { final Timer gcTimer=new Timer(true); final long delay=5 * 1000 * 60; gcTimerTask=new TimerTask(){ @Override public void run(){ log.info(""Before explicit GC  Runtime.totalMemory()="" + Runtime.getRuntime().totalMemory()); System.gc(); System.runFinalization(); log.info(""After explicit GC  Runtime.totalMemory()="" + Runtime.getRuntime().totalMemory()); } } ; gcTimer.scheduleAtFixedRate(gcTimerTask delay delay); } else { gcTimerTask=null; } this.factory.setApplyEamssFiltering(applyEamssFiltering); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,PriorityRunnable,public  (final int priority){ this.priority=priority; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,Tile,public  (final int i){ tileNumber=i; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,TileReadAggregator,public  (final Collection<Tile> tiles){ for ( final Tile t : tiles) { tileRecords.put(t new TileProcessingRecord()); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,TileReader,public  (final Tile tile final TileReadAggregator handler final TileProcessingRecord processingRecord){ this.tile=tile; this.handler=handler; this.processingRecord=processingRecord; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,addRecord,"public synchronized void  (final String barcode final CLUSTER_OUTPUT_RECORD record){ this.recordCount+=1; SortingCollection<CLUSTER_OUTPUT_RECORD> recordCollection=this.barcodeToRecordCollection.get(barcode); if (recordCollection == null) { if (!barcodeRecordWriterMap.containsKey(barcode)) { if (ignoreUnexpectedBarcodes) { return; } throw new PicardException(String.format(""Read records with barcode %s  but this barcode was not expected. (Is it referenced in the parameters file?)"" barcode)); } recordCollection=this.newSortingCollection(); this.barcodeToRecordCollection.put(barcode recordCollection); this.barcodeToProcessingState.put(barcode null); } recordCollection.add(record); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,BarcodeMetric,public  (){ barcodeBytes=null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,ExtractIlluminaBarcodes,public  (){ tileNumberFormatter.setMinimumIntegerDigits(4); tileNumberFormatter.setGroupingUsed(false); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,awaitWorkComplete,public void  () throws InterruptedException { synchronized (this.completionLatch) { this.completionLatch.wait(); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,compareTo,@Override public int  (final Tile o){ return TILE_NUMBER_COMPARATOR.compare(this.getNumber() o.getNumber()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,PerTileBarcodeExtractor,public  (final int tile final File barcodeFile final Map<String BarcodeMetric> barcodeToMetrics final BarcodeMetric noMatchMetric final IlluminaDataProviderFactory factory final int minimumBaseQuality final int maxNoCalls final int maxMismatches final int minMismatchDelta){ this.tile=tile; this.barcodeFile=barcodeFile; this.usingQualityScores=minimumBaseQuality > 0; this.maxNoCalls=maxNoCalls; this.maxMismatches=maxMismatches; this.minMismatchDelta=minMismatchDelta; this.minimumBaseQuality=minimumBaseQuality; this.metrics=new LinkedHashMap<>(barcodeToMetrics.size()); for ( final String key : barcodeToMetrics.keySet()) { this.metrics.put(key BarcodeMetric.copy(barcodeToMetrics.get(key))); } this.noMatch=BarcodeMetric.copy(noMatchMetric); this.provider=factory.makeDataProvider(Arrays.asList(tile)); this.outputReadStructure=factory.getOutputReadStructure(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,completeTile,"private void  (final Tile tile){ final TileProcessingRecord tileRecord=this.tileRecords.get(tile); if (tileRecord.getState() == TileProcessingState.DONE_READING) { throw new IllegalStateException(""This tile is already in the completed state.""); } for ( final String barcode : tileRecord.getBarcodes()) { tileRecord.setBarcodeState(barcode TileBarcodeProcessingState.READ); tileRecord.barcodeToRecordCollection.get(barcode).doneAdding(); } tileRecord.setState(TileProcessingState.DONE_READING); log.debug(String.format(""Completed reading tile %s; collected %s reads spanning %s barcodes."" tile.getNumber() tileRecord.getRecordCount() tileRecord.getBarcodeCount())); this.findAndEnqueueWorkOrSignalCompletion(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,copy,public static BarcodeMetric  (final BarcodeMetric metric){ final BarcodeMetric result=new BarcodeMetric(); result.BARCODE=metric.BARCODE; result.BARCODE_WITHOUT_DELIMITER=metric.BARCODE_WITHOUT_DELIMITER; result.BARCODE_NAME=metric.BARCODE_NAME; result.LIBRARY_NAME=metric.LIBRARY_NAME; result.barcodeBytes=metric.barcodeBytes; return result; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,countMismatches,private static int  (final byte[][] barcodeBytes final byte[][] readSubsequence final byte[][] qualities final int minimumBaseQuality){ int numMismatches=0; for (int j=0; j < barcodeBytes.length; j++) { for (int i=0; (i < barcodeBytes[j].length && readSubsequence[j].length > i); ++i) { if (SequenceUtil.isNoCall(readSubsequence[j][i])) { continue; } if (!SequenceUtil.basesEqual(barcodeBytes[j][i] readSubsequence[j][i])) { ++numMismatches; continue; } if (qualities != null && qualities[j][i] < minimumBaseQuality) { ++numMismatches; } } } return numMismatches; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,doTileProcessing,@Override public void  (){ try { final List<Tile> tiles=new ArrayList<>(); for ( final Integer tileNumber : this.tiles) { tiles.add(new Tile(tileNumber)); } final TileReadAggregator tileReadAggregator=new TileReadAggregator(tiles); tileReadAggregator.subm
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,equals,@Override public boolean  (final Object o){ return o instanceof Tile && this.getNumber() == ((Tile)o).getNumber(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,findAndEnqueueWorkOrSignalCompletion,"private void  (){ synchronized (this.workEnqueueMonitor) { if (this.isWorkCompleted()) { this.signalWorkComplete(); } else { final Queue<Runnable> tasks=new LinkedList<>(); for ( final String barcode : barcodeRecordWriterMap.keySet()) { NEXT_BARCODE: for ( final Map.Entry<Tile TileProcessingRecord> entry : this.tileRecords.entrySet()) { final Tile tile=entry.getKey(); final TileProcessingRecord tileRecord=entry.getValue(); if (tileRecord.getState() != TileProcessingState.DONE_READING) { break; } switch (tileRecord.getBarcodeState(barcode)) { case NA: case WRITTEN: continue; case QUEUED_FOR_WRITE: break NEXT_BARCODE; case READ: tileRecord.setBarcodeState(barcode TileBarcodeProcessingState.QUEUED_FOR_WRITE); log.debug(String.format(""Enqueuing work for tile %s and barcode %s."" tile.getNumber() barcode)); tasks.add(this.newBarcodeWorkInstance(tile tileRecord barcode)); break NEXT_BARCODE; } } } for (final Runnable task : tasks) { this.prioritizingThreadPool.execute(task); } } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,getBarcodeCount,public synchronized long  (){ return this.barcodeToRecordCollection.size(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,customCommandLineValidation,"@Override protected String[]  (){ final ArrayList<String> messages=new ArrayList<>(); this.bclQualityEvaluationStrategy=new BclQualityEvaluationStrategy(MINIMUM_QUALITY); readStructure=new ReadStructure(READ_STRUCTURE.replaceAll(""T|M"" ""S"")); final Illumin"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,getBarcodeProcessingStates,public synchronized Map<String TileBarcodeProcessingState>  (){ return this.barcodeToProcessingState; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,getBarcodeRecords,public synchronized Map<String SortingCollection<CLUSTER_OUTPUT_RECORD>>  (){ return barcodeToRecordCollection; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,getBarcodeState,"public synchronized TileBarcodeProcessingState  (final String barcode){ if (this.getState() == TileProcessingState.NOT_DONE_READING) { throw new IllegalStateException(""A tile's barcode data's state cannot be queried until the tile has been completely read.""); } return this.barcodeToProcessingState.getOrDefault(barcode TileBarcodeProcessingState.NA); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,getBarcodes,public synchronized Set<String>  (){ return this.getBarcodeRecords().keySet(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,getDataTypesFromReadStructure,private static IlluminaDataType[]  (final ReadStructure readStructure final boolean demultiplex){ if (readStructure.sampleBarcodes.isEmpty() || !demultiplex) { return DATA_TYPES_NO_BARCODE; } else { return DATA_TYPES_WITH_BARCODE; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,getNumber,public int  (){ return tileNumber; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,getPriority,int  (){ return this.priority; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,getRecordCount,public synchronized long  (){ return recordCount; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,getState,public synchronized TileProcessingState  (){ return this.state; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,isWorkCompleted,"public boolean  (){ for ( final Map.Entry<Tile TileProcessingRecord> entry : this.tileRecords.entrySet()) { final TileProcessingRecord tileProcessingRecord=entry.getValue(); if (tileProcessingRecord.getState() != TileProcessingState.DONE_READING) { log.debug(String.format(""Work is not completed because a tile isn't done being read: %s."" entry.getKey().getNumber())); return false; } else { for ( final Map.Entry<String TileBarcodeProcessingState> barcodeStateEntry : tileProcessingRecord.getBarcodeProcessingStates().entrySet()) { final TileBarcodeProcessingState barcodeProcessingState=barcodeStateEntry.getValue(); if (barcodeProcessingState != TileBarcodeProcessingState.WRITTEN) { log.debug(String.format(""Work is not completed because a tile isn't done being read: Tile %s  Barcode %s  Processing State %s."" entry.getKey().getNumber() barcodeStateEntry.getKey() barcodeProcessingState)); return false; } } } } log.info(""All work is complete.""); return true; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,doWork,@Override protected int  (){ IOUtil.assertFileIsWritable(METRICS_FILE); if (OUTPUT_DIR == null) { OUTPUT_DIR=BASECALLS_DIR; } IOUtil.assertDirectoryIsWritable(OUTPUT_DIR); final String[] noMatchBarcode=new String[readStructure.sampleBarcodes.length()]; in
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,newBarcodeWorkInstance,"private PriorityRunnable  (final Tile tile final TileProcessingRecord tileRecord final String barcode){ return new PriorityRunnable(){ @Override public void run(){ try { final SortingCollection<CLUSTER_OUTPUT_RECORD> records=tileRecord.getBarcodeRecords().get(barcode); final ConvertedClusterDataWriter<CLUSTER_OUTPUT_RECORD> writer=barcodeRecordWriterMap.get(barcode); log.debug(String.format(""Writing records from tile %s with barcode %s ..."" tile.getNumber() barcode)); final PeekIterator<CLUSTER_OUTPUT_RECORD> it=new PeekIterator<>(records.iterator()); while (it.hasNext()) { final CLUSTER_OUTPUT_RECORD rec=it.next(); if (it.hasNext()) { final CLUSTER_OUTPUT_RECORD lookAhead=it.peek(); if (outputRecordComparator.compare(rec lookAhead) == 0) { it.next(); log.info(""Skipping reads with identical read names: "" + rec.toString()); continue; } } writer.write(rec); writeProgressLogger.record(null 0); } tileRecord.setBarcodeState(barcode TileBarcodeProcessingState.WRITTEN); findAndEnqueueWorkOrSignalCompletion(); } catch ( final RuntimeException|Error e) { parentThread.interrupt(); throw e; } } } ; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,newSortingCollection,private synchronized SortingCollection<CLUSTER_OUTPUT_RECORD>  (){ final int maxRecordsInRam=Math.max(1 maxReadsInRamPerTile / barcodeRecordWriterMap.size()); return SortingCollection.newInstance(outputRecordClass codecPrototype.clone() outputRecordComparator maxRecordsInRam tmpDirs); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,process,"public void  (){ final BaseIlluminaDataProvider dataProvider=factory.makeDataProvider(Collections.singletonList(this.tile.getNumber())); log.debug(String.format(""Reading data from tile %s ..."" tile.getNumber())); while (dataProvider.hasNext()) { final ClusterData cluster=dataProvider.next(); readProgressLogger.record(null 0); if (cluster.isPf() || includeNonPfReads) { final String barcode=(demultiplex ? cluster.getMatchedBarcode() : null); this.processingRecord.addRecord(barcode converter.convertClusterToOutputRecord(cluster)); } } this.handler.completeTile(this.tile); dataProvider.close(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,finalizeMetrics,public static void  (final Map<String BarcodeMetric> barcodeToMetrics final BarcodeMetric noMatchMetric){ int totalReads=noMatchMetric.READS; int totalPfReads=noMatchMetric.PF_READS; int totalPfReadsAssigned=0; for ( final BarcodeMetric barcodeMetric : barcodeToMetrics.values()) { totalReads+=barcodeMetric.READS; totalPfReads+=barcodeMetric.PF_READS; totalPfReadsAssigned+=barcodeMetric.PF_READS; } if (totalReads > 0) { noMatchMetric.PCT_MATCHES=noMatchMetric.READS / (double)totalReads; double bestPctOfAllBarcodeMatches=0; for ( final BarcodeMetric barcodeMetric : barcodeToMetrics.values()) { barcodeMetric.PCT_MATCHES=barcodeMetric.READS / (double)totalReads; if (barcodeMetric.PCT_MATCHES > bestPctOfAllBarcodeMatches) { bestPctOfAllBarcodeMatches=barcodeMetric.PCT_MATCHES; } } if (bestPctOfAllBarcodeMatches > 0) { noMatchMetric.RATIO_THIS_BARCODE_TO_BEST_BARCODE_PCT=noMatchMetric.PCT_MATCHES / bestPctOfAllBarcodeMatches; for ( final BarcodeMetric barcodeMetric : barcodeToMetrics.values()) { barcodeMetric.RATIO_THIS_BARCODE_TO_BEST_BARCODE_PCT=barcodeMetric.PCT_MATCHES / bestPctOfAllBarcodeMatches; } } } if (totalPfReads > 0) { noMatchMetric.PF_PCT_MATCHES=noMatchMetric.PF_READS / (double)totalPfReads; double bestPctOfAllBarcodeMatches=0; for ( final BarcodeMetric barcodeMetric : barcodeToMetrics.values()) { barcodeMetric.PF_PCT_MATCHES=barcodeMetric.PF_READS / (double)totalPfReads; if (barcodeMetric.PF_PCT_MATCHES > bestPctOfAllBarcodeMatches) { bestPctOfAllBarcodeMatches=barcodeMetric.PF_PCT_MATCHES; } } if (bestPctOfAllBarcodeMatches > 0) { noMatchMetric.PF_RATIO_THIS_BARCODE_TO_BEST_BARCODE_PCT=noMatchMetric.PF_PCT_MATCHES / bestPctOfAllBarcodeMatches; for ( final BarcodeMetric barcodeMetric : barcodeToMetrics.values()) { barcodeMetric.PF_RATIO_THIS_BARCODE_TO_BEST_BARCODE_PCT=barcodeMetric.PF_PCT_MATCHES / bestPctOfAllBarcodeMatches; } } } if (totalPfReadsAssigned > 0) { final double mean=(double)totalPfReadsAssigned / (double)barcodeToMetrics.values().size(); for ( final BarcodeMetric m : barcodeToMetrics.values()) { m.PF_NORMALIZED_MATCHES=m.PF_READS / mean; } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,run,@Override public void  (){ try { final SortingCollection<CLUSTER_OUTPUT_RECORD> records=tileRecord.getBarcodeRecords().get(barcode); final ConvertedClusterDataWriter<CLUSTER_OUTPUT_RECORD> writer=barcodeRecordWriterMap.get(barcode); log.debug(String.forma
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,setBarcodeState,"public synchronized void  (final String barcode final TileBarcodeProcessingState state){ if (this.barcodeToProcessingState.containsKey(barcode)) { this.barcodeToProcessingState.put(barcode state); } else { throw new NoSuchElementException(String.format(""No record of the provided barcode  %s."" barcode)); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,setState,public synchronized void  (final TileProcessingState state){ this.state=state; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,shutdown,public void  (){ this.prioritizingThreadPool.shutdownNow(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,signalWorkComplete,private void  (){ synchronized (this.completionLatch) { this.completionLatch.notifyAll(); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsConverter.java,submit,"public void  (){ if (!this.submitted.compareAndSet(false true)) { throw new IllegalStateException(""The submit() method may not be called more than once.""); } this.parentThread=Thread.currentThread(); int priority=0; for ( final Tile tile : this.tileRecords.keySet()) { final TileReader reader=new TileReader(tile this this.tileRecords.get(tile)); this.prioritizingThreadPool.execute(new PriorityRunnable(--priority){ @Override public void run(){ try { reader.process(); } catch ( final RuntimeException|Error e) { parentThread.interrupt(); throw e; } } } ); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,findBestBarcodeAndUpdateMetrics,"public static BarcodeMatch  (final byte[][] readSubsequences final byte[][] qualityScores final boolean passingFilter final Map<String BarcodeMetric> metrics final BarcodeMetric noMatchBarcodeMetric final int maxNoCalls final int maxMismatches final int minMismatchDelta final int minimumBaseQuality){ BarcodeMetric bestBarcodeMetric=null; int totalBarcodeReadBases=0; int numNoCalls=0; for ( final byte[] bc : readSubsequences) { totalBarcodeReadBases+=bc.length; for ( final byte b : bc) if (SequenceUtil.isNoCall(b)) ++numNoCalls; } int numMismatchesInBestBarcode=totalBarcodeReadBases + 1; int numMismatchesInSecondBestBarcode=totalBarcodeReadBases + 1; for ( final BarcodeMetric barcodeMetric : metrics.values()) { final int numMismatches=countMismatches(barcodeMetric.barcodeBytes readSubsequences qualityScores minimumBaseQuality); if (numMismatches < numMismatchesInBestBarcode) { if (bestBarcodeMetric != null) { numMismatchesInSecondBestBarcode=numMismatchesInBestBarcode; } numMismatchesInBestBarcode=numMismatches; bestBarcodeMetric=barcodeMetric; } else if (numMismatches < numMismatchesInSecondBestBarcode) { numMismatchesInSecondBestBarcode=numMismatches; } } final boolean matched=bestBarcodeMetric != null && numNoCalls <= maxNoCalls && numMismatchesInBestBarcode <= maxMismatches && numMismatchesInSecondBestBarcode - numMismatchesInBestBarcode >= minMismatchDelta; final BarcodeMatch match=new BarcodeMatch(); if (numNoCalls + numMismatchesInBestBarcode < totalBarcodeReadBases && bestBarcodeMetric != null) { match.mismatches=numMismatchesInBestBarcode; match.mismatchesToSecondBest=numMismatchesInSecondBestBarcode; match.barcode=bestBarcodeMetric.BARCODE_WITHOUT_DELIMITER.toLowerCase(); } else { match.mismatches=totalBarcodeReadBases; match.barcode=""""; } if (matched) { ++bestBarcodeMetric.READS; if (passingFilter) { ++bestBarcodeMetric.PF_READS; } if (numMismatchesInBestBarcode == 0) { ++bestBarcodeMetric.PERFECT_MATCHES; if (passingFilter) { ++bestBarcodeMetric.PF_PERFECT_MATCHES; } } else if (numMismatchesInBestBarcode == 1) { ++bestBarcodeMetric.ONE_MISMATCH_MATCHES; if (passingFilter) { ++bestBarcodeMetric.PF_ONE_MISMATCH_MATCHES; } } match.matched=true; match.barcode=bestBarcodeMetric.BARCODE_WITHOUT_DELIMITER; } else { ++noMatchBarcodeMetric.READS; if (passingFilter) { ++noMatchBarcodeMetric.PF_READS; } } return match; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,getBarcode,public String  (){ return barcode; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,getBarcodeFile,"private File  (final int tile){ return new File(OUTPUT_DIR ""s_"" + LANE + ""_""+ tileNumberFormatter.format(tile)+ ""_barcode.txt""+ (COMPRESS_OUTPUTS ? "".gz"" : """")); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,getException,public synchronized Exception  (){ return this.exception; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,getMetrics,public synchronized Map<String BarcodeMetric>  (){ return this.metrics; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,getNoMatchMetric,public synchronized BarcodeMetric  (){ return this.noMatch; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,isMatched,public boolean  (){ return matched; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,main,public static void  (final String[] argv){ new ExtractIlluminaBarcodes().instanceMainWithExit(argv); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,merge,public void  (final BarcodeMetric metric){ this.READS+=metric.READS; this.PF_READS+=metric.PF_READS; this.PERFECT_MATCHES+=metric.PERFECT_MATCHES; this.PF_PERFECT_MATCHES+=metric.PF_PERFECT_MATCHES; this.ONE_MISMATCH_MATCHES+=metric.ONE_MISMATCH_MATCHES; this.PF_ONE_MISMATCH_MATCHES+=metric.PF_ONE_MISMATCH_MATCHES; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,parseBarcodeFile,"private void  (final ArrayList<String> messages){ final TabbedTextFileWithHeaderParser barcodesParser=new TabbedTextFileWithHeaderParser(BARCODE_FILE); final String sequenceColumn=barcodesParser.hasColumn(BARCODE_SEQUENCE_COLUMN) ? BARCODE_SEQUENCE_COLUMN : barcodesParser.hasColumn(BARCODE_SEQUENCE_1_COLUMN) ? BARCODE_SEQUENCE_1_COLUMN : null; if (sequenceColumn == null) { messages.add(BARCODE_FILE + "" does not have "" + BARCODE_SEQUENCE_COLUMN+ "" or ""+ BARCODE_SEQUENCE_1_COLUMN+ "" column header""); return; } final boolean hasBarcodeName=barcodesParser.hasColumn(BARCODE_NAME_COLUMN); final boolean hasLibraryName=barcodesParser.hasColumn(LIBRARY_NAME_COLUMN); final int numBarcodes=readStructure.sampleBarcodes.length(); final Set<String> barcodes=new HashSet<>(); for ( final TabbedTextFileWithHeaderParser.Row row : barcodesParser) { final String[] bcStrings=new String[numBarcodes]; int barcodeNum=1; for ( final ReadDescriptor rd : readStructure.descriptors) { if (rd.type != ReadType.Barcode) continue; final String header=barcodeNum == 1 ? sequenceColumn : ""barcode_sequence_"" + String.valueOf(barcodeNum); bcStrings[barcodeNum - 1]=row.getField(header); barcodeNum++; } final String bcStr=IlluminaUtil.barcodeSeqsToString(bcStrings); if (barcodes.contains(bcStr)) { messages.add(""Barcode "" + bcStr + "" specified more than once in ""+ BARCODE_FILE); } barcodes.add(bcStr); final String barcodeName=(hasBarcodeName ? row.getField(BARCODE_NAME_COLUMN) : """"); final String libraryName=(hasLibraryName ? row.getField(LIBRARY_NAME_COLUMN) : """"); final BarcodeMetric metric=new BarcodeMetric(barcodeName libraryName bcStr bcStrings); barcodeToMetrics.put(StringUtil.join("""" bcStrings) metric); } barcodesParser.close(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\ExtractIlluminaBarcodes.java,run,"synchronized public void  (){ try { if (this.provider == null) { this.provider=factory.makeDataProvider(cbcls locs filterFiles tile null); } LOG.info(""Extracting barcodes for tile "" + tile); final int[] barcodeIndices=outputReadStructure.sampleBarcodes.getIndices(); final BufferedWriter writer=IOUtil.openFileForBufferedWriting(barcodeFile); final byte[][] barcodeSubsequences=new byte[barcodeIndices.length][]; final byte[][] qualityScores=usingQualityScores ? new byte[barcodeIndices.length][] : null; while (provider.hasNext()) { final ClusterData cluster=provider.next(); for (int i=0; i < barcodeIndices.length; i++) { barcodeSubsequences[i]=cluster.getRead(barcodeIndices[i]).getBases(); if (usingQualityScores) qualityScores[i]=cluster.getRead(barcodeIndices[i]).getQualities(); } final boolean passingFilter=cluster.isPf(); final BarcodeMatch match=findBestBarcodeAndUpdateMetrics(barcodeSubsequences qualityScores passingFilter metrics noMatch maxNoCalls maxMismatches minMismatchDelta minimumBaseQuality); final String yOrN=(match.matched ? ""Y"" : ""N""); for ( final byte[] bc : barcodeSubsequences) { writer.write(StringUtil.bytesToString(bc)); } writer.write(""\t"" + yOrN + ""\t""+ match.barcode+ ""\t""+ String.valueOf(match.mismatches)+ ""\t""+ String.valueOf(match.mismatchesToSecondBest)); writer.newLine(); } writer.close(); } catch ( final Exception e) { LOG.error(e ""Error processing tile "" this.tile); this.exception=e; } finally { CloserUtil.close(provider); provider=null; } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,Codec, (final int numRecords){ this(numRecords new BAMRecordCodec(null)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,SAMFileWriterWrapper,private  (final SAMFileWriter writer){ this.writer=writer; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,SAMRecordsForCluster, (final int numRecords){ records=new SAMRecord[numRecords]; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,buildSamFileWriter,private SAMFileWriterWrapper  (final File output final String sampleAlias final String libraryName final Map<String String> headerParameters final boolean presorted){ IOUtil.assertFileIsWritable(output); final SAMReadGroupRecord rg=new SAMReadGroupRecord(READ_GROUP_ID); rg.setSample(sampleAlias); if (libraryName != null) rg.setLibrary(libraryName); for ( final Map.Entry<String String> tagNameToValue : headerParameters.entrySet()) { if (tagNameToValue.getValue() != null) { rg.setAttribute(tagNameToValue.getKey() tagNameToValue.getValue()); } } final SAMFileHeader header=new SAMFileHeader(); header.setSortOrder(SAMFileHeader.SortOrder.queryname); header.addReadGroup(rg); return new SAMFileWriterWrapper(new SAMFileWriterFactory().makeSAMOrBAMWriter(header presorted output)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,buildSamHeaderParameters,"private Map<String String>  (final List<String> barcodes){ final Map<String String> params=new LinkedHashMap<>(); String platformUnit=RUN_BARCODE + ""."" + LANE; if (barcodes != null) platformUnit+=(""."" + IlluminaUtil.barcodeSeqsToString(barcodes)); params.put(""PL"" PLATFORM); params.put(""PU"" platformUnit); params.put(""CN"" SEQUENCING_CENTER); params.put(""DT"" RUN_START_DATE == null ? null : new Iso8601Date(RUN_START_DATE).toString()); return params; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,checkRgTagColumns,"private void  (final Set<String> rgTagColumns){ final Set<String> forbiddenHeaders=buildSamHeaderParameters(null).keySet(); forbiddenHeaders.retainAll(rgTagColumns); if (!forbiddenHeaders.isEmpty()) { throw new PicardException(""Illegal ReadGroup tags in library params(barcode params) file("" + LIBRARY_PARAMS.getAbsolutePath() + "") Offending headers = ""+ StringUtil.join(""  "" forbiddenHeaders)); } for ( final String column : rgTagColumns) { if (column.length() > 2) { throw new PicardException(""Column label ("" + column + "") unrecognized. Library params(barcode params) can only contain the columns ""+ ""(OUTPUT  LIBRARY_NAME  SAMPLE_ALIAS  BARCODE  BARCODE_<X> where X is a positive integer) OR two letter RG tags!""); } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,clone,@Override public SortingCollection.Codec<SAMRecordsForCluster>  (){ return new Codec(numRecords bamCodec.clone()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,close,@Override public void  (){ writer.close(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,compare,@Override public int  (final SAMRecordsForCluster s1 final SAMRecordsForCluster s2){ return comparator.compare(s1.records[0] s2.records[0]); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,customCommandLineValidation,@Override protected String[]  (){ if (BARCODE_PARAMS != null) { LIBRARY_PARAMS=BARCODE_PARAMS; } final ArrayList<String> messages=new ArrayList<>(); readStructure=new ReadStructure(READ_STRUCTURE); if (!readStructure.sampleBarcodes.isEmpty() && LIBRARY_PA
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,decode,@Override public SAMRecordsForCluster  (){ final SAMRecord zerothRecord=bamCodec.decode(); if (zerothRecord == null) return null; final SAMRecordsForCluster ret=new SAMRecordsForCluster(numRecords); ret.records[0]=zerothRecord; for (int i=1; i < numRecord
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,doWork,@Override protected int  (){ initialize(); basecallsConverter.doTileProcessing(); return 0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,encode,"@Override public void  (final SAMRecordsForCluster val){ if (val.records.length != numRecords) { throw new IllegalStateException(String.format(""Expected number of clusters %d != actual %d"" numRecords val.records.length)); } for ( final SAMRecord rec : val"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,findAndFilterExpectedColumns,"private Set<String>  (final Set<String> actualCols final Set<String> expectedCols){ final Set<String> missingColumns=new HashSet<>(expectedCols); missingColumns.removeAll(actualCols); if (!missingColumns.isEmpty()) { throw new PicardException(String.format(""LIBRARY_PARAMS file %s is missing the following columns: %s."" LIBRARY_PARAMS.getAbsolutePath() StringUtil.join(""  "" missingColumns))); } final Set<String> remainingColumns=new HashSet<>(actualCols); remainingColumns.removeAll(expectedCols); return remainingColumns; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,initialize,"private void  (){ final BclQualityEvaluationStrategy bclQualityEvaluationStrategy=new BclQualityEvaluationStrategy(MINIMUM_QUALITY); if (OUTPUT != null) { IOUtil.assertFileIsWritable(OUTPUT); } if (LIBRARY_PARAMS != null) { IOUtil.assertFileIsReadable(LIBRARY_PARAMS); } if (OUTPUT != null) { barcodeSamWriterMap.put(null buildSamFileWriter(OUTPUT SAMPLE_ALIAS LIBRARY_NAME buildSamHeaderParameters(null) true)); } else { populateWritersFromLibraryParams(); } final int numOutputRecords=readStructure.templates.length(); final List<AdapterPair> adapters=new ArrayList<>(ADAPTERS_TO_CHECK); if (FIVE_PRIME_ADAPTER != null && THREE_PRIME_ADAPTER != null) { adapters.add(new CustomAdapterPair(FIVE_PRIME_ADAPTER THREE_PRIME_ADAPTER)); } if (IlluminaFileUtil.hasCbcls(BASECALLS_DIR LANE)) { if (BARCODES_DIR == null) BARCODES_DIR=BASECALLS_DIR; basecallsConverter=new NewIlluminaBasecallsConverter<>(BASECALLS_DIR BARCODES_DIR LANE readStructure barcodeSamWriterMap true Math.max(1 MAX_READS_IN_RAM_PER_TILE / numOutputRecords) TMP_DIR NUM_PROCESSORS FIRST_TILE TILE_LIMIT new QueryNameComparator() new Codec(numOutputRecords) SAMRecordsForCluster.class bclQualityEvaluationStrategy IGNORE_UNEXPECTED_BARCODES); } else { basecallsConverter=new IlluminaBasecallsConverter<>(BASECALLS_DIR BARCODES_DIR LANE readStructure barcodeSamWriterMap true MAX_READS_IN_RAM_PER_TILE / numOutputRecords TMP_DIR NUM_PROCESSORS FORCE_GC FIRST_TILE TILE_LIMIT new QueryNameComparator() new Codec(numOutputRecords) SAMRecordsForCluster.class bclQualityEvaluationStrategy APPLY_EAMSS_FILTER INCLUDE_NON_PF_READS IGNORE_UNEXPECTED_BARCODES); } final ClusterDataToSamConverter converter=new ClusterDataToSamConverter(RUN_BARCODE READ_GROUP_ID basecallsConverter.getFactory().getOutputReadStructure() adapters).withMolecularIndexTag(MOLECULAR_INDEX_TAG).withMolecularIndexQualityTag(MOLECULAR_INDEX_BASE_QUALITY_TAG).withTagPerMolecularIndex(TAG_PER_MOLECULAR_INDEX); basecallsConverter.setConverter(converter); log.info(""DONE_READING STRUCTURE IS "" + readStructure.toString()); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,main,public static void  (final String[] args){ System.exit(new IlluminaBasecallsToSam().instanceMain(args)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,populateWritersFromLibraryParams,"private void  (){ final TabbedTextFileWithHeaderParser libraryParamsParser=new TabbedTextFileWithHeaderParser(LIBRARY_PARAMS); final Set<String> expectedColumnLabels=CollectionUtil.makeSet(""OUTPUT"" ""SAMPLE_ALIAS"" ""LIBRARY_NAME""); final List<String> barcodeColumnLabels=new ArrayList<>(); if (readStructure.sampleBarcodes.length() == 1) { if (libraryParamsParser.hasColumn(""BARCODE"")) { barcodeColumnLabels.add(""BARCODE""); } else if (libraryParamsParser.hasColumn(""BARCODE_1"")) { barcodeColumnLabels.add(""BARCODE_1""); } else { throw new PicardException(""LIBRARY_PARAMS(BARCODE_PARAMS) file "" + LIBRARY_PARAMS + "" does not have column BARCODE or BARCODE_1.""); } } else { for (int i=1; i <= readStructure.sampleBarcodes.length(); i++) { barcodeColumnLabels.add(""BARCODE_"" + i); } } expectedColumnLabels.addAll(barcodeColumnLabels); final Set<String> rgTagColumns=findAndFilterExpectedColumns(libraryParamsParser.columnLabels() expectedColumnLabels); checkRgTagColumns(rgTagColumns); for ( final TabbedTextFileWithHeaderParser.Row row : libraryParamsParser) { List<String> barcodeValues=null; if (!barcodeColumnLabels.isEmpty()) { barcodeValues=new ArrayList<>(); for ( final String barcodeLabel : barcodeColumnLabels) { barcodeValues.add(row.getField(barcodeLabel)); } } final String key=(barcodeValues == null || barcodeValues.contains(""N"")) ? null : StringUtil.join("""" barcodeValues); if (barcodeSamWriterMap.containsKey(key)) { throw new PicardException(""Row for barcode "" + key + "" appears more than once in LIBRARY_PARAMS or BARCODE_PARAMS file ""+ LIBRARY_PARAMS); } final Map<String String> samHeaderParams=buildSamHeaderParameters(barcodeValues); for ( final String tagName : rgTagColumns) { samHeaderParams.put(tagName row.getField(tagName)); } File outputFile=new File(row.getField(""OUTPUT"")); if (PROCESS_SINGLE_TILE != null) { outputFile=new File(outputFile.getParentFile() PROCESS_SINGLE_TILE + ""."" + outputFile.getName()); } final SAMFileWriterWrapper writer=buildSamFileWriter(outputFile row.getField(""SAMPLE_ALIAS"") row.getField(""LIBRARY_NAME"") samHeaderParams true); barcodeSamWriterMap.put(key writer); } if (barcodeSamWriterMap.isEmpty()) { throw new PicardException(""LIBRARY_PARAMS(BARCODE_PARAMS) file "" + LIBRARY_PARAMS + "" does have any data rows.""); } libraryParamsParser.close(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,setInputStream,@Override public void  (final InputStream is){ bamCodec.setInputStream(is); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,setOutputStream,@Override public void  (final OutputStream os){ bamCodec.setOutputStream(os); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToSam.java,write,@Override public void  (final SAMRecordsForCluster records){ for ( final SAMRecord rec : records.records) { writer.addAlignment(rec); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,ClusterToFastqRecordsForClusterConverter, (final ReadStructure outputReadStructure){ this.templateIndices=outputReadStructure.templates.getIndices(); this.sampleBarcodeIndicies=outputReadStructure.sampleBarcodes.getIndices(); this.molecularBarcodeIndicies=outputReadStructure.molecularBarcode.getIndices(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,FastqRecordsForCluster, (final int numTemplates final int numSampleBarcodes final int numMolecularBarcodes){ templateRecords=new FastqRecord[numTemplates]; sampleBarcodeRecords=new FastqRecord[numSampleBarcodes]; molecularBarcodeRecords=new FastqRecord[numMolecularBarcodes]; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,FastqRecordsForClusterCodec, (final int numTemplates final int numSampleBarcodes final int numMolecularBarcodes){ this.numTemplates=numTemplates; this.numSampleBarcodes=numSampleBarcodes; this.numMolecularBarcodes=numMolecularBarcodes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,FastqRecordsWriter,private  (final FastqWriter[] templateWriters final FastqWriter[] sampleBarcodeWriters final FastqWriter[] molecularBarcodeWriters){ this.templateWriters=templateWriters; this.sampleBarcodeWriters=sampleBarcodeWriters; this.molecularBarcodeWriters=molecularBarcodeWriters; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,assertExpectedColumns,"private void  (final Set<String> actualCols final Set<String> expectedCols){ final Set<String> missingColumns=new HashSet<>(expectedCols); missingColumns.removeAll(actualCols); if (!missingColumns.isEmpty()) { throw new PicardException(String.format(""MULTIPLEX_PARAMS file %s is missing the following columns: %s."" MULTIPLEX_PARAMS.getAbsolutePath() StringUtil.join(""  "" missingColumns))); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,buildWriter,"private FastqRecordsWriter  (final File outputPrefix){ final File outputDir=outputPrefix.getAbsoluteFile().getParentFile(); IOUtil.assertDirectoryIsWritable(outputDir); final String prefixString=outputPrefix.getName(); final String suffixString=COMPRESS_OUTPUTS ? ""fastq.gz"" : ""fastq""; final FastqWriter[] templateWriters=new FastqWriter[readStructure.templates.length()]; final FastqWriter[] sampleBarcodeWriters=new FastqWriter[readStructure.sampleBarcodes.length()]; final FastqWriter[] molecularBarcodeWriters=new FastqWriter[readStructure.molecularBarcode.length()]; for (int i=0; i < templateWriters.length; ++i) { final String filename=String.format(""%s.%d.%s"" prefixString i + 1 suffixString); templateWriters[i]=fastqWriterFactory.newWriter(new File(outputDir filename)); } for (int i=0; i < sampleBarcodeWriters.length; ++i) { final String filename=String.format(""%s.barcode_%d.%s"" prefixString i + 1 suffixString); sampleBarcodeWriters[i]=fastqWriterFactory.newWriter(new File(outputDir filename)); } for (int i=0; i < molecularBarcodeWriters.length; ++i) { final String filename=String.format(""%s.index_%d.%s"" prefixString i + 1 suffixString); molecularBarcodeWriters[i]=fastqWriterFactory.newWriter(new File(outputDir filename)); } return new FastqRecordsWriter(templateWriters sampleBarcodeWriters molecularBarcodeWriters); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,clone,@Override public SortingCollection.Codec<FastqRecordsForCluster>  (){ return new FastqRecordsForClusterCodec(numTemplates numSampleBarcodes numMolecularBarcodes); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,close,@Override public void  (){ for ( final FastqWriter writer : templateWriters) { writer.close(); } for ( final FastqWriter writer : sampleBarcodeWriters) { writer.close(); } for ( final FastqWriter writer : molecularBarcodeWriters) { writer.close(); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,convertClusterToOutputRecord,@Override public FastqRecordsForCluster  (final ClusterData cluster){ final FastqRecordsForCluster ret=new FastqRecordsForCluster(readStructure.templates.length() readStructure.sampleBarcodes.length() readStructure.molecularBarcode.length()); final boolea
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,customCommandLineValidation,"@Override protected String[]  (){ final LinkedList<String> errors=new LinkedList<>(); if (READ_NAME_FORMAT == ReadNameFormat.CASAVA_1_8 && MACHINE_NAME == null) { errors.add(""MACHINE_NAME is required when using Casava1.8-style read name headers.""); } if ("
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,decode,@Override public FastqRecordsForCluster  (){ if (!reader.hasNext()) return null; final FastqRecordsForCluster ret=new FastqRecordsForCluster(numTemplates numSampleBarcodes numMolecularBarcodes); decodeArray(ret.templateRecords); decodeArray(ret.sampleBarc
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,decodeArray,private void  (final FastqRecord[] recs){ for (int i=0; i < recs.length; ++i) { recs[i]=reader.next(); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,doWork,@Override protected int  (){ initialize(); basecallsConverter.doTileProcessing(); return 0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,encode,@Override public void  (final FastqRecordsForCluster val){ if (numTemplates != val.templateRecords.length) throw new IllegalStateException(); if (numSampleBarcodes != val.sampleBarcodeRecords.length) throw new IllegalStateException(); encodeArray(val.temp
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,encodeArray,private void  (final FastqRecord[] recs){ for ( final FastqRecord rec : recs) { writer.write(rec); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,initialize,"private void  (){ fastqWriterFactory.setCreateMd5(CREATE_MD5_FILE); switch (READ_NAME_FORMAT) { case CASAVA_1_8: readNameEncoder=new Casava18ReadNameEncoder(MACHINE_NAME RUN_BARCODE FLOWCELL_BARCODE); break; case ILLUMINA: readNameEncoder=new IlluminaReadNameEncoder(RUN_BARCODE); break; } final BclQualityEvaluationStrategy bclQualityEvaluationStrategy=new BclQualityEvaluationStrategy(MINIMUM_QUALITY); readStructure=new ReadStructure(READ_STRUCTURE); if (MULTIPLEX_PARAMS != null) { IOUtil.assertFileIsReadable(MULTIPLEX_PARAMS); } final boolean demultiplex; if (OUTPUT_PREFIX != null) { sampleBarcodeFastqWriterMap.put(null buildWriter(OUTPUT_PREFIX)); demultiplex=false; } else { populateWritersFromMultiplexParams(); demultiplex=true; } final int readsPerCluster=readStructure.templates.length() + readStructure.sampleBarcodes.length(); if (IlluminaFileUtil.hasCbcls(BASECALLS_DIR LANE)) { if (BARCODES_DIR == null) BARCODES_DIR=BASECALLS_DIR; basecallsConverter=new NewIlluminaBasecallsConverter<>(BASECALLS_DIR BARCODES_DIR LANE readStructure sampleBarcodeFastqWriterMap demultiplex Math.max(1 MAX_READS_IN_RAM_PER_TILE / readsPerCluster) TMP_DIR NUM_PROCESSORS FIRST_TILE TILE_LIMIT queryNameComparator new FastqRecordsForClusterCodec(readStructure.templates.length() readStructure.sampleBarcodes.length() readStructure.molecularBarcode.length()) FastqRecordsForCluster.class bclQualityEvaluationStrategy IGNORE_UNEXPECTED_BARCODES); } else { basecallsConverter=new IlluminaBasecallsConverter<>(BASECALLS_DIR BARCODES_DIR LANE readStructure sampleBarcodeFastqWriterMap demultiplex Math.max(1 MAX_READS_IN_RAM_PER_TILE / readsPerCluster) TMP_DIR NUM_PROCESSORS FORCE_GC FIRST_TILE TILE_LIMIT queryNameComparator new FastqRecordsForClusterCodec(readStructure.templates.length() readStructure.sampleBarcodes.length() readStructure.molecularBarcode.length()) FastqRecordsForCluster.class bclQualityEvaluationStrategy this.APPLY_EAMSS_FILTER INCLUDE_NON_PF_READS IGNORE_UNEXPECTED_BARCODES); } basecallsConverter.setConverter(new ClusterToFastqRecordsForClusterConverter(basecallsConverter.getFactory().getOutputReadStructure())); log.info(""READ STRUCTURE IS "" + readStructure.toString()); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,main,public static void  (final String[] args){ new IlluminaBasecallsToFastq().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,makeFastqRecords,private void  (final FastqRecord[] recs final int[] indices final ClusterData cluster final boolean appendReadNumberSuffix){ for (short i=0; i < indices.length; ++i) { final ReadData readData=cluster.getRead(indices[i]); final String readBases=StringUtil.bytesToString(readData.getBases()).replace('.' 'N'); final String readName=readNameEncoder.generateReadName(cluster appendReadNumberSuffix ? i + 1 : null); recs[i]=new FastqRecord(readName readBases null SAMUtils.phredToFastq(readData.getQualities())); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,populateWritersFromMultiplexParams,"private void  (){ final TabbedTextFileWithHeaderParser libraryParamsParser=new TabbedTextFileWithHeaderParser(MULTIPLEX_PARAMS); final Set<String> expectedColumnLabels=CollectionUtil.makeSet(""OUTPUT_PREFIX""); final List<String> sampleBarcodeColumnLabels=new ArrayList<>(); for (int i=1; i <= readStructure.sampleBarcodes.length(); i++) { sampleBarcodeColumnLabels.add(""BARCODE_"" + i); } expectedColumnLabels.addAll(sampleBarcodeColumnLabels); assertExpectedColumns(libraryParamsParser.columnLabels() expectedColumnLabels); for ( final TabbedTextFileWithHeaderParser.Row row : libraryParamsParser) { List<String> sampleBarcodeValues=null; if (!sampleBarcodeColumnLabels.isEmpty()) { sampleBarcodeValues=new ArrayList<>(); for ( final String sampleBarcodeLabel : sampleBarcodeColumnLabels) { sampleBarcodeValues.add(row.getField(sampleBarcodeLabel)); } } final String key=(sampleBarcodeValues == null || sampleBarcodeValues.contains(""N"")) ? null : StringUtil.join("""" sampleBarcodeValues); if (sampleBarcodeFastqWriterMap.containsKey(key)) { throw new PicardException(""Row for barcode "" + key + "" appears more than once in MULTIPLEX_PARAMS file ""+ MULTIPLEX_PARAMS); } final FastqRecordsWriter writer=buildWriter(new File(row.getField(""OUTPUT_PREFIX""))); sampleBarcodeFastqWriterMap.put(key writer); } if (sampleBarcodeFastqWriterMap.isEmpty()) { throw new PicardException(""MULTIPLEX_PARAMS file "" + MULTIPLEX_PARAMS + "" does have any data rows.""); } libraryParamsParser.close(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,setInputStream,@Override public void  (final InputStream is){ reader=new FastqReader(new BufferedReader(new InputStreamReader(is))); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,setOutputStream,@Override public void  (final OutputStream os){ writer=new BasicFastqWriter(new PrintStream(os)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaBasecallsToFastq.java,write,private void  (final FastqWriter[] writers final FastqRecord[] records){ for (int i=0; i < writers.length; ++i) { writers[i].write(records[i]); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaPhasingMetrics.java,getExtension,"public static String  (){ return ""illumina_phasing_metrics""; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaPhasingMetrics.java,getPhasingMetricsForTiles,public static Collection<IlluminaPhasingMetrics>  (final long lane final Collection<Tile> tilesForLane final boolean usePercentage){ final LanePhasingMetricsCollector lanePhasingMetricsCollector=new LanePhasingMetricsCollector(tilesForLane usePercentage); final Collection<IlluminaPhasingMetrics> phasingMetrics=new ArrayList<IlluminaPhasingMetrics>(); for ( final TileTemplateRead tileTemplateRead : lanePhasingMetricsCollector.getMedianPhasingMap().keySet()) { final IlluminaPhasingMetrics phasingMetric=new IlluminaPhasingMetrics(); phasingMetric.LANE=lane; phasingMetric.TYPE_NAME=tileTemplateRead.toString(); phasingMetric.PHASING_APPLIED=lanePhasingMetricsCollector.getMedianPhasingMap().get(tileTemplateRead); phasingMetric.PREPHASING_APPLIED=lanePhasingMetricsCollector.getMedianPrePhasingMap().get(tileTemplateRead); phasingMetrics.add(phasingMetric); } return phasingMetrics; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\LanePhasingMetricsCollector.java,LanePhasingMetricsCollector,public  (final Collection<Tile> laneTiles final boolean usePercentage){ final Map<TileTemplateRead Float> medianPhasingMap=new TreeMap<TileTemplateRead Float>(); final Map<TileTemplateRead Float> medianPrePhasingMap=new TreeMap<TileTemplateRead Float>(); final CollectionUtil.MultiMap<TileTemplateRead Float> phasingValues=new CollectionUtil.MultiMap<TileTemplateRead Float>(); final CollectionUtil.MultiMap<TileTemplateRead Float> prePhasingValues=new CollectionUtil.MultiMap<TileTemplateRead Float>(); for ( final Tile tile : laneTiles) { for ( final TileTemplateRead tileTemplateRead : tile.getPhasingMap().keySet()) { phasingValues.append(tileTemplateRead tile.getPhasingMap().get(tileTemplateRead)); prePhasingValues.append(tileTemplateRead tile.getPrePhasingMap().get(tileTemplateRead)); } } for ( final TileTemplateRead tileTemplateRead : phasingValues.keySet()) { medianPhasingMap.put(tileTemplateRead median(phasingValues.get(tileTemplateRead) usePercentage)); medianPrePhasingMap.put(tileTemplateRead median(prePhasingValues.get(tileTemplateRead) usePercentage)); } this.medianPhasingMap=Collections.unmodifiableMap(medianPhasingMap); this.medianPrePhasingMap=Collections.unmodifiableMap(medianPrePhasingMap); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\LanePhasingMetricsCollector.java,getMedianPhasingMap,public Map<TileTemplateRead Float>  (){ return medianPhasingMap; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\LanePhasingMetricsCollector.java,getMedianPrePhasingMap,public Map<TileTemplateRead Float>  (){ return medianPrePhasingMap; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\LanePhasingMetricsCollector.java,median,private static float  (final Collection<Float> phaseValues boolean usePercentage){ final double[] values=new double[phaseValues.size()]; int i=0; for ( Float phaseValue : phaseValues) { values[i]=(double)phaseValue; i++; } float median=(float)MathUtil.median(values); return usePercentage ? median * 100 : median; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\NewIlluminaBasecallsConverter.java,Closer,private  (final ConvertedClusterDataWriter<CLUSTER_OUTPUT_RECORD> writer final String barcode){ this.writer=writer; this.barcode=barcode; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\NewIlluminaBasecallsConverter.java,NewIlluminaBasecallsConverter,"public  (final File basecallsDir final File barcodesDir final int lane final ReadStructure readStructure final Map<String ? extends ConvertedClusterDataWriter<CLUSTER_OUTPUT_RECORD>> barcodeRecordWriterMap final boolean demultiplex final int maxReadsInRamPerTile final List<File> tmpDirs final int numProcessors final Integer firstTile final Integer tileLimit final Comparator<CLUSTER_OUTPUT_RECORD> outputRecordComparator final SortingCollection.Codec<CLUSTER_OUTPUT_RECORD> codecPrototype final Class<CLUSTER_OUTPUT_RECORD> outputRecordClass final BclQualityEvaluationStrategy bclQualityEvaluationStrategy final boolean ignoreUnexpectedBarcodes){ super(barcodeRecordWriterMap maxReadsInRamPerTile tmpDirs codecPrototype ignoreUnexpectedBarcodes demultiplex outputRecordComparator bclQualityEvaluationStrategy outputRecordClass numProcessors new IlluminaDataProviderFactory(basecallsDir barcodesDir lane readStructure bclQualityEvaluationStrategy)); this.tiles=new ArrayList<>(); barcodeRecordWriterMap.keySet().forEach(barcode -> barcodeWriterThreads.put(barcode new ThreadPoolExecutorWithExceptions(1))); final File laneDir=new File(basecallsDir IlluminaFileUtil.longLaneStr(lane)); final File[] cycleDirs=IOUtil.getFilesMatchingRegexp(laneDir IlluminaFileUtil.CYCLE_SUBDIRECTORY_PATTERN); cbcls=new ArrayList<>(); Arrays.asList(cycleDirs).forEach(cycleDir -> cbcls.addAll(Arrays.asList(IOUtil.getFilesMatchingRegexp(cycleDir ""^"" + IlluminaFileUtil.longLaneStr(lane) + ""_(\\d{1 5}).cbcl$"")))); if (cbcls.size() == 0) { throw new PicardException(""No CBCL files found.""); } IOUtil.assertFilesAreReadable(cbcls); final File locsFile=new File(basecallsDir.getParentFile() AbstractIlluminaPositionFileReader.S_LOCS_FILE); try (LocsFileReader locsFileReader=new LocsFileReader(locsFile)){ while (locsFileReader.hasNext()) { locs.add(locsFileReader.next()); } } IOUtil.assertFileIsReadable(locsFile); final Pattern filterRegex=Pattern.compile(ParameterizedFileUtil.escapePeriods(ParameterizedFileUtil.makeLaneTileRegex("".filter"" lane))); filterFiles=getTiledFiles(laneDir filterRegex); for ( final File filterFile : filterFiles) { final Matcher tileMatcher=filterRegex.matcher(filterFile.getName()); if (tileMatcher.matches()) { tiles.add(Integer.valueOf(tileMatcher.group(1))); } } IOUtil.assertFilesAreReadable(Arrays.asList(filterFiles)); tiles.sort(TILE_NUMBER_COMPARATOR); if (demultiplex) { final Pattern barcodeRegex=Pattern.compile(ParameterizedFileUtil.escapePeriods(ParameterizedFileUtil.makeBarcodeRegex(lane))); final File[] barcodeTileFiles=getTiledFiles(barcodesDir barcodeRegex); if (barcodeTileFiles.length != tiles.size()) { throw new PicardException(String.format(""Barcode files are required for each tile. Found %d expected %d."" barcodeTileFiles.length tiles.size())); } for ( final File barcodeFile : barcodeTileFiles) { final Matcher tileMatcher=barcodeRegex.matcher(barcodeFile.getName()); if (tileMatcher.matches()) { barcodesFiles.put(Integer.valueOf(tileMatcher.group(1)) barcodeFile); } } } setTileLimits(firstTile tileLimit); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\NewIlluminaBasecallsConverter.java,RecordWriter, (final ConvertedClusterDataWriter<CLUSTER_OUTPUT_RECORD> writer final SortingCollection<CLUSTER_OUTPUT_RECORD> recordCollection final String barcode){ this.writer=writer; this.recordCollection=recordCollection; this.barcode=barcode; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\NewIlluminaBasecallsConverter.java,TileProcessor, (final int tileNum final File barcodeFile){ this.tileNum=tileNum; this.barcodeFile=barcodeFile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\NewIlluminaBasecallsConverter.java,addRecord,"private synchronized void  (final String barcode final CLUSTER_OUTPUT_RECORD record){ SortingCollection<CLUSTER_OUTPUT_RECORD> recordCollection=this.barcodeToRecordCollection.get(barcode); if (recordCollection == null) { if (!barcodeRecordWriterMap.containsKey(barcode)) { if (ignoreUnexpectedBarcodes) { return; } throw new PicardException(String.format(""Read records with barcode %s  but this barcode was not expected. (Is it referenced in the parameters file?)"" barcode)); } recordCollection=newSortingCollection(); this.barcodeToRecordCollection.put(barcode recordCollection); } recordCollection.add(record); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\NewIlluminaBasecallsConverter.java,awaitThreadPoolTermination,"private void  (final String executorName final ThreadPoolExecutor executorService){ try { while (!executorService.awaitTermination(300 TimeUnit.SECONDS)) { log.info(String.format(""%s waiting for job completion. Finished jobs - %d : Running jobs - %d : Queued jobs - %d"" executorName executorService.getCompletedTaskCount() executorService.getActiveCount() executorService.getQueue().size())); } } catch ( final InterruptedException e) { e.printStackTrace(); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\NewIlluminaBasecallsConverter.java,doTileProcessing,@Override public void  (){ final ThreadPoolExecutor completedWorkExecutor=new ThreadPoolExecutorWithExceptions(1); final CompletedWorkChecker workChecker=new CompletedWorkChecker(); completedWorkExecutor.submit(workChecker); completedWorkExecutor.shutdown
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\NewIlluminaBasecallsConverter.java,getBarcode,public String  (){ return barcode; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\NewIlluminaBasecallsConverter.java,getTiledFiles,public static File[]  (final File baseDirectory final Pattern pattern){ return IOUtil.getFilesMatchingRegexp(baseDirectory pattern); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\NewIlluminaBasecallsConverter.java,newSortingCollection,private synchronized SortingCollection<CLUSTER_OUTPUT_RECORD>  (){ final int maxRecordsInRam=Math.max(1 maxReadsInRamPerTile / barcodeRecordWriterMap.size()); return SortingCollection.newInstance(outputRecordClass codecPrototype.clone() outputRecordComparator maxRecordsInRam tmpDirs); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\NewIlluminaBasecallsConverter.java,run,"@Override public void  (){ while (currentTileIndex < tiles.size()) { final Integer currentTile=tiles.get(currentTileIndex); if (completedWork.containsKey(currentTile)) { log.info(""Writing out tile "" + currentTile); completedWork.get(currentTile).forEach(w"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\MarkIlluminaAdapters.java,customCommandLineValidation,"@Override protected String[]  (){ if ((FIVE_PRIME_ADAPTER != null && THREE_PRIME_ADAPTER == null) || (THREE_PRIME_ADAPTER != null && FIVE_PRIME_ADAPTER == null)) { return new String[]{""THREE_PRIME_ADAPTER and FIVE_PRIME_ADAPTER must either both be null or"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\MarkIlluminaAdapters.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(METRICS); final SamReader in=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT); final SAMFileHeader.SortOrder order=in.getFileHeade
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\MarkIlluminaAdapters.java,main,public static void  (final String[] args){ System.exit(new MarkIlluminaAdapters().instanceMain(args)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BarcodeParser.java,BarcodeDataIterator,public  (final File file){ bfr=new BarcodeFileReader(file); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BarcodeParser.java,BarcodeParser,public  (final IlluminaFileMap tilesToFiles final int nextTile){ super(tilesToFiles nextTile); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BarcodeParser.java,close,public void  (){ bfr.close(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BarcodeParser.java,getBarcode,public String  (){ return bfr.next(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BarcodeParser.java,hasNext,public boolean  (){ return bfr.hasNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BarcodeParser.java,makeTileIterator,@Override protected CloseableIterator<BarcodeData>  (File nextTileFile){ return new BarcodeDataIterator(nextTileFile); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BarcodeParser.java,next,public BarcodeData  (){ return new BarcodeData(){ public String getBarcode(){ return bfr.next(); } } ; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BarcodeParser.java,remove,public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BarcodeParser.java,supportedTypes,public Set<IlluminaDataType>  (){ return SUPPORTED_TYPES; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BaseIlluminaDataProvider.java,BaseIlluminaDataProvider,public  (final int lane final OutputMapping outputMapping){ numReads=outputMapping.numOutputReads(); this.lane=lane; this.outputReadTypes=StreamSupport.stream(outputMapping.getOutputDescriptors().spliterator() false).map(rd -> rd.type).toArray(ReadType[]::new); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BaseIlluminaDataProvider.java,addData,protected void  (final ClusterData clusterData final BarcodeData barcodeData){ clusterData.setMatchedBarcode(barcodeData.getBarcode()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BaseIlluminaDataProvider.java,addReadData,protected void  (final ClusterData clusterData final int numReads final CbclData cbclData){ final byte[][] bases=cbclData.getBases(); for (int i=0; i < numReads; i++) { clusterData.getRead(i).setBases(bases[i]); } final byte[][] qualities=cbclData.getQualities(); for (int i=0; i < numReads; i++) { clusterData.getRead(i).setQualities(qualities[i]); } clusterData.setPf(cbclData.isPf()); clusterData.setX(cbclData.getPositionInfo().xQseqCoord); clusterData.setY(cbclData.getPositionInfo().yQseqCoord); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BclData.java,BclData,public  (final int[] outputLengths){ bases=new byte[outputLengths.length][]; qualities=new byte[outputLengths.length][]; for (int i=0; i < outputLengths.length; i++) { bases[i]=new byte[outputLengths[i]]; qualities[i]=new byte[outputLengths[i]]; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BclData.java,getBases,@Override public byte[][]  (){ return bases; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BclData.java,getQualities,@Override public byte[][]  (){ return qualities; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BclParser.java,BclDataCycleFileParser,public  (final List<File> files){ reader=new BclReader(files outputMapping.getOutputReadLengths() bclQualityEvaluationStrategy false); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BclParser.java,BclParser,public  (final File directory final int lane final CycleIlluminaFileMap tilesToCycleFiles final OutputMapping outputMapping final boolean applyEamssFilter final BclQualityEvaluationStrategy bclQualityEvaluationStrategy){ super(directory lane tilesToCycleFiles outputMapping); this.bclQualityEvaluationStrategy=bclQualityEvaluationStrategy; this.applyEamssFilter=applyEamssFilter; this.initialize(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BclParser.java,close,@Override public void  (){ reader.close(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BclParser.java,hasNext,@Override public boolean  (){ try { return reader.hasNext(); } catch ( final NullPointerException npe) { return false; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BclParser.java,initialize,@Override public void  (){ seekToTile(currentTile); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BclParser.java,makeCycleFileParser,@Override protected CycleFilesParser<BclData>  (final List<File> files){ return new BclDataCycleFileParser(files); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BclParser.java,next,@Override public BclData  (){ if (!hasNext()) { throw new NoSuchElementException(); } return reader.next(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BclParser.java,runEamssForReadInPlace,protected static void  (final byte[] bases final byte[] qualities){ int eamssTally=0; int maxTally=Integer.MIN_VALUE; int indexOfMax=-1; for (int i=bases.length - 1; i >= 0; i--) { final int quality=(0xff & qualities[i]); if (quality >= EAMSS_M2_GE_THRESHOLD) { eamssTally-=2; } else if (quality < EAMSS_S1_LT_THRESHOLD) { eamssTally+=1; } if (eamssTally >= maxTally) { indexOfMax=i; maxTally=eamssTally; } } if (maxTally >= 1) { int numGs=0; int exceptions=0; for (int i=indexOfMax; i >= 0; i--) { if (bases[i] == 'G') { ++numGs; } else { final Integer skip=skipBy(i numGs exceptions bases); if (skip != null) { exceptions+=skip; numGs+=skip; i-=(skip - 1); } else { break; } } } if (numGs >= 10) { indexOfMax=(indexOfMax + 1) - numGs; } for (int i=indexOfMax; i < qualities.length; i++) { qualities[i]=MASKING_QUALITY; } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BclParser.java,skipBy,private static Integer  (final int index final int numGs final int prevExceptions final byte[] bases){ Integer skip=null; for (int backup=1; backup <= index; backup++) { final int exceptionLimit=Math.max((numGs + backup) / 10 1); if (prevExceptions + backup > exceptionLimit) { break; } if (bases[index - backup] == 'G') { skip=backup; break; } } return skip; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\BclParser.java,supportedTypes,@Override public Set<IlluminaDataType>  (){ return SUPPORTED_TYPES; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,ClusterData,public  (final ReadType[] readTypes){ reads=new ReadData[readTypes.length]; for (int i=0; i < readTypes.length; i++) { reads[i]=new ReadData(readTypes[i]); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,getLane,public int  (){ return lane; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,getMatchedBarcode,public String  (){ return matchedBarcode; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,getNumReads,public int  (){ return reads.length; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,getRead,public ReadData  (final int index){ return reads[index]; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,getTile,public int  (){ return tile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,getX,public int  (){ return x; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,getY,public int  (){ return y; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,isPf,public Boolean  (){ return pf; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,laneIsSet,public boolean  (){ return lane != -1; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,setLane,public void  (final int lane){ this.lane=lane; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,setMatchedBarcode,public void  (final String matchedBarcode){ this.matchedBarcode=matchedBarcode; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,setOrCheckLane,"public void  (final int lane){ if (laneIsSet()) { if (this.lane != lane) { throw new PicardException(""Lane number mismatch for "" + this + "" : ""+ this.lane+ "" != ""+ lane); } } else { this.lane=lane; } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,setOrCheckPf,"public void  (final boolean pf){ if (this.pf == null) { this.pf=pf; } else if (this.pf != pf) { throw new PicardException(""PF value mismatch for "" + this + "" : ""); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,setOrCheckTile,"public void  (final int tile){ if (tileIsSet()) { if (this.tile != tile) { throw new PicardException(""Tile number mismatch for "" + this + "" : ""+ this.tile+ "" != ""+ tile); } } else { this.tile=tile; } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,setOrCheckX,"public void  (final int x){ if (xIsSet()) { if (this.x != x) { throw new PicardException(""X value mismatch for "" + this + "" : ""+ this.x+ "" != ""+ x); } } else { this.x=x; } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,setOrCheckY,"public void  (final int y){ if (yIsSet()) { if (this.y != y) { throw new PicardException(""Y value mismatch for "" + this + "" : ""+ this.y+ "" != ""+ y); } } else { this.y=y; } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,setPf,public void  (final boolean pf){ this.pf=pf; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,setTile,public void  (final int tile){ this.tile=tile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,setX,public void  (final int x){ this.x=x; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,setY,public void  (final int y){ this.y=y; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,tileIsSet,public boolean  (){ return tile != -1; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,toString,"public String  (){ return ""ClusterData(lane: "" + lane + ""; tile: ""+ tile+ ""; x: ""+ x+ ""; y: ""+ y+ ""; pf: ""+ pf+ ""; matchedBarcode: ""+ matchedBarcode+ "")""; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,xIsSet,public boolean  (){ return x != -1; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterData.java,yIsSet,public boolean  (){ return y != -1; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\CbclData.java,CbclData,public  (int[] outputLengths int tile){ super(outputLengths); this.tile=tile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\CbclData.java,getPositionInfo,public AbstractIlluminaPositionFileReader.PositionInfo  (){ return positionInfo; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\CbclData.java,getTile,public int  (){ return tile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\CbclData.java,getXCoordinate,@Override public int  (){ return this.positionInfo.xQseqCoord; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\CbclData.java,getYCoordinate,@Override public int  (){ return this.positionInfo.yQseqCoord; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\CbclData.java,isPf,@Override public boolean  (){ return true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\CbclData.java,setPositionInfo,public void  (AbstractIlluminaPositionFileReader.PositionInfo positionInfo){ this.positionInfo=positionInfo; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\BarcodeFileFaker.java,addLeadingZeros,@Override protected boolean  (){ return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\BarcodeFileFaker.java,bufferSize,@Override protected int  (){ return BARCODE_STRING.getBytes().length; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\BarcodeFileFaker.java,fakeFile,@Override protected void  (final ByteBuffer buffer){ buffer.put(BARCODE_STRING.getBytes()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterIntensityFileReader.java,ClusterIntensityFileHeader,"public  (final byte[] headerBytes final File file){ if (headerBytes.length < HEADER_SIZE) { throw new PicardException(""Bytes past to header constructor are too short excpected("" + HEADER_SIZE + "") received (""+ headerBytes.length); } ByteBuffer buf=ByteBuffer.allocate(headerBytes.length); buf.order(ByteOrder.LITTLE_ENDIAN); buf.put(headerBytes); buf.position(0); final byte[] identifierBuf=new byte[IDENTIFIER.length]; buf.get(identifierBuf); if (!Arrays.equals(identifierBuf IDENTIFIER)) { throw new PicardException(""Cluster intensity file "" + file + "" contains unexpected header: ""+ StringUtil.bytesToString(identifierBuf)); } final byte fileVersion=buf.get(); if (fileVersion != FILE_VERSION) { throw new PicardException(""Cluster intensity file "" + file + "" contains unexpected version: ""+ fileVersion); } elementSize=buf.get(); if (elementSize < 1 || elementSize > 2) { throw new PicardException(""Cluster intensity file "" + file + "" contains unexpected element size: ""+ elementSize); } firstCycle=UnsignedTypeUtil.uShortToInt(buf.getShort()); numCycles=UnsignedTypeUtil.uShortToInt(buf.getShort()); if (numCycles == 0) { throw new PicardException(""Cluster intensity file "" + file + "" has zero cycles.""); } numClusters=buf.getInt(); if (numClusters < 0) { throw new PicardException(""Cluster intensity file "" + file + "" has negative number of clusters: ""+ numClusters); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterIntensityFileReader.java,ClusterIntensityFileReader,"public  (final File file){ try { this.file=file; final FileInputStream is=new FileInputStream(this.file); final FileChannel channel=is.getChannel(); final long fileSize=channel.size(); buf=channel.map(FileChannel.MapMode.READ_ONLY 0 fileSize); buf.order(ByteOrder.LITTLE_ENDIAN); CloserUtil.close(channel); CloserUtil.close(is); final byte[] headerBytes=new byte[HEADER_SIZE]; buf.get(headerBytes); this.header=new ClusterIntensityFileHeader(headerBytes this.file); } catch ( IOException e) { throw new PicardException(""IOException opening cluster intensity file "" + file e); } cycleSize=NUM_CHANNELS * header.numClusters * header.elementSize; channelSize=header.numClusters * header.elementSize; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterIntensityFileReader.java,getElementSize,public int  (){ return header.elementSize; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterIntensityFileReader.java,getFile,public File  (){ return file; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterIntensityFileReader.java,getFirstCycle,public int  (){ return header.firstCycle; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterIntensityFileReader.java,getNumClusters,public int  (){ return header.numClusters; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterIntensityFileReader.java,getNumCycles,public int  (){ return header.numCycles; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterIntensityFileReader.java,getValue,"public short  (final int cluster final IntensityChannel channel final int cycle){ if (cycle < header.firstCycle || cycle >= header.firstCycle + header.numCycles) { throw new IllegalArgumentException(""Requested cycle ("" + cycle + "") number out of range. First cycle=""+ header.firstCycle+ ""; numCycles=""+ header.numCycles); } if (cluster < 0 || cluster >= header.numClusters) { throw new IllegalArgumentException(""Requested cluster ("" + cluster + "") number out of range. numClustersInTile=""+ header.numClusters); } final int relativeCycle=cycle - header.firstCycle; final int position=HEADER_SIZE + relativeCycle * cycleSize + channel.ordinal() * channelSize + cluster * header.elementSize; buf.position(position); if (header.elementSize == 1) { return buf.get(); } else { return buf.getShort(); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ClusterIntensityFileReader.java,readHeaders,"public static ClusterIntensityFileHeader  (final File intensityFile){ FileInputStream reader=null; byte[] headerBytes=new byte[HEADER_SIZE]; int bytesRead=0; try { reader=new FileInputStream(intensityFile); bytesRead=reader.read(headerBytes); } catch ( FileNotFoundException fnfExc) { throw new PicardException(""Error opening intensity file ("" + intensityFile.getAbsolutePath() + "")"" fnfExc); } catch ( IOException ioExc) { throw new PicardException(""Error reading values from header for intensity file ("" + intensityFile.getAbsolutePath() + "")"" ioExc); } finally { CloserUtil.close(reader); } if (bytesRead != HEADER_SIZE) throw new PicardException(""Error reading intensity file header  too few bytes read  expected( "" + HEADER_SIZE + "") read(""+ bytesRead+ "")""); return new ClusterIntensityFileHeader(headerBytes intensityFile); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\CycleIlluminaFileMap.java,assertValid,"public void  (final List<Integer> expectedTiles final int[] expectedCycles){ if (size() != expectedCycles.length) { throw new PicardException(""Expected CycledIlluminaFileMap to contain "" + expectedCycles.length + "" cycles but only ""+ size()+ "" were found!""); } if (this.firstEntry().getValue().size() != expectedTiles.size()) { throw new PicardException(""Expected CycledIlluminaFileMap to contain "" + expectedTiles.size() + "" tiles but only ""+ this.firstEntry().getValue().size()+ "" were found!""); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\CycleIlluminaFileMap.java,keep,public CycleIlluminaFileMap  (final List<Integer> tilesToKeep final Set<Integer> cycles){ final CycleIlluminaFileMap ciMap=new CycleIlluminaFileMap(); if (cycles != null) { for ( final int cycle : cycles) { final IlluminaFileMap template=this.get(cycle); if (template != null) { ciMap.put(cycle template.keep(tilesToKeep)); } } } return ciMap; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\BclFileFaker.java,addLeadingZeros,@Override protected boolean  (){ return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\BclFileFaker.java,bufferSize,protected int  (){ return size + 4; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\BclFileFaker.java,fakeFile,@Override public void  (final ByteBuffer buffer){ buffer.putInt(size); while (size > 0) { buffer.put((byte)0); size--; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\IlluminaLaneMetrics.java,getExtension,"public static String  (){ return ""illumina_lane_metrics""; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\BciFileFaker.java,addLeadingZeros,@Override protected boolean  (){ return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\BciFileFaker.java,bufferSize,@Override protected int  (){ return 8 * tiles.size(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\BciFileFaker.java,fakeBciFile,public void  (final File bci final List<Integer> expectedTiles) throws IOException { tiles=expectedTiles; final FileOutputStream fileOutputStream=new FileOutputStream(bci); final FileChannel channel=fileOutputStream.getChannel(); final ByteBuffer buffer=ByteBuffer.allocate(8 * expectedTiles.size()); buffer.order(ByteOrder.LITTLE_ENDIAN); fakeFile(buffer); buffer.flip(); channel.write(buffer); channel.force(true); CloserUtil.close(channel); CloserUtil.close(fileOutputStream); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\BciFileFaker.java,fakeFile,@Override protected void  (final ByteBuffer buffer){ for ( final Integer tile : tiles) { buffer.putInt(tile); buffer.putInt(1); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\LocsFileFaker.java,addLeadingZeros,@Override protected boolean  (){ return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\LocsFileFaker.java,bufferSize,@Override protected int  (){ return (Integer.SIZE * 2) + (Float.SIZE * 3); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\LocsFileFaker.java,fakeFile,@Override protected void  (final ByteBuffer buffer){ buffer.putInt(1); buffer.putFloat(1.0f); buffer.putInt(1); buffer.putFloat(5.0f); buffer.putFloat(5.0f); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\FilterFileFaker.java,addLeadingZeros,@Override protected boolean  (){ return true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\FilterFileFaker.java,bufferSize,@Override protected int  (){ return Integer.SIZE * 3; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\FilterFileFaker.java,fakeFile,@Override protected void  (final ByteBuffer buffer){ buffer.putInt(0); buffer.putInt(3); buffer.putInt(1); buffer.put((byte)0); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\MultiTileLocsFileFaker.java,addLeadingZeros,@Override protected boolean  (){ return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\MultiTileLocsFileFaker.java,bufferSize,@Override protected int  (){ return (Integer.SIZE * 2) + (Float.SIZE * tiles.size()) + Float.SIZE; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\MultiTileLocsFileFaker.java,fakeFile,@Override protected void  (final ByteBuffer buffer){ buffer.putInt(1); buffer.putFloat(1.0f); buffer.putInt(1); for (int count=0; count < tiles.size(); count++) { buffer.putFloat(5.0f + (count * 0.5f)); buffer.putFloat(5.0f + (count * 0.5f)); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\MultiTileBclFileFaker.java,addLeadingZeros,@Override protected boolean  (){ return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\MultiTileBclFileFaker.java,bufferSize,@Override protected int  (){ return ((size - Integer.SIZE) * tiles.size()) + Integer.SIZE; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\MultiTileBclFileFaker.java,fakeFile,@Override protected void  (final ByteBuffer buffer){ buffer.putInt(1); for ( final Integer tile : tiles) { long perTileSize=size; while (perTileSize > 0) { buffer.put((byte)0); perTileSize--; } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\ClocsFileFaker.java,addLeadingZeros,@Override protected boolean  (){ return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\ClocsFileFaker.java,bufferSize,@Override protected int  (){ return Integer.SIZE + (Byte.SIZE * 4); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\ClocsFileFaker.java,fakeFile,@Override protected void  (final ByteBuffer buffer){ buffer.put((byte)1); buffer.putInt(1); buffer.put((byte)(0xff & 1)); buffer.put((byte)(0xff & 5)); buffer.put((byte)(0xff & 5)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\PosFileFaker.java,addLeadingZeros,@Override protected boolean  (){ return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\PosFileFaker.java,bufferSize,@Override protected int  (){ return POS_FILE_STRING.getBytes().length; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\fakers\PosFileFaker.java,fakeFile,@Override protected void  (final ByteBuffer buffer){ buffer.put(POS_FILE_STRING.getBytes()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\FilterParser.java,FilterParser,public  (final IlluminaFileMap tilesToFiles final int startingTile){ super(tilesToFiles startingTile); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\FilterParser.java,close,public void  (){ reader=null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\FilterParser.java,hasNext,public boolean  (){ return reader.hasNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\FilterParser.java,isPf,public boolean  (){ return nextValue; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\FilterParser.java,makeTileIterator,@Override protected CloseableIterator<PfData>  (final File iterator){ return new CloseableIterator<PfData>(){ private FilterFileReader reader=new FilterFileReader(iterator); public void close(){ reader=null; } public boolean hasNext(){ return reader.hasNe
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\FilterParser.java,next,public PfData  (){ final boolean nextValue=reader.next(); return new PfData(){ public boolean isPf(){ return nextValue; } } ; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\FilterParser.java,remove,public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\FilterParser.java,supportedTypes,public Set<IlluminaDataType>  (){ return supportedTypes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\FourChannelIntensityData.java,FourChannelIntensityData,public  (final int numberOfCycles){ a=new short[numberOfCycles]; c=new short[numberOfCycles]; g=new short[numberOfCycles]; t=new short[numberOfCycles]; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\FourChannelIntensityData.java,equals,@Override public boolean  (final Object o){ if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; final FourChannelIntensityData that=(FourChannelIntensityData)o; return Arrays.equals(this.a that.a) && Arrays.equals(this.c
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\FourChannelIntensityData.java,getA,public short[]  (){ return a; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\FourChannelIntensityData.java,getC,public short[]  (){ return c; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\FourChannelIntensityData.java,getChannel,"public short[]  (final IntensityChannel channel){ switch (channel) { case A: return a; case C: return c; case G: return g; case T: return t; } throw new PicardException(""Unexpected intensity channel "" + channel); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\FourChannelIntensityData.java,getG,public short[]  (){ return g; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\FourChannelIntensityData.java,getT,public short[]  (){ return t; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\FourChannelIntensityData.java,hashCode,@Override public int  (){ int ret=0; ret=ret * 31 + Arrays.hashCode(a); ret+=ret * 31 + Arrays.hashCode(c); ret+=ret * 31 + Arrays.hashCode(g); ret+=ret * 31 + Arrays.hashCode(t); return ret; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaDataProvider.java,IlluminaDataProvider," (final OutputMapping outputMapping final Map<IlluminaParser Set<IlluminaDataType>> parsersToDataTypes final File basecallDirectory final int lane){ super(lane outputMapping); this.basecallDirectory=basecallDirectory; final int numParsers=parsersToDataTypes.size(); if (numParsers == 0) { throw new PicardException(""There were 0 parsers passed to IlluminaDataProvider!""); } int i=0; parsers=new IlluminaParser[numParsers]; dataTypes=new IlluminaDataType[numParsers][]; for ( final Map.Entry<IlluminaParser Set<IlluminaDataType>> pToD : parsersToDataTypes.entrySet()) { parsers[i]=pToD.getKey(); final Set<IlluminaDataType> dts=pToD.getValue(); dataTypes[i]=new IlluminaDataType[dts.size()]; dts.toArray(dataTypes[i++]); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaDataProvider.java,close,@Override public void  (){ for ( final IlluminaParser parser : parsers) { parser.close(); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaDataProvider.java,hasNext,"public boolean  (){ final boolean more=parsers[0].hasNext(); if (!more) { for (int i=1; i < parsers.length; i++) { if (parsers[i].hasNext()) { throw new PicardException(""Unequal length Illumina files in "" + basecallDirectory + ""  lane ""+ lane+ "". Failing parser: ""+ parsers[i].getClass().getName()); } } } return more; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaDataProvider.java,next,"public ClusterData  (){ if (!hasNext()) { throw new NoSuchElementException(); } final ClusterData cluster=new ClusterData(outputReadTypes); cluster.setLane(lane); cluster.setTile(parsers[0].getTileOfNextCluster()); for (int i=0; i < parsers.length; i++) { final IlluminaData ilData=parsers[i].next(); for ( final IlluminaDataType ilDataType : dataTypes[i]) { switch (ilDataType) { case Position: addData(cluster (PositionalData)ilData); break; case PF: addData(cluster (PfData)ilData); break; case Barcodes: addData(cluster (BarcodeData)ilData); break; case BaseCalls: addReadData(cluster numReads (BaseData)ilData); break; case QualityScores: addReadData(cluster numReads (QualityData)ilData); break; default : throw new PicardException(""Unknown data type "" + ilDataType + "" requested by IlluminaDataProviderFactory""); } } } return cluster; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaDataProvider.java,remove,public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaDataProvider.java,seekToTile,@Override public void  (final int oneBasedTileNumber){ for ( final IlluminaParser parser : parsers) { parser.seekToTile(oneBasedTileNumber); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaFileMap.java,getFilesStartingAt,public List<File>  (final int startingTile){ return new ArrayList<File>(this.tailMap(startingTile).values()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaFileMap.java,keep,public IlluminaFileMap  (final List<Integer> tilesToKeep){ final IlluminaFileMap fileMap=new IlluminaFileMap(); for ( final Integer tile : tilesToKeep) { final File file=this.get(tile); if (file != null) { fileMap.put(tile file); } } return fileMap; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaFileNotFoundException.java,IlluminaFileNotFoundException,public  (final File file final String message final Throwable throwable){ super(message throwable); this.file=file; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaFileUtil.java,IlluminaFileUtil,"public  (final File basecallDir final File barcodeDir final int lane){ this.lane=lane; this.basecallDir=basecallDir; this.barcodeDir=barcodeDir; this.intensityDir=basecallDir.getParentFile(); final File dataDir=intensityDir.getParentFile(); this.basecallLaneDir=new File(basecallDir longLaneStr(lane)); this.intensityLaneDir=new File(intensityDir longLaneStr(lane)); final File interopDir=new File(dataDir.getParentFile() ""InterOp""); tileMetricsOut=new File(interopDir ""TileMetricsOut.bin""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaFileUtil.java,getActualTiles,"public List<Integer>  (final List<SupportedIlluminaFormat> formats){ if (formats == null) { throw new PicardException(""Format list provided to getTiles was null!""); } if (formats.isEmpty()) { throw new PicardException(""0 Formats were specified. You need to specify at least SupportedIlluminaFormat to use getTiles""); } final List<ParameterizedFileUtil> tileBasedFormats=formats.stream().map(this::getUtil).filter(ParameterizedFileUtil::checkTileCount).collect(Collectors.toList()); if (tileBasedFormats.size() > 0) { final List<Integer> expectedTiles=tileBasedFormats.get(0).getTiles(); tileBasedFormats.forEach(util -> { if (expectedTiles.size() != util.getTiles().size() || !expectedTiles.containsAll(util.getTiles())) { throw new PicardException(""Formats do not have the same number of tiles! "" + summarizeTileCounts(formats)); } } ); return expectedTiles; } else { return new ArrayList<>(); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaFileUtil.java,getExpectedTiles,public List<Integer>  (){ IOUtil.assertFileIsReadable(tileMetricsOut); final TreeSet<Integer> expectedTiles=new TreeSet<>(); final Iterator<TileMetricsOutReader.IlluminaTileMetrics> tileMetrics=new TileMetricsOutReader(tileMetricsOut TileMetricsOutReader.TileMetricsVersion.TWO); while (tileMetrics.hasNext()) { final TileMetricsOutReader.IlluminaTileMetrics tileMetric=tileMetrics.next(); if (tileMetric.getLaneNumber() == lane && !expectedTiles.contains(tileMetric.getTileNumber())) { expectedTiles.add(tileMetric.getTileNumber()); } } CloserUtil.close(tileMetrics); return new ArrayList<>(expectedTiles); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaFileUtil.java,getLane,public int  (){ return lane; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaFileUtil.java,getUtil,"public ParameterizedFileUtil  (final SupportedIlluminaFormat format){ ParameterizedFileUtil parameterizedFileUtil=utils.get(format); if (parameterizedFileUtil == null) { switch (format) { case Bcl: final ParameterizedFileUtil bclFileUtil=new PerTilePerCycleFileUtil("".bcl"" basecallLaneDir new BclFileFaker() lane); final ParameterizedFileUtil gzBclFileUtil=new PerTilePerCycleFileUtil("".bcl.gz"" basecallLaneDir new BclFileFaker() lane); if (bclFileUtil.filesAvailable() && !gzBclFileUtil.filesAvailable()) { parameterizedFileUtil=bclFileUtil; } else if (!bclFileUtil.filesAvailable() && gzBclFileUtil.filesAvailable()) { parameterizedFileUtil=gzBclFileUtil; } else if (!bclFileUtil.filesAvailable() && !gzBclFileUtil.filesAvailable()) { parameterizedFileUtil=bclFileUtil; } else { throw new PicardException(""Not all BCL files in "" + basecallLaneDir.getAbsolutePath() + "" have the same extension!""); } utils.put(SupportedIlluminaFormat.Bcl parameterizedFileUtil); break; case Locs: parameterizedFileUtil=new PerTileOrPerRunFileUtil("".locs"" intensityLaneDir new LocsFileFaker() lane); utils.put(SupportedIlluminaFormat.Locs parameterizedFileUtil); break; case Clocs: parameterizedFileUtil=new PerTileFileUtil("".clocs"" intensityLaneDir new ClocsFileFaker() lane); utils.put(SupportedIlluminaFormat.Clocs parameterizedFileUtil); break; case Pos: parameterizedFileUtil=new PerTileFileUtil(""_pos.txt"" intensityDir new PosFileFaker() lane); utils.put(SupportedIlluminaFormat.Pos parameterizedFileUtil); break; case Filter: parameterizedFileUtil=new PerTileFileUtil("".filter"" basecallLaneDir new FilterFileFaker() lane); utils.put(SupportedIlluminaFormat.Filter parameterizedFileUtil); break; case Barcode: parameterizedFileUtil=new PerTileFileUtil(""_barcode.txt"" barcodeDir != null ? barcodeDir : basecallDir new BarcodeFileFaker() lane false); utils.put(SupportedIlluminaFormat.Barcode parameterizedFileUtil); break; case MultiTileFilter: parameterizedFileUtil=new MultiTileFilterFileUtil(basecallLaneDir lane); utils.put(SupportedIlluminaFormat.MultiTileFilter parameterizedFileUtil); break; case MultiTileLocs: parameterizedFileUtil=new MultiTileLocsFileUtil(new File(intensityDir basecallLaneDir.getName()) basecallLaneDir lane); utils.put(SupportedIlluminaFormat.MultiTileLocs parameterizedFileUtil); break; case MultiTileBcl: parameterizedFileUtil=new MultiTileBclFileUtil(basecallLaneDir lane); utils.put(SupportedIlluminaFormat.MultiTileBcl parameterizedFileUtil); break; } } return parameterizedFileUtil; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaFileUtil.java,hasCbcls,"public static boolean  (final File basecallDir final int lane){ final File laneDir=new File(basecallDir IlluminaFileUtil.longLaneStr(lane)); final File[] cycleDirs=IOUtil.getFilesMatchingRegexp(laneDir IlluminaFileUtil.CYCLE_SUBDIRECTORY_PATTERN); if (cycleDirs == null) { return false; } final List<File> cbcls=new ArrayList<>(); Arrays.asList(cycleDirs).forEach(cycleDir -> cbcls.addAll(Arrays.asList(IOUtil.getFilesMatchingRegexp(cycleDir ""^"" + IlluminaFileUtil.longLaneStr(lane) + ""_(\\d{1 5}).cbcl$"")))); return cbcls.size() > 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaFileUtil.java,liToStr,"private String  (final List<Integer> intList){ if (intList.isEmpty()) { return """"; } final StringBuilder summary=new StringBuilder(String.valueOf(intList.get(0))); for (int i=1; i < intList.size(); i++) { summary.append(""  "").append(String.valueOf(intList.get(i))); } return summary.toString(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaFileUtil.java,longLaneStr,"public static String  (final int lane){ final StringBuilder lstr=new StringBuilder(String.valueOf(lane)); final int zerosToAdd=3 - lstr.length(); for (int i=0; i < zerosToAdd; i++) { lstr.insert(0 ""0""); } return ""L"" + lstr; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaFileUtil.java,summarizeTileCounts,"private String  (final List<SupportedIlluminaFormat> formats){ final StringBuilder summary; ParameterizedFileUtil pfu=getUtil(formats.get(0)); List<Integer> tiles=pfu.getTiles(); summary=new StringBuilder(pfu.extension + ""("" + liToStr(tiles)+ "")""); for ( final SupportedIlluminaFormat format : formats) { pfu=getUtil(format); tiles=pfu.getTiles(); summary.append(""  "").append(pfu.extension).append(""("").append(liToStr(tiles)).append("")""); } return summary.toString(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaFileUtil.java,tileMetricsOut,public File  (){ return tileMetricsOut; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaMetricsCode.java,IlluminaMetricsCode, (final int metricsCode){ this.metricsCode=metricsCode; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaMetricsCode.java,getMetricsCode,public int  (){ return metricsCode; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaMetricsCode.java,getPhasingCode,"public static int  (final int readDescriptorIndex final IlluminaMetricsCode phasingType){ if (!isPhasing(phasingType)) { throw new IllegalArgumentException(""phasingType must be PHASING_BASE or PREPHASING_BASE""); } return (phasingType.getMetricsCode() + (readDescriptorIndex * 2)); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaMetricsCode.java,isPhasing,public static boolean  (final IlluminaMetricsCode metricsCode){ return (metricsCode.equals(PHASING_BASE) || metricsCode.equals(PREPHASING_BASE)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaDataProviderFactory.java,IlluminaDataProviderFactory,"public  (File basecallDirectory File barcodesDirectory int lane ReadStructure readStructure BclQualityEvaluationStrategy bclQualityEvaluationStrategy){ this.basecallDirectory=basecallDirectory; this.barcodesDirectory=barcodesDirectory; this.bclQualityEvaluationStrategy=bclQualityEvaluationStrategy; this.lane=lane; this.formatToDataTypes=null; this.availableTiles=null; this.fileUtil=null; outputMapping=new OutputMapping(readStructure); Pattern laneTileRegex=Pattern.compile(ParameterizedFileUtil.escapePeriods(ParameterizedFileUtil.makeLaneTileRegex("".filter"" lane))); File laneDir=new File(basecallDirectory IlluminaFileUtil.longLaneStr(lane)); List<Integer> tiles=new ArrayList<>(); File[] filterFiles=getTiledFiles(laneDir laneTileRegex); for ( File filterFile : filterFiles) { Matcher tileMatcher=laneTileRegex.matcher(filterFile.getName()); if (tileMatcher.matches()) { tiles.add(Integer.valueOf(tileMatcher.group(1))); } } IOUtil.assertFilesAreReadable(Arrays.asList(filterFiles)); tiles.sort(NewIlluminaBasecallsConverter.TILE_NUMBER_COMPARATOR); availableTiles=tiles; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaDataProviderFactory.java,determineFormats,public static Map<SupportedIlluminaFormat Set<IlluminaDataType>>  (final Set<IlluminaDataType> requestedDataTypes final IlluminaFileUtil fileUtil){ final SortedSet<IlluminaDataType> toSupport=new TreeSet<>(requestedDataTypes); final Map<SupportedIlluminaFormat Set<IlluminaDataType>> fileTypeToDataTypes=new EnumMap<>(SupportedIlluminaFormat.class); final Map<IlluminaDataType SupportedIlluminaFormat> dataTypeToFormat=new EnumMap<>(IlluminaDataType.class); for ( final IlluminaDataType ts : toSupport) { final SupportedIlluminaFormat preferredFormat=findPreferredAvailableFormat(ts fileUtil); if (preferredFormat != null) { dataTypeToFormat.put(ts preferredFormat); } } for ( final IlluminaDataType dt : toSupport) { final SupportedIlluminaFormat format=dataTypeToFormat.get(dt); if (format != null) { if (fileTypeToDataTypes.containsKey(format)) { fileTypeToDataTypes.get(format).add(dt); } else { fileTypeToDataTypes.put(dataTypeToFormat.get(dt) makeSet(dt)); } } } return fileTypeToDataTypes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaDataProviderFactory.java,findPreferredAvailableFormat,private static SupportedIlluminaFormat  (final IlluminaDataType dt final IlluminaFileUtil fileUtil){ return findPreferredFormat(dt fileUtil true); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaDataProviderFactory.java,findPreferredFormat,private static SupportedIlluminaFormat  (final IlluminaDataType dt final IlluminaFileUtil fileUtil final boolean checkAvailable){ final List<SupportedIlluminaFormat> preferredFormats=DATA_TYPE_TO_PREFERRED_FORMATS.get(dt); SupportedIlluminaFormat format=null; for (int i=0; i < preferredFormats.size() && format == null; i++) { if (checkAvailable && fileUtil.getUtil(preferredFormats.get(i)).filesAvailable()) { format=preferredFormats.get(i); } else if (!checkAvailable) { format=preferredFormats.get(i); } } return format; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaDataProviderFactory.java,findUnmatchedTypes,public static Set<IlluminaDataType>  (final Set<IlluminaDataType> requestedDataTypes final Map<SupportedIlluminaFormat Set<IlluminaDataType>> formatToMatchedTypes){ final Set<IlluminaDataType> copiedTypes=new HashSet<>(requestedDataTypes); for ( final Set<IlluminaDataType> matchedTypes : formatToMatchedTypes.values()) { copiedTypes.removeAll(matchedTypes); } return copiedTypes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaDataProviderFactory.java,getAvailableTiles,public List<Integer>  (){ return availableTiles; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaDataProviderFactory.java,getOutputReadStructure,public ReadStructure  (){ return outputMapping.getOutputReadStructure(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaDataProviderFactory.java,makeDataProvider,"public BaseIlluminaDataProvider  (List<Integer> requestedTiles){ if (requestedTiles == null) { requestedTiles=availableTiles; } else { if (requestedTiles.isEmpty()) { throw new PicardException(""Zero length tile list supplied to makeDataProvider  you must specify at least 1 tile OR pass NULL to use all available tiles""); } } final Map<IlluminaParser Set<IlluminaDataType>> parsersToDataType=new HashMap<>(); for ( final Map.Entry<SupportedIlluminaFormat Set<IlluminaDataType>> fmToDt : formatToDataTypes.entrySet()) { parsersToDataType.put(makeParser(fmToDt.getKey() requestedTiles) fmToDt.getValue()); } log.debug(""The following parsers will be used by IlluminaDataProvider: "" + StringUtil.join("" "" + parsersToDataType.keySet())); return new IlluminaDataProvider(outputMapping parsersToDataType basecallDirectory lane); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaDataProviderFactory.java,makeParser,"private IlluminaParser  (final SupportedIlluminaFormat format final List<Integer> requestedTiles){ final IlluminaParser parser; switch (format) { case Barcode: parser=new BarcodeParser(((PerTileFileUtil)fileUtil.getUtil(SupportedIlluminaFormat.Barcode)).getFiles(requestedTiles)); break; case Bcl: { final CycleIlluminaFileMap bclFileMap=((PerTilePerCycleFileUtil)fileUtil.getUtil(SupportedIlluminaFormat.Bcl)).getFiles(requestedTiles outputMapping.getOutputCycles()); bclFileMap.assertValid(requestedTiles outputMapping.getOutputCycles()); parser=new BclParser(basecallDirectory lane bclFileMap outputMapping this.applyEamssFiltering bclQualityEvaluationStrategy); break; } case Filter: final IlluminaFileMap filterFileMap=((PerTileFileUtil)fileUtil.getUtil(SupportedIlluminaFormat.Filter)).getFiles(requestedTiles); parser=new FilterParser(filterFileMap); break; case Locs: case Clocs: case Pos: final PerTileFileUtil fu=(PerTileFileUtil)fileUtil.getUtil(format); parser=new PosParser(fu.getFiles(requestedTiles) format); break; case MultiTileFilter: parser=((MultiTileFilterFileUtil)fileUtil.getUtil(SupportedIlluminaFormat.MultiTileFilter)).makeParser(requestedTiles); break; case MultiTileLocs: parser=((MultiTileLocsFileUtil)fileUtil.getUtil(SupportedIlluminaFormat.MultiTileLocs)).makeParser(requestedTiles); break; case MultiTileBcl: { final MultiTileBclFileUtil util=(MultiTileBclFileUtil)fileUtil.getUtil(SupportedIlluminaFormat.MultiTileBcl); final CycleIlluminaFileMap bclFileMap=util.getFiles(requestedTiles outputMapping.getOutputCycles()); bclFileMap.assertValid(requestedTiles outputMapping.getOutputCycles()); parser=new MultiTileBclParser(basecallDirectory lane bclFileMap outputMapping this.applyEamssFiltering bclQualityEvaluationStrategy util.tileIndex); break; } default : throw new PicardException(""Unrecognized data type("" + format + "") found by IlluminaDataProviderFactory!""); } return parser; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaDataProviderFactory.java,setApplyEamssFiltering,public void  (final boolean applyEamssFiltering){ this.applyEamssFiltering=applyEamssFiltering; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaTextIterator.java,IlluminaTextIterator,public  (final int lane final IlluminaFileMap files final boolean treatGroupedDelimitersAsOne){ this(lane files); this.treatGroupedDelimitersAsOne=treatGroupedDelimitersAsOne; currentTile=files.firstKey(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaTextIterator.java,getCurrentFilename,public String  (){ if (parser == null) initializeParser(); return parser.getFileName(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaTextIterator.java,getLane,protected int  (){ return lane; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaTextIterator.java,hasNext,public boolean  (){ if (parser == null) initializeParser(); return parser.hasNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaTextIterator.java,initializeParser,private void  (){ final List<File> fileSubset=files.getFilesStartingAt(currentTile); parser=new BasicInputParser(treatGroupedDelimitersAsOne fileSubset.toArray(new File[fileSubset.size()])); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaTextIterator.java,next,@Override public String[]  (){ if (!hasNext()) { throw new NoSuchElementException(); } return parser.next(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaTextIterator.java,remove,"@Override public void  (){ throw new UnsupportedOperationException(""Remove is not supported by IlluminaTextIterator""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaTextIterator.java,seekToTile,public void  (final int oneBasedTileNumber){ CloserUtil.close(parser); currentTile=oneBasedTileNumber; initializeParser(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\IlluminaTextIterator.java,validateLane,"protected void  (final int lane){ if (lane != getLane()) { throw new PicardException(""Lane number mismatch: "" + lane + "" != ""+ getLane()); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclFileUtil.java,MultiTileBclFileUtil," (final File basecallLaneDir final int lane){ super(""^(\\d{4}).bcl.bgzf$"" "".bcl.bgzf"" basecallLaneDir new MultiTileBclFileFaker() lane); this.basecallLaneDir=basecallLaneDir; bci=new File(basecallLaneDir ""s_"" + lane + "".bci""); final File[] cycleFiles=IOUtil.getFilesMatchingRegexp(base matchPattern); if (bci.exists()) { tileIndex=new TileIndex(bci); if (cycleFiles != null) { for ( final File file : cycleFiles) { final String fileName=file.getName(); final String cycleNum=fileName.substring(0 fileName.indexOf('.')); final IlluminaFileMap fileMap=new IlluminaFileMap(); for ( final Integer tile : tileIndex.getTiles()) { fileMap.put(tile file); } cycleFileMap.put(Integer.valueOf(cycleNum) fileMap); } } } else { tileIndex=null; } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclFileUtil.java,fakeFiles,"@Override public List<String>  (final List<Integer> expectedTiles final int[] expectedCycles final IlluminaFileUtil.SupportedIlluminaFormat format){ if (tileIndex == null) { return Collections.singletonList(""Tile index("" + bci.getAbsolutePath() + "") does "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclFileUtil.java,filesAvailable,@Override public boolean  (){ return bci.exists() && !cycleFileMap.isEmpty(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclFileUtil.java,getFiles,public CycleIlluminaFileMap  (final List<Integer> tiles final int[] cycles){ final ArrayList<Integer> goodCycleList=new ArrayList<Integer>(cycles.length); for ( final int cycle : cycles) { if (cycleFileMap.containsKey(cycle)) { goodCycleList.add(cycle); } } Collections.sort(goodCycleList); final int[] goodCycles=new int[goodCycleList.size()]; for (int i=0; i < goodCycles.length; ++i) { goodCycles[i]=goodCycleList.get(i); } final CycleIlluminaFileMap cycledMap=new CycleIlluminaFileMap(); if (goodCycles.length > 0) { for ( final int cycle : goodCycles) { final IlluminaFileMap fileMap=cycleFileMap.get(cycle).keep(tiles); cycledMap.put(cycle fileMap); } } return cycledMap; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclFileUtil.java,getTiles,@Override public List<Integer>  (){ if (tileIndex == null) { return Collections.emptyList(); } return tileIndex.getTiles(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclFileUtil.java,verify,"@Override public List<String>  (final List<Integer> expectedTiles final int[] expectedCycles){ if (tileIndex == null) { return Collections.singletonList(""Tile index("" + bci.getAbsolutePath() + "") does not exist!""); } final List<String> ret=tileIndex.verif"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileFilterParser.java,MultiTileFilterParser,public  (final TileIndex tileIndex final List<Integer> requestedTiles final File filterFile){ super(tileIndex requestedTiles Collections.singleton(IlluminaDataType.PF)); reader=new FilterFileReader(filterFile); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileFilterParser.java,isPf,@Override public boolean  (){ return nextVal; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileFilterParser.java,readNext,@Override PfData  (){ final boolean nextVal=reader.next(); return new PfData(){ @Override public boolean isPf(){ return nextVal; } } ; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileFilterParser.java,skipRecords,@Override void  (final int numToSkip){ reader.skipRecords(numToSkip); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileFileUtil.java,MultiTileFileUtil," (final String extension final File base final File bciDir final FileFaker fileFaker final int lane){ super(false extension base fileFaker lane); bci=new File(bciDir ""s_"" + lane + "".bci""); if (bci.exists()) { tileIndex=new TileIndex(bci); } else { tileIndex=null; } final File[] filesMatchingRegexp=IOUtil.getFilesMatchingRegexp(base matchPattern); if (filesMatchingRegexp == null || filesMatchingRegexp.length == 0) { dataFile=null; } else if (filesMatchingRegexp.length == 1) { dataFile=filesMatchingRegexp[0]; } else { throw new PicardException(""More than one filter file found in "" + base.getAbsolutePath()); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileFileUtil.java,MultiTileFilterFileUtil," (final File basecallLaneDir final int lane){ super("".filter"" basecallLaneDir basecallLaneDir new FilterFileFaker() lane); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileFileUtil.java,MultiTileLocsFileUtil," (final File basecallLaneDir final File bciDir final int lane){ super("".locs"" basecallLaneDir bciDir new MultiTileLocsFileFaker() lane); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileFileUtil.java,fakeFiles,@Override public List<String>  (final List<Integer> expectedTiles final int[] expectedCycles final IlluminaFileUtil.SupportedIlluminaFormat format){ final BciFileFaker bciFileFaker=new BciFileFaker(); try { bciFileFaker.fakeBciFile(bci expectedTiles); til
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileFileUtil.java,filesAvailable,@Override public boolean  (){ return tileIndex != null && dataFile != null && dataFile.exists(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileFileUtil.java,getTiles,@Override public List<Integer>  (){ if (tileIndex == null) { return Collections.emptyList(); } return tileIndex.getTiles(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileFileUtil.java,makeParser,@Override IlluminaParser<PositionalData>  (final List<Integer> requestedTiles){ return new MultiTileLocsParser(tileIndex requestedTiles dataFile lane); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileFileUtil.java,verify,"@Override public List<String>  (final List<Integer> expectedTiles final int[] expectedCycles){ if (tileIndex == null) { return Collections.singletonList(""Tile index("" + bci.getAbsolutePath() + "") does not exist!""); } return tileIndex.verify(expectedTiles)"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileLocsParser.java,MultiTileLocsParser,public  (final TileIndex tileIndex final List<Integer> requestedTiles final File locsFile final int lane){ super(tileIndex requestedTiles Collections.singleton(IlluminaDataType.Position)); final int tileNumber; if (requestedTiles.size() == 1) tileNumber=requestedTiles.get(0); else tileNumber=-1; this.reader=new LocsFileReader(locsFile lane tileNumber); this.lane=lane; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileLocsParser.java,close,@Override public void  (){ reader.close(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileLocsParser.java,getLane,public int  (){ return lane; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileLocsParser.java,getTile,public int  (){ return tile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileLocsParser.java,getXCoordinate,public int  (){ return nextVal.xQseqCoord; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileLocsParser.java,getYCoordinate,public int  (){ return nextVal.yQseqCoord; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileLocsParser.java,readNext,@Override PositionalData  (){ final int tile=getTileOfNextCluster(); final AbstractIlluminaPositionFileReader.PositionInfo nextVal=reader.next(); return new PositionalData(){ public int getXCoordinate(){ return nextVal.xQseqCoord; } public int getYCoordin
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileLocsParser.java,skipRecords,@Override void  (final int numToSkip){ reader.skipRecords(numToSkip); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclParser.java,CountLimitedIterator, (final BclReader underlyingIterator final int recordLimit){ this.underlyingIterator=underlyingIterator; this.recordLimit=recordLimit; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclParser.java,MultiTileBclDataCycleFileParser,public  (final List<File> files final int currentTile){ this.currentTile=currentTile; reader=makeReader(files); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclParser.java,MultiTileBclParser,public  (final File directory final int lane final CycleIlluminaFileMap tilesToCycleFiles final OutputMapping outputMapping final boolean applyEamssFilter final BclQualityEvaluationStrategy bclQualityEvaluationStrategy final TileIndex tileIndex){ super(directory lane tilesToCycleFiles outputMapping applyEamssFilter bclQualityEvaluationStrategy); this.tileIndex=tileIndex; this.initialize(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclParser.java,close,@Override public void  (){ reader.close(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclParser.java,getCurrentTile,public int  (){ return currentTile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclParser.java,getReader,public BclReader  (){ return reader.getUnderlyingIterator(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclParser.java,getUnderlyingIterator,public BclReader  (){ return underlyingIterator; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclParser.java,hasNext,@Override public boolean  (){ try { return reader.hasNext(); } catch ( final NullPointerException npe) { return false; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclParser.java,initialize,@Override public void  (){ if (tileIndex != null) { seekToTile(currentTile); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclParser.java,makeCycleFileParser,@Override protected CycleFilesParser<BclData>  (final List<File> files){ if (cycleFileParser == null) { cycleFileParser=new MultiTileBclDataCycleFileParser(files currentTile); } else { final int numClustersInTile=cycleFileParser.getReader().seek(files til
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclParser.java,makeReader,private CountLimitedIterator  (final List<File> files){ if (tileIndex != null) { final BclReader bclReader=BclReader.makeSeekable(files bclQualityEvaluationStrategy outputMapping.getOutputReadLengths()); final int numClustersInTile=bclReader.seek(files tileIndex currentTile); return new CountLimitedIterator(bclReader numClustersInTile); } else { return null; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclParser.java,next,@Override public BclData  (){ if (!hasNext()) { throw new NoSuchElementException(); } return reader.next(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclParser.java,remove,@Override public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclParser.java,resetClusterLimit,public void  (final int numClustersInTile){ reader.recordLimit=numClustersInTile; reader.numRecordsRead=0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileBclParser.java,setCurrentTile,public void  (final int currentTile){ this.currentTile=currentTile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileParser.java,MultiTileParser,public  (final TileIndex tileIndex final List<Integer> requestedTiles final Set<IlluminaDataType> supportedTypes){ this.tileIndex=tileIndex; this.tileIndexIterator=tileIndex.iterator(); this.requestedTilesIterator=new PeekIterator<Integer>(requestedTiles.iterator()); this.supportedTypes=supportedTypes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileParser.java,getTileOfNextCluster,@Override public int  (){ if (!hasNext()) { throw new NoSuchElementException(); } if (currentTile != null && nextClusterInTile < currentTile.numClustersInTile) return currentTile.tile; else return requestedTilesIterator.peek(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileParser.java,hasNext,@Override public boolean  (){ while ((currentTile == null || nextClusterInTile >= currentTile.numClustersInTile) && requestedTilesIterator.hasNext()) { seekToTile(requestedTilesIterator.next()); } return currentTile != null && nextClusterInTile < currentT
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\MultiTileParser.java,next,@Override public OUTPUT_RECORD  (){ if (!hasNext()) throw new NoSuchElementException(); OUTPUT_RECORD ret=readNext(); ++nextClusterInTile; ++nextRecordIndex; return ret; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\OutputMapping.java,OutputMapping,public  (final ReadStructure readStructure){ this.outputSubstructure=readStructure.nonSkips; this.cycleToOutputIndex=makeCycleToOutputIndexArray(readStructure); this.outputReadStructure=outputSubstructure.toReadStructure(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\OutputMapping.java,TwoDIndex,public  (final int majorIndex final int minorIndex){ this.majorIndex=majorIndex; this.minorIndex=minorIndex; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\OutputMapping.java,equals,@Override public boolean  (final Object thatObj){ if (thatObj == null || !(thatObj instanceof TwoDIndex)) { return false; } final TwoDIndex that=(TwoDIndex)thatObj; return this.majorIndex == that.majorIndex && this.minorIndex == that.minorIndex; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\OutputMapping.java,getCycleIndexRanges,public Range[]  (){ return outputSubstructure.getCycleIndexRanges(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\OutputMapping.java,getOutputCycles,public int[]  (){ return outputSubstructure.getCycles(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\OutputMapping.java,getOutputDescriptors,public Iterable<ReadDescriptor>  (){ return outputSubstructure; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\OutputMapping.java,getOutputIndexForCycle,public TwoDIndex  (final int cycle){ return cycleToOutputIndex[cycle]; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\OutputMapping.java,getOutputReadLengths,public int[]  (){ return outputSubstructure.getDescriptorLengths(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\OutputMapping.java,getOutputReadStructure,public ReadStructure  (){ return outputReadStructure; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\OutputMapping.java,getTotalOutputCycles,public int  (){ return outputSubstructure.getTotalCycles(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\OutputMapping.java,makeCycleToOutputIndexArray,"private TwoDIndex[]  (final ReadStructure readStructure){ int totalCycles=readStructure.totalCycles; final TwoDIndex[] cycleToOutputIndex=new TwoDIndex[totalCycles + 1]; final int[] outputCycles=getOutputCycles(); final int[] outputLengths=getOutputReadLengths(); int outputCycleIndex=0; int arrIndex=0; int elementIndex=0; for (int i=1; i <= totalCycles && outputCycleIndex < outputCycles.length; i++) { if (outputCycles[outputCycleIndex] == i) { if (elementIndex >= outputLengths[arrIndex]) { elementIndex=0; ++arrIndex; } cycleToOutputIndex[i]=new TwoDIndex(arrIndex elementIndex); ++elementIndex; ++outputCycleIndex; } } if (outputCycleIndex != outputCycles.length) { throw new PicardException(""Error in read structure outputCycles ("" + StringUtil.intValuesToString(outputCycles) + "") and total cycles (""+ totalCycles+ "") OutputCycleIndex(""+ outputCycleIndex+ "")""); } return cycleToOutputIndex; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\OutputMapping.java,numOutputReads,public int  (){ return outputSubstructure.length(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\OutputMapping.java,toString,"@Override public String  (){ return ""TwoDIndex(majorIndex == "" + majorIndex + ""  minorIndex == ""+ minorIndex+ "")""; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ParameterizedFileUtil.java,ParameterizedFileUtil,private  (final String extension final File base final FileFaker faker final int lane final boolean skipEmptyFiles){ this.faker=faker; this.extension=extension; this.base=base; this.lane=lane; this.skipEmptyFiles=skipEmptyFiles; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ParameterizedFileUtil.java,checkTileCount,public boolean  (){ return true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ParameterizedFileUtil.java,escapePeriods,"public static String  (final String preEscaped){ return preEscaped.replaceAll(""\\."" ""\\.""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileCycleParser.java,PerTileCycleParser, (final File directory final int lane final CycleIlluminaFileMap cyclesToTileFiles final OutputMapping outputMapping){ this.tileOrder=getTileOrder(cyclesToTileFiles); this.lane=lane; this.laneDirectory=new File(directory IlluminaFileUtil.longLaneStr(this.lane)); this.cyclesToTileFiles=cyclesToTileFiles; this.currentTile=tileOrder.first(); this.outputMapping=outputMapping; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileCycleParser.java,close,@Override public void  (){ cycleFilesParser.close(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileCycleParser.java,getTileOfNextCluster,public int  (){ if (cycleFilesParser.hasNext()) { return currentTile; } if (currentTile < tileOrder.last()) { return tileOrder.higher(currentTile); } throw new NoSuchElementException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileCycleParser.java,getTileOrder,private TreeSet<Integer>  (final CycleIlluminaFileMap cyclesToTileFiles){ final TreeSet<Integer> uniqueTiles=new TreeSet<Integer>(); for ( final IlluminaFileMap fileMap : cyclesToTileFiles.values()) { uniqueTiles.addAll(fileMap.keySet()); } return uniqueTiles; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileCycleParser.java,hasNext,@Override public boolean  (){ return cycleFilesParser.hasNext() || currentTile < tileOrder.last(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\NewIlluminaDataProvider.java,NewIlluminaDataProvider, (final List<File> cbcls final List<AbstractIlluminaPositionFileReader.PositionInfo> locs final File[] filterFiles final int lane final int tileNum final OutputMapping outputMapping final File barcodeFile){ super(lane outputMapping); Map<Integer File> filterFileMap=new HashMap<>(); for ( File filterFile : filterFiles) { filterFileMap.put(fileToTile(filterFile.getName()) filterFile); } this.reader=new CbclReader(cbcls filterFileMap outputMapping.getOutputReadLengths() tileNum locs outputMapping.getOutputCycles() false); if (barcodeFile != null) { this.barcodeReader=new BarcodeFileReader(barcodeFile); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\NewIlluminaDataProvider.java,close,@Override public void  (){ reader.clear(); reader.close(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\NewIlluminaDataProvider.java,fileToTile,"public static Integer  (final String fileName){ final Matcher matcher=Pattern.compile(""^s_\\d+_(\\d{1 5}).+"").matcher(fileName); if (!matcher.matches()) { return null; } return Integer.parseInt(matcher.group(1)); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\NewIlluminaDataProvider.java,hasNext,@Override public boolean  (){ return reader.hasNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\NewIlluminaDataProvider.java,next,@Override public ClusterData  (){ CbclData cbclData=reader.next(); if (cbclData == null) return null; final ClusterData cluster=new ClusterData(outputReadTypes); cluster.setLane(lane); cluster.setTile(cbclData.getTile()); if (barcodeReader != null) { clus
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileFileUtil.java,PerTileFileUtil,public  (final String extension final File base final FileFaker faker final int lane final boolean skipEmptyFiles){ super(true extension base faker lane skipEmptyFiles); this.fileMap=getTiledFiles(base matchPattern); if (!fileMap.isEmpty()) { this.tiles=new ArrayList<>(this.fileMap.keySet()); } else { this.tiles=Collections.emptyList(); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileFileUtil.java,fakeFiles,"@Override public List<String>  (final List<Integer> expectedTiles final int[] cycles final IlluminaFileUtil.SupportedIlluminaFormat format){ final List<String> failures=new LinkedList<>(); if (!base.exists()) { failures.add(""Base directory("" + base.getAbs"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileFileUtil.java,filesAvailable,@Override public boolean  (){ return !fileMap.isEmpty(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileFileUtil.java,getFiles,public IlluminaFileMap  (final List<Integer> tiles){ return fileMap.keep(tiles); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileFileUtil.java,verify,@Override public List<String>  (final List<Integer> expectedTiles final int[] expectedCycles){ return verifyPerTile(this.base expectedTiles); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileFileUtil.java,verifyPerTile,"List<String>  (File baseDir List<Integer> expectedTiles){ final List<String> failures=new LinkedList<>(); if (!baseDir.exists()) { failures.add(""Base directory("" + baseDir.getAbsolutePath() + "") does not exist!""); } else { if (!tiles.containsAll(expectedTiles)) { final List<Integer> missing=new ArrayList<>(expectedTiles); missing.removeAll(tiles); failures.add(""Missing tile "" + missing + "" for file type ""+ extension+ "".""); } } return failures; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileOrPerRunFileUtil.java,PerTileOrPerRunFileUtil,"public  (String extension File base FileFaker faker int lane){ super(extension base faker lane); Pattern runFileMatchPattern=Pattern.compile(""^s"" + extension + ""$""); runFile=getRunFile(base.getParentFile() runFileMatchPattern); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileOrPerRunFileUtil.java,checkTileCount,@Override public boolean  (){ return runFile == null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileOrPerRunFileUtil.java,filesAvailable,@Override public boolean  (){ return super.filesAvailable() || runFile != null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileOrPerRunFileUtil.java,setTilesForPerRunFile,@Override public void  (List<Integer> tiles){ if (runFile != null) { tiles.forEach(i -> fileMap.put(i runFile)); this.tiles=tiles; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileOrPerRunFileUtil.java,verify,@Override public List<String>  (final List<Integer> expectedTiles final int[] expectedCycles){ final File baseDir=runFile != null ? runFile.getParentFile() : this.base; return verifyPerTile(baseDir expectedTiles); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\Range.java,Range,"public  (final int start final int end){ if (end < start) { throw new PicardException(""Nonsensical Range("" + start + ""  ""+ end+ "")""); } this.start=start; this.end=end; this.length=end - start + 1; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\Range.java,equals,@Override public boolean  (final Object object){ if (object == null || !(object instanceof Range)) { return false; } final Range that=(Range)object; return that.start == this.start && that.end == this.end; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\Range.java,hashCode,@Override public int  (){ return (int)Math.pow(start end); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\Range.java,toString,"@Override public String  (){ return ""Range("" + start + ""  ""+ end+ ""  ""+ length+ "")""; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileParser.java,PerTileParser,"public  (final IlluminaFileMap tilesToFiles final int nextTile){ this.tileToFiles=tilesToFiles; this.currentTile=null; this.nextTile=nextTile; if (!tilesToFiles.containsKey(nextTile)) { throw new IllegalArgumentException(""NextTile ("" + nextTile + "") is not contained by tilesToFiles (""+ StringUtil.join("" "" new ArrayList<Integer>(tilesToFiles.keySet()))); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileParser.java,advanceTile,"private void  (){ if (nextTile == null) { throw new NoSuchElementException(""No more tiles to advance!""); } if (currentIterator != null) { currentIterator.close(); } currentIterator=makeTileIterator(tileToFiles.get(nextTile)); currentTile=nextTile; nextTile=tileToFiles.higherKey(nextTile); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileParser.java,close,public void  (){ if (currentIterator != null) { currentIterator.close(); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileParser.java,getTileOfNextCluster,public int  (){ maybeAdvance(); return currentTile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTileParser.java,hasNext,public boolean  (){ while ((currentIterator == null || !currentIterator.hasNext()) && nextTile != null) { advanceTile(); } return currentIterator != null && currentIterator.hasNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PosParser.java,PosParser,public  (final IlluminaFileMap tilesToFiles final int startingTile final IlluminaFileUtil.SupportedIlluminaFormat fileType){ super(tilesToFiles startingTile); this.fileType=fileType; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PosParser.java,close,public void  (){ reader.close(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PosParser.java,getLane,public int  (){ return nextValue.lane; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PosParser.java,getTile,public int  (){ return nextValue.tile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PosParser.java,getXCoordinate,public int  (){ return nextValue.xQseqCoord; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PosParser.java,getYCoordinate,public int  (){ return nextValue.yQseqCoord; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PosParser.java,hasNext,public boolean  (){ return reader.hasNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PosParser.java,makeTileIterator,@Override protected CloseableIterator<PositionalData>  (final File file){ final AbstractIlluminaPositionFileReader fileReader; switch (fileType) { case Pos: fileReader=new PosFileReader(file); break; case Locs: fileReader=new LocsFileReader(file); break; 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PosParser.java,next,public PositionalData  (){ final AbstractIlluminaPositionFileReader.PositionInfo nextValue=reader.next(); return new PositionalData(){ public int getXCoordinate(){ return nextValue.xQseqCoord; } public int getYCoordinate(){ return nextValue.yQseqCoord; } public int getLane(){ return nextValue.lane; } public int getTile(){ return nextValue.tile; } } ; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PosParser.java,remove,public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PosParser.java,supportedTypes,@Override public Set<IlluminaDataType>  (){ return supportedTypes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadData.java,ReadData,public  (ReadType readType){ this.readType=readType; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadData.java,getBases,public byte[]  (){ return bases; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadData.java,getNoise,public FourChannelIntensityData  (){ return noise; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadData.java,getQualities,public byte[]  (){ return qualities; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadData.java,getRawIntensities,public FourChannelIntensityData  (){ return rawIntensities; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadData.java,getReadType,public ReadType  (){ return readType; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadData.java,setBases,public void  (final byte[] bases){ this.bases=bases; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadData.java,setNoise,public void  (final FourChannelIntensityData noise){ this.noise=noise; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadData.java,setQualities,public void  (final byte[] qualities){ this.qualities=qualities; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadData.java,setRawIntensities,public void  (final FourChannelIntensityData rawIntensities){ this.rawIntensities=rawIntensities; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadData.java,setReadType,public void  (final ReadType readType){ this.readType=readType; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTilePerCycleFileUtil.java,PerTilePerCycleFileUtil,public  (final String extension final File base final FileFaker faker final int lane){ super(true extension base faker lane); this.cycleFileMap=getPerTilePerCycleFiles(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTilePerCycleFileUtil.java,fakeFiles,@Override public List<String>  (final List<Integer> expectedTiles final int[] expectedCycles final IlluminaFileUtil.SupportedIlluminaFormat format){ final List<String> failures=new LinkedList<String>(); if (!base.exists()) { base.mkdirs(); } final Set<Int
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTilePerCycleFileUtil.java,filesAvailable,public boolean  (){ boolean filesAvailable=false; for ( final IlluminaFileMap fileMap : cycleFileMap.values()) { if (!fileMap.isEmpty()) { filesAvailable=true; break; } } return filesAvailable; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTilePerCycleFileUtil.java,getCycleFromDir,"public static int  (final File tempCycleDir){ final String fileName=tempCycleDir.getName(); final Matcher matcher=IlluminaFileUtil.CYCLE_SUBDIRECTORY_PATTERN.matcher(fileName); if (!matcher.matches()) { throw new PicardException(""Invalid cycle directory name "" + tempCycleDir.getName()); } return Integer.parseInt(matcher.group(1)); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTilePerCycleFileUtil.java,getDetectedCycles,public Set<Integer>  (){ return detectedCycles; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTilePerCycleFileUtil.java,getFileForCycle,"private String  (final int currentCycle final int tile){ return ""C"" + currentCycle + "".1""+ File.separator+ ""s_""+ lane+ ""_""+ tile+ extension; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTilePerCycleFileUtil.java,getFiles,public CycleIlluminaFileMap  (final List<Integer> tiles final int[] cycles){ final Set<Integer> filteredCycles=removeNonExistentCycles(cycles); return cycleFileMap.keep(tiles filteredCycles); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTilePerCycleFileUtil.java,getPerTilePerCycleFiles,protected CycleIlluminaFileMap  (){ final CycleIlluminaFileMap cycledMap=new CycleIlluminaFileMap(); final File laneDir=base; final File[] tempCycleDirs; tempCycleDirs=IOUtil.getFilesMatchingRegexp(laneDir IlluminaFileUtil.CYCLE_SUBDIRECTORY_PATTERN); if (tempCycleDirs == null || tempCycleDirs.length == 0) { return cycledMap; } for ( final File tempCycleDir : tempCycleDirs) { detectedCycles.add(getCycleFromDir(tempCycleDir)); } final Set<Integer> uniqueTiles=new HashSet<Integer>(); for ( final File cycleDir : tempCycleDirs) { final IlluminaFileMap fileMap=getTiledFiles(cycleDir matchPattern); uniqueTiles.addAll(fileMap.keySet()); cycledMap.put(getCycleFromDir(cycleDir) fileMap); } this.tiles=new ArrayList<>(uniqueTiles); return cycledMap; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTilePerCycleFileUtil.java,getTiles,public List<Integer>  (){ return tiles; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTilePerCycleFileUtil.java,removeNonExistentCycles,private Set<Integer>  (final int[] cycles){ final TreeSet<Integer> inputCyclesSet=new TreeSet<Integer>(); for ( final Integer inputCycle : cycles) { inputCyclesSet.add(inputCycle); } inputCyclesSet.retainAll(detectedCycles); return inputCyclesSet; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\PerTilePerCycleFileUtil.java,verify,@Override public List<String>  (final List<Integer> expectedTiles final int[] expectedCycles){ final List<String> failures=new LinkedList<String>(); final Map<Integer Long> tileToFileLengthMap=new HashMap<Integer Long>(); if (!base.exists()) { failures.ad
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadDescriptor.java,ReadDescriptor,public  (final int length final ReadType type){ this.length=length; this.type=type; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadDescriptor.java,equals,public boolean  (final Object other){ if (this == other) return true; if (other.getClass() != this.getClass()) return false; final ReadDescriptor that=(ReadDescriptor)other; return this.length == that.length && this.type == that.type; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadDescriptor.java,hashCode,@Override public int  (){ return 31 * this.type.ordinal() + 379 * length; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadDescriptor.java,toString,@Override public String  (){ return this.length + this.type.name(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BarcodeFileReader.java,BarcodeFileReader,public  (final File barcodeFile){ this.textIterator=new BasicInputParser(false barcodeFile); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BarcodeFileReader.java,close,public void  (){ textIterator.close(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BarcodeFileReader.java,hasNext,@Override public boolean  (){ return textIterator.hasNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BarcodeFileReader.java,next,"@Override public String  (){ final String[] fields=textIterator.next(); final String barcode; if (fields[Y_OR_N_COLUMN].equals(""Y"")) { barcode=fields[BARCODE_COLUMN]; } else { barcode=null; } return barcode; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BarcodeFileReader.java,remove,"public void  (){ throw new UnsupportedOperationException(""Remove is not supported by "" + BarcodeFileReader.class.getName()); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\AbstractIlluminaPositionFileReader.java,AbstractIlluminaPositionFileReader,public  (final File file final int lane final int tile){ this.file=file; this.lane=lane; this.tile=tile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\AbstractIlluminaPositionFileReader.java,PositionInfo,"public  (final float x final float y final int lane final int tile){ if (x < MIN_POS || y < MIN_POS || x > MAX_POS || y > MAX_POS) { throw new IllegalArgumentException(String.format(""Cluster location not in the range %f..%f. x: %f; y: %f; lane: %d; tile: %d"" MIN_POS MAX_POS x y lane tile)); } this.xPos=x; this.yPos=y; this.xQseqCoord=posToQSeqCoord(x); this.yQseqCoord=posToQSeqCoord(y); this.lane=lane; this.tile=tile; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\AbstractIlluminaPositionFileReader.java,equals,public boolean  (final Object other){ if (other == null || other.getClass() != AbstractIlluminaPositionFileReader.PositionInfo.class) { return false; } if (other == this) return true; final PositionInfo otherPi=(PositionInfo)other; return this.xPos == otherPi.xPos && this.yPos == otherPi.yPos && this.lane == otherPi.lane && this.tile == otherPi.tile && this.xQseqCoord == otherPi.xQseqCoord && this.yQseqCoord == otherPi.yQseqCoord; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\AbstractIlluminaPositionFileReader.java,fileNameToLaneAndTile,"private int[]  (final String fileName){ final String[] tokens=fileName.split(File.pathSeparator); final Matcher matcher=FileNamePattern.matcher(tokens[tokens.length - 1]); if (!matcher.matches()) { throw new PicardException(""File name not of the right structure: <filePath>/s_<lane>_<tile>(_pos.txt|_pos.txt.gz|_pos.txt.bz2.locs|.clocs). File name ("" + fileName + "")""); } return new int[]{Integer.parseInt(matcher.group(1)) Integer.parseInt(matcher.group(2))}; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\AbstractIlluminaPositionFileReader.java,getFile,public File  (){ return file; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\AbstractIlluminaPositionFileReader.java,getLane,public int  (){ return lane; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\AbstractIlluminaPositionFileReader.java,getTile,public int  (){ return tile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BaseBclReader.java,BaseBclReader, (int[] outputLengths){ this.outputLengths=outputLengths; int cycles=0; for ( final int outputLength : outputLengths) { cycles+=outputLength; } this.cycles=cycles; this.streams=new InputStream[cycles]; this.streamFiles=new File[cycles]; this.numClustersPerCycle=new int[cycles]; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BaseBclReader.java,CycleData, (final short version final int headerSize final byte bitsPerBasecall final byte bitsPerQualityScore final int numberOfBins final byte[] qualityBins final int numTiles final TileData tileInfo final boolean pfExcluded){ this.version=version; this.headerSize=headerSize; this.bitsPerBasecall=bitsPerBasecall; this.bitsPerQualityScore=bitsPerQualityScore; this.numberOfBins=numberOfBins; this.qualityBins=qualityBins; this.numTiles=numTiles; this.tileInfo=tileInfo; this.pfExcluded=pfExcluded; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BaseBclReader.java,TileData, (final int tileNum final int numClustersInTile final int uncompressedBlockSize final int compressedBlockSize long filePosition){ this.tileNum=tileNum; this.numClustersInTile=numClustersInTile; this.uncompressedBlockSize=uncompressedBlockSize; this.compressedBlockSize=compressedBlockSize; this.filePosition=filePosition; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BaseBclReader.java,decodeBasecall,void  (final BclData bclData final int read final int cycle final int byteToDecode){ if (byteToDecode == 0) { bclData.bases[read][cycle]=(byte)'.'; bclData.qualities[read][cycle]=(byte)2; } else { bclData.bases[read][cycle]=BASE_LOOKUP[byteToDecode & BASE_MASK]; bclData.qualities[read][cycle]=bclQualityEvaluationStrategy.reviseAndConditionallyLogQuality((byte)(byteToDecode >>> 2)); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BaseBclReader.java,decodeQualityBinnedBasecall,void  (final BclData bclData final int read final int cycle final int byteToDecode final CycleData cycleData){ if (byteToDecode == 0) { bclData.bases[read][cycle]=(byte)'.'; bclData.qualities[read][cycle]=2; } else { bclData.bases[read][cycle]=BASE_LOOKUP[byteToDecode & BASE_MASK]; bclData.qualities[read][cycle]=cycleData.qualityBins[byteToDecode >>> 2]; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BaseBclReader.java,getCompressedBlockSize,public int  (){ return compressedBlockSize; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BaseBclReader.java,getNumClusters,int  (){ return numClustersPerCycle[0]; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BaseBclReader.java,getNumClustersInTile,int  (){ return numClustersInTile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BaseBclReader.java,getTileInfo,public TileData  (){ return tileInfo; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BaseBclReader.java,getTileNum,public int  (){ return tileNum; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BaseBclReader.java,open,"InputStream  (final File file final boolean seekable final boolean isGzip final boolean isBgzf){ final String filePath=file.getAbsolutePath(); try { if (isBgzf) { return new BlockCompressedInputStream(IOUtil.maybeBufferedSeekableStream(file)); } else if (isGzip) { if (seekable) { throw new IllegalArgumentException(String.format(""Cannot create a seekable reader for gzip bcl: %s."" filePath)); } return (IOUtil.maybeBufferInputStream(new GZIPInputStream(new FileInputStream(file) Defaults.BUFFER_SIZE / 2) Defaults.BUFFER_SIZE / 2)); } else { if (seekable) { throw new IllegalArgumentException(String.format(""Cannot create a seekable reader for provided bcl: %s."" filePath)); } return IOUtil.maybeBufferInputStream(new FileInputStream(file)); } } catch ( final FileNotFoundException fnfe) { throw new PicardException(""File not found: ("" + filePath + "")"" fnfe); } catch ( final IOException ioe) { throw new PicardException(""Error reading file: ("" + filePath + "")"" ioe); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclIndexReader.java,BclIndexReader,"public  (final File bclFile){ bciFile=new File(bclFile.getAbsolutePath() + "".bci""); bciIterator=MMapBackedIteratorFactory.getLongIterator(BCI_HEADER_SIZE bciFile); final ByteBuffer headerBytes=bciIterator.getHeaderBytes(); final int actualVersion=headerBytes.getInt(); if (actualVersion != BCI_VERSION) { throw new PicardException(String.format(""Unexpected version number %d in %s"" actualVersion bciFile.getAbsolutePath())); } numTiles=headerBytes.getInt(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclIndexReader.java,get,"public long  (final int recordNumber){ if (recordNumber < nextRecordNumber) { throw new IllegalArgumentException(""Can only read forward""); } if (recordNumber > nextRecordNumber) { bciIterator.skipElements(recordNumber - nextRecordNumber); nextRecordNumber=recordNumber; } ++nextRecordNumber; return bciIterator.getElement(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclIndexReader.java,getBciFile,public File  (){ return bciFile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclIndexReader.java,getNumTiles,public int  (){ return numTiles; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclQualityEvaluationStrategy.java,BclQualityEvaluationStrategy,public  (final int minimumRevisedQuality){ this.minimumRevisedQuality=minimumRevisedQuality; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclQualityEvaluationStrategy.java,assertMinimumQualities,"public void  (){ final Collection<String> errorTokens=new LinkedList<String>(); for ( final Map.Entry<Byte AtomicInteger> entry : this.qualityCountMap.entrySet()) { if (generateRevisedQuality(entry.getKey()) < minimumRevisedQuality) { errorTokens.add(String.format(""quality %s observed %s times"" entry.getKey() entry.getValue())); } } if (!errorTokens.isEmpty()) { throw new PicardException(String.format(""Found BCL qualities that fell beneath minimum threshold of %s: %s."" minimumRevisedQuality CollectionUtil.join(errorTokens ""; ""))); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclQualityEvaluationStrategy.java,generateRevisedQuality,private static byte  (final byte quality){ return (byte)Math.max(quality 1); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclQualityEvaluationStrategy.java,getPoorQualityFrequencies,public Map<Byte Integer>  (){ final Map<Byte Integer> qualityCountMapCopy=new HashMap<Byte Integer>(); for ( final Map.Entry<Byte AtomicInteger> entry : qualityCountMap.entrySet()) { qualityCountMapCopy.put(entry.getKey() entry.getValue().intValue()); } return Collections.unmodifiableMap(qualityCountMapCopy); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclQualityEvaluationStrategy.java,make,@Override public AtomicInteger  (final Byte key){ return new AtomicInteger(0); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclQualityEvaluationStrategy.java,reviseAndConditionallyLogQuality,public byte  (final byte quality){ final byte revisedQuality=generateRevisedQuality(quality); if (quality < ILLUMINA_ALLEGED_MINIMUM_QUALITY) { qualityCountMap.get(quality).incrementAndGet(); } return revisedQuality; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclReader.java,BclReader,"public  (final File bclFile final BclQualityEvaluationStrategy bclQualityEvaluationStrategy final boolean seekable){ super(new int[]{1} bclQualityEvaluationStrategy); try { final ByteBuffer byteBuffer=ByteBuffer.allocate(HEADER_SIZE); final String filePath=bclFile.getName(); final boolean isGzip=filePath.endsWith("".gz""); final boolean isBgzf=filePath.endsWith("".bgzf""); final InputStream stream=open(bclFile seekable isGzip isBgzf); final int read=stream.read(byteBuffer.array()); if (read != HEADER_SIZE) { throw new RuntimeIOException(String.format(""BCL %s has invalid header structure."" bclFile.getAbsoluteFile())); } byteBuffer.order(ByteOrder.LITTLE_ENDIAN); this.numClustersPerCycle[0]=byteBuffer.getInt(); if (!isBgzf && !isGzip) { assertProperFileStructure(bclFile this.getNumClusters() stream); } this.streams[0]=stream; this.streamFiles[0]=bclFile; } catch ( final IOException ioe) { throw new PicardException(""IOException opening file "" + bclFile.getAbsoluteFile() ioe); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclReader.java,advance,"void  (){ int totalCycleCount=0; final BclData data=new BclData(outputLengths); for (int read=0; read < outputLengths.length; read++) { for (int cycle=0; cycle < outputLengths[read]; ++cycle) { try { final int readByte; try { readByte=this.streams[totalCycleCount].read(); } catch ( IOException e) { throw new IOException(String.format(""Error while reading from BCL file for cycle %d. Offending file on disk is %s"" (totalCycleCount + 1) this.streamFiles[totalCycleCount].getAbsolutePath()) e); } if (readByte == -1) { queue=null; return; } decodeBasecall(data read cycle readByte); totalCycleCount++; } catch ( final IOException ioe) { throw new RuntimeIOException(ioe); } } } this.queue=data; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclReader.java,assertProperFileStructure,"protected void  (final File file){ final long elementsInFile=file.length() - HEADER_SIZE; if (getNumClusters() != elementsInFile) { throw new PicardException(""Expected "" + getNumClusters() + "" in file ""+ file.getAbsolutePath()+ "" but found ""+ elementsInFile); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclReader.java,close,public void  (){ for ( final InputStream stream : this.streams) { CloserUtil.close(stream); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclReader.java,getNumberOfClusters,"private static long  (final String filePath final InputStream inputStream){ final byte[] header=new byte[HEADER_SIZE]; try { final int headerBytesRead=inputStream.read(header); if (headerBytesRead != HEADER_SIZE) { throw new PicardException(""Malformed file  expected header of size "" + HEADER_SIZE + "" but received ""+ headerBytesRead); } } catch ( final IOException ioe) { throw new PicardException(""Unable to read header for file ("" + filePath + "")"" ioe); } final ByteBuffer headerBuf=ByteBuffer.wrap(header); headerBuf.order(ByteOrder.LITTLE_ENDIAN); return UnsignedTypeUtil.uIntToLong(headerBuf.getInt()); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclReader.java,hasNext,@Override public boolean  (){ if (queue == null) { advance(); } return queue != null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclReader.java,isBlockGzipped,"public static boolean  (final File file){ return file.getAbsolutePath().endsWith("".bgzf""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclReader.java,isGzipped,"public static boolean  (final File file){ return file.getAbsolutePath().endsWith("".gz""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclReader.java,makeSeekable,public static BclReader  (final List<File> files final BclQualityEvaluationStrategy bclQualityEvaluationStrategy final int[] outputLengths){ return new BclReader(files outputLengths bclQualityEvaluationStrategy true); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclReader.java,next,public BclData  (){ if (queue == null) { advance(); } final BclData data=queue; queue=null; return data; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclReader.java,remove,@Override public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\BclReader.java,seek,"public int  (final List<File> files final TileIndex tileIndex final int currentTile){ int count=0; int numClustersInTile=0; for ( final InputStream inputStream : streams) { final TileIndex.TileIndexRecord tileIndexRecord=tileIndex.findTile(currentTile); final BclIndexReader bclIndexReader=new BclIndexReader(files.get(count)); final long virtualFilePointer=bclIndexReader.get(tileIndexRecord.getZeroBasedTileNumber()); if (!(inputStream instanceof BlockCompressedInputStream)) { throw new UnsupportedOperationException(""Seeking only allowed on bzgf""); } else { try { if (tileIndex.getNumTiles() != bclIndexReader.getNumTiles()) { throw new PicardException(String.format(""%s.getNumTiles(%d) != %s.getNumTiles(%d)"" tileIndex.getFile().getAbsolutePath() tileIndex.getNumTiles() bclIndexReader.getBciFile().getAbsolutePath() bclIndexReader.getNumTiles())); } ((BlockCompressedInputStream)inputStream).seek(virtualFilePointer); numClustersInTile=tileIndexRecord.getNumClustersInTile(); } catch ( final IOException e) { throw new PicardException(""Problem seeking to "" + virtualFilePointer e); } } count++; } return numClustersInTile; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\ClocsFileReader.java,ClocsFileReader,public  (final File clocsFile){ super(clocsFile); byteIterator=MMapBackedIteratorFactory.getByteIterator(HEADER_SIZE clocsFile); final ByteBuffer hbs=byteIterator.getHeaderBytes(); hbs.get(); numBins=UnsignedTypeUtil.uIntToLong(hbs.getInt()); xOffset=0; yOffset=0; currentBin=0; startBlock(); checkAndAdvanceBin(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\ClocsFileReader.java,checkAndAdvanceBin,private void  (){ while (currentClusterInBin >= numClustersInBin && currentBin < numBins) { if ((currentBin + 1) % NUM_BINS_IN_ROW == 0) { xOffset=0; yOffset+=BLOCK_SIZE; } else { xOffset+=BLOCK_SIZE; } currentBin+=1; if (currentBin < numBins) { startBlock(); } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\ClocsFileReader.java,hasNext,"@Override public boolean  (){ boolean valuesRemain=currentClusterInBin < numClustersInBin || currentBin < (numBins - 1); if (!valuesRemain && byteIterator.hasNext()) { throw new PicardException(""Read the number of expected bins( "" + numBins + "") but still"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\ClocsFileReader.java,makeExceptionMsg,"@Override protected String  (){ return ""ClocsFileReader(file="" + getFile().getName() + ""  lane=""+ getLane()+ ""  tile=""+ getTile()+ ""  currentBin=""+ currentBin+ ""  numBins=""+ numBins+ ""  xOffset=""+ xOffset+ ""  yOffset""+ yOffset+ ""  currentBlock=""+ currentC"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\ClocsFileReader.java,startBlock,private void  (){ numClustersInBin=UnsignedTypeUtil.uByteToInt(byteIterator.next()); currentClusterInBin=0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\ClocsFileReader.java,unsafeNextInfo,@Override protected PositionInfo  (){ final byte xByte=byteIterator.next(); final byte yByte=byteIterator.next(); final float xPos=UnsignedTypeUtil.uByteToInt(xByte) / 10f + xOffset; final float yPos=UnsignedTypeUtil.uByteToInt(yByte) / 10f + yOffset; ++c
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\EmpiricalPhasingMetricsOutReader.java,EmpiricalPhasingMetricsOutReader,public  (File phasingMetricsOutFile){ bbIterator=MMapBackedIteratorFactory.getByteBufferIterator(HEADER_SIZE RECORD_SIZE phasingMetricsOutFile); bbIterator.getHeaderBytes(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\EmpiricalPhasingMetricsOutReader.java,IlluminaPhasingMetrics, (final ByteBuffer bb){ this.laneTileCode=new TileMetricsOutReader.IlluminaLaneTileCode(UnsignedTypeUtil.uShortToInt(bb.getShort()) bb.getInt() 0); this.cycle=UnsignedTypeUtil.uShortToInt(bb.getShort()); this.phasingWeight=bb.getFloat(); this.prephasingWeight=bb.getFloat(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\EmpiricalPhasingMetricsOutReader.java,hasNext,@Override public boolean  (){ return bbIterator.hasNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\EmpiricalPhasingMetricsOutReader.java,next,@Override public IlluminaPhasingMetrics  (){ if (!hasNext()) { throw new NoSuchElementException(); } return new IlluminaPhasingMetrics(bbIterator.next()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\LocsFileReader.java,LocsFileReader,public  (final File file final int lane final int tile){ super(file lane tile); initialize(file); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\LocsFileReader.java,close,public void  (){ bbIterator=null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\LocsFileReader.java,hasNext,@Override public boolean  (){ return nextCluster < numClusters; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\LocsFileReader.java,initialize,"private void  (final File file){ bbIterator=MMapBackedIteratorFactory.getFloatIterator(HEADER_SIZE file); final ByteBuffer headerBuf=bbIterator.getHeaderBytes(); final int firstValue=headerBuf.getInt(); if (firstValue != BYTES_1_TO_4) { throw new PicardException(""First header byte of locs files should be "" + BYTES_1_TO_4 + "" value found(""+ firstValue+ "")""); } final float versionNumber=headerBuf.getFloat(); if (versionNumber != VERSION) { throw new PicardException(""First header byte of locs files should be "" + VERSION + "" value found(""+ firstValue+ "")""); } numClusters=UnsignedTypeUtil.uIntToLong(headerBuf.getInt()); bbIterator.assertTotalElementsEqual(numClusters * 2); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\LocsFileReader.java,makeExceptionMsg,"@Override protected String  (){ return ""LocsFileReader(file="" + getFile().getAbsolutePath() + ""  numClusters=""+ numClusters+ "") ""; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\LocsFileReader.java,skipRecords,public void  (final int numToSkip){ bbIterator.skipElements(numToSkip * 2); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\LocsFileReader.java,unsafeNextInfo,@Override protected PositionInfo  (){ final float xVal=bbIterator.next(); final float yVal=bbIterator.next(); ++nextCluster; return new PositionInfo(xVal yVal getLane() getTile()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\FilterFileReader.java,FilterFileReader,"public  (final File file){ bbIterator=MMapBackedIteratorFactory.getByteIterator(HEADER_SIZE file); final ByteBuffer headerBuf=bbIterator.getHeaderBytes(); for (int i=0; i < 4; i++) { final byte b=headerBuf.get(); if (b != 0) { throw new PicardException(""The first four bytes of a Filter File should be 0 but byte "" + i + "" was ""+ b+ "" in file ""+ file.getAbsolutePath()); } } version=headerBuf.getInt(); if (version != EXPECTED_VERSION) { throw new PicardException(""Expected version is "" + EXPECTED_VERSION + "" but version found was ""+ version+ "" in file ""+ file.getAbsolutePath()); } numClusters=UnsignedTypeUtil.uIntToLong(headerBuf.getInt()); bbIterator.assertTotalElementsEqual(numClusters); currentCluster=0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\FilterFileReader.java,hasNext,public boolean  (){ return currentCluster < numClusters; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\FilterFileReader.java,next,"public Boolean  (){ final byte value=bbIterator.next(); currentCluster+=1; if (value == PassedFilter) { return true; } else if (value == FailedFilter) { return false; } else { String hexVal=Integer.toHexString(value); hexVal=(hexVal.length() < 2 ? ""0x0"" : ""0x"") + hexVal; throw new PicardException(""Didn't recognized PF Byte ("" + hexVal + "")""+ "" for element (""+ currentCluster+ "") in file(""+ bbIterator.getFile().getAbsolutePath()+ "")""); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\FilterFileReader.java,remove,public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\FilterFileReader.java,skipRecords,public void  (final int numToSkip){ bbIterator.skipElements(numToSkip); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\MMapBackedIteratorFactory.java,BinaryFileIterator,public  (final byte[] header final File file final int elementSize){ this.header=header; this.file=file; this.fileSize=file.length(); this.elementSize=elementSize; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\MMapBackedIteratorFactory.java,ByteBufferMMapIterator,public  (final byte[] header final File file final int elementBufferSize final ByteBuffer buf){ super(header file elementBufferSize buf); this.localBacking=new byte[elementBufferSize]; this.localBuffer=ByteBuffer.wrap(localBacking); this.localBuffer.order(ByteOrder.LITTLE_ENDIAN); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\MMapBackedIteratorFactory.java,ByteMMapIterator,public  (final byte[] header final File file final ByteBuffer buf){ super(header file BYTE_SIZE buf); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\MMapBackedIteratorFactory.java,FloatMMapIterator,public  (final byte[] header final File file final ByteBuffer buf){ super(header file FLOAT_SIZE buf); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\MMapBackedIteratorFactory.java,IntegerMMapIterator,public  (final byte[] header final File file final ByteBuffer buf){ super(header file INT_SIZE buf); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\MMapBackedIteratorFactory.java,LongMMapIterator,public  (final byte[] header final File file final ByteBuffer buf){ super(header file LONG_SIZE buf); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\MMapBackedIteratorFactory.java,MMapBackedIterator,protected  (final byte[] header final File file final int elementSize final ByteBuffer buffer){ super(header file elementSize); this.buffer=buffer; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\MMapBackedIteratorFactory.java,assertTotalElementsEqual,"public void  (final long numElements){ if (getElementsInFile() != numElements) { throw new PicardException(""Expected "" + numElements + "" elements in file but found ""+ getElementsInFile()+ "" elements! File(""+ file.getAbsolutePath()+ "")""); } if (getExtraBytes() != 0) { throw new PicardException(""Malformed file  expected "" + (header.length + numElements * elementSize) + "" bytes in file  found ""+ fileSize+ "" bytes for file(""+ file.getAbsolutePath()+ "")""); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\MMapBackedIteratorFactory.java,checkFactoryVars,"private static void  (final int headerSize final File binaryFile){ IOUtil.assertFileIsReadable(binaryFile); if (headerSize < 0) { throw new PicardException(""Header size cannot be negative. HeaderSize("" + headerSize + "") for file ""+ binaryFile.getAbsolutePath()); } if (headerSize > binaryFile.length()) { throw new PicardException(""Header size("" + headerSize + "") is greater than file size(""+ binaryFile.length()+ "") for file ""+ binaryFile.getAbsolutePath()); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\MMapBackedIteratorFactory.java,getBuffer,"private static ByteBuffer  (final File binaryFile){ final ByteBuffer buf; try { final FileInputStream is=new FileInputStream(binaryFile); final FileChannel channel=is.getChannel(); final long fileSize=channel.size(); buf=channel.map(FileChannel.MapMode.READ_ONLY 0 fileSize); buf.order(ByteOrder.LITTLE_ENDIAN); CloserUtil.close(channel); CloserUtil.close(is); } catch ( IOException e) { throw new PicardException(""IOException opening cluster binary file "" + binaryFile e); } return buf; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\MMapBackedIteratorFactory.java,getByteBufferIterator,public static BinaryFileIterator<ByteBuffer>  (final int headerSize final int elementSize final File binaryFile){ checkFactoryVars(headerSize binaryFile); final ByteBuffer buf=getBuffer(binaryFile); final byte[] header=getHeader(buf headerSize); return new ByteBufferMMapIterator(header binaryFile elementSize buf); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\MMapBackedIteratorFactory.java,getByteIterator,public static BinaryFileIterator<Byte>  (final int headerSize final File binaryFile){ checkFactoryVars(headerSize binaryFile); final ByteBuffer buf=getBuffer(binaryFile); final byte[] header=getHeader(buf headerSize); return new ByteMMapIterator(header binaryFile buf); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\CbclReader.java,CbclReader,"public  (final List<File> cbcls final Map<Integer File> filterFileMap final int[] outputLengths final int tileNum final List<AbstractIlluminaPositionFileReader.PositionInfo> locs final int[] outputCycles final boolean headerOnly){ super(outputLengths); if (!filterFileMap.containsKey(tileNum)) { throw new PicardException(""Filter file for tile "" + tileNum + "" does not exist.""); } this.outputCycles=outputCycles; surfaceToTileToCbclMap=sortCbcls(cbcls); this.filterFileMap=filterFileMap; cycleData=new CycleData[cycles]; cachedTile=new byte[cycles][]; cachedTilePosition=new int[cycles]; for (int i=1; i <= cycles; i++) { allTiles.put(i new ArrayList<>()); } try { readSurfaceTile(tileNum locs headerOnly); } finally { close(); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\CbclReader.java,advance,private void  (){ int totalCycleCount=0; final CbclData data=new CbclData(outputLengths cycleData[totalCycleCount].tileInfo.tileNum); for (int read=0; read < outputLengths.length; read++) { for (int cycle=0; cycle < outputLengths[read]; cycle++) { final CycleData currentCycleData=cycleData[totalCycleCount]; if (cachedTilePosition[totalCycleCount] >= cachedTile[totalCycleCount].length || cachedTilePosition[totalCycleCount] >= cycleData[totalCycleCount].getTileInfo().getNumClustersInTile()) { return; } final int singleByte=cachedTile[totalCycleCount][cachedTilePosition[totalCycleCount]++]; decodeQualityBinnedBasecall(data read cycle singleByte currentCycleData); totalCycleCount++; } } data.setPositionInfo(positionInfoIterator.next()); this.queue=data; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\CbclReader.java,cacheFilterAndLocs,private void  (final TileData currentTileData final List<AbstractIlluminaPositionFileReader.PositionInfo> locs){ final List<Boolean> filterValues=new ArrayList<>(); final FilterFileReader reader=new FilterFileReader(filterFileMap.get(currentTileData.tileNum)); final Iterator<AbstractIlluminaPositionFileReader.PositionInfo> positionInfoIterator=locs.iterator(); while (reader.hasNext()) { filterValues.add(reader.next()); } final List<AbstractIlluminaPositionFileReader.PositionInfo> positions=new ArrayList<>(); for ( final boolean filterValue : filterValues) { final AbstractIlluminaPositionFileReader.PositionInfo info=positionInfoIterator.next(); if (filterValue) { positions.add(info); } } this.positionInfoIterator=positions.iterator(); cachedFilter.put(currentTileData.tileNum filterValues); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\CbclReader.java,cacheTile,"private void  (final int totalCycleCount final TileData tileData final CycleData currentCycleData) throws IOException { final byte[] tileByteArray=new byte[tileData.compressedBlockSize]; final InputStream stream=this.streams[totalCycleCount]; long dataLeft=tileData.filePosition - stream.skip(tileData.filePosition); while (dataLeft > 0) { dataLeft-=stream.skip(dataLeft); } final int readBytes=stream.read(tileByteArray); if (readBytes != tileData.compressedBlockSize) { throw new PicardException(String.format(""Error while reading from BCL file for cycle %d. Offending file on disk is %s"" (totalCycleCount + 1) this.streamFiles[totalCycleCount].getAbsolutePath())); } final ByteArrayInputStream byteInputStream=new ByteArrayInputStream(Arrays.copyOfRange(tileByteArray 0 readBytes)); byte[] decompressedByteArray=decompressTile(totalCycleCount tileData byteInputStream); byte[] unNibbledByteArray=promoteNibblesToBytes(decompressedByteArray); cachedTile[totalCycleCount]=filterNonPfReads(tileData currentCycleData unNibbledByteArray); cachedTilePosition[totalCycleCount]=0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\CbclReader.java,clear,public void  (){ cachedTile=null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\CbclReader.java,close,@Override public void  (){ for ( final InputStream stream : this.streams) { CloserUtil.close(stream); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\CbclReader.java,decompressTile,"private byte[]  (int totalCycleCount TileData tileData ByteArrayInputStream byteInputStream) throws IOException { final byte[] decompressedByteArray=new byte[tileData.uncompressedBlockSize]; if (decompressedByteArray.length == 0) { log.warn(""Ignoring tile "" + tileData.tileNum + "" there are no PF reads.""); } else { int read; int totalRead=0; try (GZIPInputStream gzipInputStream=new GZIPInputStream(byteInputStream decompressedByteArray.length)){ while ((read=gzipInputStream.read(decompressedByteArray totalRead decompressedByteArray.length - totalRead)) != -1) { if (read == 0) { break; } totalRead+=read; } } catch ( final EOFException eofException) { throw new PicardException(""Unexpected end of file "" + this.streamFiles[totalCycleCount].getAbsolutePath() + "" this file is likely corrupt or truncated. We have read ""+ totalRead+ "" and were expecting to read ""+ decompressedByteArray.length); } if (totalRead != tileData.uncompressedBlockSize) { throw new PicardException(String.format(""Error while decompressing from BCL file for cycle %d. Offending file on disk is %s"" (totalCycleCount + 1) this.streamFiles[totalCycleCount].getAbsolutePath())); } } return decompressedByteArray; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\CbclReader.java,filterNonPfReads,private byte[]  (TileData tileData CycleData currentCycleData byte[] unNibbledByteArray){ if (!currentCycleData.pfExcluded) { final List<Boolean> filterDatas=cachedFilter.get(tileData.tileNum); int sum=0; for ( final boolean b : filterDatas) { sum+=b ? 1 : 0; } final byte[] filteredByteArray=new byte[sum]; int filterIndex=0; int basecallIndex=0; for ( final boolean filterData : filterDatas) { final byte readByte=unNibbledByteArray[filterIndex]; if (filterData) { filteredByteArray[basecallIndex]=readByte; basecallIndex++; } filterIndex++; } return filteredByteArray; } else { return unNibbledByteArray; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\CbclReader.java,getAllTiles,public Map<Integer List<TileData>>  (){ return allTiles; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\CbclReader.java,getCycleData,public CycleData[]  (){ return cycleData; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\CbclReader.java,getFilesForCycle,public List<File>  (final int i){ final List<File> cbclFiles=new ArrayList<>(); surfaceToTileToCbclMap.values().forEach(map -> { if (map.containsKey(i)) { cbclFiles.add(map.get(i)); } } ); return cbclFiles; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\CbclReader.java,getHeaderSize,public int  (){ return headerSize; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\CbclReader.java,hasNext,@Override public boolean  (){ if (queue == null) { advance(); } return queue != null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\CbclReader.java,next,public CbclData  (){ if (queue == null) { advance(); } final CbclData data=queue; queue=null; return data; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\CbclReader.java,promoteNibblesToBytes,private byte[]  (byte[] decompressedByteArray){ final byte[] unNibbledByteArray=new byte[decompressedByteArray.length * 2]; int index=0; for ( final byte singleByte : decompressedByteArray) { unNibbledByteArray[index]=(byte)(singleByte & 0x0f); index++; unNibbledByteArray[index]=(byte)((singleByte >> 4) & 0x0f); index++; } return unNibbledByteArray; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\CbclReader.java,readSurfaceTile,"private void  (final int tileNum final List<AbstractIlluminaPositionFileReader.PositionInfo> locs final boolean headerOnly){ log.info(""Processing tile "" + tileNum); try { for ( final Map.Entry<Integer Map<Integer File>> entry : surfaceToTileToCbclMap.entrySet()) { final Map<Integer File> cycleMap=entry.getValue(); for (int i=0; i < cycles; i++) { final ByteBuffer byteBuffer=ByteBuffer.allocate(INITIAL_HEADER_SIZE); byteBuffer.order(ByteOrder.LITTLE_ENDIAN); final File bclFile=cycleMap.get(outputCycles[i]); if (bclFile == null) { throw new PicardException(""Expected cbcl file for surface "" + entry.getKey() + "" cycle ""+ (i + 1)+ "" but it was not found.""); } final InputStream stream=open(bclFile false false false); int read=stream.read(byteBuffer.array()); if (read != INITIAL_HEADER_SIZE) { throw new RuntimeIOException(String.format(""BCL %s has invalid header structure."" bclFile.getAbsoluteFile())); } final short version=byteBuffer.getShort(); headerSize=byteBuffer.getInt(); final ByteBuffer headerBuffer=ByteBuffer.allocate(headerSize - INITIAL_HEADER_SIZE); headerBuffer.order(ByteOrder.LITTLE_ENDIAN); read=stream.read(headerBuffer.array()); if (read != headerSize - INITIAL_HEADER_SIZE) { throw new PicardException(String.format(""BCL %s has invalid header structure."" bclFile.getAbsoluteFile())); } final byte bitsPerBasecall=headerBuffer.get(); final byte bitsPerQualityScore=headerBuffer.get(); if (bitsPerBasecall != 2 && bitsPerBasecall != bitsPerQualityScore) { throw new PicardException(""CBCL data not encoded in nibbles. (not currently supported) bitsPerBasecall : "" + bitsPerBasecall + "" bitsPerQualityScore : ""+ bitsPerQualityScore); } final int numberOfBins=headerBuffer.getInt(); final byte[] qualityBins=new byte[numberOfBins]; for (int j=0; j < numberOfBins; j++) { headerBuffer.getInt(); final int to=headerBuffer.getInt(); qualityBins[j]=(byte)to; } long filePos=0; final int numTiles=headerBuffer.getInt(); TileData tileInfo=null; for (int j=0; j < numTiles; j++) { final int tile=headerBuffer.getInt(); final int numClustersInTile=headerBuffer.getInt(); final int uncompressedBlockSize=headerBuffer.getInt(); final int compressedBlockSize=headerBuffer.getInt(); final TileData tileData=new TileData(tile numClustersInTile uncompressedBlockSize compressedBlockSize filePos); allTiles.get(i + 1).add(tileData); if (tile == tileNum) { tileInfo=tileData; } filePos+=compressedBlockSize; } final boolean pfExcluded=headerBuffer.get() == 1; if (tileInfo == null) { continue; } cycleData[i]=new CycleData(version headerSize bitsPerBasecall bitsPerQualityScore numberOfBins qualityBins numTiles tileInfo pfExcluded); this.streams[i]=stream; this.streamFiles[i]=bclFile; byteBuffer.clear(); headerBuffer.clear(); } } if (headerOnly) { return; } int totalCycleCount=0; if (cycleData[totalCycleCount].tileInfo == null) { throw new PicardException(""Could not find tile "" + tileNum); } for ( final int outputLength : outputLengths) { for (int cycle=0; cycle < outputLength; cycle++) { final CycleData currentCycleData=cycleData[totalCycleCount]; try { if (cachedTile[totalCycleCount] == null) { if (!cachedFilter.containsKey(cycleData[totalCycleCount].tileInfo.tileNum)) { cacheFilterAndLocs(cycleData[totalCycleCount].tileInfo locs); } cacheTile(totalCycleCount cycleData[totalCycleCount].tileInfo currentCycleData); } } catch ( final IOException e) { throw new PicardException(String.format(""Error while reading from BCL file for cycle %d. Offending file on disk is %s"" (totalCycleCount + 1) this.streamFiles[totalCycleCount].getAbsolutePath()) e); } totalCycleCount++; } } } catch ( final IOException ioe) { throw new RuntimeIOException(ioe); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\CbclReader.java,sortCbcls,"private Map<Integer Map<Integer File>>  (final List<File> cbcls){ final Map<Integer Map<Integer File>> sortedMap=new TreeMap<>(); for ( final File cbcl : cbcls) { final Matcher matcher=PATTERN.matcher(cbcl.getAbsolutePath()); if (!matcher.matches()) { throw new PicardException(""CBCL File "" + cbcl.getAbsolutePath() + "" does not match expected pattern.""); } final Integer surface=Integer.valueOf(matcher.group(3)); final Integer cycle=Integer.valueOf(matcher.group(1)); if (sortedMap.containsKey(surface)) { sortedMap.get(surface).put(cycle cbcl); } else { final Map<Integer File> cycleMap=new HashMap<>(); cycleMap.put(cycle cbcl); sortedMap.put(surface cycleMap); } } return sortedMap; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\PosFileReader.java,PosFileReader,public  (final File posFile){ super(posFile); this.parser=new BasicInputParser(true posFile); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\PosFileReader.java,close,public void  (){ CloserUtil.close(parser); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\PosFileReader.java,hasNext,public boolean  (){ return parser.hasNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\PosFileReader.java,makeExceptionMsg,"@Override protected String  (){ return ""pos file( "" + parser.getFileName() + "" ) on line number( ""+ parser.getCurrentLineNumber()+ "" ) with current line = ""+ parser.getCurrentLine(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\PosFileReader.java,unsafeNextInfo,"@Override protected PositionInfo  (){ final String[] strVals=this.parser.next(); if (strVals.length != 2) { throw new PicardException(""Pos file number of values != 2  found ("" + strVals.length + "")""+ makeExceptionMsg()); } try { final float xVal=Float.par"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,IndexedIterator,public  (final int[] indices){ this.indices=indices; this.index=0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\TileMetricsOutReader.java,IlluminaLaneTileCode,public  (final int laneNumber final int tileNumber final int metricCode){ this.laneNumber=laneNumber; this.tileNumber=tileNumber; this.metricCode=metricCode; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,ReadStructure,public  (final String readStructureString){ this(readStructureStringToDescriptors(readStructureString)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\TileMetricsOutReader.java,IlluminaTileMetrics,public  (final int laneNumber final int tileNumber final int metricCode final float metricValue){ this.laneTileCode=new IlluminaLaneTileCode(laneNumber tileNumber metricCode); this.metricValue=metricValue; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,Substructure,public  (final List<Integer> descriptorIndices final List<Range> allRanges){ this.numDescriptors=descriptorIndices.size(); this.descriptorIndices=new int[numDescriptors]; this.descriptorLengths=new int[numDescriptors]; for (int i=0; i < descriptorIndices.size(); i++) { this.descriptorIndices[i]=descriptorIndices.get(i); this.descriptorLengths[i]=descriptors.get(this.descriptorIndices[i]).length; } this.cycleIndexRanges=new Range[numDescriptors]; for (int i=0; i < numDescriptors; i++) { this.cycleIndexRanges[i]=allRanges.get(this.descriptorIndices[i]); } int totalLength=0; for ( final int length : descriptorLengths) { totalLength+=length; } totalCycles=totalLength; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\TileMetricsOutReader.java,TileMetricsOutReader,"public  (final File tileMetricsOutFile TileMetricsOutReader.TileMetricsVersion version){ bbIterator=MMapBackedIteratorFactory.getByteBufferIterator(version.headerSize version.recordSize tileMetricsOutFile); this.version=version; final ByteBuffer header=bbIterator.getHeaderBytes(); final int actualVersion=UnsignedTypeUtil.uByteToInt(header.get()); if (actualVersion != version.version) { throw new PicardException(""TileMetricsOutReader expects the version number to be "" + version.version + "". Actual Version in Header( ""+ actualVersion+ "")""); } final int actualRecordSize=UnsignedTypeUtil.uByteToInt(header.get()); if (version.recordSize != actualRecordSize) { throw new PicardException(""TileMetricsOutReader expects the record size to be "" + version.recordSize + "". Actual Record Size in Header( ""+ actualRecordSize+ "")""); } if (version == TileMetricsVersion.THREE) { this.density=UnsignedTypeUtil.uIntToFloat(header.getInt()); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\TileMetricsOutReader.java,TileMetricsVersion, (int version int headerSize int recordSize){ this.version=version; this.headerSize=headerSize; this.recordSize=recordSize; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,equals,@Override public boolean  (final Object thatObj){ if (this == thatObj) return true; if (this.getClass() != thatObj.getClass()) return false; final ReadStructure that=(ReadStructure)thatObj; if (this.descriptors.size() != that.descriptors.size()) { return 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\TileMetricsOutReader.java,equals,@Override public boolean  (final Object o){ if (o instanceof IlluminaLaneTileCode) { final IlluminaLaneTileCode that=(IlluminaLaneTileCode)o; return laneNumber == that.laneNumber && tileNumber == that.tileNumber && metricCode == that.metricCode; } else { 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,get,public ReadDescriptor  (final int index){ return descriptors.get(descriptorIndices[index]); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\TileMetricsOutReader.java,getDensity,public float  (){ return density; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,getCycleIndexRanges,public Range[]  (){ return cycleIndexRanges; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\TileMetricsOutReader.java,getLaneNumber,public int  (){ return laneNumber; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\TileMetricsOutReader.java,getLaneTileCode,public IlluminaLaneTileCode  (){ return laneTileCode; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\TileMetricsOutReader.java,getMetricCode,public int  (){ return metricCode; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,getCycles,public int[]  (){ int[] cycles=new int[totalCycles]; int cycleIndex=0; for ( final Range range : cycleIndexRanges) { for (int i=range.start; i <= range.end; i++) { cycles[cycleIndex++]=i + 1; } } return cycles; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\TileMetricsOutReader.java,getMetricValue,public float  (){ return metricValue; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,getDescriptorLengths,public int[]  (){ return descriptorLengths; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\TileMetricsOutReader.java,getTileNumber,public int  (){ return tileNumber; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,getIndices,public int[]  (){ return descriptorIndices; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\TileMetricsOutReader.java,hasNext,public boolean  (){ return bbIterator.hasNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,getNumDescriptors,public int  (){ return descriptors.size(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,getTotalCycles,public int  (){ return totalCycles; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\TileMetricsOutReader.java,hashCode,@Override public int  (){ int result=laneNumber; result=31 * result + tileNumber; result=31 * result + metricCode; return result; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,hasNext,public boolean  (){ return index < indices.length; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\TileMetricsOutReader.java,isClusterRecord,public boolean  (){ return type == 't'; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,hashCode,@Override public int  (){ int res=descriptors.get(0).hashCode(); for (int i=1; i < descriptors.size(); i++) { res*=descriptors.get(i).hashCode(); } return res; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\TileMetricsOutReader.java,next,public IlluminaTileMetrics  (){ if (!hasNext()) { throw new NoSuchElementException(); } return new IlluminaTileMetrics(bbIterator.next() version); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,isEmpty,public boolean  (){ return numDescriptors == 0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\readers\TileMetricsOutReader.java,remove,public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,iterator,public Iterator<ReadDescriptor>  (){ return new IndexedIterator(descriptorIndices); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,length,public int  (){ return numDescriptors; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,next,public ReadDescriptor  (){ return descriptors.get(indices[index++]); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,readStructureStringToDescriptors,"private final static List<ReadDescriptor>  (final String readStructure){ final Matcher fullMatcher=FullPattern.matcher(readStructure); if (!fullMatcher.matches()) { throw new IllegalArgumentException(readStructure + "" cannot be parsed as a ReadStructure! "" + ReadStructureMsg); } final Matcher subMatcher=SubPattern.matcher(readStructure); final List<ReadDescriptor> descriptors=new ArrayList<ReadDescriptor>(); while (subMatcher.find()) { final ReadDescriptor rd=new ReadDescriptor(Integer.parseInt(subMatcher.group(1)) ReadType.valueOf(subMatcher.group(2))); descriptors.add(rd); } return descriptors; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,remove,public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,toReadStructure,public ReadStructure  (){ final List<ReadDescriptor> descriptors=new ArrayList<ReadDescriptor>(numDescriptors); for ( final ReadDescriptor rd : this) { descriptors.add(rd); } return new ReadStructure(descriptors); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\ReadStructure.java,toString,"@Override public String  (){ String out=""""; for ( final ReadDescriptor rd : descriptors) { out+=rd.toString(); } return out; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\Tile.java,Tile,public  (final int lane final int tile final float density final float clusters final TilePhasingValue... tilePhasingValues){ this.lane=lane; this.tile=tile; this.density=density; this.clusters=clusters; final Collection<TilePhasingValue> phasingValues=ensureSoleTilePhasingValuesPerRead(Arrays.asList(tilePhasingValues)); final Map<TileTemplateRead Float> phasingMap=new EnumMap<TileTemplateRead Float>(TileTemplateRead.class); final Map<TileTemplateRead Float> prePhasingMap=new EnumMap<TileTemplateRead Float>(TileTemplateRead.class); for ( TilePhasingValue phasingValue : phasingValues) { phasingMap.put(phasingValue.getTileTemplateRead() phasingValue.getPhasingValue()); prePhasingMap.put(phasingValue.getTileTemplateRead() phasingValue.getPrePhasingValue()); } this.phasingMap=Collections.unmodifiableMap(phasingMap); this.prePhasingMap=Collections.unmodifiableMap(prePhasingMap); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\Tile.java,ensureSoleTilePhasingValuesPerRead,private static Collection<TilePhasingValue>  (final Collection<TilePhasingValue> tilePhasingValues){ final Map<TileTemplateRead List<TilePhasingValue>> partitionedMap=tilePhasingValues.stream().collect(Collectors.groupingBy(TilePhasingValue::getTileTemplateRead)); final Collection<TilePhasingValue> newTilePhasingValues=new LinkedList<>(); for ( final TileTemplateRead read : partitionedMap.keySet()) { newTilePhasingValues.add(CollectionUtil.getSoleElement(partitionedMap.get(read))); } return newTilePhasingValues; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\Tile.java,getClusterCount,public float  (){ return clusters; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\Tile.java,getClusterDensity,public float  (){ return density; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\Tile.java,getLaneNumber,public int  (){ return lane; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\Tile.java,getPhasingMap,public Map<TileTemplateRead Float>  (){ return phasingMap; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\Tile.java,getPrePhasingMap,public Map<TileTemplateRead Float>  (){ return prePhasingMap; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\Tile.java,getTileNumber,public int  (){ return tile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileMetricsUtil.java,computeLinearFit,"private static float[]  (Float[] xValues Float[] yValues int sampleCount){ if (sampleCount == 0 || sampleCount > xValues.length) sampleCount=xValues.length; if (xValues.length <= 1 || xValues.length != yValues.length) { throw new PicardException(""Can not compute linear fit.""); } float sumX=0; float sumY=0; float sumXX=0; float sumXY=0; float slope=0f; float offset=0f; for (int i=0; i < sampleCount; i++) { sumX+=xValues[i]; sumY+=yValues[i]; sumXY+=xValues[i] * yValues[i]; sumXX+=xValues[i] * xValues[i]; } float denominator=sampleCount * sumXX - sumX * sumX; if (denominator > Math.ulp(denominator)) { slope=(sampleCount * sumXY - sumX * sumY) / denominator; offset=(sumY * sumXX - sumX * sumXY) / denominator; } return new float[]{slope offset}; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileMetricsUtil.java,determineLastValueForLaneTileMetricsCode,private static Collection<IlluminaTileMetrics>  (final Iterator<IlluminaTileMetrics> tileMetricsIterator){ final Map<TileMetricsOutReader.IlluminaLaneTileCode IlluminaTileMetrics> filteredTileMetrics=new HashMap<>(); for ( final IlluminaTileMetrics illuminaTileMetrics : new IterableAdapter<>(tileMetricsIterator)) { filteredTileMetrics.put(illuminaTileMetrics.getLaneTileCode() illuminaTileMetrics); } return filteredTileMetrics.values(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileMetricsUtil.java,fileTileMetricsFile,"private static File  (File illuminaRunDirectory Integer numCycles boolean isNovaSeq){ Path interOpDir=illuminaRunDirectory.toPath().resolve(INTEROP_SUBDIRECTORY_NAME); final List<Path> pathsToTest=new ArrayList<>(); pathsToTest.add(interOpDir.resolve(TILE_METRICS_OUT_FILE_NAME)); if (isNovaSeq) { for (int i=numCycles; i > 0; i--) { pathsToTest.add(interOpDir.resolve(String.format(""C%d.1/%s"" i TILE_METRICS_OUT_FILE_NAME))); } } return pathsToTest.stream().filter(Files::exists).findFirst().orElseThrow(() -> { StringBuilder message=new StringBuilder(String.format(""No %s file found in %s"" INTEROP_SUBDIRECTORY_NAME interOpDir)); if (isNovaSeq) { message.append("" or any of its cycle directories.""); } return new IllegalStateException(message.toString()); } ).toFile(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileMetricsUtil.java,getTilePhasingValues,"private static Collection<TilePhasingValue>  (final Map<Integer ? extends Collection<IlluminaTileMetrics>> codeMetricsMap final ReadStructure readStructure final ValidationStringency validationStringency){ boolean isFirstRead=true; final Collection<TilePhasingValue> tilePhasingValues=new ArrayList<>(); for (int descriptorIndex=0; descriptorIndex < readStructure.descriptors.size(); descriptorIndex++) { if (readStructure.descriptors.get(descriptorIndex).type == ReadType.Template) { final TileTemplateRead tileTemplateRead=isFirstRead ? TileTemplateRead.FIRST : TileTemplateRead.SECOND; final int phasingCode=IlluminaMetricsCode.getPhasingCode(descriptorIndex IlluminaMetricsCode.PHASING_BASE); final int prePhasingCode=IlluminaMetricsCode.getPhasingCode(descriptorIndex IlluminaMetricsCode.PREPHASING_BASE); final float phasingValue  prePhasingValue; if (codeMetricsMap.containsKey(phasingCode) && codeMetricsMap.containsKey(prePhasingCode)) { phasingValue=CollectionUtil.getSoleElement(codeMetricsMap.get(phasingCode)).getMetricValue(); prePhasingValue=CollectionUtil.getSoleElement(codeMetricsMap.get(prePhasingCode)).getMetricValue(); } else { final String message=String.format(""Don't have both phasing and prephasing values for %s read cycle %s. Phasing code was %d and prephasing code was %d."" tileTemplateRead.toString() descriptorIndex + 1 phasingCode prePhasingCode); if (!codeMetricsMap.containsKey(phasingCode) && !codeMetricsMap.containsKey(prePhasingCode) && validationStringency != ValidationStringency.STRICT) { if (validationStringency == ValidationStringency.LENIENT) { LOG.warn(message); } } else { throw new PicardException(message); } phasingValue=0; prePhasingValue=0; } tilePhasingValues.add(new TilePhasingValue(tileTemplateRead phasingValue prePhasingValue)); isFirstRead=false; } } return tilePhasingValues; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileMetricsUtil.java,parseTileMetrics,"public static Collection<Tile>  (final File tileMetricsOutFile final ReadStructure readStructure final ValidationStringency validationStringency) throws FileNotFoundException { final Collection<IlluminaTileMetrics> tileMetrics=determineLastValueForLaneTileMetricsCode(new TileMetricsOutReader(tileMetricsOutFile TileMetricsOutReader.TileMetricsVersion.TWO)); final Map<String ? extends Collection<IlluminaTileMetrics>> locationToMetricsMap=partitionTileMetricsByLocation(tileMetrics); final Collection<Tile> tiles=new LinkedList<>(); for ( final Map.Entry<String ? extends Collection<IlluminaTileMetrics>> entry : locationToMetricsMap.entrySet()) { final Collection<IlluminaTileMetrics> tileRecords=entry.getValue(); final Map<Integer ? extends Collection<IlluminaTileMetrics>> codeMetricsMap=partitionTileMetricsByCode(tileRecords); final Set<Integer> observedCodes=codeMetricsMap.keySet(); if (!(observedCodes.contains(IlluminaMetricsCode.DENSITY_ID.getMetricsCode()) && observedCodes.contains(IlluminaMetricsCode.CLUSTER_ID.getMetricsCode()))) throw new PicardException(String.format(""Expected to find cluster and density record codes (%s and %s) in records read for tile location %s (lane:tile)  but found only %s."" IlluminaMetricsCode.CLUSTER_ID.getMetricsCode() IlluminaMetricsCode.DENSITY_ID.getMetricsCode() entry.getKey() observedCodes)); final IlluminaTileMetrics densityRecord=CollectionUtil.getSoleElement(codeMetricsMap.get(IlluminaMetricsCode.DENSITY_ID.getMetricsCode())); final IlluminaTileMetrics clusterRecord=CollectionUtil.getSoleElement(codeMetricsMap.get(IlluminaMetricsCode.CLUSTER_ID.getMetricsCode())); final Collection<TilePhasingValue> tilePhasingValues=getTilePhasingValues(codeMetricsMap readStructure validationStringency); tiles.add(new Tile(densityRecord.getLaneNumber() densityRecord.getTileNumber() densityRecord.getMetricValue() clusterRecord.getMetricValue() tilePhasingValues.toArray(new TilePhasingValue[tilePhasingValues.size()]))); } return Collections.unmodifiableCollection(tiles); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileMetricsUtil.java,partitionTileMetricsByCode,private static Map<Integer ? extends Collection<IlluminaTileMetrics>>  (final Collection<IlluminaTileMetrics> tileMetrics){ return tileMetrics.stream().collect(Collectors.groupingBy(IlluminaTileMetrics::getMetricCode)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileMetricsUtil.java,partitionTileMetricsByLocation,private static Map<String ? extends Collection<IlluminaTileMetrics>>  (final Collection<IlluminaTileMetrics> tileMetrics){ return tileMetrics.stream().collect(Collectors.groupingBy(TileMetricsUtil::renderMetricLocationKey)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileMetricsUtil.java,renderMetricLocationKey,"private static String  (final IlluminaTileMetrics metric){ return String.format(""%s:%s"" metric.getLaneNumber() metric.getTileNumber()); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileMetricsUtil.java,renderPhasingMetricsFilesFromBasecallingDirectory,"public static Map<Integer File>  (File illuminaRunDirectory){ File[] cycleDirs=IOUtil.getFilesMatchingRegexp(new File(illuminaRunDirectory INTEROP_SUBDIRECTORY_NAME) IlluminaFileUtil.CYCLE_SUBDIRECTORY_PATTERN); Map<Integer File> phasingMetrics=new HashMap<>(); Arrays.asList(cycleDirs).forEach(cycleDir -> { File[] filesMatchingRegexp=IOUtil.getFilesMatchingRegexp(cycleDir ""EmpiricalPhasingMetricsOut.bin""); if (filesMatchingRegexp.length > 0) { phasingMetrics.put(PerTilePerCycleFileUtil.getCycleFromDir(cycleDir) filesMatchingRegexp[0]); } } ); return phasingMetrics; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileMetricsUtil.java,renderTileMetricsFileFromBasecallingDirectory,public static File  (final File illuminaRunDirectory Integer numCycles boolean isNovaSeq){ return fileTileMetricsFile(illuminaRunDirectory numCycles isNovaSeq); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TilePhasingValue.java,TilePhasingValue,public  (final TileTemplateRead tileTemplateRead final float phasingValue final float prePhasingValue){ this.tileTemplateRead=tileTemplateRead; this.phasingValue=phasingValue; this.prePhasingValue=prePhasingValue; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TilePhasingValue.java,getPhasingValue,public float  (){ return phasingValue; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TilePhasingValue.java,getPrePhasingValue,public float  (){ return prePhasingValue; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TilePhasingValue.java,getTileTemplateRead,public TileTemplateRead  (){ return tileTemplateRead; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileIndex.java,TileIndex," (final File tileIndexFile){ try { this.tileIndexFile=tileIndexFile; final InputStream is=IOUtil.maybeBufferInputStream(new FileInputStream(tileIndexFile)); final ByteBuffer buf=ByteBuffer.allocate(8); buf.order(ByteOrder.LITTLE_ENDIAN); int absoluteRecordIndex=0; int numTiles=0; while (readTileIndexRecord(buf.array() buf.capacity() is)) { buf.rewind(); buf.limit(buf.capacity()); final int tile=buf.getInt(); if (tile < 0) throw new PicardException(""Tile number too large in "" + tileIndexFile.getAbsolutePath()); final int numClusters=buf.getInt(); if (numClusters < 0) throw new PicardException(""Cluster size too large in "" + tileIndexFile.getAbsolutePath()); tiles.add(new TileIndexRecord(tile numClusters absoluteRecordIndex numTiles++)); absoluteRecordIndex+=numClusters; } CloserUtil.close(is); } catch ( final IOException e) { throw new PicardException(""Problem reading "" + tileIndexFile.getAbsolutePath() e); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileIndex.java,TileIndexRecord,private  (final int tile final int numClustersInTile final int indexOfFirstClusterInTile final int zeroBasedTileNumber){ this.tile=tile; this.numClustersInTile=numClustersInTile; this.indexOfFirstClusterInTile=indexOfFirstClusterInTile; this.zeroBasedTileNumber=zeroBasedTileNumber; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileIndex.java,findTile,"public TileIndexRecord  (final int tileNumber){ for ( final TileIndexRecord rec : this) { if (rec.tile == tileNumber) return rec; if (rec.tile > tileNumber) { break; } } throw new NoSuchElementException(String.format(""Tile %d not found in %s"" tileNumber tileIndexFile)); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileIndex.java,getFile,public File  (){ return tileIndexFile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileIndex.java,getNumClustersInTile,public int  (){ return numClustersInTile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileIndex.java,getNumTiles,public int  (){ return tiles.size(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileIndex.java,getTiles,public List<Integer>  (){ final List<Integer> ret=new ArrayList<Integer>(tiles.size()); for ( final TileIndexRecord rec : tiles) ret.add(rec.tile); return ret; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileIndex.java,getZeroBasedTileNumber,public int  (){ return zeroBasedTileNumber; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileIndex.java,iterator,@Override public Iterator<TileIndexRecord>  (){ return tiles.iterator(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileIndex.java,readTileIndexRecord,"private boolean  (final byte[] buf final int numBytes final InputStream is) throws IOException { int totalBytesRead=0; while (totalBytesRead < numBytes) { final int bytesRead=is.read(buf totalBytesRead numBytes - totalBytesRead); if (bytesRead == -1) { if (totalBytesRead != 0) { throw new PicardException(tileIndexFile.getAbsolutePath() + "" has incomplete last block""); } else return false; } totalBytesRead+=bytesRead; } return true; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\parser\TileIndex.java,verify,"public List<String>  (final List<Integer> expectedTiles){ final Set<Integer> tileSet=new HashSet<Integer>(tiles.size()); for ( final TileIndexRecord rec : tiles) tileSet.add(rec.tile); final List<String> failures=new LinkedList<String>(); for ( final int expectedTile : expectedTiles) { if (!tileSet.contains(expectedTile)) { failures.add(""Tile "" + expectedTile + "" not found in ""+ tileIndexFile.getAbsolutePath()); } } return failures; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\quality\CollectHiSeqXPfFailMetrics.java,PerTilePFMetricsExtractor,public  (final int tile final PFFailSummaryMetric summaryMetric final Collection<PFFailDetailedMetric> detailedMetrics final IlluminaDataProviderFactory factory final double pWriteDetailed){ this.tile=tile; this.summaryMetric=summaryMetric; this.detailedMetrics=detailedMetrics; this.pWriteDetailed=pWriteDetailed; this.provider=factory.makeDataProvider(Arrays.asList(tile)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\quality\CollectHiSeqXPfFailMetrics.java,ReadClassifier,public  (final ReadData read){ final int length=read.getBases().length; numNs=countEquals(read.getBases() (byte)'.'); numQGtTwo=countGreaterThan(read.getQualities() (byte)2); failClass=PfFailReason.UNKNOWN; if (numNs >= (length - 1)) { failClass=PfFailReason.MISALIGNED; } else if (numNs <= 1) { if (numQGtTwo <= length / 3) { failClass=PfFailReason.EMPTY; } else if (numQGtTwo >= length / 2) { failClass=PfFailReason.POLYCLONAL; } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\quality\CollectHiSeqXPfFailMetrics.java,calculateDerivedFields,public void  (){ if (this.READS != 0) { this.PCT_PF_FAIL_READS=(double)this.PF_FAIL_READS / this.READS; this.PCT_PF_FAIL_EMPTY=(double)this.PF_FAIL_EMPTY / this.READS; this.PCT_PF_FAIL_MISALIGNED=(double)this.PF_FAIL_MISALIGNED / this.READS; this.PCT_PF_FAIL_POLYCLONAL=(double)this.PF_FAIL_POLYCLONAL / this.READS; this.PCT_PF_FAIL_UNKNOWN=(double)this.PF_FAIL_UNKNOWN / this.READS; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\quality\CollectHiSeqXPfFailMetrics.java,countEquals,static private int  (final byte[] array final byte toCount){ int count=0; for ( final byte t : array) { if (t == toCount) count++; } return count; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\quality\CollectHiSeqXPfFailMetrics.java,countGreaterThan,static private int  (final byte[] array final byte value){ int count=0; for ( final int t : array) { if (t > value) count++; } return count; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\quality\CollectHiSeqXPfFailMetrics.java,customCommandLineValidation,"@Override protected String[]  (){ final List<String> errors=new ArrayList<String>(); if (N_CYCLES < 0) { errors.add(""Number of Cycles to look at must be greater than 0""); } if (PROB_EXPLICIT_READS > 1 || PROB_EXPLICIT_READS < 0) { errors.add(""PROB_EXPLICI"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\quality\CollectHiSeqXPfFailMetrics.java,doWork,@Override protected int  (){ final IlluminaDataProviderFactory factory=new IlluminaDataProviderFactory(BASECALLS_DIR LANE READ_STRUCTURE new BclQualityEvaluationStrategy(BclQualityEvaluationStrategy.ILLUMINA_ALLEGED_MINIMUM_QUALITY) IlluminaDataType.BaseC
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\quality\CollectHiSeqXPfFailMetrics.java,getException,public Exception  (){ return this.exception; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\quality\CollectHiSeqXPfFailMetrics.java,main,public static void  (final String[] args){ new CollectHiSeqXPfFailMetrics().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\quality\CollectHiSeqXPfFailMetrics.java,merge,public void  (final PFFailSummaryMetric metric){ this.READS+=metric.READS; this.PF_FAIL_READS+=metric.PF_FAIL_READS; this.PF_FAIL_EMPTY+=metric.PF_FAIL_EMPTY; this.PF_FAIL_MISALIGNED+=metric.PF_FAIL_MISALIGNED; this.PF_FAIL_POLYCLONAL+=metric.PF_FAIL_POLYCLONAL; this.PF_FAIL_UNKNOWN+=metric.PF_FAIL_UNKNOWN; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\illumina\quality\CollectHiSeqXPfFailMetrics.java,run,"public void  (){ try { LOG.info(""Extracting PF metrics for tile "" + tile); while (provider.hasNext()) { final ClusterData cluster=provider.next(); this.summaryMetric.READS++; if (!cluster.isPf()) { this.summaryMetric.PF_FAIL_READS++; final ReadClassifier readClassifier=new ReadClassifier(cluster.getRead(0)); if (random.nextDouble() < pWriteDetailed) { detailedMetrics.add(new PFFailDetailedMetric(tile cluster.getX() cluster.getY() readClassifier.numNs readClassifier.numQGtTwo readClassifier.failClass)); } switch (readClassifier.failClass) { case EMPTY: this.summaryMetric.PF_FAIL_EMPTY++; break; case MISALIGNED: this.summaryMetric.PF_FAIL_MISALIGNED++; break; case POLYCLONAL: this.summaryMetric.PF_FAIL_POLYCLONAL++; break; case UNKNOWN: this.summaryMetric.PF_FAIL_UNKNOWN++; break; default : LOG.error(""Got unexpected fail Reason""); } } } } catch (final Exception e) { LOG.error(e ""Error processing tile "" this.tile); this.exception=e; } finally { provider.close(); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\metrics\MultiLevelCollector.java,AllReadsDistributor,public  (final List<SAMReadGroupRecord> rgRecs){ super(new ArrayList<SAMReadGroupRecord>()); makeCollector(null); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\metrics\MultiLevelCollector.java,Distributor,public  (final List<SAMReadGroupRecord> rgRecs){ collectors=new LinkedHashMap<String PerUnitMetricCollector<METRIC_TYPE Histogram_KEY ARGTYPE>>(); for ( final SAMReadGroupRecord rg : rgRecs) { final String key=getKey(rg); if (!collectors.containsKey(key)) { collectors.put(key makeCollector(rg)); } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\metrics\MultiLevelCollector.java,LibraryDistributor,public  (final List<SAMReadGroupRecord> rgRecs){ super(rgRecs); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\metrics\MultiLevelCollector.java,ReadGroupCollector,public  (final List<SAMReadGroupRecord> rgRecs){ super(rgRecs); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\metrics\MultiLevelCollector.java,SampleDistributor,public  (final List<SAMReadGroupRecord> rgRecs){ super(rgRecs); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\metrics\MultiLevelCollector.java,acceptRecord,public void  (final SAMRecord record final ReferenceSequence refSeq){ final ARGTYPE arg=makeArg(record refSeq); for ( final Distributor collector : outputOrderedDistributors) { collector.acceptRecord(arg record.getReadGroup()); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\metrics\MultiLevelCollector.java,addAllLevelsToFile,public void  (final MetricsFile<METRIC_TYPE Histogram_KEY> file){ for ( final Distributor collector : outputOrderedDistributors) { collector.addToFile(file); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\metrics\MultiLevelCollector.java,addToFile,@Override public void  (final MetricsFile<METRIC_TYPE Histogram_KEY> file){ allReadCollector.addMetricsToFile(file); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\metrics\MultiLevelCollector.java,finish,public void  (){ for ( final Distributor collector : outputOrderedDistributors) { collector.finish(); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\metrics\MultiLevelCollector.java,getAllReadsCollector,public PerUnitMetricCollector<METRIC_TYPE Histogram_KEY ARGTYPE>  (){ return allReadCollector; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\metrics\MultiLevelCollector.java,getKey,@Override protected String  (SAMReadGroupRecord rg){ return rg.getPlatformUnit(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\metrics\MultiLevelCollector.java,makeAllReadCollector,protected PerUnitMetricCollector<METRIC_TYPE Histogram_KEY ARGTYPE>  (){ return makeChildCollector(null null null); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\metrics\SAMRecordAndReference.java,SAMRecordAndReference,public  (final SAMRecord samRec final ReferenceSequence refSeq){ this.samRec=samRec; this.refSeq=refSeq; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\metrics\SAMRecordAndReference.java,getReferenceSequence,public ReferenceSequence  (){ return refSeq; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\metrics\SAMRecordAndReference.java,getSamRecord,public SAMRecord  (){ return samRec; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\nio\GoogleStorageUtils.java,getCloudStorageConfiguration,private static CloudStorageConfiguration  (int maxReopens){ return CloudStorageConfiguration.builder().maxChannelReopens(maxReopens).build(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\nio\GoogleStorageUtils.java,initialize,public static void  (){ CloudStorageFileSystemProvider.setDefaultCloudStorageConfiguration(GoogleStorageUtils.getCloudStorageConfiguration(20)); CloudStorageFileSystemProvider.setStorageOptions(GoogleStorageUtils.setGenerousTimeouts(StorageOptions.newBuilder()).build()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\nio\GoogleStorageUtils.java,setGenerousTimeouts,private static StorageOptions.Builder  (StorageOptions.Builder builder){ return builder.setTransportOptions(HttpTransportOptions.newBuilder().setConnectTimeout(120_000).setReadTimeout(120_000).build()).setRetrySettings(RetrySettings.newBuilder().setMaxAttempts(15).setMaxRetryDelay(Duration.ofMillis(256_000L)).setTotalTimeout(Duration.ofMillis(4000_000L)).setInitialRetryDelay(Duration.ofMillis(1000L)).setRetryDelayMultiplier(2.0).setInitialRpcTimeout(Duration.ofMillis(180_000L)).setRpcTimeoutMultiplier(1.0).setMaxRpcTimeout(Duration.ofMillis(180_000L)).build()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\metrics\SAMRecordMultiLevelCollector.java,makeArg,@Override protected SAMRecord  (SAMRecord samRec final ReferenceSequence refSeq){ return samRec; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\metrics\SAMRecordAndReferenceMultiLevelCollector.java,makeArg,@Override protected SAMRecordAndReference  (SAMRecord samRec final ReferenceSequence refSeq){ return new SAMRecordAndReference(samRec refSeq); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\pedigree\PedFile.java,PedFile,"public  (final boolean isTabMode){ delimiterPattern=isTabMode ? TAB : WHITESPACE; delimiterString=isTabMode ? ""tabs"" : ""whitespace""; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\pedigree\PedFile.java,PedTrio,"public  (final String familyId final String individualId final String paternalId final String maternalId final Sex sex final Number phenotype){ if (delimiterPattern.split(familyId).length != 1) throw new IllegalArgumentException(""FamilyID cannot contain "" + delimiterString + "": [""+ familyId+ ""]""); if (delimiterPattern.split(individualId).length != 1) throw new IllegalArgumentException(""IndividualID cannot contain "" + delimiterString + "": [""+ individualId+ ""]""); if (delimiterPattern.split(paternalId).length != 1) throw new IllegalArgumentException(""PaternalID cannot contain "" + delimiterString + "": [""+ paternalId+ ""]""); if (delimiterPattern.split(maternalId).length != 1) throw new IllegalArgumentException(""MaternalID cannot contain "" + delimiterString + "": [""+ maternalId+ ""]""); this.familyId=familyId; this.individualId=individualId; this.paternalId=paternalId; this.maternalId=maternalId; this.sex=sex; this.phenotype=phenotype; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\pedigree\PedFile.java,add,public void  (final PedTrio trio){ put(trio.getIndividualId() trio); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\pedigree\PedFile.java,fromFile,"public static PedFile  (final File file final boolean isTabMode){ final PedFile pedFile=new PedFile(isTabMode); IOUtil.assertFileIsReadable(file); for ( final String line : IOUtil.readLines(file)) { final String[] fields=pedFile.delimiterPattern.split(line); if (fields.length != 6) { log.error(""Ped file line contained invalid number of fields  skipping: "" + line); continue; } final PedTrio trio=pedFile.new PedTrio(fields[0] fields[1] fields[2] fields[3] Sex.fromCode(Integer.parseInt(fields[4])) fields[5].contains(""."") ? Double.parseDouble(fields[5]) : Integer.parseInt(fields[5])); pedFile.add(trio); } return pedFile; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\pedigree\PedFile.java,fromSexMap,"static public PedFile  (final Map<String Sex> sampleSexes){ final PedFile pedfile=new PedFile(true); for ( final Map.Entry<String Sex> sampleSex : sampleSexes.entrySet()) { final PedFile.PedTrio ped=pedfile.new PedTrio(sampleSex.getKey() sampleSex.getKey() ""."" ""."" sampleSex.getValue() PedFile.NO_PHENO); pedfile.add(ped); } return pedfile; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\pedigree\PedFile.java,getFamilyId,public String  (){ return familyId; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\pedigree\PedFile.java,getIndividualId,public String  (){ return individualId; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\pedigree\PedFile.java,getMaternalId,public String  (){ return maternalId; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\pedigree\PedFile.java,getPaternalId,public String  (){ return paternalId; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\pedigree\PedFile.java,getPhenotype,public Number  (){ return phenotype; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\pedigree\PedFile.java,getSex,public Sex  (){ return sex; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\pedigree\PedFile.java,hasBothParents,public boolean  (){ return this.paternalId != null && this.maternalId != null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\pedigree\PedFile.java,removeIncompleteTrios,public PedFile  (){ final Iterator<Map.Entry<String PedTrio>> iterator=entrySet().iterator(); while (iterator.hasNext()) { if (!iterator.next().getValue().hasBothParents()) iterator.remove(); } return this; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\pedigree\PedFile.java,write,"public void  (final File file){ IOUtil.assertFileIsWritable(file); final BufferedWriter out=IOUtil.openFileForBufferedWriting(file); try { for ( final PedTrio trio : values()) { out.write(trio.getFamilyId()); out.write(""\t""); out.write(trio.getIndividualId()); out.write(""\t""); out.write(trio.getPaternalId()); out.write(""\t""); out.write(trio.getMaternalId()); out.write(""\t""); out.write(String.valueOf(trio.getSex().toCode())); out.write(""\t""); out.write(trio.getPhenotype().toString()); out.newLine(); } out.close(); } catch ( final IOException ioe) { throw new RuntimeIOException(""IOException while writing to file "" + file.getAbsolutePath() ioe); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\pedigree\Sex.java,Sex,private  (final int code){ this.code=code; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\pedigree\Sex.java,fromCode,public static Sex  (final int code){ if (code == Male.code) return Male; else if (code == Female.code) return Female; else return Unknown; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\pedigree\Sex.java,toCode,public int  (){ return this.code; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\PicardException.java,PicardException,public  (final String message final Throwable throwable){ super(message throwable); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\reference\ExtractSequences.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INTERVAL_LIST); IOUtil.assertFileIsReadable(REFERENCE_SEQUENCE); IOUtil.assertFileIsWritable(OUTPUT); final IntervalList intervals=IntervalList.fromFile(INTERVAL_LIST); final ReferenceSequenceFile r
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\reference\ExtractSequences.java,main,public static void  (final String[] args){ new ExtractSequences().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\reference\ExtractSequences.java,requiresReference,@Override protected boolean  (){ return true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\reference\NormalizeFasta.java,doWork,"@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); if (INPUT.getAbsoluteFile().equals(OUTPUT.getAbsoluteFile())) { throw new IllegalArgumentException(""Input and output cannot be the same file.""); } final "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\reference\NormalizeFasta.java,main,public static void  (final String[] args){ new NormalizeFasta().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AbstractAlignmentMerger.java,AbstractAlignmentMerger,"public  (final File unmappedBamFile final File targetBamFile final File referenceFasta final boolean clipAdapters final boolean bisulfiteSequence final boolean alignedReadsOnly final SAMProgramRecord programRecord final List<String> attributesToRetain final List<String> attributesToRemove final Integer read1BasesTrimmed final Integer read2BasesTrimmed final List<SamPairUtil.PairOrientation> expectedOrientations final SortOrder sortOrder final PrimaryAlignmentSelectionStrategy primaryAlignmentSelectionStrategy final boolean addMateCigar final boolean unmapContaminantReads final UnmappingReadStrategy unmappingReadsStrategy){ IOUtil.assertFileIsReadable(unmappedBamFile); IOUtil.assertFileIsWritable(targetBamFile); IOUtil.assertFileIsReadable(referenceFasta); this.unmappedBamFile=unmappedBamFile; this.targetBamFile=targetBamFile; this.referenceFasta=referenceFasta; this.refSeq=new ReferenceSequenceFileWalker(referenceFasta); this.clipAdapters=clipAdapters; this.bisulfiteSequence=bisulfiteSequence; this.alignedReadsOnly=alignedReadsOnly; this.header=new SAMFileHeader(); this.sortOrder=sortOrder != null ? sortOrder : SortOrder.coordinate; header.setSortOrder(SortOrder.coordinate); if (programRecord != null) { setProgramRecord(programRecord); } if (attributesToRetain != null) { this.attributesToRetain.addAll(attributesToRetain); } if (attributesToRemove != null) { this.attributesToRemove.addAll(attributesToRemove); if (!this.attributesToRetain.isEmpty()) { this.attributesToRemove.stream().filter(this.attributesToRetain::contains).peek(a -> log.info(""Overriding retaining the "" + a + "" tag since 'remove' overrides 'retain'."")).forEach(this.attributesToRetain::remove); } } this.read1BasesTrimmed=read1BasesTrimmed; this.read2BasesTrimmed=read2BasesTrimmed; this.expectedOrientations=expectedOrientations; this.primaryAlignmentSelectionStrategy=primaryAlignmentSelectionStrategy; this.addMateCigar=addMateCigar; this.unmapContaminantReads=unmapContaminantReads; this.unmappingReadsStrategy=unmappingReadsStrategy; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AbstractAlignmentMerger.java,Sink,public  (final SortingCollection<SAMRecord> sorter){ this.writer=null; this.sorter=sorter; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AbstractAlignmentMerger.java,UnmappingReadStrategy, (final boolean resetMappingInformation final boolean populatePATag){ this.resetMappingInformation=resetMappingInformation; this.populatePATag=populatePATag; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AbstractAlignmentMerger.java,add,void  (final SAMRecord rec){ if (writer != null) { writer.addAlignment(rec); } if (sorter != null) { sorter.add(rec); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AbstractAlignmentMerger.java,addIfNotFiltered,"private void  (final Sink out final SAMRecord rec){ if (includeSecondaryAlignments || !rec.getNotPrimaryAlignmentFlag()) { out.add(rec); if (this.progress.record(rec) && crossSpeciesReads > 0) { log.info(String.format(""%d Reads have been unmapped due to being suspected of being Cross-species contamination."" crossSpeciesReads)); } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AbstractAlignmentMerger.java,clipForOverlappingReads,protected static void  (final SAMRecord read1 final SAMRecord read2){ if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) { if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) { final SAMRecord pos=(read1.getReadNegativeStrandFlag()) ? read2 : read1; final SAMRecord neg=(read1.getReadNegativeStrandFlag()) ? read1 : read2; if (pos.getAlignmentStart() < neg.getAlignmentEnd()) { final int posDiff=pos.getAlignmentEnd() - neg.getAlignmentEnd(); final int negDiff=pos.getAlignmentStart() - neg.getAlignmentStart(); if (posDiff > 0) { final List<CigarElement> elems=new ArrayList<>(pos.getCigar().getCigarElements()); Collections.reverse(elems); final int clipped=lengthOfSoftClipping(elems.iterator()); final int clipFrom=pos.getReadLength() - posDiff - clipped + 1; CigarUtil.softClip3PrimeEndOfRead(pos Math.min(pos.getReadLength() clipFrom)); removeNmMdAndUqTags(pos); } if (negDiff > 0) { final int clipped=lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator()); final int clipFrom=neg.getReadLength() - negDiff - clipped + 1; CigarUtil.softClip3PrimeEndOfRead(neg Math.min(neg.getReadLength() clipFrom)); removeNmMdAndUqTags(neg); } } } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AbstractAlignmentMerger.java,clone,"private SAMRecord  (final SAMRecord rec){ try { return (SAMRecord)rec.clone(); } catch ( CloneNotSupportedException e) { throw new PicardException(""Should never happen.""); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AbstractAlignmentMerger.java,close,public void  (){ CloserUtil.close(this.refSeq); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AbstractAlignmentMerger.java,createNewCigarIfMapsOffEndOfReference,private static Cigar  (SAMFileHeader header boolean isUnmapped int referenceIndex int alignmentEnd int readLength Cigar oldCigar){ Cigar newCigar=null; if (!isUnmapped) { final SAMSequenceRecord refseq=header.getSequence(referenceIndex); final int overhang=alignmentEnd - refseq.getSequenceLength(); if (overhang > 0) { int clipFrom=readLength - overhang + 1; final CigarElement cigarElement=oldCigar.getCigarElement(oldCigar.getCigarElements().size() - 1); if (CigarOperator.SOFT_CLIP == cigarElement.getOperator()) clipFrom-=cigarElement.getLength(); final List<CigarElement> newCigarElements=CigarUtil.softClipEndOfRead(clipFrom oldCigar.getCigarElements()); newCigar=new Cigar(newCigarElements); } } return newCigar; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AbstractAlignmentMerger.java,createNewCigarsIfMapsOffEndOfReference,public static void  (final SAMRecord rec){ if (!rec.getReadUnmappedFlag()) { final Cigar readCigar=createNewCigarIfMapsOffEndOfReference(rec.getHeader() rec.getReadUnmappedFlag() rec.getReferenceIndex() rec.getAlignmentEnd() rec.getReadLength() rec.getCigar()); if (null != readCigar) { rec.setCigar(readCigar); } } if (SAMUtils.hasMateCigar(rec)) { Cigar mateCigar=SAMUtils.getMateCigar(rec); mateCigar=createNewCigarIfMapsOffEndOfReference(rec.getHeader() rec.getMateUnmappedFlag() rec.getMateReferenceIndex() SAMUtils.getMateAlignmentEnd(rec) mateCigar.getReadLength() mateCigar); if (null != mateCigar) { rec.setAttribute(SAMTag.MC.name() mateCigar.toString()); } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AbstractAlignmentMerger.java,encodeMappingInformation,"static private String  (SAMRecord rec){ return String.join("" "" rec.getContig() ((Integer)rec.getAlignmentStart()).toString() rec.getCigarString() ((Integer)rec.getMappingQuality()).toString() getStringOfNullable(rec.getIntegerAttribute(SAMTag.NM.name()))) + "";""; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AbstractAlignmentMerger.java,filterOut,"public boolean  (final SAMRecord first final SAMRecord second){ throw new UnsupportedOperationException(""Paired SamRecordFilter not implemented!""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AbstractAlignmentMerger.java,fixNmMdAndUq,public static void  (final SAMRecord record final ReferenceSequenceFileWalker refSeqWalker final boolean isBisulfiteSequence){ final byte[] referenceBases=refSeqWalker.get(record.getReferenceIndex()).getBases(); SequenceUtil.calculateMdAndNmTags(record referenceBases true !isBisulfiteSequence); if (isBisulfiteSequence) { record.setAttribute(SAMTag.NM.name() SequenceUtil.calculateSamNmTag(record referenceBases 0 isBisulfiteSequence)); } fixUq(record refSeqWalker isBisulfiteSequence); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AbstractAlignmentMerger.java,fixUq,public static void  (final SAMRecord record final ReferenceSequenceFileWalker refSeqWalker final boolean isBisulfiteSequence){ if (record.getBaseQualities() != SAMRecord.NULL_QUALS) { final byte[] referenceBases=refSeqWalker.get(record.getReferenceIndex()).getBases(); record.setAttribute(SAMTag.UQ.name() SequenceUtil.sumQualitiesOfMismatches(record referenceBases 0 isBisulfiteSequence)); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AbstractAlignmentMerger.java,getAttributesToReverse,public Set<String>  (){ return attributesToReverse; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AbstractAlignmentMerger.java,getAttributesToReverseComplement,public Set<String>  (){ return attributesToReverseComplement; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AddCommentsToBam.java,doWork,"protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); if (INPUT.getAbsolutePath().endsWith("".sam"")) { throw new PicardException(""SAM files are not supported""); } final SAMFileHeader samFileHeader=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).getFileHeader(INPUT); for ( final String comment : COMMENT) { if (comment.contains(""\n"")) { throw new PicardException(""Comments can not contain a new line""); } samFileHeader.addComment(comment); } BamFileIoUtils.reheaderBamFile(samFileHeader INPUT OUTPUT CREATE_MD5_FILE CREATE_INDEX); return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AddCommentsToBam.java,main,public static void  (final String[] args){ new AddCommentsToBam().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\reference\NonNFastaSize.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); final ReferenceSequenceFile ref=ReferenceSequenceFileFactory.getReferenceSequenceFile(INPUT); final ReferenceSequenceMask referenceSequenceMask; if (INTE
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\reference\NonNFastaSize.java,main,public static void  (final String[] args){ new NonNFastaSize().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AddOrReplaceReadGroups.java,checkTagValue,"private Optional<String>  (final String tagName final String value){ if (value == null) { return Optional.empty(); } final Matcher matcher=pattern.matcher(value); if (matcher.matches()) { return Optional.empty(); } else { return Optional.of(String.format(""The values of tags in a SAM header must adhere to the regular expression '%s' "" + ""but the value provided for %s  '%s'  doesn't."" READGROUP_ID_REGEX tagName value)); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AddOrReplaceReadGroups.java,customCommandLineValidation,"@Override protected String[]  (){ final List<String> validationFailures=new ArrayList<>(); checkTagValue(""RGID"" RGID).ifPresent(validationFailures::add); checkTagValue(""RGLB"" RGLB).ifPresent(validationFailures::add); checkTagValue(""RGPL"" RGPL).ifPresent(v"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\AddOrReplaceReadGroups.java,doWork,"protected int  (){ IOUtil.assertInputIsValid(INPUT); IOUtil.assertFileIsWritable(OUTPUT); final SamReader in=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT)); final SAMReadGroupRecord rg=new SAMReadGroupRecord(RGID); rg.setLibrary(RGLB); rg.setPlatform(RGPL); rg.setSample(RGSM); rg.setPlatformUnit(RGPU); if (RGCN != null) rg.setSequencingCenter(RGCN); if (RGDS != null) rg.setDescription(RGDS); if (RGDT != null) rg.setRunDate(RGDT); if (RGPI != null) rg.setPredictedMedianInsertSize(RGPI); if (RGPG != null) rg.setProgramGroup(RGPG); if (RGPM != null) rg.setPlatformModel(RGPM); if (RGKS != null) rg.setKeySequence(RGKS); if (RGFO != null) rg.setFlowOrder(RGFO); log.info(String.format(""Created read-group ID=%s PL=%s LB=%s SM=%s%n"" rg.getId() rg.getPlatform() rg.getLibrary() rg.getSample())); final SAMFileHeader inHeader=in.getFileHeader(); final SAMFileHeader outHeader=inHeader.clone(); outHeader.setReadGroups(Collections.singletonList(rg)); if (SORT_ORDER != null) outHeader.setSortOrder(SORT_ORDER); final SAMFileWriter outWriter=new SAMFileWriterFactory().makeSAMOrBAMWriter(outHeader outHeader.getSortOrder() == inHeader.getSortOrder() OUTPUT); final ProgressLogger progress=new ProgressLogger(log); for ( final SAMRecord read : in) { read.setAttribute(SAMTag.RG.name() RGID); outWriter.addAlignment(read); progress.record(read); } CloserUtil.close(in); outWriter.close(); return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\BestEndMapqPrimaryAlignmentStrategy.java,compare,public int  (final SAMRecord rec1 final SAMRecord rec2){ if (rec1.getReadUnmappedFlag()) { if (rec2.getReadUnmappedFlag()) return 0; else return 1; } else if (rec2.getReadUnmappedFlag()) { return -1; } return -SAMUtils.compareMapqs(rec1.getMappingQuality() rec2.getMappingQuality()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\BestEndMapqPrimaryAlignmentStrategy.java,pickPrimaryAlignment,"public void  (final HitsForInsert hits){ if (hits.numHits() == 0) throw new IllegalArgumentException(""No alignments to pick from""); Collections.sort(hits.firstOfPairOrFragment MAPQ_COMPARATOR); Collections.sort(hits.secondOfPair MAPQ_COMPARATOR); randomlySelectPrimaryFromBest(hits.firstOfPairOrFragment); randomlySelectPrimaryFromBest(hits.secondOfPair); hits.setPrimaryAlignment(0); if (!hits.isPaired()) return; if (hits.firstOfPairOrFragment.size() <= 1 || hits.secondOfPair.size() <= 1) return; final int amountToSlide=hits.firstOfPairOrFragment.size() - 1; for (int i=0; i < amountToSlide; ++i) { hits.secondOfPair.add(1 null); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\BestEndMapqPrimaryAlignmentStrategy.java,randomlySelectPrimaryFromBest,private void  (List<SAMRecord> recs){ if (recs.isEmpty()) return; final int bestMapq=recs.get(0).getMappingQuality(); int i; for (i=1; i < recs.size() && recs.get(i).getMappingQuality() == bestMapq; ++i) { } final int bestIndex=random.nextInt(i); if (bestIndex == 0) return; final SAMRecord tmp=recs.get(0); recs.set(0 recs.get(bestIndex)); recs.set(bestIndex tmp); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\BamIndexStats.java,doWork,"protected int  (){ if (INPUT.getName().endsWith(BAMIndex.BAMIndexSuffix)) log.warn(""INPUT should be the BAM file name  not its index file""); IOUtil.assertFileIsReadable(INPUT); BAMIndexMetaData.printIndexStats(INPUT); return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\BamIndexStats.java,main,public static void  (final String[] argv){ System.exit(new BamIndexStats().instanceMain(argv)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CalculateReadGroupChecksum.java,doWork,@Override protected int  (){ final File output=OUTPUT == null ? new File(INPUT.getParentFile() getOutputFileName(INPUT)) : OUTPUT; IOUtil.assertFileIsWritable(output); final String hashText=SAMUtils.calculateReadGroupRecordChecksum(INPUT REFERENCE_SEQUENC
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CalculateReadGroupChecksum.java,getOutputFileName,public static String  (final File inputFile){ return inputFile.getName() + OUTPUT_FILE_EXTENSION; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CalculateReadGroupChecksum.java,main,public static void  (final String[] args){ new CalculateReadGroupChecksum().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\BestMapqPrimaryAlignmentSelectionStrategy.java,pickPrimaryAlignment,"public void  (final HitsForInsert hits){ if (hits.numHits() == 0) throw new IllegalArgumentException(""No alignments to pick from""); hits.coordinateByHitIndex(); final NumPrimaryAlignmentState firstEndAlignmentState=hits.tallyPrimaryAlignments(true); final NumPrimaryAlignmentState secondEndAlignmentState=hits.tallyPrimaryAlignments(false); if ((firstEndAlignmentState == NumPrimaryAlignmentState.NONE && secondEndAlignmentState == NumPrimaryAlignmentState.NONE) || firstEndAlignmentState == NumPrimaryAlignmentState.MORE_THAN_ONE || secondEndAlignmentState == NumPrimaryAlignmentState.MORE_THAN_ONE) { final List<Integer> primaryAlignmentIndices=new ArrayList<Integer>(hits.numHits()); int bestMapQ=-1; for (int i=0; i < hits.numHits(); ++i) { final int firstEndMapq; if (hits.getFirstOfPair(i) != null) { firstEndMapq=hits.getFirstOfPair(i).getMappingQuality(); } else { firstEndMapq=0; } final int secondEndMapq; if (hits.getSecondOfPair(i) != null) { secondEndMapq=hits.getSecondOfPair(i).getMappingQuality(); } else { secondEndMapq=0; } int thisMapQ=SAMUtils.combineMapqs(firstEndMapq secondEndMapq); if (thisMapQ > bestMapQ) { bestMapQ=thisMapQ; primaryAlignmentIndices.clear(); } if (thisMapQ == bestMapQ) primaryAlignmentIndices.add(i); } final int primaryAlignmentIndex; if (primaryAlignmentIndices.size() == 1) primaryAlignmentIndex=primaryAlignmentIndices.get(0); else if (primaryAlignmentIndices.size() > 1) primaryAlignmentIndex=primaryAlignmentIndices.get(random.nextInt(primaryAlignmentIndices.size())); else throw new IllegalStateException(""Never found a best MAPQ -- should never happen""); hits.setPrimaryAlignment(primaryAlignmentIndex); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CheckTerminatorBlock.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); try { final FileTermination term=BlockCompressedInputStream.checkTermination(INPUT); System.err.println(term.name()); if (term == FileTermination.DEFECTIVE) { return 100; } else { return 0; 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CheckTerminatorBlock.java,main,public static void  (final String[] args){ new CheckTerminatorBlock().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\BuildBamIndex.java,doWork,"protected int  (){ try { inputUrl=new URL(INPUT); } catch ( java.net.MalformedURLException e) { inputFile=new File(INPUT); } if (OUTPUT == null) { final String baseFileName; if (inputUrl != null) { final String path=inputUrl.getPath(); final int lastSlash=path.lastIndexOf('/'); baseFileName=path.substring(lastSlash + 1 path.length()); } else { baseFileName=inputFile.getAbsolutePath(); } if (baseFileName.endsWith(BamFileIoUtils.BAM_FILE_EXTENSION)) { final int index=baseFileName.lastIndexOf('.'); OUTPUT=new File(baseFileName.substring(0 index) + BAMIndex.BAMIndexSuffix); } else { OUTPUT=new File(baseFileName + BAMIndex.BAMIndexSuffix); } } IOUtil.assertFileIsWritable(OUTPUT); final SamReader bam; if (inputUrl != null) { bam=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).disable(SamReaderFactory.Option.EAGERLY_DECODE).enable(SamReaderFactory.Option.INCLUDE_SOURCE_IN_RECORDS).open(SamInputResource.of(inputUrl)); } else { IOUtil.assertFileIsReadable(inputFile); bam=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).enable(SamReaderFactory.Option.INCLUDE_SOURCE_IN_RECORDS).open(inputFile); } if (bam.type() != SamReader.Type.BAM_TYPE) { throw new SAMException(""Input file must be bam file  not sam file.""); } if (!bam.getFileHeader().getSortOrder().equals(SAMFileHeader.SortOrder.coordinate)) { throw new SAMException(""Input bam file must be sorted by coordinate""); } BAMIndexer.createIndex(bam OUTPUT); log.info(""Successfully wrote bam index file "" + OUTPUT); CloserUtil.close(bam); return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\BuildBamIndex.java,main,public static void  (final String[] argv){ System.exit(new BuildBamIndex().instanceMain(argv)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CreateSequenceDictionary.java,CreateSequenceDictionary,"public  (){ try { md5=MessageDigest.getInstance(""MD5""); } catch ( NoSuchAlgorithmException e) { throw new PicardException(""MD5 algorithm not found"" e); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CreateSequenceDictionary.java,clone,public StringCodec  (){ return new StringCodec(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CreateSequenceDictionary.java,customCommandLineValidation,"protected String[]  (){ if (URI == null) { URI=""file:"" + referenceSequence.getReferenceFile().getAbsolutePath(); } if (OUTPUT == null) { OUTPUT=ReferenceSequenceFileFactory.getDefaultDictionaryForReferenceSequence(referenceSequence.getReferenceFile()); logger.info(""Output dictionary will be written in "" OUTPUT); } return super.customCommandLineValidation(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CreateSequenceDictionary.java,decode,"public String  (){ try { return dis.readUTF(); } catch ( EOFException e) { return null; } catch ( IOException e) { throw new PicardException(""Exception reading sequence name from temporary file."" e); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CreateSequenceDictionary.java,doWork,"protected int  (){ if (OUTPUT.exists()) { throw new PicardException(OUTPUT.getAbsolutePath() + "" already exists. Delete this file and try again  or specify a different output file.""); } final SortingCollection<String> sequenceNames=makeSortingCollection(); try (BufferedWriter writer=makeWriter()){ final ReferenceSequenceFile refSeqFile=ReferenceSequenceFileFactory.getReferenceSequenceFile(REFERENCE_SEQUENCE TRUNCATE_NAMES_AT_WHITESPACE); SAMSequenceDictionaryCodec samDictCodec=new SAMSequenceDictionaryCodec(writer); samDictCodec.encodeHeaderLine(false); for (ReferenceSequence refSeq=refSeqFile.nextSequence(); refSeq != null; refSeq=refSeqFile.nextSequence()) { final SAMSequenceRecord samSequenceRecord=makeSequenceRecord(refSeq); samDictCodec.encodeSequenceRecord(samSequenceRecord); sequenceNames.add(refSeq.getName()); } } catch ( FileNotFoundException e) { throw new PicardException(""File "" + OUTPUT.getAbsolutePath() + "" not found""); } catch ( IOException e) { throw new PicardException(""Can't write to or close output file "" + OUTPUT.getAbsolutePath()); } final CloseableIterator<String> iterator=sequenceNames.iterator(); if (!iterator.hasNext()) return 0; String current=iterator.next(); while (iterator.hasNext()) { final String next=iterator.next(); if (current.equals(next)) { OUTPUT.delete(); throw new PicardException(""Sequence name "" + current + "" appears more than once in reference file""); } current=next; } return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CreateSequenceDictionary.java,encode,public void  (final String str){ try { dos.writeUTF(str); } catch ( IOException e) { throw new RuntimeIOException(e); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CreateSequenceDictionary.java,getReferenceFile,@Override public File  (){ return REFERENCE; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CreateSequenceDictionary.java,main,public static void  (final String[] argv){ System.exit(new CreateSequenceDictionary().instanceMain(argv)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CreateSequenceDictionary.java,makeReferenceArgumentCollection,@Override protected ReferenceArgumentCollection  (){ return new CreateSeqDictReferenceArgumentCollection(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CreateSequenceDictionary.java,makeSequenceDictionary,@Deprecated public SAMSequenceDictionary  (final File referenceFile){ final ReferenceSequenceFile refSeqFile=ReferenceSequenceFileFactory.getReferenceSequenceFile(referenceFile TRUNCATE_NAMES_AT_WHITESPACE); ReferenceSequence refSeq; final List<SAMSequenc
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CreateSequenceDictionary.java,makeSequenceRecord,private SAMSequenceRecord  (final ReferenceSequence refSeq){ final SAMSequenceRecord ret=new SAMSequenceRecord(refSeq.getName() refSeq.length()); final byte[] bases=refSeq.getBases(); for (int i=0; i < bases.length; ++i) { bases[i]=StringUtil.toUpperCase(bases[i]); } ret.setAttribute(SAMSequenceRecord.MD5_TAG md5Hash(bases)); if (GENOME_ASSEMBLY != null) { ret.setAttribute(SAMSequenceRecord.ASSEMBLY_TAG GENOME_ASSEMBLY); } ret.setAttribute(SAMSequenceRecord.URI_TAG URI); if (SPECIES != null) { ret.setAttribute(SAMSequenceRecord.SPECIES_TAG SPECIES); } return ret; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CreateSequenceDictionary.java,makeSortingCollection,private SortingCollection<String>  (){ final String name=getClass().getSimpleName(); final File tmpDir=IOUtil.createTempDir(name null); tmpDir.deleteOnExit(); long maxNamesInRam=Runtime.getRuntime().maxMemory() / 256 / 10; return SortingCollection.newInstance(String.class new StringCodec() String::compareTo (int)Math.min(maxNamesInRam Integer.MAX_VALUE) tmpDir); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CreateSequenceDictionary.java,makeWriter,"private BufferedWriter  () throws FileNotFoundException { return new BufferedWriter(new AsciiWriter(this.CREATE_MD5_FILE ? new Md5CalculatingOutputStream(new FileOutputStream(OUTPUT false) new File(OUTPUT.getAbsolutePath() + "".md5"")) : new FileOutputStream(OUTPUT))); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CreateSequenceDictionary.java,md5Hash,"private String  (final byte[] bytes){ md5.reset(); md5.update(bytes); String s=new BigInteger(1 md5.digest()).toString(16); if (s.length() != 32) { final String zeros=""00000000000000000000000000000000""; s=zeros.substring(0 32 - s.length()) + s; } return s; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CreateSequenceDictionary.java,setInputStream,public void  (final InputStream is){ dis=new DataInputStream(is); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CreateSequenceDictionary.java,setOutputStream,public void  (final OutputStream os){ dos=new DataOutputStream(os); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\DownsampleSam.java,customCommandLineValidation,"@Override protected String[]  (){ if (PROBABILITY < 0 || PROBABILITY > 1) return new String[]{""Downsampling requires 0<=PROBABILITY<=1. Found invalid value: "" + PROBABILITY}; return super.customCommandLineValidation(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\DownsampleSam.java,doWork,"@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); if (PROBABILITY == 1) { log.warn(""Running DownsampleSam with PROBABILITY=1! This will likely just recreate the input file.""); } if (PROBABILITY == 0) { l"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\DownsampleSam.java,getReferenceFile,@Override public File  (){ return REFERENCE_SEQUENCE; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\DownsampleSam.java,makeReferenceArgumentCollection,"@Override protected ReferenceArgumentCollection  (){ return new ReferenceArgumentCollection(){ @Argument(doc=""The reference sequence file."" optional=true common=false) public File REFERENCE_SEQUENCE; @Override public File getReferenceFile(){ return REFERE"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\EarliestFragmentPrimaryAlignmentSelectionStrategy.java,getIndexOfFirstAlignedBase,int  (final SAMRecord rec){ final List<AlignmentBlock> alignmentBlocks=rec.getAlignmentBlocks(); if (rec.getReadNegativeStrandFlag()) { final AlignmentBlock alignmentBlock=alignmentBlocks.get(alignmentBlocks.size() - 1); return rec.getReadLength() - CoordMath.getEnd(alignmentBlock.getReadStart() alignmentBlock.getLength()) + 1; } else { return alignmentBlocks.get(0).getReadStart(); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\EarliestFragmentPrimaryAlignmentSelectionStrategy.java,pickPrimaryAlignment,"public void  (final HitsForInsert hitsForInsert){ if (hitsForInsert.numHits() == 0) throw new IllegalArgumentException(""No alignments to pick from""); final List<Integer> earliestAlignments=new ArrayList<Integer>(); int earliestMappedBase=Integer.MAX_VALUE; int bestMapQ=-1; for (int i=0; i < hitsForInsert.numHits(); ++i) { final SAMRecord rec=hitsForInsert.getFragment(i); if (rec.getReadUnmappedFlag()) continue; final int thisFirstMappedBase=getIndexOfFirstAlignedBase(rec); final int thisMapQ=rec.getMappingQuality(); if (thisFirstMappedBase < earliestMappedBase || (thisFirstMappedBase == earliestMappedBase && thisMapQ > bestMapQ)) { earliestAlignments.clear(); earliestAlignments.add(i); earliestMappedBase=thisFirstMappedBase; bestMapQ=thisMapQ; } else if (thisFirstMappedBase == earliestMappedBase && thisMapQ == bestMapQ) { earliestAlignments.add(i); } } if (earliestAlignments.size() == 1) { hitsForInsert.setPrimaryAlignment(earliestAlignments.get(0)); } else { hitsForInsert.setPrimaryAlignment(earliestAlignments.get(random.nextInt(earliestAlignments.size()))); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,areEqual,public boolean  (){ return areEqual; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,compareAlignmentCoordinates,private int  (final SAMRecord left final SAMRecord right){ final String leftReferenceName=left.getReferenceName(); final String rightReferenceName=right.getReferenceName(); if (leftReferenceName == null && rightReferenceName == null) { return 0; } else if (leftReferenceName == null) { return 1; } else if (rightReferenceName == null) { return -1; } final int leftReferenceIndex=samReaders[0].getFileHeader().getSequenceIndex(leftReferenceName); final int rightReferenceIndex=samReaders[0].getFileHeader().getSequenceIndex(rightReferenceName); if (leftReferenceIndex != rightReferenceIndex) { return leftReferenceIndex - rightReferenceIndex; } return left.getAlignmentStart() - right.getAlignmentStart(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,compareAlignments,"private boolean  (){ if (!compareValues(samReaders[0].getFileHeader().getSortOrder() samReaders[1].getFileHeader().getSortOrder() ""Sort Order"")) { System.out.println(""Cannot compare alignments if sort orders differ.""); return false; } switch (samReaders[0].getFileHeader().getSortOrder()) { case coordinate: if (sequenceDictionariesDiffer) { System.out.println(""Cannot compare coordinate-sorted SAM files because sequence dictionaries differ.""); return false; } return compareCoordinateSortedAlignments(); case queryname: return compareQueryNameSortedAlignments(); case duplicate: case unsorted: return compareUnsortedAlignments(); default : return false; } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,compareCoordinateSortedAlignments,private boolean  (){ final SecondaryOrSupplementarySkippingIterator itLeft=new SecondaryOrSupplementarySkippingIterator(samReaders[0].iterator()); final SecondaryOrSupplementarySkippingIterator itRight=new SecondaryOrSupplementarySkippingIterator(samReaders[1].iterator()); final Map<String SAMRecord> leftUnmatched=new HashMap<String SAMRecord>(); final Map<String SAMRecord> rightUnmatched=new HashMap<String SAMRecord>(); boolean ret=true; while (itLeft.hasCurrent()) { if (!itRight.hasCurrent()) { for (; itLeft.hasCurrent(); itLeft.advance()) { final SAMRecord left=itLeft.getCurrent(); final SAMRecord right=rightUnmatched.remove(getKeyForRecord(left)); if (right == null) { ++missingRight; } else { tallyAlignmentRecords(left right); } } break; } final SAMRecord left=itLeft.getCurrent(); final Map<String SAMRecord> leftCurrentCoordinate=new HashMap<String SAMRecord>(); leftCurrentCoordinate.put(getKeyForRecord(left) left); while (itLeft.advance()) { final SAMRecord nextLeft=itLeft.getCurrent(); if (compareAlignmentCoordinates(left nextLeft) == 0) { leftCurrentCoordinate.put(getKeyForRecord(nextLeft) nextLeft); } else { break; } } while (itRight.hasCurrent() && compareAlignmentCoordinates(left itRight.getCurrent()) > 0) { final SAMRecord right=itRight.getCurrent(); rightUnmatched.put(getKeyForRecord(right) right); itRight.advance(); } for (; itRight.hasCurrent() && compareAlignmentCoordinates(left itRight.getCurrent()) == 0; itRight.advance()) { final SAMRecord right=itRight.getCurrent(); final SAMRecord matchingLeft=leftCurrentCoordinate.remove(getKeyForRecord(right)); if (matchingLeft != null) { ret=tallyAlignmentRecords(matchingLeft right) && ret; } else { rightUnmatched.put(getKeyForRecord(right) right); } } for ( final SAMRecord samRecord : leftCurrentCoordinate.values()) { leftUnmatched.put(getKeyForRecord(samRecord) samRecord); } } for (; itRight.hasCurrent(); itRight.advance()) { final SAMRecord right=itRight.getCurrent(); final SAMRecord left=leftUnmatched.remove(getKeyForRecord(right)); if (left != null) { tallyAlignmentRecords(left right); } else { ++missingLeft; } } for ( final Map.Entry<String SAMRecord> leftEntry : leftUnmatched.entrySet()) { final String key=leftEntry.getKey(); final SAMRecord left=leftEntry.getValue(); final SAMRecord right=rightUnmatched.remove(key); if (right == null) { ++missingRight; continue; } tallyAlignmentRecords(left right); } missingLeft+=rightUnmatched.size(); if (ret && (missingLeft > 0 || missingRight > 0 || mappingsDiffer > 0 || unmappedLeft > 0 || unmappedRight > 0)) { ret=false; } return ret; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,compareHeaders,"private boolean  (){ final SAMFileHeader h1=samReaders[0].getFileHeader(); final SAMFileHeader h2=samReaders[1].getFileHeader(); boolean ret=compareValues(h1.getVersion() h2.getVersion() ""File format version""); ret=compareValues(h1.getCreator() h2.getCreator() ""File creator"") && ret; ret=compareValues(h1.getAttribute(""SO"") h2.getAttribute(""SO"") ""Sort order"") && ret; if (!compareSequenceDictionaries(h1 h2)) { ret=false; sequenceDictionariesDiffer=true; } ret=compareReadGroups(h1 h2) && ret; ret=compareProgramRecords(h1 h2) && ret; return ret; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,compareProgramRecord,"private boolean  (final SAMProgramRecord programRecord1 final SAMProgramRecord programRecord2){ if (programRecord1 == null && programRecord2 == null) { return true; } if (programRecord1 == null) { reportDifference(""null"" programRecord2.getProgramGroupId() ""Program Record""); return false; } if (programRecord2 == null) { reportDifference(programRecord1.getProgramGroupId() ""null"" ""Program Record""); return false; } boolean ret=compareValues(programRecord1.getProgramGroupId() programRecord2.getProgramGroupId() ""Program Name""); final String[] attributes={""VN"" ""CL""}; for ( final String attribute : attributes) { ret=compareValues(programRecord1.getAttribute(attribute) programRecord2.getAttribute(attribute) attribute + "" Program Record attribute"") && ret; } return ret; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,compareProgramRecords,"private boolean  (final SAMFileHeader h1 final SAMFileHeader h2){ final List<SAMProgramRecord> l1=h1.getProgramRecords(); final List<SAMProgramRecord> l2=h2.getProgramRecords(); if (!compareValues(l1.size() l2.size() ""Number of program records"")) { return false; } boolean ret=true; for (int i=0; i < l1.size(); ++i) { ret=compareProgramRecord(l1.get(i) l2.get(i)) && ret; } return ret; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,compareQueryNameSortedAlignments,private boolean  (){ final SecondaryOrSupplementarySkippingIterator it1=new SecondaryOrSupplementarySkippingIterator(samReaders[0].iterator()); final SecondaryOrSupplementarySkippingIterator it2=new SecondaryOrSupplementarySkippingIterator(samReaders[1].iterator()); boolean ret=true; while (it1.hasCurrent()) { if (!it2.hasCurrent()) { missingRight+=countRemaining(it1); return false; } final int cmp=it1.getCurrent().getReadName().compareTo(it2.getCurrent().getReadName()); if (cmp < 0) { ++missingRight; it1.advance(); ret=false; } else if (cmp > 0) { ++missingLeft; it2.advance(); ret=false; } else { if (!tallyAlignmentRecords(it1.getCurrent() it2.getCurrent())) { ret=false; } it1.advance(); it2.advance(); } } if (it2.hasCurrent()) { missingLeft+=countRemaining(it2); return false; } return ret; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,compareReadGroup,"private boolean  (final SAMReadGroupRecord samReadGroupRecord1 final SAMReadGroupRecord samReadGroupRecord2){ boolean ret=compareValues(samReadGroupRecord1.getReadGroupId() samReadGroupRecord2.getReadGroupId() ""Read Group ID""); ret=compareValues(samReadGroupRecord1.getSample() samReadGroupRecord2.getSample() ""Sample for read group "" + samReadGroupRecord1.getReadGroupId()) && ret; ret=compareValues(samReadGroupRecord1.getLibrary() samReadGroupRecord2.getLibrary() ""Library for read group "" + samReadGroupRecord1.getReadGroupId()) && ret; final String[] attributes={""DS"" ""PU"" ""PI"" ""CN"" ""DT"" ""PL""}; for ( final String attribute : attributes) { ret=compareValues(samReadGroupRecord1.getAttribute(attribute) samReadGroupRecord2.getAttribute(attribute) attribute + "" for read group "" + samReadGroupRecord1.getReadGroupId()) && ret; } return ret; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,compareReadGroups,"private boolean  (final SAMFileHeader h1 final SAMFileHeader h2){ final List<SAMReadGroupRecord> l1=h1.getReadGroups(); final List<SAMReadGroupRecord> l2=h2.getReadGroups(); if (!compareValues(l1.size() l2.size() ""Number of read groups"")) { return false; } boolean ret=true; for (int i=0; i < l1.size(); ++i) { ret=compareReadGroup(l1.get(i) l2.get(i)) && ret; } return ret; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,compareSequenceDictionaries,"private boolean  (final SAMFileHeader h1 final SAMFileHeader h2){ final List<SAMSequenceRecord> s1=h1.getSequenceDictionary().getSequences(); final List<SAMSequenceRecord> s2=h2.getSequenceDictionary().getSequences(); if (s1.size() != s2.size()) { reportDifference(s1.size() s2.size() ""Length of sequence dictionaries""); return false; } boolean ret=true; for (int i=0; i < s1.size(); ++i) { ret=compareSequenceRecord(s1.get(i) s2.get(i) i + 1) && ret; } return ret; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,compareSequenceRecord,"private boolean  (final SAMSequenceRecord sequenceRecord1 final SAMSequenceRecord sequenceRecord2 final int which){ if (!sequenceRecord1.getSequenceName().equals(sequenceRecord2.getSequenceName())) { reportDifference(sequenceRecord1.getSequenceName() sequenceRecord2.getSequenceName() ""Name of sequence record "" + which); return false; } boolean ret=compareValues(sequenceRecord1.getSequenceLength() sequenceRecord2.getSequenceLength() ""Length of sequence "" + sequenceRecord1.getSequenceName()); ret=compareValues(sequenceRecord1.getSpecies() sequenceRecord2.getSpecies() ""Species of sequence "" + sequenceRecord1.getSequenceName()) && ret; ret=compareValues(sequenceRecord1.getAssembly() sequenceRecord2.getAssembly() ""Assembly of sequence "" + sequenceRecord1.getSequenceName()) && ret; ret=compareValues(sequenceRecord1.getAttribute(""M5"") sequenceRecord2.getAttribute(""M5"") ""MD5 of sequence "" + sequenceRecord1.getSequenceName()) && ret; ret=compareValues(sequenceRecord1.getAttribute(""UR"") sequenceRecord2.getAttribute(""UR"") ""URI of sequence "" + sequenceRecord1.getSequenceName()) && ret; return ret; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,compareUnsortedAlignments,"private boolean  (){ final SecondaryOrSupplementarySkippingIterator it1=new SecondaryOrSupplementarySkippingIterator(samReaders[0].iterator()); final SecondaryOrSupplementarySkippingIterator it2=new SecondaryOrSupplementarySkippingIterator(samReaders[1].iterator()); boolean ret=true; for (; it1.hasCurrent(); it1.advance()  it2.advance()) { if (!it2.hasCurrent()) { missingRight+=countRemaining(it1); return false; } final SAMRecord s1=it1.getCurrent(); final SAMRecord s2=it2.getCurrent(); if (!compareValues(s1.getReadName() s2.getReadName() ""Read names"")) { System.out.println(""Read names cease agreeing in unsorted SAM files . Comparison aborting.""); } ret=tallyAlignmentRecords(s1 s2) && ret; } if (it2.hasCurrent()) { missingLeft+=countRemaining(it2); return false; } return ret; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,compareValues,private <T>boolean  (final T v1 final T v2 final String label){ if (v1 == null) { if (v2 == null) { return true; } reportDifference(v1 v2 label); return false; } if (v2 == null) { reportDifference(v1 v2 label); return false; } if (!v1.equals(v2)) { reportDifference(v1 v2 label); return false; } return true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,countRemaining,private int  (final SecondaryOrSupplementarySkippingIterator it){ int i; for (i=0; it.hasCurrent(); ++i) { it.advance(); } return i; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,doWork,@Override protected int  (){ for (int i=0; i < samFiles.size(); ++i) { samReaders[i]=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(samFiles.get(i)); } areEqual=compareHeaders(); areEqual=compareAlignments() && areEqual; printRe
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,getKeyForRecord,"private String  (final SAMRecord record){ final boolean isSecondOfPair=record.getReadPairedFlag() && record.getSecondOfPairFlag(); return record.getReadName() + ""-"" + (isSecondOfPair ? ""second"" : ""first""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,getMappingsDiffer,public int  (){ return mappingsDiffer; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,getMappingsMatch,public int  (){ return mappingsMatch; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,getMissingLeft,public int  (){ return missingLeft; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,getMissingRight,public int  (){ return missingRight; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,getUnmappedBoth,public int  (){ return unmappedBoth; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,getUnmappedLeft,public int  (){ return unmappedLeft; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,getUnmappedRight,public int  (){ return unmappedRight; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,main,public static void  (String[] argv){ new CompareSAMs().instanceMainWithExit(argv); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,printReport,"private void  (){ System.out.println(""Match\t"" + mappingsMatch); System.out.println(""Differ\t"" + mappingsDiffer); System.out.println(""Unmapped_both\t"" + unmappedBoth); System.out.println(""Unmapped_left\t"" + unmappedLeft); System.out.println(""Unmapped_right\t"" + unmappedRight); System.out.println(""Missing_left\t"" + missingLeft); System.out.println(""Missing_right\t"" + missingRight); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,reportDifference,"private void  (Object o1 Object o2 final String label){ if (o1 == null) { o1=""null""; } if (o2 == null) { o2=""null""; } reportDifference(o1.toString() o2.toString() label); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CompareSAMs.java,tallyAlignmentRecords,"private boolean  (final SAMRecord s1 final SAMRecord s2){ if (!s1.getReadName().equals(s2.getReadName())) { throw new PicardException(""Read names do not match: "" + s1.getReadName() + "" : ""+ s2.getReadName()); } if (s1.getReadUnmappedFlag() && s2.getReadUnmappedFlag()) { ++unmappedBoth; return true; } if (s1.getReadUnmappedFlag()) { ++unmappedLeft; return false; } if (s2.getReadUnmappedFlag()) { ++unmappedRight; return false; } final boolean ret=(s1.getReferenceName().equals(s2.getReferenceName()) && s1.getAlignmentStart() == s2.getAlignmentStart() && s1.getReadNegativeStrandFlag() == s1.getReadNegativeStrandFlag()); if (!ret) { ++mappingsDiffer; } else { ++mappingsMatch; } return ret; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CleanSam.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); final SamReaderFactory factory=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE); if (VALIDATION_STRINGENCY == ValidationStringency.ST
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\CleanSam.java,main,public static void  (final String[] argv){ new CleanSam().instanceMainWithExit(argv); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FixMateInformation.java,close,@Override public void  (){ super.close(); sorter.cleanup(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FixMateInformation.java,closeWriter,protected void  (){ out.close(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FixMateInformation.java,createSamFileWriter,protected void  (final SAMFileHeader header){ out=new SAMFileWriterFactory().makeSAMOrBAMWriter(header header.getSortOrder() == SortOrder.queryname OUTPUT); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FixMateInformation.java,doWork,"protected int  (){ boolean allQueryNameSorted=true; final List<SamReader> readers=new ArrayList<>(); for ( final File f : INPUT) { IOUtil.assertFileIsReadable(f); final SamReader reader=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(f); readers.add(reader); if (reader.getFileHeader().getSortOrder() != SortOrder.queryname) allQueryNameSorted=false; } if (OUTPUT != null) OUTPUT=OUTPUT.getAbsoluteFile(); final boolean differentOutputSpecified=OUTPUT != null; if (differentOutputSpecified) { IOUtil.assertFileIsWritable(OUTPUT); } else if (INPUT.size() != 1) { throw new PicardException(""Must specify either an explicit OUTPUT file or a single INPUT file to be overridden.""); } else { final File soleInput=INPUT.get(0).getAbsoluteFile(); final File dir=soleInput.getParentFile().getAbsoluteFile(); try { IOUtil.assertFileIsWritable(soleInput); IOUtil.assertDirectoryIsWritable(dir); OUTPUT=File.createTempFile(soleInput.getName() + "".being_fixed."" BamFileIoUtils.BAM_FILE_EXTENSION dir); } catch ( final IOException ioe) { throw new RuntimeIOException(""Could not create tmp file in "" + dir.getAbsolutePath()); } } final PeekableIterator<SAMRecord> iterator; final SAMFileHeader header; { final Iterator<SAMRecord> tmp; if (INPUT.size() > 1) { final List<SAMFileHeader> headers=new ArrayList<>(readers.size()); for ( final SamReader reader : readers) { headers.add(reader.getFileHeader()); } final SortOrder sortOrder=(allQueryNameSorted ? SortOrder.queryname : SortOrder.unsorted); final SamFileHeaderMerger merger=new SamFileHeaderMerger(sortOrder headers false); tmp=new MergingSamRecordIterator(merger readers false); header=merger.getMergedHeader(); } else { tmp=readers.get(0).iterator(); header=readers.get(0).getFileHeader(); } if (ASSUME_SORTED || allQueryNameSorted) { iterator=new SamPairUtil.SetMateInfoIterator(new PeekableIterator<>(tmp) ADD_MATE_CIGAR IGNORE_MISSING_MATES); } else { log.info(""Sorting input into queryname order.""); final SortingCollection<SAMRecord> sorter=SortingCollection.newInstance(SAMRecord.class new BAMRecordCodec(header) new SAMRecordQueryNameComparator() MAX_RECORDS_IN_RAM TMP_DIR); while (tmp.hasNext()) { sorter.add(tmp.next()); } iterator=new SamPairUtil.SetMateInfoIterator(new PeekableIterator<SAMRecord>(sorter.iterator()){ @Override public void close(){ super.close(); sorter.cleanup(); } }  ADD_MATE_CIGAR IGNORE_MISSING_MATES); log.info(""Sorting by queryname complete.""); } final SortOrder outputSortOrder=SORT_ORDER == null ? readers.get(0).getFileHeader().getSortOrder() : SORT_ORDER; log.info(""Output will be sorted by "" + outputSortOrder); header.setSortOrder(outputSortOrder); } if (CREATE_INDEX && header.getSortOrder() != SortOrder.coordinate) { throw new PicardException(""Can't CREATE_INDEX unless sort order is coordinate""); } createSamFileWriter(header); log.info(""Traversing query name sorted records and fixing up mate pair information.""); final ProgressLogger progress=new ProgressLogger(log); while (iterator.hasNext()) { final SAMRecord record=iterator.next(); out.addAlignment(record); progress.record(record); } iterator.close(); if (header.getSortOrder() == SortOrder.queryname) { log.info(""Closing output file.""); } else { log.info(""Finished processing reads; re-sorting output file.""); } closeWriter(); if (!differentOutputSpecified) { log.info(""Replacing input file with fixed file.""); final File soleInput=INPUT.get(0).getAbsoluteFile(); final File old=new File(soleInput.getParentFile() soleInput.getName() + "".old""); if (!old.exists() && soleInput.renameTo(old)) { if (OUTPUT.renameTo(soleInput)) { if (!old.delete()) { log.warn(""Could not delete old file: "" + old.getAbsolutePath()); return 1; } if (CREATE_INDEX) { final File newIndex=new File(OUTPUT.getParent() OUTPUT.getName().substring(0 OUTPUT.getName().length() - 4) + "".bai""); final File oldIndex=new File(soleInput.getParent() soleInput.getName().substring(0 soleInput.getName().length() - 4) + "".bai""); if (!newIndex.renameTo(oldIndex)) { log.warn(""Could not overwrite index file: "" + oldIndex.getAbsolutePath()); } } } else { log.error(""Could not move new file to "" + soleInput.getAbsolutePath()); log.error(""Input file preserved as: "" + old.getAbsolutePath()); log.error(""New file preserved as: "" + OUTPUT.getAbsolutePath()); return 1; } } else { log.error(""Could not move input file out of the way: "" + soleInput.getAbsolutePath()); if (!OUTPUT.delete()) { log.error(""Could not delete temporary file: "" + OUTPUT.getAbsolutePath()); } return 1; } } CloserUtil.close(readers); return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FixMateInformation.java,main,public static void  (final String[] args){ new FixMateInformation().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FixMateInformation.java,writeAlignment,protected void  (final SAMRecord sam){ out.addAlignment(sam); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FilterSamReads.java,Filter, (final String description){ this.description=description; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FilterSamReads.java,checkInputs,"private Optional<String>  (final List<Filter> filters final Object inputObject final String inputFileVariable){ if (filters.contains(FILTER) && inputObject == null) return Optional.of(String.format(""%s must be specified when using FILTER=%s  but it was null."" inputFileVariable FILTER)); if (!filters.contains(FILTER) && inputObject != null) return Optional.of(String.format(""%s may only be specified when using FILTER from %s  FILTER value: %s  %s value: %s"" inputFileVariable String.join(""  "" filters.stream().map(Enum::toString).collect(Collectors.toList())) FILTER inputFileVariable inputObject)); return Optional.empty(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FilterSamReads.java,customCommandLineValidation,"@Override protected String[]  (){ List<String> errors=new ArrayList<>(); if (INPUT.equals(OUTPUT)) errors.add(""INPUT file and OUTPUT file must differ!""); List<Filter> tagFilters=Arrays.asList(Filter.includeTagValues Filter.excludeTagValues); checkInputs(A"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FilterSamReads.java,doWork,@Override protected int  (){ try { IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); if (WRITE_READS_FILES) writeReadsFile(INPUT); final SamReader samReader=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(I
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FilterSamReads.java,filterReads,"private void  (final FilteringSamIterator filteringIterator){ final SAMFileHeader fileHeader=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).getFileHeader(INPUT); final SAMFileHeader.SortOrder inputSortOrder=fileHeader.getSortOrder(); if (SORT_ORDER != null) { fileHeader.setSortOrder(SORT_ORDER); } if (FILTER == Filter.includePairedIntervals && fileHeader.getSortOrder() != SAMFileHeader.SortOrder.coordinate) { throw new UnsupportedOperationException(""Input must be coordinate sorted to use includePairedIntervals""); } final boolean presorted=inputSortOrder.equals(fileHeader.getSortOrder()); log.info(""Filtering [presorted="" + presorted + ""] ""+ INPUT.getName()+ "" -> OUTPUT=""+ OUTPUT.getName()+ "" [sortorder=""+ fileHeader.getSortOrder().name()+ ""]""); final SAMFileWriter outputWriter=new SAMFileWriterFactory().makeSAMOrBAMWriter(fileHeader presorted OUTPUT); final ProgressLogger progress=new ProgressLogger(log (int)1e6 ""Written""); while (filteringIterator.hasNext()) { final SAMRecord rec=filteringIterator.next(); outputWriter.addAlignment(rec); progress.record(rec); } filteringIterator.close(); outputWriter.close(); log.info(new DecimalFormat(""# ###"").format(progress.getCount()) + "" SAMRecords written to "" + OUTPUT.getName()); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FilterSamReads.java,getHelpDoc,@Override public String  (){ return description; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FilterSamReads.java,getIntervalList,private List<Interval>  (final File intervalFile) throws IOException { IOUtil.assertFileIsReadable(intervalFile); return IntervalList.fromFile(intervalFile).getIntervals(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FilterSamReads.java,writeReadsFile,"private void  (final File samOrBamFile) throws IOException { final File readsFile=new File(OUTPUT.getParentFile() IOUtil.basename(samOrBamFile) + "".reads""); IOUtil.assertFileIsWritable(readsFile); try (final SamReader reader=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(samOrBamFile);final BufferedWriter bw=IOUtil.openFileForBufferedWriting(readsFile false)){ for ( final SAMRecord rec : reader) { bw.write(rec.toString() + ""\n""); } } IOUtil.assertFileIsReadable(readsFile); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\GatherBamFiles.java,determineBlockCopyingStatus,private boolean  (final List<File> inputs){ boolean useBlockCopying=true; for ( final File f : inputs) { if (!BamFileIoUtils.isBamFile(f)) { useBlockCopying=false; } } return useBlockCopying; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\GatherBamFiles.java,doWork,"@Override protected int  (){ final List<File> inputs=IOUtil.unrollFiles(INPUT BamFileIoUtils.BAM_FILE_EXTENSION "".sam""); for ( final File f : inputs) IOUtil.assertFileIsReadable(f); IOUtil.assertFileIsWritable(OUTPUT); if (determineBlockCopyingStatus(inpu"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\GatherBamFiles.java,gatherNormally,"private static void  (final List<File> inputs final File output final boolean createIndex final boolean createMd5 final File referenceFasta){ final SAMFileHeader header; { header=SamReaderFactory.makeDefault().referenceSequence(referenceFasta).getFileHeader(inputs.get(0)); } final SAMFileWriter out=new SAMFileWriterFactory().setCreateIndex(createIndex).setCreateMd5File(createMd5).makeSAMOrBAMWriter(header true output); for ( final File f : inputs) { log.info(""Gathering "" + f.getAbsolutePath()); final SamReader in=SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(f); for ( final SAMRecord rec : in) out.addAlignment(rec); CloserUtil.close(in); } out.close(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\GatherBamFiles.java,main,public static void  (final String[] args){ final GatherBamFiles gatherer=new GatherBamFiles(); gatherer.CREATE_INDEX=true; gatherer.instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FastqToSam.java,convertQuality,void  (final byte[] quals final FastqQualityFormat version){ switch (version) { case Standard: SAMUtils.fastqToPhred(quals); break; case Solexa: solexaQualityConverter.convertSolexaQualityCharsToPhredBinary(quals); break; case Illumina: solexaQualityConverter.convertSolexa_1_3_QualityCharsToPhredBinary(quals); break; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FastqToSam.java,createSamFileHeader,public SAMFileHeader  (){ final SAMReadGroupRecord rgroup=new SAMReadGroupRecord(this.READ_GROUP_NAME); rgroup.setSample(this.SAMPLE_NAME); if (this.LIBRARY_NAME != null) rgroup.setLibrary(this.LIBRARY_NAME); if (this.PLATFORM != null) rgroup.setPlatform(this.PLATFORM); if (this.PLATFORM_UNIT != null) rgroup.setPlatformUnit(this.PLATFORM_UNIT); if (this.SEQUENCING_CENTER != null) rgroup.setSequencingCenter(SEQUENCING_CENTER); if (this.PREDICTED_INSERT_SIZE != null) rgroup.setPredictedMedianInsertSize(PREDICTED_INSERT_SIZE); if (this.DESCRIPTION != null) rgroup.setDescription(this.DESCRIPTION); if (this.RUN_DATE != null) rgroup.setRunDate(this.RUN_DATE); if (this.PLATFORM_MODEL != null) rgroup.setPlatformModel(this.PLATFORM_MODEL); if (this.PROGRAM_GROUP != null) rgroup.setProgramGroup(this.PROGRAM_GROUP); final SAMFileHeader header=new SAMFileHeader(); header.addReadGroup(rgroup); for ( final String comment : COMMENT) { header.addComment(comment); } header.setSortOrder(this.SORT_ORDER); return header; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FastqToSam.java,createSamRecord,"private SAMRecord  (final SAMFileHeader header final String baseName final FastqRecord frec final boolean paired){ final SAMRecord srec=new SAMRecord(header); srec.setReadName(baseName); srec.setReadString(frec.getReadString()); srec.setReadUnmappedFlag(true); srec.setAttribute(ReservedTagConstants.READ_GROUP_ID READ_GROUP_NAME); final byte[] quals=StringUtil.stringToBytes(frec.getBaseQualityString()); convertQuality(quals QUALITY_FORMAT); for ( final byte qual : quals) { final int uQual=qual & 0xff; if (uQual < MIN_Q || uQual > MAX_Q) { throw new PicardException(""Base quality "" + uQual + "" is not in the range ""+ MIN_Q+ ""..""+ MAX_Q+ "" for read ""+ frec.getReadHeader()); } } srec.setBaseQualities(quals); if (paired) { srec.setReadPairedFlag(true); srec.setMateUnmappedFlag(true); } return srec; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FastqToSam.java,customCommandLineValidation,"@Override protected String[]  (){ if (MIN_Q < 0) return new String[]{""MIN_Q must be >= 0""}; if (MAX_Q > SAMUtils.MAX_PHRED_SCORE) return new String[]{""MAX_Q must be <= "" + SAMUtils.MAX_PHRED_SCORE}; return null; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FastqToSam.java,determineQualityFormat,"public static FastqQualityFormat  (final FastqReader reader1 final FastqReader reader2 final FastqQualityFormat expectedQuality){ final QualityEncodingDetector detector=new QualityEncodingDetector(); if (reader2 == null) { detector.add(QualityEncodingDetector.DEFAULT_MAX_RECORDS_TO_ITERATE reader1); } else { detector.add(QualityEncodingDetector.DEFAULT_MAX_RECORDS_TO_ITERATE reader1 reader2); reader2.close(); } reader1.close(); final FastqQualityFormat qualityFormat=detector.generateBestGuess(QualityEncodingDetector.FileContext.FASTQ expectedQuality); if (detector.isDeterminationAmbiguous()) { LOG.warn(""Making ambiguous determination about fastq's quality encoding; more than one format possible based on observed qualities.""); } LOG.info(String.format(""Auto-detected quality format as: %s."" qualityFormat)); return qualityFormat; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FastqToSam.java,doPaired,"protected int  (final FastqReader freader1 final FastqReader freader2 final SAMFileWriter writer){ int readCount=0; final ProgressLogger progress=new ProgressLogger(LOG); for (; freader1.hasNext() && freader2.hasNext(); readCount++) { final FastqRecord frec1=freader1.next(); final FastqRecord frec2=freader2.next(); final String frec1Name=SequenceUtil.getSamReadNameFromFastqHeader(frec1.getReadHeader()); final String frec2Name=SequenceUtil.getSamReadNameFromFastqHeader(frec2.getReadHeader()); final String baseName=getBaseName(frec1Name frec2Name freader1 freader2); final SAMRecord srec1=createSamRecord(writer.getFileHeader() baseName frec1 true); srec1.setFirstOfPairFlag(true); srec1.setSecondOfPairFlag(false); writer.addAlignment(srec1); progress.record(srec1); final SAMRecord srec2=createSamRecord(writer.getFileHeader() baseName frec2 true); srec2.setFirstOfPairFlag(false); srec2.setSecondOfPairFlag(true); writer.addAlignment(srec2); progress.record(srec2); } if (freader1.hasNext() || freader2.hasNext()) { throw new PicardException(""Input paired fastq files must be the same length""); } return readCount; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FastqToSam.java,doUnpaired,protected int  (final FastqReader freader final SAMFileWriter writer){ int readCount=0; final ProgressLogger progress=new ProgressLogger(LOG); for (; freader.hasNext(); readCount++) { final FastqRecord frec=freader.next(); final SAMRecord srec=createSamRecord(writer.getFileHeader() SequenceUtil.getSamReadNameFromFastqHeader(frec.getReadHeader()) frec false); srec.setReadPairedFlag(false); writer.addAlignment(srec); progress.record(srec); } return readCount; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FastqToSam.java,doWork,"protected int  (){ IOUtil.assertFileIsReadable(FASTQ); if (FASTQ2 != null) { IOUtil.assertFileIsReadable(FASTQ2); } IOUtil.assertFileIsWritable(OUTPUT); final SAMFileHeader header=createSamFileHeader(); final SAMFileWriter writer=new SAMFileWriterFactory().makeSAMOrBAMWriter(header false OUTPUT); QUALITY_FORMAT=FastqToSam.determineQualityFormat(fileToFastqReader(FASTQ) (FASTQ2 == null) ? null : fileToFastqReader(FASTQ2) QUALITY_FORMAT); final List<FastqReader> readers1=new ArrayList<FastqReader>(); final List<FastqReader> readers2=new ArrayList<FastqReader>(); if (USE_SEQUENTIAL_FASTQS) { for ( final File fastq : getSequentialFileList(FASTQ)) { readers1.add(fileToFastqReader(fastq)); } if (null != FASTQ2) { for ( final File fastq : getSequentialFileList(FASTQ2)) { readers2.add(fileToFastqReader(fastq)); } if (readers1.size() != readers2.size()) { throw new PicardException(String.format(""Found %d files for FASTQ and %d files for FASTQ2."" readers1.size() readers2.size())); } } } else { readers1.add(fileToFastqReader(FASTQ)); if (FASTQ2 != null) { readers2.add(fileToFastqReader(FASTQ2)); } } for (int idx=0; idx < readers1.size(); idx++) { makeItSo(readers1.get(idx) (readers2.isEmpty()) ? null : readers2.get(idx) writer); } for ( final FastqReader reader : readers1) reader.close(); for ( final FastqReader reader : readers2) reader.close(); writer.close(); return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FastqToSam.java,error,"private String  (final FastqReader freader final String str){ return str + "" at line "" + freader.getLineNumber()+ "" in file ""+ freader.getFile().getAbsolutePath(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FastqToSam.java,fileToFastqReader,private FastqReader  (final File file){ return new FastqReader(file ALLOW_AND_IGNORE_EMPTY_LINES); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FastqToSam.java,getBaseName,"String  (final String readName1 final String readName2 final FastqReader freader1 final FastqReader freader2){ String[] toks=getReadNameTokens(readName1 1 freader1); final String baseName1=toks[0]; final String num1=toks[1]; toks=getReadNameTokens(readName2 2 freader2); final String baseName2=toks[0]; final String num2=toks[1]; if (!baseName1.equals(baseName2)) { throw new PicardException(String.format(""In paired mode  read name 1 (%s) does not match read name 2 (%s)"" baseName1 baseName2)); } final boolean num1Blank=StringUtil.isBlank(num1); final boolean num2Blank=StringUtil.isBlank(num2); if (num1Blank || num2Blank) { if (!num1Blank) throw new PicardException(error(freader1 ""Pair 1 number is missing ("" + readName1 + ""). Both pair numbers must be present or neither."")); else if (!num2Blank) throw new PicardException(error(freader2 ""Pair 2 number is missing ("" + readName2 + ""). Both pair numbers must be present or neither."")); } else { if (!num1.equals(""1"")) throw new PicardException(error(freader1 ""Pair 1 number must be 1 ("" + readName1 + "")"")); if (!num2.equals(""2"")) throw new PicardException(error(freader2 ""Pair 2 number must be 2 ("" + readName2 + "")"")); } return baseName1; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FastqToSam.java,getReadNameTokens,"private String[]  (final String readName final int pairNum final FastqReader freader){ if (readName.equals("""")) throw new PicardException(error(freader ""Pair read name "" + pairNum + "" cannot be empty: ""+ readName)); final int idx=readName.lastIndexOf('/'); final String[] result=new String[2]; if (idx == -1) { result[0]=readName; result[1]=null; } else { result[1]=readName.substring(idx + 1 readName.length()); if (!result[1].equals(""1"") && !result[1].equals(""2"")) { result[0]=readName; result[1]=null; } else { result[0]=readName.substring(0 idx); } } return result; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FastqToSam.java,getSequentialFileList,"protected static List<File>  (final File baseFastq){ final List<File> files=new ArrayList<File>(); files.add(baseFastq); FastqExtensions fastqExtensions=null; String suffix=null; for ( final FastqExtensions ext : FastqExtensions.values()) { suffix=""_001"" + ext.getExtension(); if (baseFastq.getAbsolutePath().endsWith(suffix)) { fastqExtensions=ext; break; } } if (null == fastqExtensions) { throw new PicardException(String.format(""Could not parse the FASTQ extension (expected '_001' + '%s'): %s"" FastqExtensions.values().toString() baseFastq)); } for (int idx=2; true; idx++) { String fastq=baseFastq.getAbsolutePath(); fastq=String.format(""%s_%03d%s"" fastq.substring(0 fastq.length() - suffix.length()) idx fastqExtensions.getExtension()); try { IOUtil.assertFileIsReadable(new File(fastq)); } catch ( final SAMException e) { break; } files.add(new File(fastq)); } return files; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FastqToSam.java,main,public static void  (final String[] argv){ System.exit(new FastqToSam().instanceMain(argv)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\FastqToSam.java,makeItSo,"public void  (final FastqReader reader1 final FastqReader reader2 final SAMFileWriter writer){ final int readCount=(reader2 == null) ? doUnpaired(reader1 writer) : doPaired(reader1 reader2 writer); LOG.info(""Processed "" + readCount + "" fastq reads""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\DuplicationMetrics.java,calculateDerivedFields,@Override public void  (){ this.ESTIMATED_LIBRARY_SIZE=estimateLibrarySize(this.READ_PAIRS_EXAMINED - this.READ_PAIR_OPTICAL_DUPLICATES this.READ_PAIRS_EXAMINED - this.READ_PAIR_DUPLICATES); PERCENT_DUPLICATION=(UNPAIRED_READ_DUPLICATES + READ_PAIR_DUPLIC
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\DuplicationMetrics.java,calculateDerivedMetrics,@Deprecated public void  (){ this.calculateDerivedFields(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\DuplicationMetrics.java,calculateRoiHistogram,public Histogram<Double>  (){ if (ESTIMATED_LIBRARY_SIZE == null) { try { calculateDerivedFields(); if (ESTIMATED_LIBRARY_SIZE == null) { return null; } } catch ( IllegalStateException ise) { return null; } } long uniquePairs=READ_PAIRS_EXAMINED - READ_PAIR_DUPLICATES; Histogram<Double> histo=new Histogram<>(); for (double x=1; x <= 100; x+=1) { histo.increment(x estimateRoi(ESTIMATED_LIBRARY_SIZE x READ_PAIRS_EXAMINED uniquePairs)); } return histo; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\DuplicationMetrics.java,estimateLibrarySize,"public static Long  (final long readPairs final long uniqueReadPairs){ final long readPairDuplicates=readPairs - uniqueReadPairs; if (readPairs > 0 && readPairDuplicates > 0) { double m=1.0; double M=100.0; if (uniqueReadPairs >= readPairs || f(m * uniqueReadPairs uniqueReadPairs readPairs) < 0) { throw new IllegalStateException(""Invalid values for pairs and unique pairs: "" + readPairs + ""  ""+ uniqueReadPairs); } while (f(M * uniqueReadPairs uniqueReadPairs readPairs) > 0) { M*=10.0; } for (int i=0; i < 40; i++) { double r=(m + M) / 2.0; double u=f(r * uniqueReadPairs uniqueReadPairs readPairs); if (u == 0) { break; } else if (u > 0) { m=r; } else if (u < 0) { M=r; } } return (long)(uniqueReadPairs * (m + M) / 2.0); } else { return null; } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\DuplicationMetrics.java,estimateRoi,public static double  (long estimatedLibrarySize double x long pairs long uniquePairs){ return estimatedLibrarySize * (1 - Math.exp(-(x * pairs) / estimatedLibrarySize)) / uniquePairs; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\DuplicationMetrics.java,f,private static double  (double x double c double n){ return c / x - 1 + Math.exp(-n / x); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\DuplicationMetrics.java,main,"public static void  (String[] args){ DuplicationMetrics m=new DuplicationMetrics(); m.READ_PAIRS_EXAMINED=Integer.parseInt(args[0]); m.READ_PAIR_DUPLICATES=Integer.parseInt(args[1]); m.calculateDerivedFields(); System.out.println(""Percent Duplication: "" + m.PERCENT_DUPLICATION); System.out.println(""Est. Library Size : "" + m.ESTIMATED_LIBRARY_SIZE); System.out.println(); System.out.println(""X Seq\tX Unique""); for ( Histogram.Bin<Double> bin : m.calculateRoiHistogram().values()) { System.out.println(bin.getId() + ""\t"" + bin.getValue()); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,addFirstOfPairOrFragment,public void  (final SAMRecord rec){ firstOfPairOrFragment.add(rec); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,addSecondOfPair,public void  (final SAMRecord rec){ secondOfPair.add(rec); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,addSupplementalFirstOfPairOrFragment,public void  (final SAMRecord rec){ supplementalFirstOfPairOrFragment.add(rec); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,addSupplementalSecondOfPair,public void  (final SAMRecord rec){ supplementalSecondOfPair.add(rec); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,compare,public int  (final SAMRecord rec1 final SAMRecord rec2){ final Integer hi1=rec1.getIntegerAttribute(SAMTag.HI.name()); final Integer hi2=rec2.getIntegerAttribute(SAMTag.HI.name()); if (hi1 == null) { if (hi2 == null) return 0; else return 1; } else if (hi2 == null) { return -1; } else { return hi1.compareTo(hi2); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,coordinateByHitIndex,public void  (){ Collections.sort(firstOfPairOrFragment comparator); Collections.sort(secondOfPair comparator); for (int i=0; i < Math.min(firstOfPairOrFragment.size() secondOfPair.size()); ++i) { final Integer leftHi=firstOfPairOrFragment.get(i).getIntegerAttribute(SAMTag.HI.name()); final Integer rightHi=secondOfPair.get(i).getIntegerAttribute(SAMTag.HI.name()); if (leftHi != null) { if (rightHi != null) { if (leftHi < rightHi) secondOfPair.add(i null); else if (rightHi < leftHi) firstOfPairOrFragment.add(i null); } } else if (rightHi != null) { firstOfPairOrFragment.add(i null); } else { secondOfPair.add(i null); } } int hi=0; for (int i=0; i < numHits(); ++i) { final SAMRecord first=getFirstOfPair(i); final SAMRecord second=getSecondOfPair(i); if (first != null && second != null) { first.setAttribute(SAMTag.HI.name() i); second.setAttribute(SAMTag.HI.name() i); ++hi; } else if (first != null) { first.setAttribute(SAMTag.HI.name() null); } else { second.setAttribute(SAMTag.HI.name() null); } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,getFirstOfPair,public SAMRecord  (final int i){ if (i >= firstOfPairOrFragment.size()) { return null; } else { return firstOfPairOrFragment.get(i); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,getFragment,"public SAMRecord  (final int i){ final SAMRecord samRecord=firstOfPairOrFragment.get(i); if (samRecord.getReadPairedFlag()) throw new UnsupportedOperationException(""getFragment called for paired read""); return samRecord; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,getIndexOfEarliestPrimary,public int  (){ for (int i=0; i < numHits(); i++) { final SAMRecord firstAligned=getFirstOfPair(i); final SAMRecord secondAligned=getSecondOfPair(i); final boolean isPrimaryAlignment=(firstAligned != null && !firstAligned.isSecondaryOrSupplementary()) || (secondAligned != null && !secondAligned.isSecondaryOrSupplementary()); if (isPrimaryAlignment) return i; } return -1; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,getReadName,public String  (){ return getRepresentativeRead().getReadName(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,getRepresentativeRead,"public SAMRecord  (){ for ( final SAMRecord rec : firstOfPairOrFragment) { if (rec != null) return rec; } for ( final SAMRecord rec : secondOfPair) { if (rec != null) return rec; } throw new IllegalStateException(""Should not be called if numHits == 0""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,getSecondOfPair,public SAMRecord  (final int i){ if (i >= secondOfPair.size()) { return null; } else { return secondOfPair.get(i); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,getSupplementalFirstOfPairOrFragment,List<SAMRecord>  (){ return supplementalFirstOfPairOrFragment; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,getSupplementalSecondOfPair,List<SAMRecord>  (){ return supplementalSecondOfPair; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,hasSupplementalHits,public boolean  (){ return !(this.supplementalFirstOfPairOrFragment.isEmpty() && this.supplementalSecondOfPair.isEmpty()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,isPaired,public boolean  (){ return getRepresentativeRead().getReadPairedFlag(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,numHits,public int  (){ return Math.max(firstOfPairOrFragment.size() secondOfPair.size()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,setPrimaryAlignment,"public void  (final int primaryAlignmentIndex){ if (primaryAlignmentIndex < 0 || primaryAlignmentIndex >= this.numHits()) { throw new IllegalArgumentException(""primaryAlignmentIndex("" + primaryAlignmentIndex + "") out of range for numHits(""+ numHits()+ "")""); } for (int i=0; i < this.numHits(); ++i) { final boolean notPrimary=(i != primaryAlignmentIndex); if (this.getFirstOfPair(i) != null) { this.getFirstOfPair(i).setNotPrimaryAlignmentFlag(notPrimary); } if (this.getSecondOfPair(i) != null) { this.getSecondOfPair(i).setNotPrimaryAlignmentFlag(notPrimary); } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\HitsForInsert.java,tallyPrimaryAlignments,public NumPrimaryAlignmentState  (final boolean firstEnd){ if (firstEnd) return tallyPrimaryAlignments(firstOfPairOrFragment); else return tallyPrimaryAlignments(secondOfPair); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\ElcDuplicatesFinderResolver.java,ElcDuplicatesFinderResolver, (double maxDiffRate int maxReadLength int minIdenticalBases boolean useBarcodes OpticalDuplicateFinder opticalDuplicateFinder){ this.useBarcodes=useBarcodes; this.hashBasedDuplicatesFinder=new ElcHashBasedDuplicatesFinder(maxDiffRate maxReadLength minIdenticalBases opticalDuplicateFinder); this.identicalBasesDuplicateFinder=new ElcIdenticalBasesDuplicatesFinder(maxDiffRate maxReadLength minIdenticalBases useBarcodes opticalDuplicateFinder); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\ElcDuplicatesFinderResolver.java,resolveAndSearch,void  (List<PairedReadSequence> sequences Histogram<Integer> duplicationHisto Histogram<Integer> opticalHisto){ if (useBarcodes || sequences.size() < BOUNDARY_LIBRARY_SIZE) { identicalBasesDuplicateFinder.searchDuplicates(sequences duplicationHisto opticalHisto); } else { hashBasedDuplicatesFinder.searchDuplicates(sequences duplicationHisto opticalHisto); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\ElcDuplicatesFinder.java,ElcDuplicatesFinder, (double maxDiffRate int maxReadLength int minIdenticalBases OpticalDuplicateFinder opticalDuplicateFinder){ this.maxDiffRate=maxDiffRate; this.minIdenticalBases=minIdenticalBases; this.opticalDuplicateFinder=opticalDuplicateFinder; this.maxReadLength=(maxReadLength <= 0) ? Integer.MAX_VALUE : maxReadLength; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\ElcDuplicatesFinder.java,fillHistogram,protected void  (Histogram<Integer> duplicationHisto Histogram<Integer> opticalHisto PairedReadSequence prs List<PairedReadSequence> dupes){ if (!dupes.isEmpty()) { dupes.add(prs); final int duplicateCount=dupes.size(); duplicationHisto.increment(duplicateCount); final boolean[] flags=opticalDuplicateFinder.findOpticalDuplicates(dupes prs); for ( final boolean b : flags) { if (b) opticalHisto.increment(duplicateCount); } } else { duplicationHisto.increment(1); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\ElcDuplicatesFinder.java,minLength,protected int  (byte[] read1 byte[] read2){ return Math.min(Math.min(read1.length read2.length) maxReadLength); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\ElcIdenticalBasesDuplicatesFinder.java,ElcIdenticalBasesDuplicatesFinder, (double maxDiffRate int maxReadLength int minIdenticalBases boolean useBarcodes OpticalDuplicateFinder opticalDuplicateFinder){ super(maxDiffRate maxReadLength minIdenticalBases opticalDuplicateFinder); this.useBarcodes=useBarcodes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\ElcIdenticalBasesDuplicatesFinder.java,matches,private boolean  (final PairedReadSequence lhs final PairedReadSequence rhs final double maxDiffRate final boolean useBarcodes){ final int read1Length=minLength(lhs.read1 rhs.read1); final int read2Length=minLength(lhs.read2 rhs.read2); final int maxErrors=(int)Math.floor((read1Length + read2Length) * maxDiffRate); int errors=0; if (useBarcodes) { final PairedReadSequenceWithBarcodes lhsWithBarcodes=(PairedReadSequenceWithBarcodes)lhs; final PairedReadSequenceWithBarcodes rhsWithBarcodes=(PairedReadSequenceWithBarcodes)rhs; if (lhsWithBarcodes.barcode != rhsWithBarcodes.barcode || lhsWithBarcodes.readOneBarcode != rhsWithBarcodes.readOneBarcode || lhsWithBarcodes.readTwoBarcode != rhsWithBarcodes.readTwoBarcode) { return false; } } for (int i=minIdenticalBases; i < read1Length; ++i) { if (lhs.read1[i] != rhs.read1[i] && ++errors > maxErrors) { return false; } } for (int i=minIdenticalBases; i < read2Length; ++i) { if (lhs.read2[i] != rhs.read2[i] && ++errors > maxErrors) { return false; } } return true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\ElcHashBasedDuplicatesFinder.java,ElcHashBasedDuplicatesFinder, (double maxDiffRate int maxReadLength int minIdenticalBases OpticalDuplicateFinder opticalDuplicateFinder){ super(maxDiffRate maxReadLength minIdenticalBases opticalDuplicateFinder); readsByHashInGroup=new HashMap<>(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\ElcHashBasedDuplicatesFinder.java,compareHashes,private int  (byte[] read1 byte[] read2 int hashNumber){ int errors=0; int position=minIdenticalBases + hashNumber; while (position < minReadLenInGroup) { if (read1[position] != read2[position]) { errors++; } position+=numberOfHashesInGroup; } return errors; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\ElcHashBasedDuplicatesFinder.java,compareReadToRead,private int  (byte[] read1 int[] hashes1 byte[] read2 int[] hashes2 int maxErrors){ int errors=0; final int minReadLength=minLength(read1 read2); for (int hashNumber=0; hashNumber < numberOfHashesInGroup; ++hashNumber) { if (hashes1[hashNumber] != hashes2[hashNumber]) { errors+=compareHashes(read1 read2 hashNumber); if (errors > maxErrors) { return errors; } } } if (minReadLength > minReadLenInGroup) { errors+=compareTails(read1 read2 minReadLenInGroup minReadLength); } return errors; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\ElcHashBasedDuplicatesFinder.java,compareTails,private int  (byte[] read1 byte[] read2 int start int stop){ int errors=0; for (int i=start; i < stop; ++i) { if (read1[i] != read2[i]) { errors++; } } return errors; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\ElcHashBasedDuplicatesFinder.java,fillHashValues,private void  (List<PairedReadSequence> sequences){ for ( PairedReadSequence prs : sequences) { prs.initHashes(numberOfHashesInGroup minIdenticalBases minReadLenInGroup); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\ElcHashBasedDuplicatesFinder.java,getSimilarReads,private Set<PairedReadSequence>  (final PairedReadSequence pattern){ final Set<PairedReadSequence> toCheck=new HashSet<>(); for ( int[] hashesForRead : new int[][]{pattern.hashes1 pattern.hashes2}) { for ( int hash : hashesForRead) { List<PairedReadSequence> readsWithSameHash=readsByHashInGroup.get(hash); if (readsWithSameHash.size() > 1) { toCheck.addAll(readsWithSameHash); } } } return toCheck; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\ElcHashBasedDuplicatesFinder.java,initHashLength,private void  (List<PairedReadSequence> sequences){ for ( PairedReadSequence prs : sequences) { int minReadLength=Math.min(Math.min(prs.read1.length prs.read2.length) maxReadLength); int numberOfHashes=(int)((minReadLength - minIdenticalBases) * maxDiffRate) + 1; if (numberOfHashes > numberOfHashesInGroup) { numberOfHashesInGroup=numberOfHashes; } if (minReadLenInGroup > minReadLength) { minReadLenInGroup=minReadLength; } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\ElcHashBasedDuplicatesFinder.java,isDuplicate,private boolean  (final PairedReadSequence lhs final PairedReadSequence rhs){ if (lhs == rhs) { return false; } final int read1Length=minLength(lhs.read1 rhs.read1); final int read2Length=minLength(lhs.read2 rhs.read2); final int maxErrors=(int)Math.floor((read1Length + read2Length) * maxDiffRate); int errors=compareReadToRead(lhs.read1 lhs.hashes1 rhs.read1 rhs.hashes1 maxErrors); if (errors > maxErrors) { return false; } errors+=compareReadToRead(lhs.read2 lhs.hashes2 rhs.read2 rhs.hashes2 maxErrors); return errors <= maxErrors; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\ElcHashBasedDuplicatesFinder.java,populateDupCandidates,private void  (List<PairedReadSequence> seqs){ readsByHashInGroup.clear(); for ( PairedReadSequence prs : seqs) { int[][] readHashValues={prs.hashes1 prs.hashes2}; for ( int[] readHashValue : readHashValues) { for ( int key : readHashValue) { final List<PairedReadSequence> dupCandidates=readsByHashInGroup.computeIfAbsent(key k -> new ArrayList<>()); dupCandidates.add(prs); } } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\ElcHashBasedDuplicatesFinder.java,searchDuplicates,@Override void  (List<PairedReadSequence> sequences Histogram<Integer> duplicationHisto Histogram<Integer> opticalHisto){ initHashLength(sequences); fillHashValues(sequences); populateDupCandidates(sequences); final Set<PairedReadSequence> dupSet=new Hash
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\ElcIdenticalBasesDuplicatesFinder.java,searchDuplicates,@Override void  (List<PairedReadSequence> sequences Histogram<Integer> duplicationHisto Histogram<Integer> opticalHisto){ for (int i=0; i < sequences.size(); ++i) { final PairedReadSequence lhs=sequences.get(i); if (lhs == null) continue; final List<Paire
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,DuplicateType, (final String code){ this.code=code; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,MarkDuplicates,public  (){ DUPLICATE_SCORING_STRATEGY=ScoringStrategy.SUM_OF_BASE_QUALITIES; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,ReadEndsMDComparator,public  (final boolean useBarcodes){ this.useBarcodes=useBarcodes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,addIndexAsDuplicate,private void  (final long bamIndex){ this.duplicateIndexes.add(bamIndex); ++this.numDuplicateIndices; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,addRepresentativeReadIndex,private void  (final List<ReadEndsForMarkDuplicates> list){ short maxScore=0; ReadEndsForMarkDuplicates best=null; for ( ReadEndsForMarkDuplicates end : list) { if (end.score > maxScore || best == null) { maxScore=end.score; best=end; } } for ( final ReadEndsForMarkDuplicates end : list) { addRepresentativeReadOfDuplicateSet(best.read1IndexInFile list.size() end.read1IndexInFile); addRepresentativeReadOfDuplicateSet(best.read1IndexInFile list.size() end.read2IndexInFile); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,addRepresentativeReadOfDuplicateSet,private void  (final long representativeReadIndexInFile final int setSize final long read1IndexInFile){ final RepresentativeReadIndexer rri=new RepresentativeReadIndexer(); rri.representativeReadIndexInFile=(int)representativeReadIndexInFile; rri.setSize=setSize; rri.readIndexInFile=(int)read1IndexInFile; this.representativeReadIndicesForDuplicates.add(rri); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,areComparableForDuplicates,private boolean  (final ReadEndsForMarkDuplicates lhs final ReadEndsForMarkDuplicates rhs final boolean compareRead2 final boolean useBarcodes){ boolean areComparable=lhs.libraryId == rhs.libraryId; if (useBarcodes && areComparable) { final ReadEndsForMarkDuplicatesWithBarcodes lhsWithBarcodes=(ReadEndsForMarkDuplicatesWithBarcodes)lhs; final ReadEndsForMarkDuplicatesWithBarcodes rhsWithBarcodes=(ReadEndsForMarkDuplicatesWithBarcodes)rhs; areComparable=lhsWithBarcodes.barcode == rhsWithBarcodes.barcode && lhsWithBarcodes.readOneBarcode == rhsWithBarcodes.readOneBarcode && lhsWithBarcodes.readTwoBarcode == rhsWithBarcodes.readTwoBarcode; } if (areComparable) { areComparable=lhs.read1ReferenceIndex == rhs.read1ReferenceIndex && lhs.read1Coordinate == rhs.read1Coordinate && lhs.orientation == rhs.orientation; } if (areComparable && compareRead2) { areComparable=lhs.read2ReferenceIndex == rhs.read2ReferenceIndex && lhs.read2Coordinate == rhs.read2Coordinate; } return areComparable; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,buildReadEnds,private ReadEndsForMarkDuplicates  (final SAMFileHeader header final long index final SAMRecord rec final boolean useBarcodes){ final ReadEndsForMarkDuplicates ends; if (useBarcodes) { ends=new ReadEndsForMarkDuplicatesWithBarcodes(); } else { ends=new ReadEndsForMarkDuplicates(); } ends.read1ReferenceIndex=rec.getReferenceIndex(); ends.read1Coordinate=rec.getReadNegativeStrandFlag() ? rec.getUnclippedEnd() : rec.getUnclippedStart(); ends.orientation=rec.getReadNegativeStrandFlag() ? ReadEnds.R : ReadEnds.F; ends.read1IndexInFile=index; ends.score=DuplicateScoringStrategy.computeDuplicateScore(rec this.DUPLICATE_SCORING_STRATEGY); if (rec.getReadPairedFlag() && !rec.getMateUnmappedFlag()) { ends.read2ReferenceIndex=rec.getMateReferenceIndex(); } ends.libraryId=libraryIdGenerator.getLibraryId(rec); if (this.opticalDuplicateFinder.addLocationInformation(rec.getReadName() ends)) { ends.readGroup=0; final String rg=(String)rec.getAttribute(ReservedTagConstants.READ_GROUP_ID); final List<SAMReadGroupRecord> readGroups=header.getReadGroups(); if (rg != null && readGroups != null) { for ( final SAMReadGroupRecord readGroup : readGroups) { if (readGroup.getReadGroupId().equals(rg)) break; else ends.readGroup++; } } } if (useBarcodes) { final ReadEndsForMarkDuplicatesWithBarcodes endsWithBarcode=(ReadEndsForMarkDuplicatesWithBarcodes)ends; endsWithBarcode.barcode=getBarcodeValue(rec); if (!rec.getReadPairedFlag() || rec.getFirstOfPairFlag()) { endsWithBarcode.readOneBarcode=getReadOneBarcodeValue(rec); } else { endsWithBarcode.readTwoBarcode=getReadTwoBarcodeValue(rec); } } return ends; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,buildSortedReadEndLists,"private void  (final boolean useBarcodes){ final int sizeInBytes; if (useBarcodes) { sizeInBytes=ReadEndsForMarkDuplicatesWithBarcodes.getSizeOf(); } else { sizeInBytes=ReadEndsForMarkDuplicates.getSizeOf(); } MAX_RECORDS_IN_RAM=(int)(Runtime.getRuntime().maxMemory() / sizeInBytes) / 2; final int maxInMemory=(int)((Runtime.getRuntime().maxMemory() * SORTING_COLLECTION_SIZE_RATIO) / sizeInBytes); log.info(""Will retain up to "" + maxInMemory + "" data points before spilling to disk.""); final ReadEndsForMarkDuplicatesCodec fragCodec  pairCodec  diskCodec; if (useBarcodes) { fragCodec=new ReadEndsForMarkDuplicatesWithBarcodesCodec(); pairCodec=new ReadEndsForMarkDuplicatesWithBarcodesCodec(); diskCodec=new ReadEndsForMarkDuplicatesWithBarcodesCodec(); } else { fragCodec=new ReadEndsForMarkDuplicatesCodec(); pairCodec=new ReadEndsForMarkDuplicatesCodec(); diskCodec=new ReadEndsForMarkDuplicatesCodec(); } this.pairSort=SortingCollection.newInstance(ReadEndsForMarkDuplicates.class pairCodec new ReadEndsMDComparator(useBarcodes) maxInMemory TMP_DIR); this.fragSort=SortingCollection.newInstance(ReadEndsForMarkDuplicates.class fragCodec new ReadEndsMDComparator(useBarcodes) maxInMemory TMP_DIR); final SamHeaderAndIterator headerAndIterator=openInputs(true); final SAMFileHeader.SortOrder assumedSortOrder=headerAndIterator.header.getSortOrder(); final SAMFileHeader header=headerAndIterator.header; final ReadEndsForMarkDuplicatesMap tmp=new DiskBasedReadEndsForMarkDuplicatesMap(MAX_FILE_HANDLES_FOR_READ_ENDS_MAP diskCodec); long index=0; final ProgressLogger progress=new ProgressLogger(log (int)1e6 ""Read""); final CloseableIterator<SAMRecord> iterator=headerAndIterator.iterator; if (null == this.libraryIdGenerator) { this.libraryIdGenerator=new LibraryIdGenerator(header); } String duplicateQueryName=null; long duplicateIndex=NO_SUCH_INDEX; while (iterator.hasNext()) { final SAMRecord rec=iterator.next(); if (PROGRAM_RECORD_ID != null) { pgIdsSeen.add(rec.getStringAttribute(SAMTag.PG.name())); } if (assumedSortOrder == SAMFileHeader.SortOrder.queryname && !rec.getReadName().equals(duplicateQueryName)) { duplicateQueryName=rec.getReadName(); duplicateIndex=index; } if (rec.getReadUnmappedFlag()) { if (rec.getReferenceIndex() == -1 && assumedSortOrder == SAMFileHeader.SortOrder.coordinate) { break; } } else if (!rec.isSecondaryOrSupplementary()) { final long indexForRead=assumedSortOrder == SAMFileHeader.SortOrder.queryname ? duplicateIndex : index; final ReadEndsForMarkDuplicates fragmentEnd=buildReadEnds(header indexForRead rec useBarcodes); this.fragSort.add(fragmentEnd); if (rec.getReadPairedFlag() && !rec.getMateUnmappedFlag()) { final String key=rec.getAttribute(ReservedTagConstants.READ_GROUP_ID) + "":"" + rec.getReadName(); ReadEndsForMarkDuplicates pairedEnds=tmp.remove(rec.getReferenceIndex() key); if (pairedEnds == null) { pairedEnds=fragmentEnd.clone(); tmp.put(pairedEnds.read2ReferenceIndex key pairedEnds); } else { final int matesRefIndex=fragmentEnd.read1ReferenceIndex; final int matesCoordinate=fragmentEnd.read1Coordinate; if (rec.getFirstOfPairFlag()) { pairedEnds.orientationForOpticalDuplicates=ReadEnds.getOrientationByte(rec.getReadNegativeStrandFlag() pairedEnds.orientation == ReadEnds.R); if (useBarcodes) ((ReadEndsForMarkDuplicatesWithBarcodes)pairedEnds).readOneBarcode=getReadOneBarcodeValue(rec); } else { pairedEnds.orientationForOpticalDuplicates=ReadEnds.getOrientationByte(pairedEnds.orientation == ReadEnds.R rec.getReadNegativeStrandFlag()); if (useBarcodes) ((ReadEndsForMarkDuplicatesWithBarcodes)pairedEnds).readTwoBarcode=getReadTwoBarcodeValue(rec); } if (matesRefIndex > pairedEnds.read1ReferenceIndex || (matesRefIndex == pairedEnds.read1ReferenceIndex && matesCoordinate >= pairedEnds.read1Coordinate)) { pairedEnds.read2ReferenceIndex=matesRefIndex; pairedEnds.read2Coordinate=matesCoordinate; pairedEnds.read2IndexInFile=indexForRead; pairedEnds.orientation=ReadEnds.getOrientationByte(pairedEnds.orientation == ReadEnds.R rec.getReadNegativeStrandFlag()); if (pairedEnds.read2ReferenceIndex == pairedEnds.read1ReferenceIndex && pairedEnds.read2Coordinate == pairedEnds.read1Coordinate && pairedEnds.orientation == ReadEnds.RF) { pairedEnds.orientation=ReadEnds.FR; } } else { pairedEnds.read2ReferenceIndex=pairedEnds.read1ReferenceIndex; pairedEnds.read2Coordinate=pairedEnds.read1Coordinate; pairedEnds.read2IndexInFile=pairedEnds.read1IndexInFile; pairedEnds.read1ReferenceIndex=matesRefIndex; pairedEnds.read1Coordinate=matesCoordinate; pairedEnds.read1IndexInFile=indexForRead; pairedEnds.orientation=ReadEnds.getOrientationByte(rec.getReadNegativeStrandFlag() pairedEnds.orientation == ReadEnds.R); } pairedEnds.score+=DuplicateScoringStrategy.computeDuplicateScore(rec this.DUPLICATE_SCORING_STRATEGY); this.pairSort.add(pairedEnds); } } } ++index; if (progress.record(rec)) { log.info(""Tracking "" + tmp.size() + "" as yet unmatched pairs. ""+ tmp.sizeInRam()+ "" records in RAM.""); } } log.info(""Read "" + index + "" records. ""+ tmp.size()+ "" pairs never matched.""); iterator.close(); this.pairSort.doneAdding(); this.fragSort.doneAdding(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,code,public String  (){ return this.code; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,compare,public int  (final ReadEndsForMarkDuplicates lhs final ReadEndsForMarkDuplicates rhs){ int compareDifference=lhs.libraryId - rhs.libraryId; if (useBarcodes) { final ReadEndsForMarkDuplicatesWithBarcodes lhsWithBarcodes=(ReadEndsForMarkDuplicatesWithBarcodes)lhs; final ReadEndsForMarkDuplicatesWithBarcodes rhsWithBarcodes=(ReadEndsForMarkDuplicatesWithBarcodes)rhs; if (compareDifference == 0) { compareDifference=Integer.compare(lhsWithBarcodes.barcode rhsWithBarcodes.barcode); } if (compareDifference == 0) { compareDifference=Integer.compare(lhsWithBarcodes.readOneBarcode rhsWithBarcodes.readOneBarcode); } if (compareDifference == 0) { compareDifference=Integer.compare(lhsWithBarcodes.readTwoBarcode rhsWithBarcodes.readTwoBarcode); } } if (compareDifference == 0) { compareDifference=lhs.read1ReferenceIndex - rhs.read1ReferenceIndex; } if (compareDifference == 0) { compareDifference=lhs.read1Coordinate - rhs.read1Coordinate; } if (compareDifference == 0) { compareDifference=lhs.orientation - rhs.orientation; } if (compareDifference == 0) { compareDifference=lhs.read2ReferenceIndex - rhs.read2ReferenceIndex; } if (compareDifference == 0) { compareDifference=lhs.read2Coordinate - rhs.read2Coordinate; } if (compareDifference == 0) { compareDifference=(int)(lhs.read1IndexInFile - rhs.read1IndexInFile); } if (compareDifference == 0) { compareDifference=(int)(lhs.read2IndexInFile - rhs.read2IndexInFile); } return compareDifference; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,doWork,"protected int  (){ IOUtil.assertInputsAreValid(INPUT); IOUtil.assertFileIsWritable(OUTPUT); IOUtil.assertFileIsWritable(METRICS_FILE); final boolean useBarcodes=(null != BARCODE_TAG || null != READ_ONE_BARCODE_TAG || null != READ_TWO_BARCODE_TAG); reportMemoryStats(""Start of doWork""); log.info(""Reading input file and constructing read end information.""); buildSortedReadEndLists(useBarcodes); reportMemoryStats(""After buildSortedReadEndLists""); generateDuplicateIndexes(useBarcodes this.REMOVE_SEQUENCING_DUPLICATES || this.TAGGING_POLICY != DuplicateTaggingPolicy.DontTag); reportMemoryStats(""After generateDuplicateIndexes""); log.info(""Marking "" + this.numDuplicateIndices + "" records as duplicates.""); if (this.READ_NAME_REGEX == null) { log.warn(""Skipped optical duplicate cluster discovery; library size estimation may be inaccurate!""); } else { log.info(""Found "" + (this.libraryIdGenerator.getNumberOfOpticalDuplicateClusters()) + "" optical duplicate clusters.""); } final SamHeaderAndIterator headerAndIterator=openInputs(false); final SAMFileHeader header=headerAndIterator.header; final SAMFileHeader.SortOrder sortOrder=header.getSortOrder(); final SAMFileHeader outputHeader=header.clone(); log.info(""Reads are assumed to be ordered by: "" + sortOrder); if (sortOrder != SAMFileHeader.SortOrder.coordinate && sortOrder != SAMFileHeader.SortOrder.queryname) { throw new PicardException(""This program requires input that are either coordinate or query sorted. "" + ""Found "" + sortOrder); } COMMENT.forEach(outputHeader::addComment); final Map<String String> chainedPgIds=getChainedPgIds(outputHeader); final SAMFileWriter out=new SAMFileWriterFactory().makeSAMOrBAMWriter(outputHeader true OUTPUT); long recordInFileIndex=0; long nextOpticalDuplicateIndex=this.opticalDuplicateIndexes != null && this.opticalDuplicateIndexes.hasNext() ? this.opticalDuplicateIndexes.next() : NO_SUCH_INDEX; long nextDuplicateIndex=(this.duplicateIndexes.hasNext() ? this.duplicateIndexes.next() : NO_SUCH_INDEX); CloseableIterator<RepresentativeReadIndexer> representativeReadIterator=null; RepresentativeReadIndexer rri=null; int representativeReadIndexInFile=-1; int duplicateSetSize=-1; int nextRepresentativeIndex=-1; if (TAG_DUPLICATE_SET_MEMBERS) { representativeReadIterator=this.representativeReadIndicesForDuplicates.iterator(); if (representativeReadIterator.hasNext()) { rri=representativeReadIterator.next(); nextRepresentativeIndex=rri.readIndexInFile; representativeReadIndexInFile=rri.representativeReadIndexInFile; duplicateSetSize=rri.setSize; } } final ProgressLogger progress=new ProgressLogger(log (int)1e7 ""Written""); final CloseableIterator<SAMRecord> iterator=headerAndIterator.iterator; String duplicateQueryName=null; String opticalDuplicateQueryName=null; while (iterator.hasNext()) { final SAMRecord rec=iterator.next(); final String library=LibraryIdGenerator.getLibraryName(header rec); DuplicationMetrics metrics=libraryIdGenerator.getMetricsByLibrary(library); if (metrics == null) { metrics=new DuplicationMetrics(); metrics.LIBRARY=library; libraryIdGenerator.addMetricsByLibrary(library metrics); } if (rec.getReadUnmappedFlag()) { ++metrics.UNMAPPED_READS; } else if (rec.isSecondaryOrSupplementary()) { ++metrics.SECONDARY_OR_SUPPLEMENTARY_RDS; } else if (!rec.getReadPairedFlag() || rec.getMateUnmappedFlag()) { ++metrics.UNPAIRED_READS_EXAMINED; } else { ++metrics.READ_PAIRS_EXAMINED; } final boolean needNextDuplicateIndex=recordInFileIndex > nextDuplicateIndex && (sortOrder == SAMFileHeader.SortOrder.coordinate || !rec.getReadName().equals(duplicateQueryName)); if (needNextDuplicateIndex) { nextDuplicateIndex=(this.duplicateIndexes.hasNext() ? this.duplicateIndexes.next() : NO_SUCH_INDEX); } final boolean isDuplicate=recordInFileIndex == nextDuplicateIndex || (sortOrder == SAMFileHeader.SortOrder.queryname && recordInFileIndex > nextDuplicateIndex && rec.getReadName().equals(duplicateQueryName)); if (isDuplicate) { duplicateQueryName=rec.getReadName(); rec.setDuplicateReadFlag(true); if (!rec.isSecondaryOrSupplementary() && !rec.getReadUnmappedFlag()) { if (!rec.getReadPairedFlag() || rec.getMateUnmappedFlag()) { ++metrics.UNPAIRED_READ_DUPLICATES; } else { ++metrics.READ_PAIR_DUPLICATES; } } } else { rec.setDuplicateReadFlag(false); } final boolean needNextOpticalDuplicateIndex=recordInFileIndex > nextOpticalDuplicateIndex && (sortOrder == SAMFileHeader.SortOrder.coordinate || !rec.getReadName().equals(opticalDuplicateQueryName)); if (needNextOpticalDuplicateIndex) { nextOpticalDuplicateIndex=(this.opticalDuplicateIndexes.hasNext() ? this.opticalDuplicateIndexes.next() : NO_SUCH_INDEX); } final boolean isOpticalDuplicate=sortOrder == SAMFileHeader.SortOrder.queryname && recordInFileIndex > nextOpticalDuplicateIndex && rec.getReadName().equals(opticalDuplicateQueryName) || recordInFileIndex == nextOpticalDuplicateIndex; if (CLEAR_DT) { rec.setAttribute(DUPLICATE_TYPE_TAG null); } if (this.TAGGING_POLICY != DuplicateTaggingPolicy.DontTag && rec.getDuplicateReadFlag()) { if (isOpticalDuplicate) { opticalDuplicateQueryName=rec.getReadName(); rec.setAttribute(DUPLICATE_TYPE_TAG DuplicateType.SEQUENCING.code()); } else if (this.TAGGING_POLICY == DuplicateTaggingPolicy.All) { rec.setAttribute(DUPLICATE_TYPE_TAG DuplicateType.LIBRARY.code()); } } if (TAG_DUPLICATE_SET_MEMBERS) { final boolean needNextRepresentativeIndex=recordInFileIndex > nextRepresentativeIndex; if (needNextRepresentativeIndex && representativeReadIterator.hasNext()) { rri=representativeReadIterator.next(); nextRepresentativeIndex=rri.readIndexInFile; representativeReadIndexInFile=rri.representativeReadIndexInFile; duplicateSetSize=rri.setSize; } final boolean isInDuplicateSet=recordInFileIndex == nextRepresentativeIndex || (sortOrder == SAMFileHeader.SortOrder.queryname && recordInFileIndex > nextDuplicateIndex); if (isInDuplicateSet) { if (!rec.isSecondaryOrSupplementary() && !rec.getReadUnmappedFlag()) { if (TAG_DUPLICATE_SET_MEMBERS) { rec.setAttribute(DUPLICATE_SET_INDEX_TAG representativeReadIndexInFile); rec.setAttribute(DUPLICATE_SET_SIZE_TAG duplicateSetSize); } } } } recordInFileIndex++; if (this.REMOVE_DUPLICATES && rec.getDuplicateReadFlag()) { continue; } if (this.REMOVE_SEQUENCING_DUPLICATES && isOpticalDuplicate) { continue; } if (PROGRAM_RECORD_ID != null && pgTagArgumentCollection.ADD_PG_TAG_TO_READS) { rec.setAttribute(SAMTag.PG.name() chainedPgIds.get(rec.getStringAttribute(SAMTag.PG.name()))); } out.addAlignment(rec); progress.record(rec); } iterator.close(); this.duplicateIndexes.cleanup(); if (TAG_DUPLICATE_SET_MEMBERS) { this.representativeReadIndicesForDuplicates.cleanup(); } reportMemoryStats(""Before output close""); out.close(); reportMemoryStats(""After output close""); finalizeAndWriteMetrics(libraryIdGenerator); return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,generateDuplicateIndexes,"private void  (final boolean useBarcodes final boolean indexOpticalDuplicates){ final int entryOverhead; if (TAG_DUPLICATE_SET_MEMBERS) { entryOverhead=16; } else { entryOverhead=SortingLongCollection.SIZEOF; } int maxInMemory=(int)Math.min((Runtime.getRuntime().maxMemory() * 0.25) / entryOverhead (double)(Integer.MAX_VALUE - 5)); if (indexOpticalDuplicates) { maxInMemory/=((entryOverhead + SortingLongCollection.SIZEOF) / entryOverhead); this.opticalDuplicateIndexes=new SortingLongCollection(maxInMemory TMP_DIR.toArray(new File[TMP_DIR.size()])); } log.info(""Will retain up to "" + maxInMemory + "" duplicate indices before spilling to disk.""); this.duplicateIndexes=new SortingLongCollection(maxInMemory TMP_DIR.toArray(new File[TMP_DIR.size()])); if (TAG_DUPLICATE_SET_MEMBERS) { final RepresentativeReadIndexerCodec representativeIndexCodec=new RepresentativeReadIndexerCodec(); this.representativeReadIndicesForDuplicates=SortingCollection.newInstance(RepresentativeReadIndexer.class representativeIndexCodec Comparator.comparing(read -> read.readIndexInFile) maxInMemory TMP_DIR); } ReadEndsForMarkDuplicates firstOfNextChunk=null; final List<ReadEndsForMarkDuplicates> nextChunk=new ArrayList<>(200); log.info(""Traversing read pair information and detecting duplicates.""); for ( final ReadEndsForMarkDuplicates next : this.pairSort) { if (firstOfNextChunk != null && areComparableForDuplicates(firstOfNextChunk next true useBarcodes)) { nextChunk.add(next); } else { if (nextChunk.size() > 1) { markDuplicatePairs(nextChunk); if (TAG_DUPLICATE_SET_MEMBERS) { addRepresentativeReadIndex(nextChunk); } } nextChunk.clear(); nextChunk.add(next); firstOfNextChunk=next; } } if (nextChunk.size() > 1) { markDuplicatePairs(nextChunk); if (TAG_DUPLICATE_SET_MEMBERS) { addRepresentativeReadIndex(nextChunk); } } this.pairSort.cleanup(); this.pairSort=null; log.info(""Traversing fragment information and detecting duplicates.""); boolean containsPairs=false; boolean containsFrags=false; firstOfNextChunk=null; for ( final ReadEndsForMarkDuplicates next : this.fragSort) { if (firstOfNextChunk != null && areComparableForDuplicates(firstOfNextChunk next false useBarcodes)) { nextChunk.add(next); containsPairs=containsPairs || next.isPaired(); containsFrags=containsFrags || !next.isPaired(); } else { if (nextChunk.size() > 1 && containsFrags) { markDuplicateFragments(nextChunk containsPairs); } nextChunk.clear(); nextChunk.add(next); firstOfNextChunk=next; containsPairs=next.isPaired(); containsFrags=!next.isPaired(); } } markDuplicateFragments(nextChunk containsPairs); this.fragSort.cleanup(); this.fragSort=null; log.info(""Sorting list of duplicate records.""); this.duplicateIndexes.doneAddingStartIteration(); if (this.opticalDuplicateIndexes != null) { this.opticalDuplicateIndexes.doneAddingStartIteration(); } if (TAG_DUPLICATE_SET_MEMBERS) { this.representativeReadIndicesForDuplicates.doneAdding(); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,getBarcodeValue,private int  (final SAMRecord record){ return EstimateLibraryComplexity.getReadBarcodeValue(record BARCODE_TAG); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,getReadOneBarcodeValue,private int  (final SAMRecord record){ return EstimateLibraryComplexity.getReadBarcodeValue(record READ_ONE_BARCODE_TAG); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,getReadTwoBarcodeValue,private int  (final SAMRecord record){ return EstimateLibraryComplexity.getReadBarcodeValue(record READ_TWO_BARCODE_TAG); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,main,public static void  (final String[] args){ new MarkDuplicates().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,markDuplicateFragments,private void  (final List<ReadEndsForMarkDuplicates> list final boolean containsPairs){ if (containsPairs) { for ( final ReadEndsForMarkDuplicates end : list) { if (!end.isPaired()) { addIndexAsDuplicate(end.read1IndexInFile); } } } else { short maxScore=0; ReadEndsForMarkDuplicates best=null; for ( final ReadEndsForMarkDuplicates end : list) { if (end.score > maxScore || best == null) { maxScore=end.score; best=end; } } for ( final ReadEndsForMarkDuplicates end : list) { if (end != best) { addIndexAsDuplicate(end.read1IndexInFile); } } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,markDuplicatePairs,private void  (final List<ReadEndsForMarkDuplicates> list){ short maxScore=0; ReadEndsForMarkDuplicates best=null; for ( ReadEndsForMarkDuplicates end : list) { if (end.score > maxScore || best == null) { maxScore=end.score; best=end; } } if (this.READ_NAME_REGEX != null) { AbstractMarkDuplicatesCommandLineProgram.trackOpticalDuplicates(list best opticalDuplicateFinder libraryIdGenerator); } for ( final ReadEndsForMarkDuplicates end : list) { if (end != best) { addIndexAsDuplicate(end.read1IndexInFile); if (end.read2IndexInFile != end.read1IndexInFile) { addIndexAsDuplicate(end.read2IndexInFile); } if (end.isOpticalDuplicate && this.opticalDuplicateIndexes != null) { this.opticalDuplicateIndexes.add(end.read1IndexInFile); this.opticalDuplicateIndexes.add(end.read2IndexInFile); } } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,numOpticalDuplicates,long  (){ return ((long)this.libraryIdGenerator.getOpticalDuplicatesByLibraryIdMap().getSumOfValues()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicates.java,reportMemoryStats,"private void  (final String stage){ System.gc(); final Runtime runtime=Runtime.getRuntime(); log.info(stage + "" freeMemory: "" + runtime.freeMemory()+ ""; totalMemory: ""+ runtime.totalMemory()+ ""; maxMemory: ""+ runtime.maxMemory()); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,EstimateLibraryComplexity,public  (){ final int sizeInBytes; if (null != BARCODE_TAG || null != READ_ONE_BARCODE_TAG || null != READ_TWO_BARCODE_TAG) { sizeInBytes=PairedReadSequenceWithBarcodes.getSizeInBytes(); } else { sizeInBytes=PairedReadSequence.getSizeInBytes(); } MAX_RECORDS_IN_RAM=(int)(Runtime.getRuntime().maxMemory() / sizeInBytes) / 2; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,PairedReadSequenceWithBarcodes,"public  (final PairedReadSequence val){ if (null == val) throw new PicardException(""val was null""); this.readGroup=val.getReadGroup(); this.tile=val.getTile(); this.x=val.getX(); this.y=val.getY(); this.qualityOk=val.qualityOk; this.read1=val.read1.clone(); this.read2=val.read2.clone(); this.libraryId=val.getLibraryId(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,clone,@Override public SortingCollection.Codec<PairedReadSequence>  (){ return new PairedReadWithBarcodesCodec(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,compare,public int  (final PairedReadSequence lhs final PairedReadSequence rhs){ for (int i=0; i < BASES; ++i) { final int retval=lhs.read1[i] - rhs.read1[i]; if (retval != 0) return retval; } for (int i=0; i < BASES; ++i) { final int retval=lhs.read2[i] - rhs.read2[i]; if (retval != 0) return retval; } return 0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,customCommandLineValidation,"@Override protected String[]  (){ final List<String> errorMsgs=new ArrayList<String>(); if (0 < MAX_READ_LENGTH && MAX_READ_LENGTH < MIN_IDENTICAL_BASES) { errorMsgs.add(""MAX_READ_LENGTH must be greater than MIN_IDENTICAL_BASES""); } if (MIN_IDENTICAL_BASE"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,decode,@Override public PairedReadSequence  (){ try { final PairedReadSequence parentVal=super.decode(); if (null == parentVal) return null; final PairedReadSequenceWithBarcodes val=new PairedReadSequenceWithBarcodes(parentVal); val.barcode=this.in.readInt(); va
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,doWork,"@Override protected int  (){ for ( final File f : INPUT) IOUtil.assertFileIsReadable(f); log.info(""Will store "" + MAX_RECORDS_IN_RAM + "" read pairs in memory before sorting.""); final List<SAMReadGroupRecord> readGroups=new ArrayList<SAMReadGroupRecord>();"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,encode,"@Override public void  (final PairedReadSequence val){ if (!(val instanceof PairedReadSequenceWithBarcodes)) { throw new PicardException(""Val was not a PairedReadSequenceWithBarcodes""); } final PairedReadSequenceWithBarcodes data=(PairedReadSequenceWithBa"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,getBarcodeValue,public int  (final SAMRecord record){ return getReadBarcodeValue(record BARCODE_TAG); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,getCodec,public static SortingCollection.Codec<PairedReadSequence>  (){ return new PairedReadCodec(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,getHashes,private int[]  (byte[] read int numberOfHashes int skippedBases int minReadLength){ final int[] hashValues=new int[numberOfHashes]; for (int i=0; i < numberOfHashes; ++i) { hashValues[i]=1; int position=skippedBases + i; while (position < minReadLength) { hashValues[i]=31 * hashValues[i] + read[position]; position+=numberOfHashes; } } return hashValues; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,getLibraryId,public short  (){ return this.libraryId; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,getNextGroup,List<PairedReadSequence>  (final PeekableIterator<PairedReadSequence> iterator){ final List<PairedReadSequence> group=new ArrayList<PairedReadSequence>(); final PairedReadSequence first=iterator.next(); group.add(first); outer: while (iterator.hasNext()) { final PairedReadSequence next=iterator.peek(); for (int i=0; i < MIN_IDENTICAL_BASES; ++i) { if (first.read1[i] != next.read1[i] || first.read2[i] != next.read2[i]) break outer; } group.add(iterator.next()); } return group; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,getReadBarcodeValue,public static int  (final SAMRecord record final String tag){ if (null == tag) return 0; final String attr=record.getStringAttribute(tag); if (null == attr) return 0; else return attr.hashCode(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,getReadGroup,public short  (){ return this.readGroup; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,getReadOneBarcodeValue,private int  (final SAMRecord record){ return getReadBarcodeValue(record READ_ONE_BARCODE_TAG); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,getReadTwoBarcodeValue,private int  (final SAMRecord record){ return getReadBarcodeValue(record READ_TWO_BARCODE_TAG); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,getSizeInBytes,public static int  (){ return PairedReadSequence.getSizeInBytes() + (3 * 4); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,initHashes,void  (int numberOfHashes int skippedBases int minReadLength){ hashes1=getHashes(read1 numberOfHashes skippedBases minReadLength); hashes2=getHashes(read2 numberOfHashes skippedBases minReadLength); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,main,public static void  (final String[] args){ new EstimateLibraryComplexity().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,passesQualityCheck,boolean  (final byte[] bases final byte[] quals final int seedLength final int minQuality){ if (bases.length < seedLength) return false; for (int i=0; i < seedLength; ++i) { if (SequenceUtil.isNoCall(bases[i])) return false; } final int maxReadLength=(MAX_READ_LENGTH <= 0) ? Integer.MAX_VALUE : MAX_READ_LENGTH; final int readLength=Math.min(bases.length maxReadLength); int total=0; for (int i=0; i < readLength; i++) total+=quals[i]; return total / readLength >= minQuality; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,setInputStream,public void  (final InputStream in){ this.in=new DataInputStream(in); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,setLibraryId,public void  (final short libraryId){ this.libraryId=libraryId; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,setOutputStream,public void  (final OutputStream out){ this.out=new DataOutputStream(out); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,setReadGroup,public void  (final short readGroup){ this.readGroup=readGroup; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\EstimateLibraryComplexity.java,splitByLibrary,"Map<String List<PairedReadSequence>>  (final List<PairedReadSequence> input final List<SAMReadGroupRecord> rgs){ final Map<String List<PairedReadSequence>> out=new HashMap<>(); for ( final PairedReadSequence seq : input) { String library; if (seq.getReadGroup() != -1) { library=rgs.get(seq.getReadGroup()).getLibrary(); if (library == null) library=""Unknown""; } else { library=""Unknown""; } List<PairedReadSequence> librarySeqs=out.get(library); if (librarySeqs == null) { librarySeqs=new ArrayList<>(); out.put(library librarySeqs); } librarySeqs.add(seq); } return out; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigar.java,doWork,"protected int  (){ IOUtil.assertInputsAreValid(INPUT); IOUtil.assertFileIsWritable(OUTPUT); IOUtil.assertFileIsWritable(METRICS_FILE); final SamHeaderAndIterator headerAndIterator=openInputs(true); final SAMFileHeader header=headerAndIterator.header; final SAMFileHeader outputHeader=header.clone(); if (outputHeader.getSortOrder() != SAMFileHeader.SortOrder.coordinate) { throw new PicardException(""This program requires inputs in coordinate SortOrder""); } COMMENT.forEach(outputHeader::addComment); setPGIdsSeen(outputHeader); final Map<String String> chainedPgIds=getChainedPgIds(outputHeader); final SAMFileWriter out=new SAMFileWriterFactory().makeSAMOrBAMWriter(outputHeader true OUTPUT); final MarkDuplicatesWithMateCigarIterator iterator=new MarkDuplicatesWithMateCigarIterator(headerAndIterator.header headerAndIterator.iterator this.opticalDuplicateFinder this.DUPLICATE_SCORING_STRATEGY this.MINIMUM_DISTANCE this.REMOVE_DUPLICATES this.SKIP_PAIRS_WITH_NO_MATE_CIGAR this.MAX_RECORDS_IN_RAM this.BLOCK_SIZE this.TMP_DIR); final ProgressLogger progress=new ProgressLogger(log (int)1e6 ""Read""); for ( final SAMRecord record : new IterableAdapter<SAMRecord>(iterator)) { if (progress.record(record)) { iterator.logMemoryStats(log); } updateProgramRecord(record chainedPgIds); out.addAlignment(record); } iterator.close(); out.close(); final Histogram<Short> opticalDupesByLibraryId=iterator.getOpticalDupesByLibraryId(); log.info(""Processed "" + progress.getCount() + "" records""); log.info(""Found "" + iterator.getNumRecordsWithNoMateCigar() + "" records with no mate cigar optional tag.""); log.info(""Marking "" + iterator.getNumDuplicates() + "" records as duplicates.""); log.info(""Found "" + ((long)opticalDupesByLibraryId.getSumOfValues()) + "" optical duplicate clusters.""); finalizeAndWriteMetrics(iterator.getLibraryIdGenerator()); return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigar.java,main,public static void  (final String[] args){ new MarkDuplicatesWithMateCigar().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigar.java,setPGIdsSeen,private void  (final SAMFileHeader header){ final Set<String> pgIdsSeenAsPrevious=new HashSet<String>(); for ( final SAMProgramRecord samProgramRecord : header.getProgramRecords()) { final String previousProgramGroupID=samProgramRecord.getPreviousProgramGroupId(); if (null != previousProgramGroupID) pgIdsSeenAsPrevious.add(previousProgramGroupID); } for ( final SAMProgramRecord samProgramRecord : header.getProgramRecords()) { final String pgId=samProgramRecord.getId(); if (!pgIdsSeenAsPrevious.contains(pgId)) this.pgIdsSeen.add(pgId); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigar.java,updateProgramRecord,"private void  (final SAMRecord record final Map<String String> chainedPgIds){ if (PROGRAM_RECORD_ID != null && pgTagArgumentCollection.ADD_PG_TAG_TO_READS) { final String pgId=record.getStringAttribute(SAMTag.PG.name()); if (null == pgId) { if (!warnedNullProgramRecords) { warnedNullProgramRecords=true; log.warn(""Encountered a record with no program record  program group chaining will not occur for this read: "" + record); } } else if (!chainedPgIds.containsKey(pgId)) { if (!warnedMissingProgramRecords) { warnedMissingProgramRecords=true; log.warn(""Encountered a record with an intermediate program record  program group chaining will not occur for this read: "" + record); } } else { record.setAttribute(SAMTag.PG.name() chainedPgIds.get(pgId)); } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\SimpleMarkDuplicatesWithMateCigar.java,doWork,"protected int  (){ IOUtil.assertInputsAreValid(INPUT); IOUtil.assertFileIsWritable(OUTPUT); IOUtil.assertFileIsWritable(METRICS_FILE); final SamHeaderAndIterator headerAndIterator=openInputs(true); final SAMFileHeader header=headerAndIterator.header; final SAMFileHeader outputHeader=header.clone(); if (outputHeader.getSortOrder() != SAMFileHeader.SortOrder.coordinate) { throw new PicardException(""This program requires inputs in coordinate SortOrder""); } COMMENT.forEach(outputHeader::addComment); final Map<String String> chainedPgIds=getChainedPgIds(outputHeader); final SAMFileWriter out=new SAMFileWriterFactory().makeSAMOrBAMWriter(outputHeader false OUTPUT); final SAMRecordDuplicateComparator comparator=new SAMRecordDuplicateComparator(Collections.singletonList(headerAndIterator.header)); comparator.setScoringStrategy(this.DUPLICATE_SCORING_STRATEGY); final CloseableIterator<DuplicateSet> iterator=getDuplicateSetIterator(headerAndIterator comparator); final ProgressLogger progress=new ProgressLogger(log (int)1e6 ""Read""); int numDuplicates=0; libraryIdGenerator=new LibraryIdGenerator(headerAndIterator.header); for ( final DuplicateSet duplicateSet : new IterableAdapter<>(iterator)) { final SAMRecord representative=duplicateSet.getRepresentative(); final boolean doOpticalDuplicateTracking=(this.READ_NAME_REGEX != null) && isPairedAndBothMapped(representative) && representative.getFirstOfPairFlag(); final Set<String> duplicateReadEndsSeen=new HashSet<>(); final List<ReadEnds> duplicateReadEnds=new ArrayList<>(); for ( final SAMRecord record : duplicateSet.getRecords()) { final String library=LibraryIdGenerator.getLibraryName(header record); DuplicationMetrics metrics=libraryIdGenerator.getMetricsByLibrary(library); if (metrics == null) { metrics=new DuplicationMetrics(); metrics.LIBRARY=library; libraryIdGenerator.addMetricsByLibrary(library metrics); } if (record.isSecondaryOrSupplementary()) { ++metrics.SECONDARY_OR_SUPPLEMENTARY_RDS; } else { if (record.getReadUnmappedFlag()) { ++metrics.UNMAPPED_READS; } else if (!record.getReadPairedFlag() || record.getMateUnmappedFlag()) { ++metrics.UNPAIRED_READS_EXAMINED; } else { ++metrics.READ_PAIRS_EXAMINED; } if (record.getDuplicateReadFlag()) { if (!record.getReadPairedFlag() || record.getMateUnmappedFlag()) { ++metrics.UNPAIRED_READ_DUPLICATES; } else { ++metrics.READ_PAIR_DUPLICATES; } numDuplicates++; } if (doOpticalDuplicateTracking && isPairedAndBothMapped(record) && !duplicateReadEndsSeen.contains(record.getReadName())) { final ReadEndsForSimpleMarkDuplicatesWithMateCigar readEnd=new ReadEndsForSimpleMarkDuplicatesWithMateCigar(); if (record.getFirstOfPairFlag()) { readEnd.orientationForOpticalDuplicates=ReadEnds.getOrientationByte(record.getReadNegativeStrandFlag() record.getMateNegativeStrandFlag()); } else { readEnd.orientationForOpticalDuplicates=ReadEnds.getOrientationByte(record.getMateNegativeStrandFlag() record.getReadNegativeStrandFlag()); } if (opticalDuplicateFinder.addLocationInformation(record.getReadName() readEnd)) { if (null != record.getReadGroup()) { final short index=libraryIdGenerator.getLibraryId(record); readEnd.setLibraryId(index); } } duplicateReadEnds.add(readEnd); duplicateReadEndsSeen.add(record.getReadName()); } } if (!this.REMOVE_DUPLICATES || !record.getDuplicateReadFlag()) { if (PROGRAM_RECORD_ID != null) { record.setAttribute(SAMTag.PG.name() chainedPgIds.get(record.getStringAttribute(SAMTag.PG.name()))); } out.addAlignment(record); progress.record(record); } } if (this.READ_NAME_REGEX != null && 1 < duplicateReadEnds.size()) { AbstractMarkDuplicatesCommandLineProgram.trackOpticalDuplicates(duplicateReadEnds duplicateReadEnds.get(0) opticalDuplicateFinder libraryIdGenerator); } } iterator.close(); out.close(); if (this.READ_NAME_REGEX == null) { log.warn(""Skipped optical duplicate cluster discovery; library size estimation may be inaccurate!""); } else { log.info(""Found "" + (this.libraryIdGenerator.getNumberOfOpticalDuplicateClusters()) + "" optical duplicate clusters.""); } log.info(""Processed "" + progress.getCount() + "" records""); log.info(""Marking "" + numDuplicates + "" records as duplicates.""); finalizeAndWriteMetrics(libraryIdGenerator); return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\SimpleMarkDuplicatesWithMateCigar.java,getDuplicateSetIterator,protected CloseableIterator<DuplicateSet>  (final SamHeaderAndIterator headerAndIterator final SAMRecordDuplicateComparator comparator){ return new DuplicateSetIterator(headerAndIterator.iterator headerAndIterator.header false comparator); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\SimpleMarkDuplicatesWithMateCigar.java,isPairedAndBothMapped,private static boolean  (final SAMRecord record){ return record.getReadPairedFlag() && !record.getReadUnmappedFlag() && !record.getMateUnmappedFlag(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\SimpleMarkDuplicatesWithMateCigar.java,main,public static void  (final String[] args){ new MarkDuplicatesWithMateCigar().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,MarkDuplicatesWithMateCigarIterator,"public  (final SAMFileHeader header final CloseableIterator<SAMRecord> iterator final OpticalDuplicateFinder opticalDuplicateFinder final ScoringStrategy duplicateScoringStrategy final int toMarkQueueMinimumDistance final boolean removeDuplicates final boolean skipPairsWithNoMateCigar final int maxRecordsInRam final int blockSize final List<File> tmpDirs) throws PicardException { if (header.getSortOrder() != SAMFileHeader.SortOrder.coordinate) { throw new PicardException(getClass().getName() + "" expects the input to be in coordinate sort order.""); } this.header=header; backingIterator=new PeekableIterator<SAMRecord>(iterator); outputBuffer=new SamRecordTrackingBuffer<SamRecordWithOrdinalAndSetDuplicateReadFlag>(maxRecordsInRam blockSize tmpDirs header SamRecordWithOrdinalAndSetDuplicateReadFlag.class); this.removeDuplicates=removeDuplicates; this.skipPairsWithNoMateCigar=skipPairsWithNoMateCigar; this.opticalDuplicateFinder=opticalDuplicateFinder; toMarkQueue=new MarkQueue(duplicateScoringStrategy); libraryIdGenerator=new LibraryIdGenerator(header); if (duplicateScoringStrategy == ScoringStrategy.SUM_OF_BASE_QUALITIES) throw new PicardException(""SUM_OF_BASE_QUALITIES not supported as this may cause inconsistencies across ends in a pair. Please use a different scoring strategy.""); for ( final SAMReadGroupRecord readGroup : header.getReadGroups()) { final String library=LibraryIdGenerator.getReadGroupLibraryName(readGroup); DuplicationMetrics metrics=libraryIdGenerator.getMetricsByLibrary(library); if (metrics == null) { metrics=new DuplicationMetrics(); metrics.LIBRARY=library; libraryIdGenerator.addMetricsByLibrary(library metrics); } } toMarkQueue.setToMarkQueueMinimumDistance(toMarkQueueMinimumDistance); nextRecord=markDuplicatesAndGetTheNextAvailable(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,addRecordToTheOutputBuffer,"private void  (final SamRecordWithOrdinal samRecordWithOrdinal) throws PicardException { final int recordReferenceIndex=samRecordWithOrdinal.getRecord().getReferenceIndex(); if (recordReferenceIndex < referenceIndex) { throw new PicardException(""Records out of order: "" + recordReferenceIndex + "" < ""+ referenceIndex); } else if (referenceIndex < recordReferenceIndex) { tryPollingTheToMarkQueue(true null); referenceIndex=recordReferenceIndex; } outputBuffer.add(samRecordWithOrdinal); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,assertSorted,"@Override public SAMRecordIterator  (final SAMFileHeader.SortOrder sortOrder){ if (sortOrder != SAMFileHeader.SortOrder.coordinate) { throw new IllegalStateException(""Cannot assort "" + sortOrder + "" when expecting coordinate sorted input""); } return this;"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,checkCigarForSkips,private boolean  (final Cigar cigar){ final List<CigarElement> elements=cigar.getCigarElements(); for ( final CigarElement el : elements) { if (el.getOperator() == CigarOperator.N) return true; } return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,checkForMinimumDistanceFailure,"private void  (final ReadEndsForMateCigar current){ if (!toMarkQueue.isEmpty()) { final ReadEndsForMateCigar other=toMarkQueue.peek(); if (other.read1ReferenceIndex == current.read1ReferenceIndex && toMarkQueue.getToMarkQueueMinimumDistance() <= other.read1Coordinate - current.read1Coordinate) { if (checkCigarForSkips(other.getRecord().getCigar())) { throw new PicardException(""Found a samRecordWithOrdinal with sufficiently large code length that we may have\n"" + "" missed including it in an early duplicate marking iteration. Alignment contains skipped"" + "" reference bases (N's). If this is an\n RNAseq aligned bam  please use MarkDuplicates instead ""+ "" as this tool does not work well with spliced reads.\n Minimum distance set to "" + toMarkQueue.getToMarkQueueMinimumDistance() + "" but ""+ (other.read1Coordinate - current.read1Coordinate - 1)+ "" would be required.\n""+ ""Record was: ""+ other.getRecord().getSAMString()); } else { System.err.print(""record #1: "" + other.getRecord().getSAMString()); System.err.print(""record #2: "" + current.getRecord().getSAMString()); throw new PicardException(""Found a samRecordWithOrdinal with sufficiently large clipping that we may have\n"" + "" missed including it in an early duplicate marking iteration. Please increase the"" + "" minimum distance to at least "" + (other.read1Coordinate - current.read1Coordinate - 1) + ""bp\nto ensure it is considered (was ""+ toMarkQueue.getToMarkQueueMinimumDistance()+ "").\n""+ ""Record was: ""+ other.getRecord().getSAMString()); } } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,close,@Override public void  (){ backingIterator.close(); outputBuffer.close(); isClosed=true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,enforceClosed,"private void  (){ if (!isClosed) throw new PicardException(""Calling a method that assumes the iterator is closed""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,flush,private SAMRecord  (){ while (!outputBuffer.isEmpty() && outputBuffer.canEmit()) { final SAMRecord record=outputBuffer.next().getRecord(); if (!removeDuplicates || !record.getDuplicateReadFlag()) { return record; } } return null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,getLibraryIdGenerator,public LibraryIdGenerator  (){ enforceClosed(); return libraryIdGenerator; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,getMetrics,private DuplicationMetrics  (final SAMRecord record){ final String library=LibraryIdGenerator.getLibraryName(header record); DuplicationMetrics metrics=libraryIdGenerator.getMetricsByLibrary(library); if (metrics == null) { metrics=new DuplicationMetrics(); metrics.LIBRARY=library; libraryIdGenerator.addMetricsByLibrary(library metrics); } return metrics; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,getNumDuplicates,public int  (){ enforceClosed(); return toMarkQueue.getNumDuplicates(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,getNumRecordsWithNoMateCigar,public int  (){ enforceClosed(); return numRecordsWithNoMateCigar; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,getOpticalDupesByLibraryId,public Histogram<Short>  (){ enforceClosed(); return libraryIdGenerator.getOpticalDuplicatesByLibraryIdMap(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,hasNext,@Override public boolean  (){ if (null != nextRecord) return true; return (backingIterator.hasNext() || !outputBuffer.isEmpty()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,ignoreDueToMissingMateCigar,"private boolean  (final SamRecordWithOrdinal samRecordWithOrdinal){ final SAMRecord record=samRecordWithOrdinal.getRecord(); if (record.getReadPairedFlag() && !record.getMateUnmappedFlag() && null == SAMUtils.getMateCigar(record)) { final DuplicationMetrics metrics=getMetrics(record); if (record.isSecondaryOrSupplementary()) { ++metrics.SECONDARY_OR_SUPPLEMENTARY_RDS; } else { if (record.getReadUnmappedFlag()) { ++metrics.UNMAPPED_READS; } else if (!record.getReadPairedFlag() || record.getMateUnmappedFlag()) { ++metrics.UNPAIRED_READS_EXAMINED; } else { ++metrics.READ_PAIRS_EXAMINED; } } if (skipPairsWithNoMateCigar) { addRecordToTheOutputBuffer(samRecordWithOrdinal); backingIteratorRecordIndex++; outputBuffer.setResultState(samRecordWithOrdinal false); numRecordsWithNoMateCigar++; backingIterator.next(); return true; } else { throw new PicardException(""Read "" + record.getReadName() + "" was mapped and had a mapped mate  but no mate cigar (\""MC\"") tag.""); } } return false; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,logMemoryStats,"public void  (final Log log){ System.gc(); final Runtime runtime=Runtime.getRuntime(); log.info(""freeMemory: "" + runtime.freeMemory() + ""; totalMemory: ""+ runtime.totalMemory()+ ""; maxMemory: ""+ runtime.maxMemory()+ ""; output buffer size: ""+ outputBuffer.size()+ ""; duplicate queue size: ""+ toMarkQueue.size()); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,markDuplicatesAndGetTheNextAvailable,private SAMRecord  (){ { final SAMRecord record=flush(); if (null != record) return record; } if (!backingIterator.hasNext()) { if (toMarkQueue.isEmpty()) { if (outputBuffer.isEmpty()) { return null; } } else { tryPollingTheToMarkQueue(true null); } referenceIndex=header.getSequenceDictionary().getSequences().size(); return markDuplicatesAndGetTheNextAvailable(); } while (backingIterator.hasNext()) { SAMRecord record=backingIterator.peek(); final SamRecordWithOrdinal samRecordWithOrdinal=new SamRecordWithOrdinalAndSetDuplicateReadFlag(record backingIteratorRecordIndex); ReadEndsForMateCigar readEnds=null; boolean performedChunkAndMarkTheDuplicates=false; record.setDuplicateReadFlag(false); if (ignoreDueToMissingMateCigar(samRecordWithOrdinal)) { continue; } if (record.getReadUnmappedFlag()) { if (-1 == record.getReferenceIndex()) { return nextIfRecordIsUnmappedAtEOF(record); } else if (!record.isSecondaryOrSupplementary()) { final DuplicationMetrics metrics=getMetrics(record); ++metrics.UNMAPPED_READS; } } else { if (-1 == toMarkQueue.getToMarkQueueMinimumDistance()) { toMarkQueue.setToMarkQueueMinimumDistance(Math.max(2 * record.getReadBases().length 100)); } readEnds=new ReadEndsForMateCigar(header samRecordWithOrdinal opticalDuplicateFinder libraryIdGenerator.getLibraryId(samRecordWithOrdinal.getRecord())); checkForMinimumDistanceFailure(readEnds); performedChunkAndMarkTheDuplicates=tryPollingTheToMarkQueue(false readEnds); } backingIterator.next(); addRecordToTheOutputBuffer(samRecordWithOrdinal); backingIteratorRecordIndex++; final DuplicationMetrics metrics=getMetrics(record); if (record.isSecondaryOrSupplementary() || record.getReadUnmappedFlag()) { outputBuffer.setResultState(samRecordWithOrdinal false); if (record.isSecondaryOrSupplementary()) { ++metrics.SECONDARY_OR_SUPPLEMENTARY_RDS; } } else { if (!record.getReadPairedFlag() || record.getMateUnmappedFlag()) { ++metrics.UNPAIRED_READS_EXAMINED; } else { ++metrics.READ_PAIRS_EXAMINED; } toMarkQueue.add(readEnds outputBuffer getMetrics(readEnds.getRecord())); } if (performedChunkAndMarkTheDuplicates) { record=flush(); if (null != record) return record; } } return markDuplicatesAndGetTheNextAvailable(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,next,@Override public SAMRecord  () throws PicardException { final SAMRecord toReturn=nextRecord; if (null == toReturn) { throw new NoSuchElementException(); } if (hasNext()) { nextRecord=markDuplicatesAndGetTheNextAvailable(); } else { nextRecord=null; } if (
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,nextIfRecordIsUnmappedAtEOF,"private SAMRecord  (final SAMRecord record){ if (foundUnmappedEOFReads) { final SAMRecord unmappedRecord=backingIterator.next(); if (!record.isSecondaryOrSupplementary()) { final DuplicationMetrics metrics=getMetrics(record); ++metrics.UNMAPPED_READS; } if (!outputBuffer.isEmpty()) { throw new PicardException(""Encountered unmapped reads at the end of the file  but the alignment start buffer was not empty.""); } return unmappedRecord; } else { foundUnmappedEOFReads=true; referenceIndex=header.getSequenceDictionary().getSequences().size(); tryPollingTheToMarkQueue(true null); return markDuplicatesAndGetTheNextAvailable(); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,remove,@Override public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarIterator.java,tryPollingTheToMarkQueue,"private boolean  (final boolean flush final ReadEndsForMateCigar current){ boolean performedChunkAndMarkTheDuplicates=false; if (!flush && null == current) throw new PicardException(""Flush cannot be false and current be null""); if (toMarkQueue.isEmpty()) return false; if (!toMarkQueue.isEmpty() && outputBuffer.isEmpty()) { throw new PicardException(""0 < toMarkQueue && outputBuffer.isEmpty()""); } while (!toMarkQueue.isEmpty() && (flush || referenceIndex != current.read1ReferenceIndex || toMarkQueue.getToMarkQueueMinimumDistance() < current.read1Coordinate - toMarkQueue.peek().read1Coordinate)) { final ReadEndsForMateCigar next=toMarkQueue.poll(outputBuffer header opticalDuplicateFinder libraryIdGenerator); performedChunkAndMarkTheDuplicates=true; if (toMarkQueue.shouldBeInLocations(next) && next.getRecord().getFirstOfPairFlag()) { final Set<ReadEnds> locations=toMarkQueue.getLocations(next); if (!locations.isEmpty()) { AbstractMarkDuplicatesCommandLineProgram.trackOpticalDuplicates(new ArrayList<ReadEnds>(locations) null opticalDuplicateFinder libraryIdGenerator); } } } return performedChunkAndMarkTheDuplicates; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\UmiAwareDuplicateSetIterator.java,UmiAwareDuplicateSetIterator, (final DuplicateSetIterator wrappedIterator final int maxEditDistanceToJoin final String umiTag final String assignedUmiTag final boolean allowMissingUmis final UmiMetrics metrics){ this.wrappedIterator=wrappedIterator; this.maxEditDistanceToJoin=maxEditDistanceToJoin; this.umiTag=umiTag; this.inferredUmiTag=assignedUmiTag; this.allowMissingUmis=allowMissingUmis; this.metrics=metrics; isOpen=true; nextSetsIterator=Collections.emptyIterator(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\UmiAwareDuplicateSetIterator.java,close,@Override public void  (){ isOpen=false; wrappedIterator.close(); metrics.calculateDerivedFields(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\UmiAwareDuplicateSetIterator.java,hasNext,@Override public boolean  (){ if (!isOpen) { return false; } else { if (nextSetsIterator.hasNext() || wrappedIterator.hasNext()) { return true; } else { isOpen=false; return false; } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\UmiAwareDuplicateSetIterator.java,next,@Override public DuplicateSet  (){ if (!nextSetsIterator.hasNext()) { process(wrappedIterator.next()); } return nextSetsIterator.next(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\UmiAwareDuplicateSetIterator.java,process,"private void  (final DuplicateSet set){ if (nextSetsIterator.hasNext()) { throw new PicardException(""nextSetsIterator is expected to be empty  but already contains data.""); } final UmiGraph umiGraph=new UmiGraph(set umiTag inferredUmiTag allowMissingUmis); List<DuplicateSet> duplicateSets=umiGraph.joinUmisIntoDuplicateSets(maxEditDistanceToJoin); for ( DuplicateSet ds : duplicateSets) { List<SAMRecord> records=ds.getRecords(); SAMRecord representativeRead=ds.getRepresentative(); String inferredUmi=representativeRead.getStringAttribute(inferredUmiTag); for ( SAMRecord rec : records) { String currentUmi=UmiUtil.getSanitizedUMI(rec umiTag); if (currentUmi != null) { if (currentUmi.contains(""N"")) { metrics.addUmiObservationN(); } else { if (!haveWeSeenFirstRead) { metrics.MEAN_UMI_LENGTH=currentUmi.length(); haveWeSeenFirstRead=true; } else { if (metrics.MEAN_UMI_LENGTH != currentUmi.length()) { throw new PicardException(""UMIs of differing lengths were found.""); } } metrics.OBSERVED_BASE_ERRORS+=hammingDistance(currentUmi inferredUmi); observedUmiBases+=currentUmi.length(); metrics.addUmiObservation(currentUmi inferredUmi); } } } } metrics.DUPLICATE_SETS_WITH_UMI+=duplicateSets.size(); metrics.DUPLICATE_SETS_IGNORING_UMI++; nextSetsIterator=duplicateSets.iterator(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\UmiGraph.java,UmiGraph,"public  (DuplicateSet set String umiTag String assignedUmiTag boolean allowMissingUmis){ this.umiTag=umiTag; this.assignedUmiTag=assignedUmiTag; this.allowMissingUmis=allowMissingUmis; records=set.getRecords(); for ( SAMRecord rec : records) { if (UmiUtil.getSanitizedUMI(rec umiTag) == null) { if (allowMissingUmis) { rec.setAttribute(umiTag """"); } else { throw new PicardException(""Read "" + rec.getReadName() + "" does not contain a UMI with the ""+ umiTag+ "" attribute.""); } } } umiCounts=records.stream().collect(Collectors.groupingBy(p -> UmiUtil.getSanitizedUMI(p umiTag) counting())); numUmis=umiCounts.size(); umi=new String[numUmis]; duplicateSetID=IntStream.rangeClosed(0 numUmis - 1).toArray(); int i=0; for ( String key : umiCounts.keySet()) { umi[i]=key; i++; } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\UmiGraph.java,getDuplicateSetsFromUmis,private Map<String Integer>  (){ final Map<String Integer> duplicateSetsFromUmis=new HashMap<>(); for (int i=0; i < duplicateSetID.length; i++) { duplicateSetsFromUmis.put(umi[i] duplicateSetID[i]); } return duplicateSetsFromUmis; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\UmiGraph.java,joinUmisIntoDuplicateSets,"List<DuplicateSet>  (final int maxEditDistanceToJoin){ GraphUtils.Graph<Integer> umiGraph=new GraphUtils.Graph<>(); for (int i=0; i < numUmis; i++) { umiGraph.addNode(i); for (int j=i + 1; j < numUmis; j++) { if (StringUtil.isWithinHammingDistance(umi[i] umi[j] maxEditDistanceToJoin)) { umiGraph.addEdge(i j); } } } final Map<Integer Integer> umiClusterMap=umiGraph.cluster(); for (int i=0; i < numUmis; i++) { duplicateSetID[i]=umiClusterMap.get(i); } final Map<Integer List<SAMRecord>> duplicateSets=new HashMap<>(); final Map<String Integer> duplicateSetsFromUmis=getDuplicateSetsFromUmis(); for ( SAMRecord rec : records) { final String umi=UmiUtil.getSanitizedUMI(rec umiTag); final Integer duplicateSetIndex=duplicateSetsFromUmis.get(umi); if (duplicateSets.containsKey(duplicateSetIndex)) { duplicateSets.get(duplicateSetIndex).add(rec); } else { final List<SAMRecord> n=new ArrayList<>(); n.add(rec); duplicateSets.put(duplicateSetIndex n); } } final List<DuplicateSet> duplicateSetList=new ArrayList<>(); for ( final Map.Entry<Integer List<SAMRecord>> entry : duplicateSets.entrySet()) { final DuplicateSet ds=new DuplicateSet(); final List<SAMRecord> recordList=entry.getValue(); recordList.forEach(ds::add); long maxCount=0; String assignedUmi=null; String fewestNUmi=null; long nCount=0; for ( SAMRecord rec : recordList) { final String umi=UmiUtil.getSanitizedUMI(rec umiTag); if (umi.contains(""N"")) { int count=StringUtils.countMatches(umi ""N""); if (nCount == 0) { nCount=count; fewestNUmi=umi; } else if (count < nCount) { nCount=count; fewestNUmi=umi; } } else if (umiCounts.get(umi) > maxCount) { maxCount=umiCounts.get(umi); assignedUmi=umi; } } if (assignedUmi == null) { assignedUmi=fewestNUmi; } for ( final SAMRecord rec : recordList) { if (allowMissingUmis && rec.getStringAttribute(umiTag).isEmpty()) { rec.setAttribute(umiTag null); } else { rec.setAttribute(assignedUmiTag assignedUmi); } } duplicateSetList.add(ds); } return duplicateSetList; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\UmiMetrics.java,UmiMetrics,public  (final double length final int observedUniqueUmis final int inferredUniqueUmis final int observedBaseErrors final int duplicateSetsWithoutUmi final int duplicateSetsWithUmi final double effectiveLengthOfInferredUmis final double effectiveLengthOfObservedUmis final double estimatedBaseQualityOfUmis final double percentUmiWithN){ MEAN_UMI_LENGTH=length; OBSERVED_UNIQUE_UMIS=observedUniqueUmis; INFERRED_UNIQUE_UMIS=inferredUniqueUmis; OBSERVED_BASE_ERRORS=observedBaseErrors; DUPLICATE_SETS_IGNORING_UMI=duplicateSetsWithoutUmi; DUPLICATE_SETS_WITH_UMI=duplicateSetsWithUmi; INFERRED_UMI_ENTROPY=effectiveLengthOfInferredUmis; OBSERVED_UMI_ENTROPY=effectiveLengthOfObservedUmis; UMI_BASE_QUALITIES=estimatedBaseQualityOfUmis; PCT_UMI_WITH_N=percentUmiWithN; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\UmiMetrics.java,addUmiObservation,public void  (String observedUmi String inferredUmi){ observedUmis.increment(observedUmi); inferredUmis.increment(inferredUmi); observedUmiBases+=observedUmi.length(); totalObservedUmisWithoutNs++; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\UmiMetrics.java,addUmiObservationN,public void  (){ observedUmiWithNs++; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\UmiMetrics.java,calculateDerivedFields,public void  (){ OBSERVED_UNIQUE_UMIS=observedUmis.size(); INFERRED_UNIQUE_UMIS=inferredUmis.size(); PCT_UMI_WITH_N=(double)observedUmiWithNs / ((double)observedUmiWithNs + (double)totalObservedUmisWithoutNs); OBSERVED_UMI_ENTROPY=effectiveNumberOfBases(observedUmis); INFERRED_UMI_ENTROPY=effectiveNumberOfBases(inferredUmis); UMI_BASE_QUALITIES=QualityUtil.getPhredScoreFromErrorProbability((double)OBSERVED_BASE_ERRORS / (double)observedUmiBases); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\UmiMetrics.java,effectiveNumberOfBases,private double  (Histogram<?> observations){ double totalObservations=observations.getSumOfValues(); double entropyBaseE=observations.values().stream().collect(Collectors.summingDouble(v -> { double p=v.getValue() / totalObservations; return -p * Math.log(p); } )); return entropyBaseE / MathUtil.LOG_4_BASE_E; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigar.java,doWork,@Override protected int  (){ IOUtil.assertFileIsWritable(UMI_METRICS_FILE); int retval=super.doWork(); MetricsFile<UmiMetrics Double> metricsFile=getMetricsFile(); metricsFile.addMetric(metrics); metricsFile.write(UMI_METRICS_FILE); return retval; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigar.java,getDuplicateSetIterator,@Override protected CloseableIterator<DuplicateSet>  (final SamHeaderAndIterator headerAndIterator final SAMRecordDuplicateComparator comparator){ return new UmiAwareDuplicateSetIterator(new DuplicateSetIterator(headerAndIterator.iterator headerAndIterato
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\UmiUtil.java,getSanitizedUMI,"public static String  (final SAMRecord record final String umiTag){ String umi=record.getStringAttribute(umiTag); if (umi == null) return null; return umi.replace(""-"" """"); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\DiskBasedReadEndsForMarkDuplicatesMap.java,Codec,public  (final ReadEndsForMarkDuplicatesCodec readEndsForMarkDuplicatesCodec){ this.readEndsForMarkDuplicatesCodec=readEndsForMarkDuplicatesCodec; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\DiskBasedReadEndsForMarkDuplicatesMap.java,DiskBasedReadEndsForMarkDuplicatesMap,public  (int maxOpenFiles final ReadEndsForMarkDuplicatesCodec readEndsForMarkDuplicatesCodec){ pairInfoMap=new CoordinateSortedPairInfoMap<String ReadEndsForMarkDuplicates>(maxOpenFiles new Codec(readEndsForMarkDuplicatesCodec)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\DiskBasedReadEndsForMarkDuplicatesMap.java,decode,"public Map.Entry<String ReadEndsForMarkDuplicates>  (){ try { final String key=readEndsForMarkDuplicatesCodec.getInputStream().readUTF(); final ReadEndsForMarkDuplicates record=readEndsForMarkDuplicatesCodec.decode(); return new AbstractMap.SimpleEntry<java.lang.String ReadEndsForMarkDuplicates>(key record); } catch ( IOException e) { throw new PicardException(""Error loading ReadEndsForMarkDuplicatesMap from disk"" e); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\DiskBasedReadEndsForMarkDuplicatesMap.java,encode,"public void  (final String key final ReadEndsForMarkDuplicates readEnds){ try { readEndsForMarkDuplicatesCodec.getOutputStream().writeUTF(key); readEndsForMarkDuplicatesCodec.encode(readEnds); } catch ( IOException e) { throw new PicardException(""Error spilling ReadEndsForMarkDuplicatesMap to disk."" e); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\DiskBasedReadEndsForMarkDuplicatesMap.java,put,public void  (int mateSequenceIndex String key ReadEndsForMarkDuplicates readEnds){ pairInfoMap.put(mateSequenceIndex key readEnds); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\DiskBasedReadEndsForMarkDuplicatesMap.java,remove,public ReadEndsForMarkDuplicates  (int mateSequenceIndex String key){ return pairInfoMap.remove(mateSequenceIndex key); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\DiskBasedReadEndsForMarkDuplicatesMap.java,setInputStream,public void  (final InputStream is){ readEndsForMarkDuplicatesCodec.setInputStream(is); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\DiskBasedReadEndsForMarkDuplicatesMap.java,setOutputStream,public void  (final OutputStream os){ readEndsForMarkDuplicatesCodec.setOutputStream(os); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\DiskBasedReadEndsForMarkDuplicatesMap.java,size,public int  (){ return pairInfoMap.size(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\DiskBasedReadEndsForMarkDuplicatesMap.java,sizeInRam,public int  (){ return pairInfoMap.sizeInRam(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\AbstractMarkDuplicatesCommandLineProgram.java,SamHeaderAndIterator,public  (final SAMFileHeader header final CloseableIterator<SAMRecord> iterator){ this.header=header; this.iterator=iterator; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\AbstractMarkDuplicatesCommandLineProgram.java,finalizeAndWriteMetrics,protected void  (final LibraryIdGenerator libraryIdGenerator){ final Map<String DuplicationMetrics> metricsByLibrary=libraryIdGenerator.getMetricsByLibraryMap(); final Histogram<Short> opticalDuplicatesByLibraryId=libraryIdGenerator.getOpticalDuplicatesByLibraryIdMap(); final Map<String Short> libraryIds=libraryIdGenerator.getLibraryIdsMap(); final MetricsFile<DuplicationMetrics Double> file=getMetricsFile(); for ( final Map.Entry<String DuplicationMetrics> entry : metricsByLibrary.entrySet()) { final String libraryName=entry.getKey(); final DuplicationMetrics metrics=entry.getValue(); metrics.READ_PAIRS_EXAMINED=metrics.READ_PAIRS_EXAMINED / 2; metrics.READ_PAIR_DUPLICATES=metrics.READ_PAIR_DUPLICATES / 2; final Short libraryId=libraryIds.get(libraryName); if (libraryId != null) { final Histogram.Bin<Short> bin=opticalDuplicatesByLibraryId.get(libraryId); if (bin != null) { metrics.READ_PAIR_OPTICAL_DUPLICATES=(long)bin.getValue(); } } metrics.calculateDerivedFields(); file.addMetric(metrics); } if (metricsByLibrary.size() == 1) { file.setHistogram(metricsByLibrary.values().iterator().next().calculateRoiHistogram()); } file.write(METRICS_FILE); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\AbstractMarkDuplicatesCommandLineProgram.java,getChainedPgIds,protected Map<String String>  (final SAMFileHeader outputHeader){ final Map<String String> chainedPgIds; if (PROGRAM_RECORD_ID != null) { final SAMFileHeader.PgIdGenerator pgIdGenerator=new SAMFileHeader.PgIdGenerator(outputHeader); if (PROGRAM_GROUP_VERSION == null) { PROGRAM_GROUP_VERSION=this.getVersion(); } if (PROGRAM_GROUP_COMMAND_LINE == null) { PROGRAM_GROUP_COMMAND_LINE=this.getCommandLine(); } chainedPgIds=new HashMap<>(); for ( final String existingId : this.pgIdsSeen) { final String newPgId=pgIdGenerator.getNonCollidingId(PROGRAM_RECORD_ID); chainedPgIds.put(existingId newPgId); final SAMProgramRecord programRecord=new SAMProgramRecord(newPgId); programRecord.setProgramVersion(PROGRAM_GROUP_VERSION); programRecord.setCommandLine(PROGRAM_GROUP_COMMAND_LINE); programRecord.setProgramName(PROGRAM_GROUP_NAME); programRecord.setPreviousProgramGroupId(existingId); outputHeader.addProgramRecord(programRecord); } } else { chainedPgIds=null; } return chainedPgIds; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\AbstractMarkDuplicatesCommandLineProgram.java,openInputs,protected SamHeaderAndIterator  (boolean eagerlyDecode){ final List<SAMFileHeader> headers=new ArrayList<>(INPUT.size()); final List<SamReader> readers=new ArrayList<>(INPUT.size()); for ( final String input : INPUT) { SamReaderFactory readerFactory=SamReaderFactory.makeDefault(); SamReader reader=eagerlyDecode ? readerFactory.enable(SamReaderFactory.Option.EAGERLY_DECODE).open(SamInputResource.of(input)) : readerFactory.open(SamInputResource.of(input)); final SAMFileHeader header=reader.getFileHeader(); headers.add(header); readers.add(reader); } if (ASSUME_SORT_ORDER != null || ASSUME_SORTED) { if (ASSUME_SORT_ORDER == null) { ASSUME_SORT_ORDER=SAMFileHeader.SortOrder.coordinate; ASSUME_SORTED=false; } headers.get(0).setSortOrder(ASSUME_SORT_ORDER); } if (headers.size() == 1) { return new SamHeaderAndIterator(headers.get(0) readers.get(0).iterator()); } else { final SamFileHeaderMerger headerMerger=new SamFileHeaderMerger(headers.get(0).getSortOrder() headers false); final MergingSamRecordIterator iterator=new MergingSamRecordIterator(headerMerger readers ASSUME_SORT_ORDER != null); return new SamHeaderAndIterator(headerMerger.getMergedHeader() iterator); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\AbstractMarkDuplicatesCommandLineProgram.java,trackOpticalDuplicates,private static void  (final List<? extends ReadEnds> list final ReadEnds keeper final OpticalDuplicateFinder opticalDuplicateFinder final Histogram<Short> opticalDuplicatesByLibraryId){ final boolean[] opticalDuplicateFlags=opticalDuplicateFinder.findOpticalDuplicates(list keeper); int opticalDuplicates=0; for (int i=0; i < opticalDuplicateFlags.length; ++i) { if (opticalDuplicateFlags[i]) { ++opticalDuplicates; list.get(i).isOpticalDuplicate=true; } } if (opticalDuplicates > 0) { opticalDuplicatesByLibraryId.increment(list.get(0).getLibraryId() opticalDuplicates); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\LibraryIdGenerator.java,LibraryIdGenerator,public  (final SAMFileHeader header){ this.header=header; for ( final SAMReadGroupRecord readGroup : header.getReadGroups()) { final String library=LibraryIdGenerator.getReadGroupLibraryName(readGroup); DuplicationMetrics metrics=metricsByLibrary.get(library); if (metrics == null) { metrics=new DuplicationMetrics(); metrics.LIBRARY=library; metricsByLibrary.put(library metrics); } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\LibraryIdGenerator.java,addMetricsByLibrary,public void  (final String library final DuplicationMetrics metrics){ this.metricsByLibrary.put(library metrics); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\LibraryIdGenerator.java,getLibraryId,public short  (final SAMRecord rec){ final String library=getLibraryName(this.header rec); Short libraryId=this.libraryIds.get(library); if (libraryId == null) { libraryId=this.nextLibraryId++; this.libraryIds.put(library libraryId); } return libraryId; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\LibraryIdGenerator.java,getLibraryIdsMap,public Map<String Short>  (){ return this.libraryIds; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\LibraryIdGenerator.java,getLibraryName,public static String  (final SAMFileHeader header final SAMRecord rec){ final String readGroupId=(String)rec.getAttribute(ReservedTagConstants.READ_GROUP_ID); if (readGroupId != null) { final SAMReadGroupRecord rg=header.getReadGroup(readGroupId); if (rg != null) { final String libraryName=rg.getLibrary(); if (null != libraryName) return libraryName; } } return UNKNOWN_LIBRARY; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\LibraryIdGenerator.java,getMetricsByLibrary,public DuplicationMetrics  (final String library){ return this.metricsByLibrary.get(library); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\LibraryIdGenerator.java,getMetricsByLibraryMap,public Map<String DuplicationMetrics>  (){ return this.metricsByLibrary; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\LibraryIdGenerator.java,getNumberOfOpticalDuplicateClusters,public long  (){ return (long)this.opticalDuplicatesByLibraryId.getSumOfValues(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\LibraryIdGenerator.java,getOpticalDuplicatesByLibraryIdMap,public Histogram<Short>  (){ return this.opticalDuplicatesByLibraryId; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\LibraryIdGenerator.java,getReadGroupLibraryName,public static String  (SAMReadGroupRecord readGroup){ return Optional.ofNullable(readGroup.getLibrary()).orElse(UNKNOWN_LIBRARY); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\AbstractOpticalDuplicateFinderCommandLineProgram.java,customCommandLineValidation,@Override protected String[]  (){ setupOpticalDuplicateFinder(); return super.customCommandLineValidation(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\AbstractOpticalDuplicateFinderCommandLineProgram.java,setupOpticalDuplicateFinder,public void  (){ this.opticalDuplicateFinder=new OpticalDuplicateFinder(READ_NAME_REGEX OPTICAL_DUPLICATE_PIXEL_DISTANCE MAX_OPTICAL_DUPLICATE_SET_SIZE LOG); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\MarkQueue.java,MarkQueue,public  (final ScoringStrategy duplicateScoringStrategy){ comparator=new ReadEndsMCComparator(duplicateScoringStrategy); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\MarkQueue.java,ReadEndsMCComparator,public  (final ScoringStrategy duplicateScoringStrategy){ this.duplicateScoringStrategy=duplicateScoringStrategy; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\MarkQueue.java,add,"public void  (final ReadEndsForMateCigar other final SamRecordTrackingBuffer outputBuffer final DuplicationMetrics metrics){ PhysicalLocationForMateCigarSet locationSet=null; boolean addToLocationSet=true; ReadEndsForMateCigar duplicate=null; if (this.nonDuplicateReadEndsSet.contains(other)) { final SortedSet<ReadEndsForMateCigar> sortedSet=this.nonDuplicateReadEndsSet.subSet(other true other true); if (1 != sortedSet.size()) throw new PicardException(""SortedSet should have size one (has size "" + sortedSet.size() + "" )""); final ReadEndsForMateCigar current=sortedSet.first(); final String otherName=SAMUtils.getCanonicalRecordName(other.getRecord()); final String currentName=SAMUtils.getCanonicalRecordName(current.getRecord()); final int comparison=this.comparator.compare(current other); if (currentName.equals(otherName)) { if (0 < comparison) { this.nonDuplicateReadEndsSet.remove(current); this.nonDuplicateReadEndsSet.add(other); this.otherEndOfNonDuplicateReadEndsSet.add(current); if (shouldBeInLocations(other)) { locationSet=current.removeLocationSet(); locationSet.replace(current other); other.setLocationSet(locationSet); addToLocationSet=false; } } else { this.otherEndOfNonDuplicateReadEndsSet.add(other); if (shouldBeInLocations(current)) { locationSet=current.getLocationSet(); addToLocationSet=false; } } } else { if (0 < comparison) { if (shouldBeInLocations(current)) { locationSet=current.removeLocationSet(); } else { locationSet=new PhysicalLocationForMateCigarSet(); } other.setLocationSet(locationSet); this.nonDuplicateReadEndsSet.remove(current); this.nonDuplicateReadEndsSet.add(other); if (this.otherEndOfNonDuplicateReadEndsSet.contains(current)) { final ReadEndsForMateCigar pair=this.otherEndOfNonDuplicateReadEndsSet.subSet(current true current true).first(); this.otherEndOfNonDuplicateReadEndsSet.remove(current); outputBuffer.setResultState(pair.getSamRecordIndex() true); updateDuplicationMetrics(pair metrics); } duplicate=current; } else { if (shouldBeInLocations(current)) { locationSet=current.getLocationSet(); } duplicate=other; } } } else { if (shouldBeInLocations(other)) { locationSet=new PhysicalLocationForMateCigarSet(); other.setLocationSet(locationSet); } this.nonDuplicateReadEndsSet.add(other); } final SAMRecord record=other.getRecord(); if (record.getReadPairedFlag() && !record.getReadUnmappedFlag() && !record.getMateUnmappedFlag()&& addToLocationSet) { if (null == locationSet) throw new PicardException(""location nonDuplicateReadEndsSet was null: "" + record.getSAMString()); locationSet.add(other); } if (null != duplicate) { outputBuffer.setResultState(duplicate.getSamRecordIndex() true); updateDuplicationMetrics(duplicate metrics); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\MarkQueue.java,compare,public int  (final ReadEndsForMateCigar lhs final ReadEndsForMateCigar rhs){ int retval=lhs.libraryId - rhs.libraryId; if (retval == 0) retval=lhs.read1ReferenceIndex - rhs.read1ReferenceIndex; if (retval == 0) retval=lhs.read1Coordinate - rhs.read1Coordinate; if (retval == 0) retval=rhs.orientation - lhs.orientation; if (retval == 0 && lhs.isPaired() != rhs.isPaired()) return lhs.isPaired() ? -1 : 1; if (retval == 0) retval=lhs.hasUnmapped - rhs.hasUnmapped; if (retval == 0) retval=lhs.read2ReferenceIndex - rhs.read2ReferenceIndex; if (retval == 0) retval=lhs.read2Coordinate - rhs.read2Coordinate; if (retval == 0) retval=DuplicateScoringStrategy.compare(lhs.getRecord() rhs.getRecord() this.duplicateScoringStrategy true); if (retval == 0) retval=lhs.getRecordReadName().compareTo(rhs.getRecordReadName()); if (retval == 0 && lhs.isPaired() && rhs.isPaired() && null != lhs.getSamRecordIndex()) { if (lhs.getRecord().getFirstOfPairFlag()) retval=-1; else retval=1; } return retval; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\MarkQueue.java,getLocations,"public Set<ReadEnds>  (final ReadEndsForMateCigar current){ if (!shouldBeInLocations(current)) throw new PicardException(""Not implemented""); final Set<ReadEnds> locationSet=current.getReadEndSetForOpticalDuplicates(); if (null == locationSet) throw new PicardException(""Locations was empty: unexpected error""); return locationSet; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\MarkQueue.java,getNumDuplicates,public int  (){ return this.numDuplicates; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\MarkQueue.java,getToMarkQueueMinimumDistance,public int  (){ return this.toMarkQueueMinimumDistance; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\MarkQueue.java,isEmpty,public boolean  (){ return this.nonDuplicateReadEndsSet.isEmpty(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\MarkQueue.java,peek,public ReadEndsForMateCigar  (){ return this.nonDuplicateReadEndsSet.first(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\MarkQueue.java,poll,"public ReadEndsForMateCigar  (final SamRecordTrackingBuffer outputBuffer final SAMFileHeader header final OpticalDuplicateFinder opticalDuplicateFinder final LibraryIdGenerator libraryIdGenerator){ final ReadEndsForMateCigar current=this.nonDuplicateReadEndsSet.pollFirst(); if (current.isPaired()) { if (this.otherEndOfNonDuplicateReadEndsSet.contains(current)) { final ReadEndsForMateCigar pair=this.otherEndOfNonDuplicateReadEndsSet.subSet(current true current true).first(); outputBuffer.setResultState(pair.getSamRecordIndex() false); this.otherEndOfNonDuplicateReadEndsSet.remove(current); } if (null == this.tmpReadEnds) { this.tmpReadEnds=new ReadEndsForMateCigar(header current.getSamRecordIndex() opticalDuplicateFinder current.libraryId); this.tmpReadEnds.read2ReferenceIndex=this.tmpReadEnds.read2Coordinate=-1; this.tmpReadEnds.samRecordWithOrdinal=null; } else { this.tmpReadEnds.read1ReferenceIndex=current.read1ReferenceIndex; this.tmpReadEnds.read1Coordinate=current.read1Coordinate; } if (current.orientation == ReadEnds.FF || current.orientation == ReadEnds.FR || current.orientation == ReadEnds.F) { this.tmpReadEnds.orientation=ReadEnds.F; } else { this.tmpReadEnds.orientation=ReadEnds.R; } if (this.nonDuplicateReadEndsSet.contains(this.tmpReadEnds)) { final SortedSet<ReadEndsForMateCigar> sortedSet=this.nonDuplicateReadEndsSet.subSet(this.tmpReadEnds true this.tmpReadEnds true); if (1 != sortedSet.size()) throw new PicardException(""SortedSet should have size one (has size "" + sortedSet.size() + "" )""); final ReadEndsForMateCigar duplicate=sortedSet.first(); outputBuffer.setResultState(duplicate.getSamRecordIndex() true); this.nonDuplicateReadEndsSet.remove(this.tmpReadEnds); updateDuplicationMetrics(duplicate libraryIdGenerator.getMetricsByLibrary(libraryIdGenerator.getLibraryName(header duplicate.getRecord()))); } } outputBuffer.setResultState(current.getSamRecordIndex() false); return current; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\MarkQueue.java,setToMarkQueueMinimumDistance,public void  (final int toMarkQueueMinimumDistance){ this.toMarkQueueMinimumDistance=toMarkQueueMinimumDistance; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\MarkQueue.java,shouldBeInLocations,public boolean  (final ReadEndsForMateCigar current){ return (current.isPaired() && 0 == current.hasUnmapped); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\MarkQueue.java,size,public int  (){ return this.nonDuplicateReadEndsSet.size() + this.otherEndOfNonDuplicateReadEndsSet.size(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\MarkQueue.java,updateDuplicationMetrics,private void  (final ReadEndsForMateCigar duplicate final DuplicationMetrics metrics){ if (!duplicate.getRecord().getReadPairedFlag() || duplicate.getRecord().getMateUnmappedFlag()) { ++metrics.UNPAIRED_READ_DUPLICATES; } else { ++metrics.READ_PAIR_DUPLICATES; } this.numDuplicates++; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\OpticalDuplicateFinder.java,OpticalDuplicateFinder,public  (final String readNameRegex final int opticalDuplicatePixelDistance final long maxDuplicateSetSize final Log log){ super(readNameRegex log); this.opticalDuplicatePixelDistance=opticalDuplicatePixelDistance; this.maxDuplicateSetSize=maxDuplicateSetSize; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\OpticalDuplicateFinder.java,closeEnough,private boolean  (final PhysicalLocation lhs final PhysicalLocation rhs final int distance){ return lhs != rhs && lhs.hasLocation() && rhs.hasLocation() && lhs.getReadGroup() == rhs.getReadGroup() && lhs.getTile() == rhs.getTile() && Math.abs(lhs.getX() - rhs.getX()) <= distance && Math.abs(lhs.getY() - rhs.getY()) <= distance; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\OpticalDuplicateFinder.java,findOpticalDuplicates,"public boolean[]  (final List<? extends PhysicalLocation> list final PhysicalLocation keeper){ final int length=list.size(); final boolean[] opticalDuplicateFlags=new boolean[length]; if (length < 2 || length > maxDuplicateSetSize) { return opticalDuplicateFlags; } final int distance=this.opticalDuplicatePixelDistance; final PhysicalLocation actualKeeper=keeperOrNull(list keeper); final Log log; final ProgressLogger progressLoggerForKeeper  progressLoggerForRest; final boolean logProgress=length > bigDuplicateSetSize; if (logProgress) { log=Log.getInstance(OpticalDuplicateFinder.class); progressLoggerForKeeper=new ProgressLogger(log 10000 ""compared"" ""ReadEnds to keeper""); progressLoggerForRest=new ProgressLogger(log 1000 ""compared"" ""ReadEnds to others""); log.info(""Large duplicate set. size = "" + length); log.debug(""About to compare to keeper:"" + actualKeeper); } else { log=null; progressLoggerForKeeper=null; progressLoggerForRest=null; } if (actualKeeper != null) { for (int i=0; i < length; ++i) { final PhysicalLocation other=list.get(i); opticalDuplicateFlags[i]=closeEnough(actualKeeper other distance); if (logProgress) progressLoggerForKeeper.record(String.format(""%d"" other.getReadGroup()) other.getX()); } } if (logProgress) log.debug(""Done with comparing to keeper  now the rest.""); for (int i=0; i < length; ++i) { final PhysicalLocation lhs=list.get(i); if (lhs == actualKeeper) continue; if (logProgress) progressLoggerForRest.record(String.format(""%d"" lhs.getReadGroup()) lhs.getX()); for (int j=i + 1; j < length; ++j) { final PhysicalLocation rhs=list.get(j); if (rhs == actualKeeper) continue; if (opticalDuplicateFlags[i] && opticalDuplicateFlags[j]) continue; if (closeEnough(lhs rhs distance)) { final int index=opticalDuplicateFlags[j] ? i : j; opticalDuplicateFlags[index]=true; } } } return opticalDuplicateFlags; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\OpticalDuplicateFinder.java,keeperOrNull,private PhysicalLocation  (final List<? extends PhysicalLocation> list final PhysicalLocation keeper){ if (keeper != null && keeper.hasLocation()) { for ( final PhysicalLocation loc : list) { if (loc == keeper) return keeper; } } return null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\OpticalDuplicateFinder.java,setBigDuplicateSetSize,public void  (final int bigDuplicateSetSize){ this.bigDuplicateSetSize=bigDuplicateSetSize; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\OpticalDuplicateFinder.java,setMaxDuplicateSetSize,public void  (final long maxDuplicateSetSize){ if (maxDuplicateSetSize < 1) { this.maxDuplicateSetSize=Long.MAX_VALUE; } this.maxDuplicateSetSize=maxDuplicateSetSize; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\MemoryBasedReadEndsForMarkDuplicatesMap.java,put,public void  (int mateSequenceIndex String key ReadEndsForMarkDuplicates readEnds){ while (mateSequenceIndex >= mapPerSequence.size()) { mapPerSequence.add(new HashMap<String ReadEndsForMarkDuplicates>()); } mapPerSequence.get(mateSequenceIndex).put(key readEnds); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\MemoryBasedReadEndsForMarkDuplicatesMap.java,remove,public ReadEndsForMarkDuplicates  (int mateSequenceIndex String key){ if (mateSequenceIndex >= mapPerSequence.size()) { return null; } return mapPerSequence.get(mateSequenceIndex).remove(key); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\MemoryBasedReadEndsForMarkDuplicatesMap.java,size,public int  (){ int total=0; for ( Map<String ReadEndsForMarkDuplicates> map : mapPerSequence) { total+=map.size(); } return total; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\MemoryBasedReadEndsForMarkDuplicatesMap.java,sizeInRam,public int  (){ return size(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\PhysicalLocationForMateCigar.java,PhysicalLocationForMateCigar,public  (final PhysicalLocation rec){ this.setReadGroup(rec.getReadGroup()); this.setTile(rec.getTile()); this.setX(rec.getX()); this.setY(rec.getY()); this.setLibraryId(rec.getLibraryId()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\PhysicalLocationForMateCigar.java,equals,@Override public boolean  (Object other){ if (other instanceof PhysicalLocationForMateCigar) { int cmp; PhysicalLocationForMateCigar loc=(PhysicalLocationForMateCigar)other; cmp=getLibraryId() - loc.getLibraryId(); if (0 == cmp) cmp=getReadGroup() - loc.g
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\PhysicalLocationForMateCigar.java,getLibraryId,@Override public short  (){ return this.libraryId; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\PhysicalLocationForMateCigar.java,getReadGroup,@Override public short  (){ return this.readGroup; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\PhysicalLocationForMateCigar.java,hashCode,@Override public int  (){ int result=getLibraryId(); result=31 * result + getReadGroup(); result=31 * result + getTile(); result=31 * result + getY(); result=31 * result + getX(); return result; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\PhysicalLocationForMateCigar.java,setLibraryId,@Override public void  (final short libraryId){ this.libraryId=libraryId; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\PhysicalLocationForMateCigar.java,setReadGroup,@Override public void  (final short rg){ this.readGroup=rg; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\PhysicalLocationForMateCigarSet.java,add,public void  (final ReadEndsForMateCigar end){ final PhysicalLocationForMateCigar location=new PhysicalLocationForMateCigar(end); if (!physicalLocations.contains(location)) { readEnds.add(end); physicalLocations.add(new PhysicalLocationForMateCigar(location)); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\PhysicalLocationForMateCigarSet.java,getReadEnds,public Set<ReadEnds>  (){ return this.readEnds; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\PhysicalLocationForMateCigarSet.java,remove,public void  (final ReadEndsForMateCigar end){ final PhysicalLocationForMateCigar location=new PhysicalLocationForMateCigar(end); if (physicalLocations.contains(location)) { readEnds.remove(end); physicalLocations.remove(location); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\PhysicalLocationForMateCigarSet.java,replace,"public void  (final ReadEndsForMateCigar current final ReadEndsForMateCigar other){ final PhysicalLocationForMateCigar location=new PhysicalLocationForMateCigar(current); if (!physicalLocations.contains(location)) { throw new PicardException(""Trying to replace something not in the set""); } this.remove(current); this.add(other); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\PhysicalLocationForMateCigarSet.java,size,public int  (){ return physicalLocations.size(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEnds.java,getLibraryId,@Override public short  (){ return this.libraryId; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEnds.java,getOrientationByte,public static byte  (final boolean read1NegativeStrand final boolean read2NegativeStrand){ if (read1NegativeStrand) { if (read2NegativeStrand) return ReadEnds.RR; else return ReadEnds.RF; } else { if (read2NegativeStrand) return ReadEnds.FR; else return ReadEnds.FF; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEnds.java,getReadGroup,@Override public short  (){ return this.readGroup; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEnds.java,isPaired,public boolean  (){ return this.read2ReferenceIndex != -1; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEnds.java,setLibraryId,@Override public void  (final short libraryId){ this.libraryId=libraryId; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEnds.java,setReadGroup,@Override public void  (final short readGroup){ this.readGroup=readGroup; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMarkDuplicates.java,ReadEndsForMarkDuplicates,public  (final ReadEndsForMarkDuplicates read){ this.libraryId=read.getLibraryId(); this.orientation=read.orientation; this.read1ReferenceIndex=read.read1ReferenceIndex; this.read1Coordinate=read.read1Coordinate; this.read2ReferenceIndex=read.read2ReferenceIndex; this.read2Coordinate=read.read2Coordinate; this.readGroup=read.getReadGroup(); this.tile=read.getTile(); this.x=read.x; this.y=read.y; this.orientationForOpticalDuplicates=read.orientationForOpticalDuplicates; this.score=read.score; this.read1IndexInFile=read.read1IndexInFile; this.read2IndexInFile=read.read2IndexInFile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMarkDuplicates.java,clone,@Override public ReadEndsForMarkDuplicates  (){ return new ReadEndsForMarkDuplicates(this); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMarkDuplicates.java,getSizeOf,public static int  (){ return SIZE_OF; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMarkDuplicatesCodec.java,clone,public SortingCollection.Codec<ReadEndsForMarkDuplicates>  (){ return new ReadEndsForMarkDuplicatesCodec(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMarkDuplicatesCodec.java,decode,"public ReadEndsForMarkDuplicates  (){ final ReadEndsForMarkDuplicates read=new ReadEndsForMarkDuplicates(); try { try { read.score=this.in.readShort(); } catch ( final EOFException eof) { return null; } read.libraryId=this.in.readShort(); read.orientation=this.in.readByte(); read.read1ReferenceIndex=this.in.readInt(); read.read1Coordinate=this.in.readInt(); read.read1IndexInFile=this.in.readLong(); read.read2ReferenceIndex=this.in.readInt(); if (read.orientation > ReadEnds.R) { read.read2Coordinate=this.in.readInt(); read.read2IndexInFile=this.in.readLong(); } read.readGroup=this.in.readShort(); read.tile=this.in.readShort(); read.x=this.in.readShort(); read.y=this.in.readShort(); read.orientationForOpticalDuplicates=this.in.readByte(); read.duplicateSetSize=this.in.readInt(); return read; } catch ( final IOException ioe) { throw new PicardException(""Exception writing ReadEnds to file."" ioe); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMarkDuplicatesCodec.java,encode,"public void  (final ReadEndsForMarkDuplicates read){ try { this.out.writeShort(read.score); this.out.writeShort(read.libraryId); this.out.writeByte(read.orientation); this.out.writeInt(read.read1ReferenceIndex); this.out.writeInt(read.read1Coordinate); this.out.writeLong(read.read1IndexInFile); this.out.writeInt(read.read2ReferenceIndex); if (read.orientation > ReadEnds.R) { this.out.writeInt(read.read2Coordinate); this.out.writeLong(read.read2IndexInFile); } this.out.writeShort(read.readGroup); this.out.writeShort(read.tile); this.out.writeShort((short)read.x); this.out.writeShort((short)read.y); this.out.writeByte(read.orientationForOpticalDuplicates); this.out.writeInt(read.duplicateSetSize); } catch ( final IOException ioe) { throw new PicardException(""Exception writing ReadEnds to file."" ioe); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMarkDuplicatesCodec.java,getInputStream,public DataInputStream  (){ return in; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMarkDuplicatesCodec.java,getOutputStream,public DataOutputStream  (){ return out; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMarkDuplicatesCodec.java,setInputStream,public void  (final InputStream is){ this.in=new DataInputStream(is); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMarkDuplicatesCodec.java,setOutputStream,public void  (final OutputStream os){ this.out=new DataOutputStream(os); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMarkDuplicatesWithBarcodesCodec.java,clone,@Override public SortingCollection.Codec<ReadEndsForMarkDuplicates>  (){ return new ReadEndsForMarkDuplicatesWithBarcodesCodec(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMarkDuplicatesWithBarcodesCodec.java,decode,@Override public ReadEndsForMarkDuplicates  (){ final ReadEndsForMarkDuplicates parentRead=super.decode(); if (null == parentRead) return null; final ReadEndsForMarkDuplicatesWithBarcodes read=new ReadEndsForMarkDuplicatesWithBarcodes(parentRead); try { r
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMarkDuplicatesWithBarcodesCodec.java,encode,"@Override public void  (final ReadEndsForMarkDuplicates read){ if (!(read instanceof ReadEndsForMarkDuplicatesWithBarcodes)) { throw new PicardException(""Read was not a ReadEndsForMarkDuplicatesWithBarcodes""); } super.encode(read); try { final ReadEndsFor"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMarkDuplicatesWithBarcodes.java,ReadEndsForMarkDuplicatesWithBarcodes,public  (final ReadEndsForMarkDuplicatesWithBarcodes read){ super(read); barcode=read.barcode; readOneBarcode=read.readOneBarcode; readTwoBarcode=read.readTwoBarcode; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMarkDuplicatesWithBarcodes.java,clone,@Override public ReadEndsForMarkDuplicatesWithBarcodes  (){ return new ReadEndsForMarkDuplicatesWithBarcodes(this); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMarkDuplicatesWithBarcodes.java,getSizeOf,public static int  (){ return ReadEndsForMarkDuplicates.getSizeOf() + (3 * 4); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\SamRecordWithOrdinalAndSetDuplicateReadFlag.java,SamRecordWithOrdinalAndSetDuplicateReadFlag,public  (final SAMRecord record final long recordIndex){ super(record recordIndex); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\SamRecordWithOrdinalAndSetDuplicateReadFlag.java,setResultState,@Override public void  (final boolean resultState){ this.getRecord().setDuplicateReadFlag(resultState); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\RepresentativeReadIndexerCodec.java,clone,public SortingCollection.Codec<RepresentativeReadIndexer>  (){ return new RepresentativeReadIndexerCodec(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\RepresentativeReadIndexerCodec.java,decode,"public RepresentativeReadIndexer  (){ final RepresentativeReadIndexer rni=new RepresentativeReadIndexer(); try { try { rni.readIndexInFile=this.in.readInt(); } catch ( final EOFException eof) { return null; } rni.setSize=this.in.readInt(); rni.representativeReadIndexInFile=this.in.readInt(); return rni; } catch ( final IOException ioe) { throw new PicardException(""Exception writing ReadEnds to file."" ioe); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\RepresentativeReadIndexerCodec.java,encode,"public void  (final RepresentativeReadIndexer rni){ try { this.out.writeInt(rni.readIndexInFile); this.out.writeInt(rni.setSize); this.out.writeInt(rni.representativeReadIndexInFile); } catch ( final IOException ioe) { throw new PicardException(""Exception writing ReadEnds to file."" ioe); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\RepresentativeReadIndexerCodec.java,getInputStream,public DataInputStream  (){ return in; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\RepresentativeReadIndexerCodec.java,getOutputStream,public DataOutputStream  (){ return out; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\RepresentativeReadIndexerCodec.java,setInputStream,public void  (final InputStream is){ this.in=new DataInputStream(is); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\RepresentativeReadIndexerCodec.java,setOutputStream,public void  (final OutputStream os){ this.out=new DataOutputStream(os); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MergeBamAlignment.java,PrimaryAlignmentStrategy, (final Class<?> clazz final String description){ this.clazz=(Class<PrimaryAlignmentSelectionStrategy>)clazz; this.description=description; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MergeBamAlignment.java,customCommandLineValidation,"protected String[]  (){ if ((PROGRAM_RECORD_ID != null || PROGRAM_GROUP_VERSION != null || PROGRAM_GROUP_COMMAND_LINE != null) && (PROGRAM_RECORD_ID == null || PROGRAM_GROUP_VERSION == null || PROGRAM_GROUP_COMMAND_LINE == null)) { return new String[]{""PROGRAM_RECORD_ID  PROGRAM_GROUP_VERSION  and "" + ""PROGRAM_GROUP_COMMAND_LINE must all be supplied or none should "" + ""be included.""}; } final boolean r1sExist=READ1_ALIGNED_BAM != null && !READ1_ALIGNED_BAM.isEmpty(); final boolean r2sExist=READ2_ALIGNED_BAM != null && !READ2_ALIGNED_BAM.isEmpty(); if ((r1sExist && !r2sExist) || (r2sExist && !r1sExist)) { return new String[]{""READ1_ALIGNED_BAM and READ2_ALIGNED_BAM "" + ""must both be supplied or neither should be included. For "" + ""single-end read use ALIGNED_BAM.""}; } if (ALIGNED_BAM == null || ALIGNED_BAM.isEmpty() && !(r1sExist && r2sExist)) { return new String[]{""Either ALIGNED_BAM or the combination of "" + ""READ1_ALIGNED_BAM and READ2_ALIGNED_BAM must be supplied.""}; } return null; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMateCigar.java,ReadEndsForMateCigar,public  (final ReadEndsForMateCigar other final SamRecordWithOrdinal samRecordWithOrdinal){ this.readGroup=other.readGroup; this.tile=other.tile; this.x=other.x; this.y=other.y; this.read1ReferenceIndex=other.read1ReferenceIndex; this.read1Coordinate=other.read1Coordinate; this.read2ReferenceIndex=other.read2ReferenceIndex; this.read2Coordinate=other.read2Coordinate; this.hasUnmapped=other.hasUnmapped; this.samRecordWithOrdinal=samRecordWithOrdinal; this.orientation=other.orientation; this.libraryId=other.libraryId; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MergeBamAlignment.java,doWork,@Override protected int  (){ SAMProgramRecord prod=null; if (PROGRAM_RECORD_ID != null) { prod=new SAMProgramRecord(PROGRAM_RECORD_ID); prod.setProgramVersion(PROGRAM_GROUP_VERSION); prod.setCommandLine(PROGRAM_GROUP_COMMAND_LINE); prod.setProgramName(PRO
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMateCigar.java,getLocationSet,public PhysicalLocationForMateCigarSet  (){ return this.locationSet; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MergeBamAlignment.java,getHelpDoc,public String  (){ return description; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMateCigar.java,getReadEndSetForOpticalDuplicates,"public Set<ReadEnds>  (){ if (null == this.locationSet) throw new PicardException(""Already called getReadEndSetForOpticalDuplicates""); final Set<ReadEnds> locationSet=this.locationSet.getReadEnds(); this.locationSet=null; return locationSet; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MergeBamAlignment.java,newInstance,"PrimaryAlignmentSelectionStrategy  (){ try { return clazz.newInstance(); } catch ( Exception e) { throw new PicardException(""Trouble instantiating "" + clazz.getName() e); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMateCigar.java,getRecord,public SAMRecord  (){ return this.samRecordWithOrdinal.getRecord(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MergeBamAlignment.java,requiresReference,@Override protected boolean  (){ return true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMateCigar.java,getRecordReadName,public String  (){ return this.samRecordWithOrdinal.getRecord().getReadName(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMateCigar.java,getSamRecordIndex,public SamRecordWithOrdinal  (){ return this.samRecordWithOrdinal; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMateCigar.java,isPaired,@Override public boolean  (){ return this.getRecord().getReadPairedFlag(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMateCigar.java,removeLocationSet,public PhysicalLocationForMateCigarSet  (){ final PhysicalLocationForMateCigarSet locationSet=this.locationSet; this.locationSet=null; return locationSet; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\markduplicates\util\ReadEndsForMateCigar.java,setLocationSet,public void  (final PhysicalLocationForMateCigarSet locationSet){ this.locationSet=locationSet; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MergeSamFiles.java,customCommandLineValidation,"@Override protected String[]  (){ if (CREATE_INDEX && SORT_ORDER != SAMFileHeader.SortOrder.coordinate) { return new String[]{""Can't CREATE_INDEX unless SORT_ORDER is coordinate""}; } return null; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MergeSamFiles.java,doWork,@Override protected int  (){ boolean matchedSortOrders=true; final List<Interval> intervalList=(INTERVALS == null ? null : IntervalList.fromFile(INTERVALS).uniqued().getIntervals()); final Map<SamReader CloseableIterator<SAMRecord>> samReaderToIterator=ne
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MergeSamFiles.java,main,public static void  (final String[] argv){ System.exit(new MergeSamFiles().instanceMain(argv)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MostDistantPrimaryAlignmentSelectionStrategy.java,considerBest,public void  (final SAMRecord firstEnd final SAMRecord secondEnd){ final int thisPairMapq=SAMUtils.combineMapqs(firstEnd.getMappingQuality() secondEnd.getMappingQuality()); final int thisDistance=CoordMath.getLength(Math.min(firstEnd.getAlignmentStart() secondEnd.getAlignmentStart()) Math.max(firstEnd.getAlignmentEnd() secondEnd.getAlignmentEnd())); if (thisDistance > bestDistance || (thisDistance == bestDistance && thisPairMapq > bestPairMapq)) { bestDistance=thisDistance; bestPairMapq=thisPairMapq; bestAlignmentPairs.clear(); bestAlignmentPairs.add(new AbstractMap.SimpleEntry<SAMRecord SAMRecord>(firstEnd secondEnd)); } else if (thisDistance == bestDistance && thisPairMapq == bestPairMapq) { bestAlignmentPairs.add(new AbstractMap.SimpleEntry<SAMRecord SAMRecord>(firstEnd secondEnd)); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MostDistantPrimaryAlignmentSelectionStrategy.java,hasBest,public boolean  (){ return bestDistance != -1; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MostDistantPrimaryAlignmentSelectionStrategy.java,moveToHead,"private void  (final List<SAMRecord> list final SAMRecord rec){ if (list.get(0) == rec) return; for (int i=1; i < list.size(); ++i) { if (list.get(i) == rec) { list.remove(i); list.add(0 rec); return; } } throw new IllegalStateException(""Should not be reached""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\PositionBasedDownsampleSam.java,CircleSelector," (final double fraction){ final double p; if (fraction > 0.5) { p=1 - fraction; positiveSelection=false; } else { p=fraction; positiveSelection=true; } radiusSquared=p / Math.PI; if (p < 0) { throw new PicardException(""This shouldn't happen...""); } offset=Math.sqrt(radiusSquared - p * p / 4); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\PositionBasedDownsampleSam.java,Coord,public  (){ count=0; minX=0; minY=0; maxX=0; maxY=0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MostDistantPrimaryAlignmentSelectionStrategy.java,pickPrimaryAlignment,@Override public void  (final HitsForInsert hitsForInsert){ final BestEndAlignmentsAccumulator firstEndBest=new BestEndAlignmentsAccumulator(); final BestEndAlignmentsAccumulator secondEndBest=new BestEndAlignmentsAccumulator(); final CollectionUtil.Multi
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MostDistantPrimaryAlignmentSelectionStrategy.java,pickRandomlyFromList,private <T>T  (final List<T> list){ return list.get(random.nextInt(list.size())); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\PositionBasedDownsampleSam.java,checkProgramRecords,"private void  (){ final SamReader in=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT); for ( final SAMProgramRecord pg : in.getFileHeader().getProgramRecords()) { if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) { final String outText=""Found previous Program Record that indicates that this BAM has been downsampled already with this program. Operation not supported! Previous PG: "" + pg.toString(); if (ALLOW_MULTIPLE_DOWNSAMPLING_DESPITE_WARNINGS) { log.warn(outText); } else { log.error(outText); throw new PicardException(outText); } } } CloserUtil.close(in); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\PositionBasedDownsampleSam.java,customCommandLineValidation,"@Override protected String[]  (){ final List<String> errors=new ArrayList<>(); if (FRACTION < 0 || FRACTION > 1) { errors.add(""FRACTION must be a value between 0 and 1  found: "" + FRACTION); } if (!errors.isEmpty()) return errors.toArray(new String[errors"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\PositionBasedDownsampleSam.java,doWork,"@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); log.info(""Checking to see if input file has been downsampled with this program before.""); checkProgramRecords(); readNameParser=new ReadNameParser(READ_N"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\PositionBasedDownsampleSam.java,fillTileMinMaxCoord,"private void  (){ final SamReader in=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT); final ProgressLogger progress=new ProgressLogger(log (int)1e7 ""Read""); int total=0; for ( final SAMRecord rec : in) { if (STOP_AFTER != null && total >= STOP_AFTER) break; total++; progress.record(rec); final PhysicalLocationInt location=getSamRecordLocation(rec); final Coord Pos=tileCoord.get(location.getTile()); Pos.maxX=Math.max(Pos.maxX location.getX()); Pos.minX=Math.min(Pos.minX location.getX()); Pos.maxY=Math.max(Pos.maxY location.getY()); Pos.minY=Math.min(Pos.minY location.getY()); Pos.count++; } for ( final Coord coord : tileCoord.values()) { final int diffX=coord.maxX - coord.minX; final int diffY=coord.maxY - coord.minY; coord.maxX+=diffX / coord.count; coord.minX-=diffX / coord.count; coord.maxY+=diffY / coord.count; coord.minY-=diffY / coord.count; } CloserUtil.close(in); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\PositionBasedDownsampleSam.java,getSamRecordLocation,private PhysicalLocationInt  (final SAMRecord rec){ final PhysicalLocationInt pos=new PhysicalLocationInt(); readNameParser.addLocationInformation(rec.getReadName() pos); return pos; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\PositionBasedDownsampleSam.java,outputSamRecords,"private void  (){ final ProgressLogger progress=new ProgressLogger(log (int)1e7); final SamReader in=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT); final SAMFileHeader header=in.getFileHeader().clone(); final SAMFileHeader.PgIdGenerator pgIdGenerator=new SAMFileHeader.PgIdGenerator(header); final SAMProgramRecord programRecord=new SAMProgramRecord(pgIdGenerator.getNonCollidingId(PG_PROGRAM_NAME)); programRecord.setProgramName(PG_PROGRAM_NAME); programRecord.setCommandLine(getCommandLine()); programRecord.setProgramVersion(getVersion()); header.addProgramRecord(programRecord); final SAMFileWriter out=new SAMFileWriterFactory().makeSAMOrBAMWriter(header true OUTPUT); final CircleSelector selector=new CircleSelector(FRACTION); for ( final SAMRecord rec : in) { if (STOP_AFTER != null && total >= STOP_AFTER) break; total++; final PhysicalLocationInt pos=getSamRecordLocation(rec); if (!xPositions.containsKey(pos.getTile())) { xPositions.put(pos.getTile() new Histogram<>(pos.getTile() + ""-xpos"" ""count"")); } if (!yPositions.containsKey(pos.getTile())) { yPositions.put(pos.getTile() new Histogram<>(pos.getTile() + ""-ypos"" ""count"")); } final boolean keepRecord=selector.select(pos tileCoord.get(pos.getTile())); if (keepRecord) { if (REMOVE_DUPLICATE_INFORMATION) rec.setDuplicateReadFlag(false); out.addAlignment(rec); kept++; } progress.record(rec); } out.close(); CloserUtil.close(in); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\PositionBasedDownsampleSam.java,roundedPart,private double  (final double x){ return x - Math.round(x); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\PositionBasedDownsampleSam.java,select,private boolean  (final PhysicalLocationInt coord final Coord tileCoord){ final double distanceSquared=Math.pow(roundedPart(((coord.getX() - tileCoord.minX) / (double)(tileCoord.maxX - tileCoord.minX)) - offset) 2) + Math.pow(roundedPart(((coord.getY() - tileCoord.minY) / (double)(tileCoord.maxY - tileCoord.minY)) - offset) 2); return (distanceSquared > radiusSquared) ^ positiveSelection; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MultiHitAlignedReadIterator.java,MultiHitAlignedReadIterator, (final CloseableIterator<SAMRecord> querynameOrderIterator final PrimaryAlignmentSelectionStrategy primaryAlignmentSelectionStrategy){ this.primaryAlignmentSelectionStrategy=primaryAlignmentSelectionStrategy; peekIterator=new PeekableIterator<SAMRecord>(new FilteringSamIterator(querynameOrderIterator new SamRecordFilter(){ public boolean filterOut( final SAMRecord record){ return record.getReadUnmappedFlag() || SAMUtils.cigarMapsNoBasesToRef(record.getCigar()); } public boolean filterOut( final SAMRecord first  final SAMRecord second){ return ((first.getReadUnmappedFlag() || SAMUtils.cigarMapsNoBasesToRef(first.getCigar())) && (second.getReadUnmappedFlag() || SAMUtils.cigarMapsNoBasesToRef(second.getCigar()))); } } )); advance(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MultiHitAlignedReadIterator.java,advance,private void  (){ while (peekIterator.hasNext()) { theNext=nextMaybeEmpty(); if (theNext.numHits() > 0) return; } theNext=null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MultiHitAlignedReadIterator.java,close,public void  (){ peekIterator.close(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MultiHitAlignedReadIterator.java,filterOut,public boolean  (final SAMRecord first final SAMRecord second){ return ((first.getReadUnmappedFlag() || SAMUtils.cigarMapsNoBasesToRef(first.getCigar())) && (second.getReadUnmappedFlag() || SAMUtils.cigarMapsNoBasesToRef(second.getCigar()))); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MultiHitAlignedReadIterator.java,hasNext,public boolean  (){ return theNext != null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MultiHitAlignedReadIterator.java,next,public HitsForInsert  (){ if (!hasNext()) throw new NoSuchElementException(); final HitsForInsert ret=theNext; advance(); return ret; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MultiHitAlignedReadIterator.java,nextMaybeEmpty,"private HitsForInsert  (){ if (!peekIterator.hasNext()) throw new IllegalStateException(); final String readName=peekIterator.peek().getReadName(); final HitsForInsert hits=new HitsForInsert(); Boolean isPaired=null; do { final SAMRecord rec=peekIterator.next(); replaceHardWithSoftClips(rec); if (peekIterator.hasNext() && queryNameComparator.fileOrderCompare(rec peekIterator.peek()) > 0) { throw new IllegalStateException(""Underlying iterator is not queryname sorted: "" + rec + "" > ""+ peekIterator.peek()); } if (isPaired == null) { isPaired=rec.getReadPairedFlag(); } else if (isPaired != rec.getReadPairedFlag()) { throw new PicardException(""Got a mix of paired and unpaired alignments for read "" + readName); } if (!rec.getReadPairedFlag() || rec.getFirstOfPairFlag()) { if (rec.getSupplementaryAlignmentFlag()) { hits.addSupplementalFirstOfPairOrFragment(rec); } else { hits.addFirstOfPairOrFragment(rec); } } else if (rec.getSecondOfPairFlag()) { if (rec.getSupplementaryAlignmentFlag()) { hits.addSupplementalSecondOfPair(rec); } else { hits.addSecondOfPair(rec); } } else throw new PicardException(""Read is marked as pair but neither first or second: "" + readName); } while (peekIterator.hasNext() && peekIterator.peek().getReadName().equals(readName)); if (hits.numHits() <= 1) { if (hits.getFirstOfPair(0) != null) { hits.getFirstOfPair(0).setAttribute(SAMTag.HI.name() null); hits.getFirstOfPair(0).setNotPrimaryAlignmentFlag(false); } if (hits.getSecondOfPair(0) != null) { hits.getSecondOfPair(0).setAttribute(SAMTag.HI.name() null); hits.getSecondOfPair(0).setNotPrimaryAlignmentFlag(false); } } else { primaryAlignmentSelectionStrategy.pickPrimaryAlignment(hits); } return hits; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MultiHitAlignedReadIterator.java,remove,public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\MultiHitAlignedReadIterator.java,replaceHardWithSoftClips,private void  (final SAMRecord rec){ if (rec.getReadUnmappedFlag()) return; if (rec.getCigar().isEmpty()) return; List<CigarElement> elements=rec.getCigar().getCigarElements(); final CigarElement first=elements.get(0); final CigarElement last=elements.size() == 1 ? null : elements.get(elements.size() - 1); final int startHardClip=first.getOperator() == CigarOperator.H ? first.getLength() : 0; final int endHardClip=(last != null && last.getOperator() == CigarOperator.H) ? last.getLength() : 0; if (startHardClip + endHardClip > 0) { final int len=rec.getReadBases().length + startHardClip + endHardClip; final byte[] bases=new byte[len]; Arrays.fill(bases (byte)'N'); System.arraycopy(rec.getReadBases() 0 bases startHardClip rec.getReadBases().length); final byte[] quals=new byte[len]; Arrays.fill(quals (byte)2); System.arraycopy(rec.getBaseQualities() 0 quals startHardClip rec.getBaseQualities().length); elements=new ArrayList<CigarElement>(elements); if (startHardClip > 0) elements.set(0 new CigarElement(first.getLength() CigarOperator.S)); if (endHardClip > 0) elements.set(elements.size() - 1 new CigarElement(last.getLength() CigarOperator.S)); rec.setReadBases(bases); rec.setBaseQualities(quals); rec.setCigar(new Cigar(elements)); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ReplaceSamHeader.java,blockCopyReheader,private void  (final SAMFileHeader replacementHeader){ BamFileIoUtils.reheaderBamFile(replacementHeader INPUT OUTPUT CREATE_MD5_FILE CREATE_INDEX); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ReplaceSamHeader.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsReadable(HEADER); IOUtil.assertFileIsWritable(OUTPUT); final SAMFileHeader replacementHeader=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).getFileHe
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ReplaceSamHeader.java,main,public static void  (final String[] argv){ new ReplaceSamHeader().instanceMainWithExit(argv); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ReplaceSamHeader.java,standardReheader,"private void  (final SAMFileHeader replacementHeader){ final SamReader recordReader=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).validationStringency(ValidationStringency.SILENT).open(INPUT); if (replacementHeader.getSortOrder() != recordReader.getFileHeader().getSortOrder()) { throw new PicardException(""Sort orders of INPUT ("" + recordReader.getFileHeader().getSortOrder().name() + "") and HEADER (""+ replacementHeader.getSortOrder().name()+ "") do not agree.""); } final SAMFileWriter writer=new SAMFileWriterFactory().makeSAMOrBAMWriter(replacementHeader true OUTPUT); final ProgressLogger progress=new ProgressLogger(Log.getInstance(ReplaceSamHeader.class)); for ( final SAMRecord rec : recordReader) { rec.setHeader(replacementHeader); writer.addAlignment(rec); progress.record(rec); } writer.close(); CloserUtil.close(recordReader); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ReorderSam.java,buildSequenceDictionaryMap,"private Map<Integer Integer>  (final SAMSequenceDictionary refDict final SAMSequenceDictionary readsDict){ Map<Integer Integer> newOrder=new HashMap<Integer Integer>(); log.info(""Reordering SAM/BAM file:""); for ( final SAMSequenceRecord refRec : refDict.getSequences()) { final SAMSequenceRecord readsRec=readsDict.getSequence(refRec.getSequenceName()); if (readsRec != null) { if (refRec.getSequenceLength() != readsRec.getSequenceLength()) { String msg=String.format(""Discordant contig lengths: read %s LN=%d  ref %s LN=%d"" readsRec.getSequenceName() readsRec.getSequenceLength() refRec.getSequenceName() refRec.getSequenceLength()); if (ALLOW_CONTIG_LENGTH_DISCORDANCE) { log.warn(msg); } else { throw new PicardException(msg); } } log.info(String.format("" Reordering read contig %s [index=%d] to => ref contig %s [index=%d]%n"" readsRec.getSequenceName() readsRec.getSequenceIndex() refRec.getSequenceName() refRec.getSequenceIndex())); newOrder.put(readsRec.getSequenceIndex() refRec.getSequenceIndex()); } } for ( SAMSequenceRecord readsRec : readsDict.getSequences()) { if (!newOrder.containsKey(readsRec.getSequenceIndex())) { if (ALLOW_INCOMPLETE_DICT_CONCORDANCE) newOrder.put(readsRec.getSequenceIndex() -1); else throw new PicardException(""New reference sequence does not contain a matching contig for "" + readsRec.getSequenceName()); } } return newOrder; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ReorderSam.java,doWork,"protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsReadable(REFERENCE_SEQUENCE); IOUtil.assertFileIsWritable(OUTPUT); final SamReader in=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT); final ReferenceSequenceFile reference=ReferenceSequenceFileFactory.getReferenceSequenceFile(REFERENCE_SEQUENCE); final SAMSequenceDictionary refDict=reference.getSequenceDictionary(); if (refDict == null) { log.error(""No reference sequence dictionary found. Aborting. You can create a sequence dictionary for the reference fasta using CreateSequenceDictionary.jar.""); CloserUtil.close(in); return 1; } printDictionary(""SAM/BAM file"" in.getFileHeader().getSequenceDictionary()); printDictionary(""Reference"" refDict); final Map<Integer Integer> newOrder=buildSequenceDictionaryMap(refDict in.getFileHeader().getSequenceDictionary()); final SAMFileHeader outHeader=in.getFileHeader().clone(); outHeader.setSequenceDictionary(refDict); log.info(""Writing reads...""); if (in.hasIndex()) { try (final SAMFileWriter out=new SAMFileWriterFactory().makeSAMOrBAMWriter(outHeader true OUTPUT)){ for ( final SAMSequenceRecord contig : refDict.getSequences()) { final SAMRecordIterator it=in.query(contig.getSequenceName() 0 0 false); writeReads(out it newOrder contig.getSequenceName()); } writeReads(out in.queryUnmapped() newOrder ""unmapped""); } } else { try (final SAMFileWriter out=new SAMFileWriterFactory().makeSAMOrBAMWriter(outHeader false OUTPUT)){ writeReads(out in.iterator() newOrder ""All reads""); } } CloserUtil.close(in); return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ReorderSam.java,getReferenceFile,@Override public File  (){ return REFERENCE; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ReorderSam.java,makeReferenceArgumentCollection,@Override protected ReferenceArgumentCollection  (){ return new ReorderSamReferenceArgumentCollection(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ReorderSam.java,newOrderIndex,"private int  (SAMRecord read int oldIndex Map<Integer Integer> newOrder){ if (oldIndex == -1) return -1; else { final Integer n=newOrder.get(oldIndex); if (n == null) throw new PicardException(""BUG: no mapping found for read "" + read.getSAMString()); else return n; } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ReorderSam.java,printDictionary,"private void  (String name SAMSequenceDictionary dict){ log.info(name); for ( final SAMSequenceRecord contig : dict.getSequences()) { log.info("" SN=%s LN=%d%n"" contig.getSequenceName() contig.getSequenceLength()); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ReorderSam.java,writeReads,"private void  (final SAMFileWriter out final SAMRecordIterator it final Map<Integer Integer> newOrder final String name){ long counter=0; log.info("" Processing "" + name); while (it.hasNext()) { counter++; final SAMRecord read=it.next(); final int oldRefIndex=read.getReferenceIndex(); final int oldMateIndex=read.getMateReferenceIndex(); final int newRefIndex=newOrderIndex(read oldRefIndex newOrder); read.setHeader(out.getFileHeader()); read.setReferenceIndex(newRefIndex); final int newMateIndex=newOrderIndex(read oldMateIndex newOrder); if (oldMateIndex != -1 && newMateIndex == -1) { read.setMateAlignmentStart(0); read.setMateUnmappedFlag(true); read.setAttribute(SAMTag.MC.name() null); } read.setMateReferenceIndex(newMateIndex); out.addAlignment(read); } it.close(); log.info(""Wrote "" + counter + "" reads""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertOriginalBaseQualitiesAndAddMateCigar.java,CanSkipSamFile,private  (final String format final boolean skip){ this.format=format; this.skip=skip; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertOriginalBaseQualitiesAndAddMateCigar.java,RevertOriginalBaseQualitiesAndAddMateCigar,public  (){ this.CREATE_INDEX=true; this.CREATE_MD5_FILE=true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertOriginalBaseQualitiesAndAddMateCigar.java,canSkip,public boolean  (){ return this.skip; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertOriginalBaseQualitiesAndAddMateCigar.java,canSkipSAMFile,public static CanSkipSamFile  (final File inputFile final int maxRecordsToExamine boolean revertOriginalBaseQualities final File referenceFasta){ final SamReader in=SamReaderFactory.makeDefault().referenceSequence(referenceFasta).enable(SamReaderFactory.Option.EAGERLY_DECODE).open(inputFile); final Iterator<SAMRecord> iterator=in.iterator(); int numRecordsExamined=0; CanSkipSamFile returnType=CanSkipSamFile.FOUND_NO_EVIDENCE; while (iterator.hasNext() && numRecordsExamined < maxRecordsToExamine) { final SAMRecord record=iterator.next(); if (revertOriginalBaseQualities && null != record.getOriginalBaseQualities()) { returnType=CanSkipSamFile.CANNOT_SKIP_FOUND_OQ; break; } if (record.getReadPairedFlag() && !record.getMateUnmappedFlag()) { if (null == SAMUtils.getMateCigar(record)) { returnType=CanSkipSamFile.CANNOT_SKIP_FOUND_NO_MC; break; } else { returnType=CanSkipSamFile.CAN_SKIP; break; } } numRecordsExamined++; } if (!iterator.hasNext() && CanSkipSamFile.FOUND_NO_EVIDENCE == returnType) { returnType=CanSkipSamFile.CAN_SKIP; } CloserUtil.close(in); return returnType; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertOriginalBaseQualitiesAndAddMateCigar.java,doWork,"public int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); boolean foundPairedMappedReads=false; final CanSkipSamFile skipSamFile=RevertOriginalBaseQualitiesAndAddMateCigar.canSkipSAMFile(INPUT MAX_RECORDS_TO_EXAMINE RESTORE_ORIGINAL_QUALITIES REFERENCE_SEQUENCE); log.info(skipSamFile.getMessage(MAX_RECORDS_TO_EXAMINE)); if (skipSamFile.canSkip()) return 0; final SamReader in=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).enable(SamReaderFactory.Option.EAGERLY_DECODE).open(INPUT); final SAMFileHeader inHeader=in.getFileHeader(); final SAMFileHeader outHeader=inHeader.clone(); if (null == SORT_ORDER) this.SORT_ORDER=inHeader.getSortOrder(); outHeader.setSortOrder(SORT_ORDER); SAMFileWriterFactory.setDefaultCreateIndexWhileWriting(CREATE_INDEX); SAMFileWriterFactory.setDefaultCreateMd5File(CREATE_MD5_FILE); final SAMFileWriter out=new SAMFileWriterFactory().makeSAMOrBAMWriter(outHeader false OUTPUT); final SortingCollection<SAMRecord> sorter=SortingCollection.newInstance(SAMRecord.class new BAMRecordCodec(outHeader) new SAMRecordQueryNameComparator() MAX_RECORDS_IN_RAM); final ProgressLogger revertingProgress=new ProgressLogger(log 1000000 "" reverted OQs""); int numOriginalQualitiesRestored=0; for ( final SAMRecord record : in) { AbstractAlignmentMerger.createNewCigarsIfMapsOffEndOfReference(record); if (RESTORE_ORIGINAL_QUALITIES && null != record.getOriginalBaseQualities()) { record.setBaseQualities(record.getOriginalBaseQualities()); record.setOriginalBaseQualities(null); numOriginalQualitiesRestored++; } if (!foundPairedMappedReads && record.getReadPairedFlag() && !record.getReadUnmappedFlag()) foundPairedMappedReads=true; revertingProgress.record(record); sorter.add(record); } CloserUtil.close(in); log.info(""Reverted the original base qualities for "" + numOriginalQualitiesRestored + "" records""); final SamPairUtil.SetMateInfoIterator sorterIterator=new SamPairUtil.SetMateInfoIterator(sorter.iterator() true); final ProgressLogger sorterProgress=new ProgressLogger(log 1000000 "" mate cigars added""); while (sorterIterator.hasNext()) { final SAMRecord record=sorterIterator.next(); out.addAlignment(record); sorterProgress.record(record); } sorterIterator.close(); CloserUtil.close(out); log.info(""Updated "" + sorterIterator.getNumMateCigarsAdded() + "" records with mate cigar""); if (!foundPairedMappedReads) log.info(""Did not find any paired mapped reads.""); return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertOriginalBaseQualitiesAndAddMateCigar.java,getMessage,public String  (final int maxRecordsToExamine){ return String.format(this.format maxRecordsToExamine); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertOriginalBaseQualitiesAndAddMateCigar.java,main,public static void  (final String[] args){ new RevertOriginalBaseQualitiesAndAddMateCigar().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,FileType, (String descrition){ this.description=descrition; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,RevertSamSorter, (final boolean outputByReadGroup final Map<String SAMFileHeader> headerMap final SAMFileHeader singleOutHeader final int maxRecordsInRam){ this.outputByReadGroup=outputByReadGroup; if (outputByReadGroup) { for ( final Map.Entry<String SAMFileHeader> entry : headerMap.entrySet()) { final String readGroupId=entry.getKey(); final SAMFileHeader outHeader=entry.getValue(); final SortingCollection<SAMRecord> sorter=SortingCollection.newInstance(SAMRecord.class new BAMRecordCodec(outHeader) new SAMRecordQueryNameComparator() maxRecordsInRam); sorterMap.put(readGroupId sorter); } singleSorter=null; } else { singleSorter=SortingCollection.newInstance(SAMRecord.class new BAMRecordCodec(singleOutHeader) new SAMRecordQueryNameComparator() maxRecordsInRam); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,RevertSamWriter, (final boolean outputByReadGroup final Map<String SAMFileHeader> headerMap final Map<String File> outputMap final SAMFileHeader singleOutHeader final File singleOutput final boolean presorted final SAMFileWriterFactory factory final File referenceFasta){ this.outputByReadGroup=outputByReadGroup; if (outputByReadGroup) { singleWriter=null; for ( final Map.Entry<String File> outputMapEntry : outputMap.entrySet()) { final String readGroupId=outputMapEntry.getKey(); final File output=outputMapEntry.getValue(); final SAMFileHeader header=headerMap.get(readGroupId); final SAMFileWriter writer=factory.makeWriter(header presorted output referenceFasta); writerMap.put(readGroupId writer); } } else { singleWriter=factory.makeWriter(singleOutHeader presorted singleOutput referenceFasta); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,add,void  (final SAMRecord rec){ final SortingCollection<SAMRecord> sorter; if (outputByReadGroup) { sorter=sorterMap.get(rec.getReadGroup().getId()); } else { sorter=singleSorter; } sorter.add(rec); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,addAlignment,void  (final SAMRecord rec){ final SAMFileWriter writer; if (outputByReadGroup) { writer=writerMap.get(rec.getReadGroup().getId()); } else { writer=singleWriter; } writer.addAlignment(rec); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,assertAllReadGroupsMapped,"static void  (final Map<String File> outputMap final List<SAMReadGroupRecord> readGroups){ for ( final SAMReadGroupRecord readGroup : readGroups) { final String id=readGroup.getId(); final File output=outputMap.get(id); if (output == null) { throw new PicardException(""Read group id "" + id + "" not found in OUTPUT_MAP ""+ outputMap); } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,assertWritable,static void  (final File output final boolean outputByReadGroup){ if (outputByReadGroup) { if (output != null) { IOUtil.assertDirectoryIsWritable(output); } } else { IOUtil.assertFileIsWritable(output); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,close,void  (){ if (outputByReadGroup) { writerMap.values().forEach(SAMFileWriter::close); } else { singleWriter.close(); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,createHeaderMap,private Map<String SAMFileHeader>  (final SAMFileHeader inHeader final SortOrder sortOrder final boolean removeAlignmentInformation){ final Map<String SAMFileHeader> headerMap=new HashMap<>(); for ( final SAMReadGroupRecord readGroup : inHeader.getReadGroups()) { final SAMFileHeader header=createOutHeader(inHeader sortOrder removeAlignmentInformation); header.addReadGroup(readGroup); headerMap.put(readGroup.getId() header); } return headerMap; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,createOutHeader,private SAMFileHeader  (final SAMFileHeader inHeader final SAMFileHeader.SortOrder sortOrder final boolean removeAlignmentInformation){ final SAMFileHeader outHeader=new SAMFileHeader(); outHeader.setSortOrder(sortOrder); if (!removeAlignmentInformation) { outHeader.setSequenceDictionary(inHeader.getSequenceDictionary()); outHeader.setProgramRecords(inHeader.getProgramRecords()); } return outHeader; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,createOutputMap,private static Map<String File>  (final List<SAMReadGroupRecord> readGroups final File outputDir final String extension){ final Map<String File> outputMap=new HashMap<>(); for ( final SAMReadGroupRecord readGroup : readGroups) { final String id=readGroup.getId(); final String fileName=id + extension; final Path outputPath=Paths.get(outputDir.toString() fileName); outputMap.put(id outputPath.toFile()); } return outputMap; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,createOutputMapFromFile,"private static Map<String File>  (final File outputMapFile){ final Map<String File> outputMap=new HashMap<>(); final TabbedTextFileWithHeaderParser parser=new TabbedTextFileWithHeaderParser(outputMapFile); for ( final TabbedTextFileWithHeaderParser.Row row : parser) { final String id=row.getField(""READ_GROUP_ID""); final String output=row.getField(""OUTPUT""); final File outputPath=new File(output); outputMap.put(id outputPath); } CloserUtil.close(parser); return outputMap; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,createReadGroupFormatMap,"private Map<SAMReadGroupRecord FastqQualityFormat>  (final SAMFileHeader inHeader final File referenceSequence final ValidationStringency validationStringency final File input final boolean restoreOriginalQualities){ final Map<SAMReadGroupRecord FastqQualityFormat> readGroupToFormat=new HashMap<>(); for ( final SAMReadGroupRecord rg : inHeader.getReadGroups()) { final SamReader reader=SamReaderFactory.makeDefault().referenceSequence(referenceSequence).validationStringency(validationStringency).open(input); final SamRecordFilter filter=new SamRecordFilter(){ public boolean filterOut( final SAMRecord rec){ return !rec.getReadGroup().getId().equals(rg.getId()); } public boolean filterOut( final SAMRecord first  final SAMRecord second){ throw new UnsupportedOperationException(); } } ; readGroupToFormat.put(rg QualityEncodingDetector.detect(QualityEncodingDetector.DEFAULT_MAX_RECORDS_TO_ITERATE new FilteringSamIterator(reader.iterator() filter) restoreOriginalQualities)); CloserUtil.close(reader); } for ( final SAMReadGroupRecord r : readGroupToFormat.keySet()) { log.info(""Detected quality format for "" + r.getReadGroupId() + "": ""+ readGroupToFormat.get(r)); } if (readGroupToFormat.values().contains(FastqQualityFormat.Solexa)) { throw new PicardException(""No quality score encoding conversion implemented for "" + FastqQualityFormat.Solexa); } return readGroupToFormat; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,customCommandLineValidation,@Override protected String[]  (){ final List<String> errors=new ArrayList<>(); ValidationUtil.validateSanitizeSortOrder(SANITIZE SORT_ORDER errors); ValidationUtil.validateOutputParams(OUTPUT_BY_READGROUP OUTPUT OUTPUT_MAP errors); if (!SANITIZE && KEEP_F
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,doWork,"protected int  (){ IOUtil.assertFileIsReadable(INPUT); ValidationUtil.assertWritable(OUTPUT OUTPUT_BY_READGROUP); final boolean sanitizing=SANITIZE; final SamReader in=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).validationStringency(VALIDATION_STRINGENCY).open(INPUT); final SAMFileHeader inHeader=in.getFileHeader(); ValidationUtil.validateHeaderOverrides(inHeader SAMPLE_ALIAS LIBRARY_NAME); final boolean presorted=isPresorted(inHeader SORT_ORDER sanitizing); if (SAMPLE_ALIAS != null) overwriteSample(inHeader.getReadGroups() SAMPLE_ALIAS); if (LIBRARY_NAME != null) overwriteLibrary(inHeader.getReadGroups() LIBRARY_NAME); final SAMFileHeader singleOutHeader=createOutHeader(inHeader SORT_ORDER REMOVE_ALIGNMENT_INFORMATION); inHeader.getReadGroups().forEach(readGroup -> singleOutHeader.addReadGroup(readGroup)); final Map<String File> outputMap; final Map<String SAMFileHeader> headerMap; if (OUTPUT_BY_READGROUP) { if (inHeader.getReadGroups().isEmpty()) { throw new PicardException(INPUT + "" does not contain Read Groups""); } final String defaultExtension; if (OUTPUT_BY_READGROUP_FILE_FORMAT == FileType.dynamic) { defaultExtension=getDefaultExtension(INPUT.toString()); } else { defaultExtension=""."" + OUTPUT_BY_READGROUP_FILE_FORMAT.toString(); } outputMap=createOutputMap(OUTPUT_MAP OUTPUT defaultExtension inHeader.getReadGroups()); ValidationUtil.assertAllReadGroupsMapped(outputMap inHeader.getReadGroups()); headerMap=createHeaderMap(inHeader SORT_ORDER REMOVE_ALIGNMENT_INFORMATION); } else { outputMap=null; headerMap=null; } final SAMFileWriterFactory factory=new SAMFileWriterFactory(); final RevertSamWriter out=new RevertSamWriter(OUTPUT_BY_READGROUP headerMap outputMap singleOutHeader OUTPUT presorted factory REFERENCE_SEQUENCE); final RevertSamSorter sorter; if (sanitizing) sorter=new RevertSamSorter(OUTPUT_BY_READGROUP headerMap singleOutHeader MAX_RECORDS_IN_RAM); else sorter=null; final ProgressLogger progress=new ProgressLogger(log 1000000 ""Reverted""); for ( final SAMRecord rec : in) { if (rec.isSecondaryOrSupplementary()) continue; progress.record(rec); revertSamRecord(rec); if (sanitizing) sorter.add(rec); else out.addAlignment(rec); } CloserUtil.close(in); if (!sanitizing) { out.close(); } else { final Map<SAMReadGroupRecord FastqQualityFormat> readGroupToFormat; try { readGroupToFormat=createReadGroupFormatMap(inHeader REFERENCE_SEQUENCE VALIDATION_STRINGENCY INPUT RESTORE_ORIGINAL_QUALITIES); } catch ( final PicardException e) { log.error(e.getMessage()); return -1; } final long[] sanitizeResults=sanitize(readGroupToFormat sorter out); final long discarded=sanitizeResults[0]; final long total=sanitizeResults[1]; out.close(); final double discardRate=discarded / (double)total; final NumberFormat fmt=new DecimalFormat(""0.000%""); log.info(""Discarded "" + discarded + "" out of ""+ total+ "" (""+ fmt.format(discardRate)+ "") reads in order to sanitize output.""); if (discardRate > MAX_DISCARD_FRACTION) { throw new PicardException(""Discarded "" + fmt.format(discardRate) + "" which is above MAX_DISCARD_FRACTION of ""+ fmt.format(MAX_DISCARD_FRACTION)); } } return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,fetchByReadName,private List<SAMRecord>  (final PeekableIterator<SAMRecord> iterator){ final List<SAMRecord> out=new ArrayList<>(); if (iterator.hasNext()) { final SAMRecord first=iterator.next(); out.add(first); while (iterator.hasNext() && iterator.peek().getReadName().equals(first.getReadName())) { out.add(iterator.next()); } } return out; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,filterOut,public boolean  (final SAMRecord first final SAMRecord second){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,getDefaultExtension,"static String  (final String input){ if (input.endsWith("".sam"")) { return "".sam""; } if (input.endsWith("".cram"")) { return "".cram""; } return "".bam""; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,getHelpDoc,@Override public String  (){ return description; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,isOutputMapHeaderValid,"static boolean  (final List<String> columnLabels){ if (columnLabels.size() < 2) { return false; } if (!""READ_GROUP_ID"".equals(columnLabels.get(0))) { return false; } if (!""OUTPUT"".equals(columnLabels.get(1))) { return false; } return true; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,isPresorted,private boolean  (final SAMFileHeader inHeader final SortOrder sortOrder final boolean sanitizing){ return (inHeader.getSortOrder() == sortOrder) || (sortOrder == SortOrder.queryname && sanitizing); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,iterators,List<PeekableIterator<SAMRecord>>  (){ final List<PeekableIterator<SAMRecord>> iterators=new ArrayList<>(); if (outputByReadGroup) { for ( final SortingCollection<SAMRecord> sorter : sorterMap.values()) { final PeekableIterator<SAMRecord> iterator=new PeekableIterator<>(sorter.iterator()); iterators.add(iterator); } } else { final PeekableIterator<SAMRecord> iterator=new PeekableIterator<>(singleSorter.iterator()); iterators.add(iterator); } return iterators; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,overwriteLibrary,private void  (final List<SAMReadGroupRecord> readGroups final String libraryName){ readGroups.forEach(rg -> rg.setLibrary(libraryName)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,overwriteSample,private void  (final List<SAMReadGroupRecord> readGroups final String sampleAlias){ readGroups.forEach(rg -> rg.setSample(sampleAlias)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,revertSamRecord,public void  (final SAMRecord rec){ if (RESTORE_ORIGINAL_QUALITIES) { final byte[] oq=rec.getOriginalBaseQualities(); if (oq != null) { rec.setBaseQualities(oq); rec.setOriginalBaseQualities(null); } } if (REMOVE_DUPLICATE_INFORMATION) { rec.setDuplicateReadFlag(false); } if (REMOVE_ALIGNMENT_INFORMATION) { if (rec.getReadNegativeStrandFlag()) { rec.reverseComplement(true); rec.setReadNegativeStrandFlag(false); } rec.setReferenceIndex(SAMRecord.NO_ALIGNMENT_REFERENCE_INDEX); rec.setAlignmentStart(SAMRecord.NO_ALIGNMENT_START); rec.setCigarString(SAMRecord.NO_ALIGNMENT_CIGAR); rec.setMappingQuality(SAMRecord.NO_MAPPING_QUALITY); rec.setInferredInsertSize(0); rec.setNotPrimaryAlignmentFlag(false); rec.setProperPairFlag(false); rec.setReadUnmappedFlag(true); rec.setMateAlignmentStart(SAMRecord.NO_ALIGNMENT_START); rec.setMateNegativeStrandFlag(false); rec.setMateReferenceIndex(SAMRecord.NO_ALIGNMENT_REFERENCE_INDEX); rec.setMateUnmappedFlag(rec.getReadPairedFlag()); ATTRIBUTE_TO_CLEAR.forEach(tag -> rec.setAttribute(tag null)); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,sanitize,"private long[]  (final Map<SAMReadGroupRecord FastqQualityFormat> readGroupToFormat final RevertSamSorter sorter final RevertSamWriter out){ long total=0  discarded=0; final ProgressLogger sanitizerProgress=new ProgressLogger(log 1000000 ""Sanitized""); final List<PeekableIterator<SAMRecord>> iterators=sorter.iterators(); for ( final PeekableIterator<SAMRecord> iterator : iterators) { readNameLoop: while (iterator.hasNext()) { List<SAMRecord> recs=fetchByReadName(iterator); total+=recs.size(); for ( final SAMRecord rec : recs) { if (rec.getReadBases().length != rec.getBaseQualities().length) { log.debug(""Discarding "" recs.size() "" reads with name "" rec.getReadName() "" for mismatching bases and quals length.""); discarded+=recs.size(); continue readNameLoop; } } int firsts=0  seconds=0  unpaired=0; SAMRecord firstRecord=null  secondRecord=null  unpairedRecord=null; for ( final SAMRecord rec : recs) { if (!rec.getReadPairedFlag()) { if (unpairedRecord == null) { unpairedRecord=rec; } ++unpaired; } else { if (rec.getFirstOfPairFlag()) { if (firstRecord == null) { firstRecord=rec; } ++firsts; } if (rec.getSecondOfPairFlag()) { if (secondRecord == null) { secondRecord=rec; } ++seconds; } } } if (firsts > 0 || seconds > 0) { if (firsts != 1 || seconds != 1) { if (KEEP_FIRST_DUPLICATE && firsts >= 1 && seconds >= 1) { discarded+=recs.size() - 2; recs=Arrays.asList(firstRecord secondRecord); } else { log.debug(""Discarding "" recs.size() "" reads with name "" recs.get(0).getReadName() "" because we found "" firsts "" R1s "" seconds "" R2s and "" unpaired "" unpaired reads.""); discarded+=recs.size(); continue readNameLoop; } } } else if (unpaired > 1) { if (KEEP_FIRST_DUPLICATE) { discarded+=recs.size() - 1; recs=Collections.singletonList(unpairedRecord); } else { log.debug(""Discarding "" recs.size() "" reads with name "" recs.get(0).getReadName() "" because we found "" unpaired "" unpaired reads.""); discarded+=recs.size(); continue readNameLoop; } } for ( final SAMRecord rec : recs) { final FastqQualityFormat recordFormat=readGroupToFormat.get(rec.getReadGroup()); if (recordFormat != null && !recordFormat.equals(FastqQualityFormat.Standard)) { final byte[] quals=rec.getBaseQualities(); for (int i=0; i < quals.length; i++) { quals[i]-=SolexaQualityConverter.ILLUMINA_TO_PHRED_SUBTRAHEND; } rec.setBaseQualities(quals); } out.addAlignment(rec); sanitizerProgress.record(rec); } } } return new long[]{discarded total}; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,validateHeaderOverrides,"static void  (final SAMFileHeader inHeader final String sampleAlias final String libraryName){ final List<SAMReadGroupRecord> rgs=inHeader.getReadGroups(); if (sampleAlias != null || libraryName != null) { boolean allSampleAliasesIdentical=true; boolean allLibraryNamesIdentical=true; for (int i=1; i < rgs.size(); i++) { if (!rgs.get(0).getSample().equals(rgs.get(i).getSample())) { allSampleAliasesIdentical=false; } if (!rgs.get(0).getLibrary().equals(rgs.get(i).getLibrary())) { allLibraryNamesIdentical=false; } } if (sampleAlias != null && !allSampleAliasesIdentical) { throw new PicardException(""Read groups have multiple values for sample. "" + ""A value for SAMPLE_ALIAS cannot be supplied.""); } if (libraryName != null && !allLibraryNamesIdentical) { throw new PicardException(""Read groups have multiple values for library name. "" + ""A value for library name cannot be supplied.""); } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,validateOutputParams,static void  (final boolean outputByReadGroup final File output final File outputMap final List<String> errors){ if (outputByReadGroup) { validateOutputParamsByReadGroup(output outputMap errors); } else { validateOutputParamsNotByReadGroup(output outputMap errors); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,validateOutputParamsByReadGroup,"static void  (final File output final File outputMap final List<String> errors){ if (output != null) { if (!Files.isDirectory(output.toPath())) { errors.add(""When OUTPUT_BY_READGROUP=true and OUTPUT is provided  it must be a directory: "" + output); } return; } if (outputMap == null) { errors.add(""Must provide either OUTPUT or OUTPUT_MAP when OUTPUT_BY_READGROUP=true.""); return; } if (!Files.isReadable(outputMap.toPath())) { errors.add(""Cannot read OUTPUT_MAP "" + outputMap); return; } final TabbedTextFileWithHeaderParser parser=new TabbedTextFileWithHeaderParser(outputMap); if (!ValidationUtil.isOutputMapHeaderValid(parser.columnLabelsList())) { errors.add(""Invalid header: "" + outputMap + "". Must be a tab-separated file with READ_GROUP_ID as first column and OUTPUT as second column.""); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,validateOutputParamsNotByReadGroup,"static void  (final File output final File outputMap final List<String> errors){ if (outputMap != null) { errors.add(""Cannot provide OUTPUT_MAP when OUTPUT_BY_READGROUP=false. Provide OUTPUT instead.""); } if (output == null) { errors.add(""OUTPUT is required when OUTPUT_BY_READGROUP=false""); return; } if (Files.isDirectory(output.toPath())) { errors.add(""OUTPUT "" + output + "" should not be a directory when OUTPUT_BY_READGROUP=false""); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\RevertSam.java,validateSanitizeSortOrder,"static void  (final boolean sanitize final SAMFileHeader.SortOrder sortOrder final List<String> errors){ if (sanitize && sortOrder != SAMFileHeader.SortOrder.queryname) { errors.add(""SORT_ORDER must be queryname when sanitization is enabled with SANITIZE=true.""); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamFormatConverter.java,doWork,"protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); final SamReader reader=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT); final SAMFileWriter writer=new SAMFileWriterFactory().makeWriter(reader.getFileHeader() true OUTPUT REFERENCE_SEQUENCE); if (CREATE_INDEX && writer.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.coordinate) { throw new PicardException(""Can't CREATE_INDEX unless sort order is coordinate""); } final ProgressLogger progress=new ProgressLogger(Log.getInstance(SamFormatConverter.class)); for ( final SAMRecord rec : reader) { writer.addAlignment(rec); progress.record(rec); } CloserUtil.close(reader); writer.close(); return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamFormatConverter.java,main,public static void  (final String[] argv){ new SamFormatConverter().instanceMainWithExit(argv); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastq.java,FastqWriters,private  (final FastqWriter firstOfPair final FastqWriter secondOfPair final FastqWriter unpaired){ this(firstOfPair new Lazy<>(() -> secondOfPair) unpaired); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastq.java,assertPairedMates,"protected static void  (final SAMRecord record1 final SAMRecord record2){ if (!(record1.getFirstOfPairFlag() && record2.getSecondOfPairFlag() || record2.getFirstOfPairFlag() && record1.getSecondOfPairFlag())) { throw new PicardException(""Illegal mate state: "" + record1.getReadName()); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastq.java,clip,private static String  (final String src final int point final Character replacement final boolean posStrand){ final int len=src.length(); StringBuilder result=new StringBuilder(posStrand ? src.substring(0 point - 1) : src.substring(len - point + 1)); if (replacement != null) { if (posStrand) { for (int i=point; i <= len; i++) { result.append(replacement); } } else { for (int i=0; i <= len - point; i++) { result.insert(0 replacement); } } } return result.toString(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastq.java,closeAll,private void  (){ final Set<FastqWriter> fastqWriters=new HashSet<>(); fastqWriters.add(firstOfPair); fastqWriters.add(unpaired); if (secondOfPair.isInitialized()) { fastqWriters.add(secondOfPair.get()); } for ( final FastqWriter fastqWriter : fastqWriters) { fastqWriter.close(); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastq.java,customCommandLineValidation,"protected String[]  (){ List<String> errors=new ArrayList<>(); if (INTERLEAVE && SECOND_END_FASTQ != null) { errors.add(""Cannot set INTERLEAVE to true and pass in a SECOND_END_FASTQ""); } if (UNPAIRED_FASTQ != null && SECOND_END_FASTQ == null) { errors.add(""UNPAIRED_FASTQ may only be set when also emitting read1 and read2 fastqs (so SECOND_END_FASTQ must also be set).""); } if ((CLIPPING_ATTRIBUTE != null && CLIPPING_ACTION == null) || (CLIPPING_ATTRIBUTE == null && CLIPPING_ACTION != null)) { errors.add(""Both or neither of CLIPPING_ATTRIBUTE and CLIPPING_ACTION should be set.""); } if (CLIPPING_ACTION != null) { if (!CLIPPING_ACTION.equals(CLIP_TO_N) && !CLIPPING_ACTION.equals(CLIP_TRIM)) { try { Integer.parseInt(CLIPPING_ACTION); } catch ( NumberFormatException nfe) { errors.add(""CLIPPING ACTION must be one of: N  X  or an integer""); } } } if ((OUTPUT_PER_RG && OUTPUT_DIR == null) || ((!OUTPUT_PER_RG) && OUTPUT_DIR != null)) { errors.add(""If OUTPUT_PER_RG is true  then OUTPUT_DIR should be set. If ""); } if (OUTPUT_PER_RG) { if (RG_TAG == null) { errors.add(""If OUTPUT_PER_RG is true  then RG_TAG should be set.""); } else if (!(RG_TAG.equalsIgnoreCase(""PU"") || RG_TAG.equalsIgnoreCase(""ID""))) { errors.add(""RG_TAG must be: PU or ID""); } } return errors.isEmpty() ? super.customCommandLineValidation() : errors.toArray(new String[errors.size()]); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastq.java,doWork,"protected int  (){ IOUtil.assertFileIsReadable(INPUT); final SamReader reader=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT); final Map<String SAMRecord> firstSeenMates=new HashMap<>(); final FastqWriterFactory factory=new FastqWriterFactory(); factory.setCreateMd5(CREATE_MD5_FILE); initializeAdditionalWriters(); final Map<SAMReadGroupRecord FastqWriters> writers=generateWriters(reader.getFileHeader().getReadGroups() factory); final Map<SAMReadGroupRecord List<FastqWriter>> additionalWriters=generateAdditionalWriters(reader.getFileHeader().getReadGroups() factory); if (writers.isEmpty()) { final String msgBase=INPUT + "" does not contain Read Groups""; final String msg=OUTPUT_PER_RG ? msgBase + ""  consider not using the OUTPUT_PER_RG option"" : msgBase; throw new PicardException(msg); } final ProgressLogger progress=new ProgressLogger(log); for ( final SAMRecord currentRecord : reader) { handleRecord(currentRecord writers additionalWriters firstSeenMates); progress.record(currentRecord); } CloserUtil.close(reader); for ( final FastqWriters writerMapping : new HashSet<>(writers.values())) { writerMapping.closeAll(); } final Set<FastqWriter> additionalWriterSet=new HashSet<>(); additionalWriters.values().forEach(additionalWriterSet::addAll); for ( final FastqWriter fastqWriter : additionalWriterSet) { fastqWriter.close(); } if (!firstSeenMates.isEmpty()) { SAMUtils.processValidationError(new SAMValidationError(SAMValidationError.Type.MATE_NOT_FOUND ""Found "" + firstSeenMates.size() + "" unpaired mates"" null) VALIDATION_STRINGENCY); } return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastq.java,generateAdditionalWriters,protected Map<SAMReadGroupRecord List<FastqWriter>>  (List<SAMReadGroupRecord> readGroups FastqWriterFactory factory){ return Collections.emptyMap(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastq.java,generateWriters,"private Map<SAMReadGroupRecord FastqWriters>  (List<SAMReadGroupRecord> samReadGroupRecords FastqWriterFactory factory){ final Map<SAMReadGroupRecord FastqWriters> writerMap=new HashMap<>(); final FastqWriters fastqWriters; if (!OUTPUT_PER_RG) { IOUtil.assertFileIsWritable(FASTQ); final FastqWriter firstOfPairWriter=factory.newWriter(FASTQ); final FastqWriter secondOfPairWriter; if (INTERLEAVE) { secondOfPairWriter=firstOfPairWriter; } else if (SECOND_END_FASTQ != null) { IOUtil.assertFileIsWritable(SECOND_END_FASTQ); secondOfPairWriter=factory.newWriter(SECOND_END_FASTQ); } else { secondOfPairWriter=null; } final FastqWriter unpairedWriter=UNPAIRED_FASTQ == null ? firstOfPairWriter : factory.newWriter(UNPAIRED_FASTQ); fastqWriters=new FastqWriters(firstOfPairWriter secondOfPairWriter unpairedWriter); writerMap.put(null fastqWriters); for ( final SAMReadGroupRecord rg : samReadGroupRecords) { writerMap.put(rg fastqWriters); } } else { for ( final SAMReadGroupRecord rg : samReadGroupRecords) { final FastqWriter firstOfPairWriter=factory.newWriter(makeReadGroupFile(rg ""_1"")); final Lazy<FastqWriter> lazySecondOfPairWriter=new Lazy<>(() -> INTERLEAVE ? firstOfPairWriter : factory.newWriter(makeReadGroupFile(rg ""_2""))); writerMap.put(rg new FastqWriters(firstOfPairWriter lazySecondOfPairWriter firstOfPairWriter)); } } return writerMap; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastq.java,getFirstOfPair,private FastqWriter  (){ return firstOfPair; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastq.java,getSecondOfPair,private FastqWriter  (){ return secondOfPair.get(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastq.java,getUnpaired,private FastqWriter  (){ return unpaired; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastq.java,handleRecord,"private void  (final SAMRecord currentRecord final Map<SAMReadGroupRecord FastqWriters> writers final Map<SAMReadGroupRecord List<FastqWriter>> additionalWriters final Map<String SAMRecord> firstSeenMates){ if (currentRecord.isSecondaryOrSupplementary() && !INCLUDE_NON_PRIMARY_ALIGNMENTS) { return; } if (currentRecord.getReadFailsVendorQualityCheckFlag() && !INCLUDE_NON_PF_READS) { return; } final FastqWriters fq=writers.get(currentRecord.getReadGroup()); SAMRecord read1=null; SAMRecord read2=null; if (currentRecord.getReadPairedFlag()) { final String currentReadName=currentRecord.getReadName(); final SAMRecord firstRecord=firstSeenMates.remove(currentReadName); if (firstRecord == null) { firstSeenMates.put(currentReadName currentRecord); } else { assertPairedMates(firstRecord currentRecord); read1=currentRecord.getFirstOfPairFlag() ? currentRecord : firstRecord; read2=currentRecord.getFirstOfPairFlag() ? firstRecord : currentRecord; writeRecord(read1 1 fq.getFirstOfPair() READ1_TRIM READ1_MAX_BASES_TO_WRITE); final FastqWriter secondOfPairWriter=fq.getSecondOfPair(); if (secondOfPairWriter == null) { throw new PicardException(""Input contains paired reads but no SECOND_END_FASTQ specified.""); } writeRecord(read2 2 secondOfPairWriter READ2_TRIM READ2_MAX_BASES_TO_WRITE); } } else { writeRecord(currentRecord null fq.getUnpaired() READ1_TRIM READ1_MAX_BASES_TO_WRITE); } handleAdditionalRecords(currentRecord additionalWriters read1 read2); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastq.java,main,public static void  (final String[] argv){ System.exit(new SamToFastq().instanceMain(argv)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastq.java,makeReadGroupFile,"private File  (final SAMReadGroupRecord readGroup final String preExtSuffix){ String fileName=null; if (RG_TAG.equalsIgnoreCase(""PU"")) { fileName=readGroup.getPlatformUnit(); } else if (RG_TAG.equalsIgnoreCase(""ID"")) { fileName=readGroup.getReadGroupId(); } if (fileName == null) { throw new PicardException(""The selected RG_TAG: "" + RG_TAG + "" is not present in the bam header.""); } fileName=IOUtil.makeFileNameSafe(fileName); if (preExtSuffix != null) { fileName+=preExtSuffix; } fileName+=COMPRESS_OUTPUTS_PER_RG ? "".fastq.gz"" : "".fastq""; final File result=(OUTPUT_DIR != null) ? new File(OUTPUT_DIR fileName) : new File(fileName); IOUtil.assertFileIsWritable(result); return result; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastq.java,writeRecord,"private void  (final SAMRecord read final Integer mateNumber final FastqWriter writer final int basesToTrim final Integer maxBasesToWrite){ final String seqHeader=mateNumber == null ? read.getReadName() : read.getReadName() + ""/"" + mateNumber; String readString=read.getReadString(); String baseQualities=read.getBaseQualityString(); if (CLIPPING_ATTRIBUTE != null) { Integer clipPoint=(Integer)read.getAttribute(CLIPPING_ATTRIBUTE); if (clipPoint != null && clipPoint < CLIPPING_MIN_LENGTH) { clipPoint=Math.min(readString.length() CLIPPING_MIN_LENGTH); } if (clipPoint != null) { if (CLIPPING_ACTION.equalsIgnoreCase(CLIP_TRIM)) { readString=clip(readString clipPoint null !read.getReadNegativeStrandFlag()); baseQualities=clip(baseQualities clipPoint null !read.getReadNegativeStrandFlag()); } else if (CLIPPING_ACTION.equalsIgnoreCase(CLIP_TO_N)) { readString=clip(readString clipPoint CLIP_TO_N.charAt(0) !read.getReadNegativeStrandFlag()); } else { final char newQual=SAMUtils.phredToFastq(new byte[]{(byte)Integer.parseInt(CLIPPING_ACTION)}).charAt(0); baseQualities=clip(baseQualities clipPoint newQual !read.getReadNegativeStrandFlag()); } } } if (RE_REVERSE && read.getReadNegativeStrandFlag()) { readString=SequenceUtil.reverseComplement(readString); baseQualities=StringUtil.reverseString(baseQualities); } if (basesToTrim > 0) { readString=readString.substring(basesToTrim); baseQualities=baseQualities.substring(basesToTrim); } if (QUALITY != null) { final byte[] quals=SAMUtils.fastqToPhred(baseQualities); final int qualityTrimIndex=Math.max(1 TrimmingUtil.findQualityTrimPoint(quals QUALITY)); if (qualityTrimIndex < quals.length) { readString=readString.substring(0 qualityTrimIndex); baseQualities=baseQualities.substring(0 qualityTrimIndex); } } if (maxBasesToWrite != null && maxBasesToWrite < readString.length()) { readString=readString.substring(0 maxBasesToWrite); baseQualities=baseQualities.substring(0 maxBasesToWrite); } writer.write(new FastqRecord(seqHeader readString """" baseQualities)); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamAlignmentMerger.java,SamAlignmentMerger,"public  (final File unmappedBamFile final File targetBamFile final File referenceFasta final SAMProgramRecord programRecord final boolean clipAdapters final boolean bisulfiteSequence final boolean alignedReadsOnly final List<File> alignedSamFile final int maxGaps final List<String> attributesToRetain final List<String> attributesToRemove final Integer read1BasesTrimmed final Integer read2BasesTrimmed final List<File> read1AlignedSamFile final List<File> read2AlignedSamFile final List<SamPairUtil.PairOrientation> expectedOrientations final SortOrder sortOrder final PrimaryAlignmentSelectionStrategy primaryAlignmentSelectionStrategy final boolean addMateCigar final boolean unmapContaminantReads final int minUnclippedBases final UnmappingReadStrategy unmappingReadStrategy final List<String> requiredMatchingDictionaryTags){ super(unmappedBamFile targetBamFile referenceFasta clipAdapters bisulfiteSequence alignedReadsOnly programRecord attributesToRetain attributesToRemove read1BasesTrimmed read2BasesTrimmed expectedOrientations sortOrder primaryAlignmentSelectionStrategy addMateCigar unmapContaminantReads unmappingReadStrategy); if ((alignedSamFile == null || alignedSamFile.isEmpty()) && (read1AlignedSamFile == null || read1AlignedSamFile.isEmpty() || read2AlignedSamFile == null || read2AlignedSamFile.isEmpty())) { throw new IllegalArgumentException(""Either alignedSamFile or BOTH of read1AlignedSamFile and "" + ""read2AlignedSamFile must be specified.""); } if (alignedSamFile != null) { alignedSamFile.forEach(IOUtil::assertFileIsReadable); } else { read1AlignedSamFile.forEach(IOUtil::assertFileIsReadable); read2AlignedSamFile.forEach(IOUtil::assertFileIsReadable); } this.alignedSamFile=alignedSamFile; this.read1AlignedSamFile=read1AlignedSamFile; this.read2AlignedSamFile=read2AlignedSamFile; this.maxGaps=maxGaps; this.minUnclippedBases=minUnclippedBases; this.contaminationFilter=new OverclippedReadFilter(minUnclippedBases false); this.requiredMatchingDictionaryTags=requiredMatchingDictionaryTags; log.info(""Processing SAM file(s): "" + ((alignedSamFile != null) ? alignedSamFile : (read1AlignedSamFile + "" "" + read2AlignedSamFile))); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamAlignmentMerger.java,SeparateEndAlignmentIterator,"public  (final List<File> read1Alignments final List<File> read2Alignments File referenceFasta){ final List<SAMFileHeader> headers=new ArrayList<>(); final List<SamReader> read1=new ArrayList<>(read1Alignments.size()); final List<SamReader> read2=new ArrayList<>(read2Alignments.size()); for ( final File f : read1Alignments) { final SamReader r=SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(f); headers.add(r.getFileHeader()); read1.add(r); } for ( final File f : read2Alignments) { final SamReader r=SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(f); headers.add(r.getFileHeader()); read2.add(r); } final SamFileHeaderMerger headerMerger=new SamFileHeaderMerger(SAMFileHeader.SortOrder.coordinate headers false); read1Iterator=new PeekableIterator<>(new SuffixTrimingSamRecordIterator(new MergingSamRecordIterator(headerMerger read1 true) ""/1"")); read2Iterator=new PeekableIterator<>(new SuffixTrimingSamRecordIterator(new MergingSamRecordIterator(headerMerger read2 true) ""/2"")); header=headerMerger.getMergedHeader(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamAlignmentMerger.java,SuffixTrimingSamRecordIterator,private  (final CloseableIterator<SAMRecord> underlyingIterator final String suffixToTrim){ this.underlyingIterator=underlyingIterator; this.suffixToTrim=suffixToTrim; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamAlignmentMerger.java,close,public void  (){ read1Iterator.close(); read2Iterator.close(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamAlignmentMerger.java,getDictionaryForMergedBam,"@Override protected SAMSequenceDictionary  (){ SAMSequenceDictionary referenceDict=SAMSequenceDictionaryExtractor.extractDictionary(referenceFasta.toPath()); if (referenceDict == null) { throw new PicardException(""No sequence dictionary found for "" + refe"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamAlignmentMerger.java,getForceSort,public boolean  (){ return this.forceSort; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamAlignmentMerger.java,getHeader,public SAMFileHeader  (){ return this.header; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamAlignmentMerger.java,getQuerynameSortedAlignedRecords,"protected CloseableIterator<SAMRecord>  (){ final CloseableIterator<SAMRecord> mergingIterator; final SAMFileHeader header; if (alignedSamFile != null && !alignedSamFile.isEmpty()) { final List<SAMFileHeader> headers=new ArrayList<>(alignedSamFile.size()); final List<SamReader> readers=new ArrayList<>(alignedSamFile.size()); for ( final File f : this.alignedSamFile) { final SamReader r=SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(f); headers.add(r.getFileHeader()); readers.add(r); if (getProgramRecord() == null && r.getFileHeader().getProgramRecords().size() == 1) { setProgramRecord(r.getFileHeader().getProgramRecords().iterator().next()); } } alignedSamDictionary=headers.get(0).getSequenceDictionary(); headers.stream().map(SAMFileHeader::getSequenceDictionary).forEach(alignedSamDictionary::assertSameDictionary); final SamFileHeaderMerger headerMerger=new SamFileHeaderMerger(SortOrder.queryname headers false); mergingIterator=new MergingSamRecordIterator(headerMerger readers true); header=headerMerger.getMergedHeader(); } else { mergingIterator=new SeparateEndAlignmentIterator(this.read1AlignedSamFile this.read2AlignedSamFile referenceFasta); header=((SeparateEndAlignmentIterator)mergingIterator).getHeader(); alignedSamDictionary=header.getSequenceDictionary(); if (getProgramRecord() == null && header.getProgramRecords().size() == 1) { setProgramRecord(header.getProgramRecords().iterator().next()); } } if (!forceSort) { return mergingIterator; } final SortingCollection<SAMRecord> alignmentSorter=SortingCollection.newInstance(SAMRecord.class new BAMRecordCodec(header) new SAMRecordQueryNameComparator() MAX_RECORDS_IN_RAM); int count=0; while (mergingIterator.hasNext()) { alignmentSorter.add(mergingIterator.next()); count++; if (count > 0 && count % 1000000 == 0) { log.info(""Read "" + count + "" records from alignment SAM/BAM.""); } } log.info(""Finished reading "" + count + "" total records from alignment SAM/BAM.""); mergingIterator.close(); return new DelegatingIterator<SAMRecord>(alignmentSorter.iterator()){ @Override public void close(){ super.close(); alignmentSorter.cleanup(); } } ; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamAlignmentMerger.java,hasNext,public boolean  (){ return read1Iterator.hasNext() || read2Iterator.hasNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamAlignmentMerger.java,ignoreAlignment,protected boolean  (final SAMRecord sam){ if (maxGaps == -1) return false; int gaps=0; for ( final CigarElement el : sam.getCigar().getCigarElements()) { if (el.getOperator() == CigarOperator.I || el.getOperator() == CigarOperator.D) { gaps++; } } return gaps > maxGaps; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamAlignmentMerger.java,isContaminant,"protected boolean  (final HitsForInsert hits){ boolean isContaminant=false; if (hits.numHits() > 0) { final int primaryIndex=hits.getIndexOfEarliestPrimary(); if (primaryIndex < 0) throw new IllegalStateException(""No primary alignment was found  despite having nonzero hits.""); final SAMRecord primaryRead1=hits.getFirstOfPair(primaryIndex); final SAMRecord primaryRead2=hits.getSecondOfPair(primaryIndex); if (primaryRead1 != null && primaryRead2 != null) isContaminant=contaminationFilter.filterOut(primaryRead1 primaryRead2); else if (primaryRead1 != null) isContaminant=contaminationFilter.filterOut(primaryRead1); else if (primaryRead2 != null) isContaminant=contaminationFilter.filterOut(primaryRead2); else throw new IllegalStateException(""Neither read1 or read2 exist for chosen primary alignment""); } return isContaminant; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamAlignmentMerger.java,mergeAlignment,"public void  (final File referenceFasta){ try { super.mergeAlignment(referenceFasta); } catch ( final IllegalStateException ise) { log.warn(""Exception merging bam alignment - attempting to sort aligned reads and try again: "" ise.getMessage()); forceSort=true; resetRefSeqFileWalker(); super.mergeAlignment(referenceFasta); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamAlignmentMerger.java,next,public SAMRecord  (){ if (read1Iterator.hasNext()) { if (read2Iterator.hasNext()) { return (read1Iterator.peek().getReadName().compareTo(read2Iterator.peek().getReadName()) <= 0) ? setPairFlags(read1Iterator.next() true) : setPairFlags(read2Iterator.next() false); } else { return setPairFlags(read1Iterator.next() true); } } else { return setPairFlags(read2Iterator.next() false); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamAlignmentMerger.java,remove,"public void  (){ throw new UnsupportedOperationException(""remove() not supported""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamAlignmentMerger.java,setPairFlags,private SAMRecord  (final SAMRecord sam final boolean firstOfPair){ sam.setReadPairedFlag(true); sam.setFirstOfPairFlag(firstOfPair); sam.setSecondOfPairFlag(!firstOfPair); return sam; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastqWithTags.java,assertTagExists,"private String  (final SAMRecord record final String tag){ String value=record.getStringAttribute(tag); if (value == null) { throw new PicardException(""Record: "" + record.getReadName() + "" does have a value for tag: ""+ tag); } return value; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastqWithTags.java,customCommandLineValidation,"@Override protected String[]  (){ List<String> errors=new ArrayList<>(); if (!QUALITY_TAG_GROUP.isEmpty() && SEQUENCE_TAG_GROUP.size() != QUALITY_TAG_GROUP.size()) { errors.add(""QUALITY_TAG_GROUP size must be equal to SEQUENCE_TAG_GROUP or not be specifie"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastqWithTags.java,generateAdditionalWriters,@Override protected Map<SAMReadGroupRecord List<FastqWriter>>  (List<SAMReadGroupRecord> readGroups FastqWriterFactory factory){ return generateTagWriters(readGroups factory); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastqWithTags.java,generateTagWriters,private Map<SAMReadGroupRecord List<FastqWriter>>  (final List<SAMReadGroupRecord> samReadGroupRecords final FastqWriterFactory factory){ final Map<SAMReadGroupRecord List<FastqWriter>> writerMap=new HashMap<>(); if (!OUTPUT_PER_RG) { final List<FastqWriter> tagFastqWriters=makeTagWriters(null factory); writerMap.put(null tagFastqWriters); for ( final SAMReadGroupRecord rg : samReadGroupRecords) { writerMap.put(rg tagFastqWriters); } } else { for ( final SAMReadGroupRecord rg : samReadGroupRecords) { final List<FastqWriter> tagWriters=makeTagWriters(rg factory); writerMap.put(rg tagWriters); } } return writerMap; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastqWithTags.java,handleAdditionalRecords,@Override protected void  (SAMRecord currentRecord Map<SAMReadGroupRecord List<FastqWriter>> tagWriters SAMRecord read1 SAMRecord read2){ final List<FastqWriter> rgTagWriters=tagWriters.get(currentRecord.getReadGroup()); if (currentRecord.getReadPairedFla
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastqWithTags.java,initializeAdditionalWriters,@Override protected void  (){ setupTagSplitValues(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastqWithTags.java,makeTagWriters,"private List<FastqWriter>  (final SAMReadGroupRecord readGroup final FastqWriterFactory factory){ String baseFilename=null; if (readGroup != null) { if (RG_TAG.equalsIgnoreCase(""PU"")) { baseFilename=readGroup.getPlatformUnit() + ""_""; } else if (RG_TAG.equalsIgnoreCase(""ID"")) { baseFilename=readGroup.getReadGroupId() + ""_""; } if (baseFilename == null) { throw new PicardException(""The selected RG_TAG: "" + RG_TAG + "" is not present in the bam header.""); } } else { baseFilename=""""; } List<File> tagFiles=new ArrayList<>(); for ( String tagSplit : SEQUENCE_TAG_GROUP) { String fileName=baseFilename + tagSplit.replace("" "" ""_""); fileName=IOUtil.makeFileNameSafe(fileName); fileName+=COMPRESS_OUTPUTS_PER_TAG_GROUP ? "".fastq.gz"" : "".fastq""; final File result=(OUTPUT_DIR != null) ? new File(OUTPUT_DIR fileName) : new File(FASTQ.getParent() fileName); IOUtil.assertFileIsWritable(result); tagFiles.add(result); } return tagFiles.stream().map(factory::newWriter).collect(Collectors.toList()); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastqWithTags.java,setupTagSplitValues,"private void  (){ SPLIT_SEQUENCE_TAGS=new ArrayList<>(); SPLIT_QUALITY_TAGS=new ArrayList<>(); SPLIT_SEPARATOR_TAGS=new ArrayList<>(); for (int i=0; i < SEQUENCE_TAG_GROUP.size(); i++) { SPLIT_SEQUENCE_TAGS.add(SEQUENCE_TAG_GROUP.get(i).trim().split("" "")); SPLIT_QUALITY_TAGS.add(QUALITY_TAG_GROUP.isEmpty() ? null : QUALITY_TAG_GROUP.get(i).trim().split("" "")); SPLIT_SEPARATOR_TAGS.add(TAG_GROUP_SEPERATOR.isEmpty() ? TAG_SPLIT_DEFAULT_SEP : TAG_GROUP_SEPERATOR.get(i)); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SamToFastqWithTags.java,writeTagRecords,"private void  (final SAMRecord read final Integer mateNumber final List<FastqWriter> tagWriters){ if (SEQUENCE_TAG_GROUP.isEmpty()) { return; } final String seqHeader=mateNumber == null ? read.getReadName() : read.getReadName() + ""/"" + mateNumber; for (int i=0; i < SEQUENCE_TAG_GROUP.size(); i++) { final String tmpTagSep=SPLIT_SEPARATOR_TAGS.get(i); final String[] sequenceTagsToWrite=SPLIT_SEQUENCE_TAGS.get(i); final String newSequence=String.join(tmpTagSep Arrays.stream(sequenceTagsToWrite).map(tag -> assertTagExists(read tag)).collect(Collectors.toList())); final String tmpQualSep=StringUtils.repeat(TAG_SPLIT_QUAL tmpTagSep.length()); final String[] qualityTagsToWrite=SPLIT_QUALITY_TAGS.get(i); final String newQual=QUALITY_TAG_GROUP.isEmpty() ? StringUtils.repeat(TAG_SPLIT_QUAL newSequence.length()) : String.join(tmpQualSep Arrays.stream(qualityTagsToWrite).map(tag -> assertTagExists(read tag)).collect(Collectors.toList())); FastqWriter writer=tagWriters.get(i); writer.write(new FastqRecord(seqHeader newSequence """" newQual)); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SetNmMdAndUqTags.java,doWork,"protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); final SamReader reader=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT); if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.coordinate) { throw new SAMException(""Input must be coordinate-sorted for this program to run. Found: "" + reader.getFileHeader().getSortOrder()); } final SAMFileWriter writer=new SAMFileWriterFactory().makeSAMOrBAMWriter(reader.getFileHeader() true OUTPUT); writer.setProgressLogger(new ProgressLogger(log (int)1e7 ""Wrote"" ""records"")); final ReferenceSequenceFileWalker refSeqWalker=new ReferenceSequenceFileWalker(REFERENCE_SEQUENCE); StreamSupport.stream(reader.spliterator() false).peek(rec -> fixRecord(rec refSeqWalker)).forEach(writer::addAlignment); CloserUtil.close(reader); writer.close(); return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SetNmMdAndUqTags.java,fixRecord,private void  (SAMRecord record ReferenceSequenceFileWalker refSeqWalker){ if (!record.getReadUnmappedFlag()) { if (SET_ONLY_UQ) { AbstractAlignmentMerger.fixUq(record refSeqWalker IS_BISULFITE_SEQUENCE); } else { AbstractAlignmentMerger.fixNmMdAndUq(record refSeqWalker IS_BISULFITE_SEQUENCE); } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SetNmMdAndUqTags.java,main,public static void  (final String[] argv){ new SetNmMdAndUqTags().instanceMainWithExit(argv); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SetNmMdAndUqTags.java,requiresReference,@Override protected boolean  (){ return true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SplitSamByLibrary.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertDirectoryIsWritable(OUTPUT); SamReader reader=SamReaderFactory.makeDefault().open(INPUT); Map<String SAMFileWriter> libraryToWriter=new HashMap<String SAMFileWriter>(); Map<Stri
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SplitSamByLibrary.java,main,public static void  (String[] args){ System.exit(new SplitSamByLibrary().instanceMain(args)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SplitSamByNumberOfReads.java,customCommandLineValidation,"protected String[]  (){ if (TOTAL_READS_IN_INPUT < 0) { return new String[]{String.format(""Cannot set TOTAL_READS_IN_INPUT to a number less than 1  found %d."" TOTAL_READS_IN_INPUT)}; } if (SPLIT_TO_N_FILES <= 1 && SPLIT_TO_N_READS <= 1) { return new String[]{String.format(""One of SPLIT_TO_N_FILES or SPLIT_TO_N_READS must be greater than 0. "" + ""Found SPLIT_TO_N_FILES is %d and SPLIT_TO_N_READS is %d."" SPLIT_TO_N_FILES SPLIT_TO_N_READS)}; } return null; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SplitSamByNumberOfReads.java,doWork,"protected int  (){ IOUtil.assertFileIsReadable(INPUT); if (TOTAL_READS_IN_INPUT == 0 && !Files.isRegularFile(INPUT.toPath())) { log.error(String.format(""INPUT is not a regular file: %s. "" + ""If TOTAL_READS_IN_INPUT is not supplied  INPUT cannot be a stream."" INPUT)); return 1; } IOUtil.assertDirectoryIsWritable(OUTPUT); final SamReaderFactory readerFactory=SamReaderFactory.makeDefault(); final SamReader reader=readerFactory.referenceSequence(REFERENCE_SEQUENCE).open(INPUT); final SAMFileHeader header=reader.getFileHeader(); if (header.getSortOrder() == SAMFileHeader.SortOrder.coordinate) { log.warn(""Splitting a coordinate sorted bam may result in invalid bams "" + ""that do not always contain each read's mate in the same bam.""); } if (!header.getVersion().equals(SAMFileHeader.CURRENT_VERSION)) { log.warn(String.format(""Input file's version is %s  but the current SAM format version is %s. Outputs will be written "" + ""with current version."" header.getVersion() SAMFileHeader.CURRENT_VERSION)); } final ProgressLogger firstPassProgress=new ProgressLogger(log 1000000 ""Counted""); if (TOTAL_READS_IN_INPUT == 0) { final SamReader firstPassReader=readerFactory.referenceSequence(REFERENCE_SEQUENCE).open(INPUT); log.info(""First pass traversal to count number of reads is beginning. If number of reads "" + ""is known  use TOTAL_READS_IN_INPUT to skip first traversal.""); for ( SAMRecord rec : firstPassReader) { firstPassProgress.record(rec); } CloserUtil.close(firstPassReader); log.info(String.format(""First pass traversal to count number of reads ended  found %d total reads."" firstPassProgress.getCount())); } final long totalReads=TOTAL_READS_IN_INPUT == 0 ? firstPassProgress.getCount() : TOTAL_READS_IN_INPUT; final SAMFileWriterFactory writerFactory=new SAMFileWriterFactory(); final DecimalFormat fileNameFormatter=new DecimalFormat(OUT_PREFIX + ""_"" + String.format(""0000"")+ BamFileIoUtils.BAM_FILE_EXTENSION); final int splitToNFiles=SPLIT_TO_N_FILES != 0 ? SPLIT_TO_N_FILES : (int)Math.ceil(totalReads / (double)SPLIT_TO_N_READS); final int readsPerFile=(int)Math.ceil(totalReads / (double)splitToNFiles); int readsWritten=0; int fileIndex=1; SAMFileWriter currentWriter=writerFactory.makeSAMOrBAMWriter(header true new File(OUTPUT fileNameFormatter.format(fileIndex++))); String lastReadName=""""; final ProgressLogger progress=new ProgressLogger(log); for ( SAMRecord currentRecord : reader) { if (readsWritten >= readsPerFile && !lastReadName.equals(currentRecord.getReadName())) { currentWriter.close(); currentWriter=writerFactory.makeSAMOrBAMWriter(header true new File(OUTPUT fileNameFormatter.format(fileIndex++))); readsWritten=0; } currentWriter.addAlignment(currentRecord); lastReadName=currentRecord.getReadName(); readsWritten++; progress.record(currentRecord); } currentWriter.close(); CloserUtil.close(reader); if (progress.getCount() != totalReads) { log.warn(String.format(""The totalReads (%d) provided does not match the reads found in the "" + ""input file (%d). Files may not be split evenly or number of files may not "" + ""match what was requested. There were %d files generated each with around %d ""+ ""reads except the last file which contained %d reads."" totalReads progress.getCount() fileIndex - 1 readsPerFile readsWritten)); } return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SortSam.java,SortOrder, (String description){ this.description=description; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SortSam.java,doWork,"protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); final SamReader reader=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT); ; reader.getFileHeader().setSortOrder(SORT_ORDER.getSortOrder()); final SAMFileWriter writer=new SAMFileWriterFactory().makeSAMOrBAMWriter(reader.getFileHeader() false OUTPUT); writer.setProgressLogger(new ProgressLogger(log (int)1e7 ""Wrote"" ""records from a sorting collection"")); final ProgressLogger progress=new ProgressLogger(log (int)1e7 ""Read""); for ( final SAMRecord rec : reader) { writer.addAlignment(rec); progress.record(rec); } log.info(""Finished reading inputs  merging and writing to output now.""); CloserUtil.close(reader); writer.close(); return 0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SortSam.java,getHelpDoc,@Override public String  (){ return description; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\SortSam.java,getSortOrder,public SAMFileHeader.SortOrder  (){ return SAMFileHeader.SortOrder.valueOf(this.name()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\util\PhysicalLocationInt.java,getLibraryId,"public short  (){ throw new PicardException(""Not Implemented""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\util\PhysicalLocationInt.java,getReadGroup,"public short  (){ throw new PicardException(""Not Implemented""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\util\PhysicalLocationInt.java,getTile,public short  (){ return tile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\util\PhysicalLocationInt.java,getX,public int  (){ return x; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\util\PhysicalLocationInt.java,getY,public int  (){ return y; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\util\PhysicalLocationInt.java,setLibraryId,"public void  (final short libraryId){ throw new PicardException(""Not Implemented""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\util\PhysicalLocationInt.java,setReadGroup,"public void  (final short readGroup){ throw new PicardException(""Not Implemented""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\util\PhysicalLocationInt.java,setTile,public void  (final short tile){ this.tile=tile; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\util\PhysicalLocationInt.java,setX,public void  (final int x){ this.x=x; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\util\PhysicalLocationInt.java,setY,public void  (final int y){ this.y=y; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\util\PhysicalLocationShort.java,setX,@Override public void  (final int x){ super.setX((short)x); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\util\PhysicalLocationShort.java,setY,@Override public void  (final int y){ super.setY((short)y); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ValidateSamFile.java,ReturnTypes, (final int value){ this.value=value; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ValidateSamFile.java,customCommandLineValidation,"@Override protected String[]  (){ if ((!VALIDATE_INDEX && INDEX_VALIDATION_STRINGENCY != IndexValidationStringency.NONE) || (VALIDATE_INDEX && INDEX_VALIDATION_STRINGENCY == IndexValidationStringency.NONE)) { return new String[]{""VALIDATE_INDEX and INDEX_"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ValidateSamFile.java,doWork,@Override protected int  (){ try { IOUtil.assertFileIsReadable(INPUT); ReferenceSequenceFile reference=null; if (REFERENCE_SEQUENCE != null) { IOUtil.assertFileIsReadable(REFERENCE_SEQUENCE); reference=ReferenceSequenceFileFactory.getReferenceSequenceFile
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ValidateSamFile.java,main,public static void  (final String[] args){ System.exit(new ValidateSamFile().instanceMain(args)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ValidateSamFile.java,value,int  (){ return value; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\util\ReadNameParser.java,ReadNameParser,public  (final String readNameRegex final Log log){ this.readNameRegex=readNameRegex; this.log=log; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\util\ReadNameParser.java,addLocationInformation,"public boolean  (final String readName final PhysicalLocation loc){ try { if (this.readNameRegex == ReadNameParser.DEFAULT_READ_NAME_REGEX) { final int fields=getLastThreeFields(readName ':' tmpLocationFields); if (!(fields == 5 || fields == 7)) { if (null != log && !this.warnedAboutRegexNotMatching) { this.log.warn(String.format(""Default READ_NAME_REGEX '%s' did not match read name '%s'. "" + ""You may need to specify a READ_NAME_REGEX in order to correctly identify optical duplicates. "" + ""Note that this message will not be emitted again even if other read names do not match the regex."" this.readNameRegex readName)); this.warnedAboutRegexNotMatching=true; } return false; } loc.setTile((short)tmpLocationFields[0]); loc.setX(tmpLocationFields[1]); loc.setY(tmpLocationFields[2]); return true; } else if (this.readNameRegex == null) { return false; } else { if (this.readNamePattern == null) this.readNamePattern=Pattern.compile(this.readNameRegex); final Matcher m=this.readNamePattern.matcher(readName); if (m.matches()) { loc.setTile((short)Integer.parseInt(m.group(1))); loc.setX(Integer.parseInt(m.group(2))); loc.setY(Integer.parseInt(m.group(3))); return true; } else { if (null != log && !this.warnedAboutRegexNotMatching) { this.log.warn(String.format(""READ_NAME_REGEX '%s' did not match read name '%s'. Your regex may not be correct. "" + ""Note that this message will not be emitted again even if other read names do not match the regex."" this.readNameRegex readName)); warnedAboutRegexNotMatching=true; } return false; } } } catch ( NumberFormatException nfe) { if (log != null && !this.warnedAboutRegexNotMatching) { this.log.warn(""A field field parsed out of a read name was expected to contain an integer and did not. "" ""Read name: "" readName "". Cause: "" nfe.getMessage()); warnedAboutRegexNotMatching=true; } return false; } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\util\ReadNameParser.java,getLastThreeFields,public static int  (final String readName final char delim final int[] tokens) throws NumberFormatException { int tokensIdx=2; int numFields=0; int i  endIdx; endIdx=readName.length(); for (i=readName.length() - 1; 0 <= i && 0 <= tokensIdx; i--) { if (readName.charAt(i) == delim || 0 == i) { numFields++; tokens[tokensIdx]=rapidParseInt(readName.substring((0 == i) ? 0 : (i + 1) endIdx)); tokensIdx--; endIdx=i; } } while (0 <= i) { if (readName.charAt(i) == delim || 0 == i) numFields++; i--; } if (numFields < 3) { tokens[0]=tokens[1]=tokens[2]=-1; return -1; } else { return numFields; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\util\ReadNameParser.java,rapidParseInt,"public static int  (final String input) throws NumberFormatException { final int len=input.length(); int val=0; int i=0; boolean isNegative=false; if (0 < len && '-' == input.charAt(0)) { i=1; isNegative=true; } boolean hasDigits=false; for (; i < len; ++i) { final char ch=input.charAt(i); if (Character.isDigit(ch)) { val=(val * 10) + (ch - 48); hasDigits=true; } else { break; } } if (!hasDigits) throw new NumberFormatException(""String '"" + input + ""' did not start with a parsable number.""); if (isNegative) val=-val; return val; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ViewSam.java,customCommandLineValidation,"@Override protected String[]  (){ if (HEADER_ONLY && RECORDS_ONLY) { return new String[]{""Cannot specify both HEADER_ONLY=true and RECORDS_ONLY=true.""}; } return super.customCommandLineValidation(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ViewSam.java,doWork,@Override protected int  (){ return writeSamText(System.out); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ViewSam.java,main,public static void  (final String[] args){ new ViewSam().instanceMain(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\sam\ViewSam.java,writeSamText,"int  (PrintStream printStream){ try { final CloseableIterator<SAMRecord> samRecordsIterator; final SamReader samReader=SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT)); if (HEADER_ONLY || INTERVAL_LIST == null) { samRecordsIterator=samReader.iterator(); } else { IOUtil.assertFileIsReadable(INTERVAL_LIST); final List<Interval> intervals=IntervalList.fromFile(INTERVAL_LIST).uniqued().getIntervals(); samRecordsIterator=new SamRecordIntervalIteratorFactory().makeSamRecordIntervalIterator(samReader intervals samReader.hasIndex()); } final AsciiWriter writer=new AsciiWriter(printStream); final SAMFileHeader header=samReader.getFileHeader(); if (!RECORDS_ONLY) { if (header.getTextHeader() != null) { writer.write(header.getTextHeader()); } else { new SAMTextHeaderCodec().encode(writer header true); } } if (!HEADER_ONLY) { while (samRecordsIterator.hasNext()) { final SAMRecord rec=samRecordsIterator.next(); if (printStream.checkError()) { return 1; } if (this.ALIGNMENT_STATUS == AlignmentStatus.Aligned && rec.getReadUnmappedFlag()) continue; if (this.ALIGNMENT_STATUS == AlignmentStatus.Unaligned && !rec.getReadUnmappedFlag()) continue; if (this.PF_STATUS == PfStatus.PF && rec.getReadFailsVendorQualityCheckFlag()) continue; if (this.PF_STATUS == PfStatus.NonPF && !rec.getReadFailsVendorQualityCheckFlag()) continue; writer.write(rec.getSAMString()); } } writer.flush(); if (printStream.checkError()) { return 1; } CloserUtil.close(writer); CloserUtil.close(samRecordsIterator); return 0; } catch ( IOException e) { throw new PicardException(""Exception writing SAM text"" e); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\Test.java,main,public static void  (String[] args){ new Test().run(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\Test.java,run,"public void  (){ final int ITERATIONS=1000000; final String[] fields=new String[10000]; final StopWatch watch=new StopWatch(); watch.start(); for (int i=0; i < ITERATIONS; ++i) { if (StringUtil.split(TEXT fields '\t') > 100) { System.out.println(""Mama Mia that's a lot of tokens!!""); } } watch.stop(); System.out.println(""StringUtil.split() took "" + watch.getElapsedTime()); watch.reset(); watch.start(); for (int i=0; i < ITERATIONS; ++i) { if (split(TEXT fields ""\t"") > 100) { System.out.println(""Mama Mia that's a lot of tokens!!""); } } watch.stop(); System.out.println(""StringTokenizer took "" + watch.getElapsedTime()); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\Test.java,split,public int  (final String s final String[] tokens final String token){ final StringTokenizer tokenizer=new StringTokenizer(s token false); int i=0; while (tokenizer.hasMoreTokens()) { tokens[i++]=tokenizer.nextToken(); } return i; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,AdapterMarker,"public  (final int adapterLength final AdapterPair... originalAdapters){ final ArrayList<TruncatedAdapterPair> truncatedAdapters=new ArrayList<TruncatedAdapterPair>(); for ( final AdapterPair adapter : originalAdapters) { final TruncatedAdapterPair truncatedAdapter=makeTruncatedAdapterPair(adapter adapterLength); final int matchingIndex=truncatedAdapters.indexOf(truncatedAdapter); if (matchingIndex == -1) { truncatedAdapters.add(truncatedAdapter); } else { final TruncatedAdapterPair matchingAdapter=truncatedAdapters.get(matchingIndex); matchingAdapter.setName(matchingAdapter.getName() + ""|"" + adapter.getName()); } } adapters.set(truncatedAdapters.toArray(new AdapterPair[truncatedAdapters.size()])); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,TruncatedAdapterPair,private  (final String name final String threePrimeReadOrder final String fivePrimeReadOrder){ this.name=name; this.threePrime=threePrimeReadOrder; this.threePrimeBytes=StringUtil.stringToBytes(threePrimeReadOrder); this.fivePrimeReadOrder=fivePrimeReadOrder; this.fivePrimeReadOrderBytes=StringUtil.stringToBytes(fivePrimeReadOrder); this.fivePrime=SequenceUtil.reverseComplement(fivePrimeReadOrder); this.fivePrimeBytes=StringUtil.stringToBytes(this.fivePrime); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,adapterTrimIlluminaPairedReads,public AdapterPair  (final SAMRecord read1 final SAMRecord read2 final int minMatchBases final double maxErrorRate){ final AdapterPair ret=ClippingUtility.adapterTrimIlluminaPairedReads(read1 read2 minMatchBases maxErrorRate adapters.get()); tallyAndFixAdapters(ret read1 read2); return ret; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,adapterTrimIlluminaSingleRead,public AdapterPair  (final SAMRecord read final int minMatchBases final double maxErrorRate){ final AdapterPair ret=ClippingUtility.adapterTrimIlluminaSingleRead(read minMatchBases maxErrorRate adapters.get()); tallyAndFixAdapters(ret read); return ret; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,compare,@Override public int  (final Integer integer final Integer integer2){ return integer2.compareTo(integer); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,equals,@Override public boolean  (final Object o){ if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; final TruncatedAdapterPair that=(TruncatedAdapterPair)o; if (!fivePrime.equals(that.fivePrime)) return false; if (!threePrim
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,fixAlreadySeenReads,private void  (){ Arrays.stream(adapters.get()).forEach(adapter -> preAdapterPrunedRecords.remove(adapter)); preAdapterPrunedRecords.values().forEach(readList -> readList.parallelStream().forEach(read -> { Stream<SAMRecord.SAMTagAndValue> filterAttributes=read.getAttributes().stream().filter(tag -> !tag.tag.equals(ReservedTagConstants.XT)); read.clearAttributes(); filterAttributes.forEach(tag -> read.setAttribute(tag.tag tag.value)); } )); preAdapterPrunedRecords.clear(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,get3PrimeAdapter,public String  (){ return threePrime; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,get3PrimeAdapterBytes,public byte[]  (){ return threePrimeBytes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,get3PrimeAdapterBytesInReadOrder,public byte[]  (){ return threePrimeBytes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,get3PrimeAdapterInReadOrder,public String  (){ return threePrime; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,get5PrimeAdapter,public String  (){ return fivePrime; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,get5PrimeAdapterBytes,public byte[]  (){ return fivePrimeBytes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,get5PrimeAdapterBytesInReadOrder,public byte[]  (){ return fivePrimeReadOrderBytes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,get5PrimeAdapterInReadOrder,public String  (){ return fivePrimeReadOrder; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,getAdapters,AdapterPair[]  (){ return adapters.get(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,getMaxPairErrorRate,public double  (){ return maxPairErrorRate; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,getMaxSingleEndErrorRate,public double  (){ return maxSingleEndErrorRate; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,getMinPairMatchBases,public int  (){ return minPairMatchBases; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,getMinSingleEndMatchBases,public int  (){ return minSingleEndMatchBases; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,getName,public String  (){ return this.name; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,getNumAdaptersToKeep,public int  (){ return numAdaptersToKeep; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,getThresholdForSelectingAdaptersToKeep,public int  (){ return thresholdForSelectingAdaptersToKeep; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,hashCode,@Override public int  (){ int result=fivePrime.hashCode(); result=31 * result + threePrime.hashCode(); return result; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,makeTruncatedAdapterPair,"private TruncatedAdapterPair  (final AdapterPair adapterPair final int adapterLength){ return new TruncatedAdapterPair(""truncated "" + adapterPair.getName() substringAndRemoveTrailingNs(adapterPair.get3PrimeAdapterInReadOrder() adapterLength) substringAndRemoveTrailingNs(adapterPair.get5PrimeAdapterInReadOrder() adapterLength)); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,setMaxPairErrorRate,public synchronized AdapterMarker  (final double maxPairErrorRate){ this.maxPairErrorRate=maxPairErrorRate; return this; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,setMaxSingleEndErrorRate,public synchronized AdapterMarker  (final double maxSingleEndErrorRate){ this.maxSingleEndErrorRate=maxSingleEndErrorRate; return this; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,setMinPairMatchBases,public synchronized AdapterMarker  (final int minPairMatchBases){ this.minPairMatchBases=minPairMatchBases; return this; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,setMinSingleEndMatchBases,public synchronized AdapterMarker  (final int minSingleEndMatchBases){ this.minSingleEndMatchBases=minSingleEndMatchBases; return this; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,setName,public void  (final String name){ this.name=name; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,setNumAdaptersToKeep,"public synchronized AdapterMarker  (final int numAdaptersToKeep){ if (numAdaptersToKeep <= 0) { throw new IllegalArgumentException(String.format(""numAdaptersToKeep should be positive: %d"" numAdaptersToKeep)); } this.numAdaptersToKeep=numAdaptersToKeep; return this; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,setThresholdForSelectingAdaptersToKeep,public synchronized AdapterMarker  (final int thresholdForSelectingAdaptersToKeep){ this.thresholdForSelectingAdaptersToKeep=thresholdForSelectingAdaptersToKeep; return this; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,substringAndRemoveTrailingNs,private String  (final String s int length){ length=Math.min(length s.length()); final byte[] bytes=StringUtil.stringToBytes(s); while (length > 0 && SequenceUtil.isNoCall(bytes[length - 1])) { length--; } return s.substring(0 length); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,tallyAndFixAdapters,private void  (AdapterPair ret SAMRecord... reads){ if (ret != null && !thresholdReached) { if (!preAdapterPrunedRecords.containsKey(ret)) { preAdapterPrunedRecords.put(ret new ArrayList<>()); } Arrays.stream(reads).forEach(read -> preAdapterPrunedRecords.get(ret).add(read)); tallyFoundAdapter(ret); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,tallyFoundAdapter,private void  (final AdapterPair foundAdapter){ if (thresholdForSelectingAdaptersToKeep < 1) return; synchronized (this) { seenCounts.put(foundAdapter seenCounts.get(foundAdapter) + 1); numAdaptersSeen+=1; if (numAdaptersSeen >= thresholdForSelectingAdaptersToKeep) { final TreeMap<Integer AdapterPair> sortedAdapters=new TreeMap<Integer AdapterPair>(new Comparator<Integer>(){ @Override public int compare( final Integer integer  final Integer integer2){ return integer2.compareTo(integer); } } ); for ( final Map.Entry<AdapterPair Integer> entry : seenCounts.entrySet()) { sortedAdapters.put(entry.getValue() entry.getKey()); } final ArrayList<AdapterPair> bestAdapters=new ArrayList<AdapterPair>(numAdaptersToKeep); int countOfLastAdapter=Integer.MAX_VALUE; for ( final Map.Entry<Integer AdapterPair> entry : sortedAdapters.entrySet()) { if (bestAdapters.size() >= numAdaptersToKeep) { if (entry.getKey() == countOfLastAdapter) { bestAdapters.add(entry.getValue()); } else { break; } } else { countOfLastAdapter=entry.getKey(); bestAdapters.add(entry.getValue()); } } thresholdReached=true; adapters.set(bestAdapters.toArray(new AdapterPair[bestAdapters.size()])); fixAlreadySeenReads(); } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AdapterMarker.java,toString,"@Override public String  (){ return ""TruncatedAdapterPair{"" + ""fivePrimeReadOrder='"" + fivePrimeReadOrder + '\''+ ""  threePrime='""+ threePrime+ '\''+ ""  name='""+ name+ '\''+ '}'; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AbstractInputParser.java,advance,@Override protected String[]  (){ byte[] nextLine; do { nextLine=readNextLine(); } while (nextLine != null && ((this.skipBlankLines && isBlank(nextLine)) || isComment(nextLine))); return nextLine == null ? null : parseLine(nextLine); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AbstractInputParser.java,calculateWordCount,protected void  (final byte[] line){ int words=0; boolean delimiter=true; for ( final byte b : line) { if (isDelimiter(b)) { if (delimiter && !isTreatGroupedDelimitersAsOne()) words++; delimiter=true; } else { if (delimiter) words++; delimiter=false; } } if (delimiter && !isTreatGroupedDelimitersAsOne()) { words+=1; } setWordCount(words); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AsyncIterator.java,AsyncIterator,public  (final CloseableIterator<T> underlyingIterator final int queueSize final String threadNamePrefix){ this.underlyingIterator=underlyingIterator; this.queue=new ArrayBlockingQueue<T>(queueSize); this.readerRunnable=new ReaderRunnable(); this.reader=new Thread(readerRunnable threadNamePrefix + threadsCreated++); this.reader.setDaemon(true); this.reader.start(); getNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AsyncIterator.java,assertOpen,"private void  (){ if (this.isClosed.get()) { throw new RuntimeException(""AsyncIterator already closed.""); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AsyncIterator.java,checkAndRethrow,private void  (){ final Throwable t=this.ex.get(); if (t != null) { if (t instanceof Error) throw (Error)t; if (t instanceof RuntimeException) throw (RuntimeException)t; else throw new RuntimeException(t); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AsyncIterator.java,close,"public void  (){ checkAndRethrow(); assertOpen(); this.isClosed.set(true); try { this.reader.join(); } catch ( InterruptedException ie) { throw new RuntimeException(""Interrupted waiting on reader thread."" ie); } underlyingIterator.close(); checkAndRethrow(); this.queue.clear(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AsyncIterator.java,getNext,"private void  (){ assertOpen(); checkAndRethrow(); try { theNext=null; while (!this.queue.isEmpty() || !this.readerRunnable.isDone()) { theNext=this.queue.poll(5 TimeUnit.SECONDS); checkAndRethrow(); if (theNext != null) break; } } catch ( InterruptedException ie) { throw new RuntimeException(""Interrupted queueing item for writing."" ie); } checkAndRethrow(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AsyncIterator.java,hasNext,public boolean  (){ assertOpen(); return theNext != null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AsyncIterator.java,isDone,public boolean  (){ return readerDone.get(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AsyncIterator.java,next,public T  (){ assertOpen(); if (!hasNext()) throw new NoSuchElementException(); final T ret=theNext; getNext(); return ret; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AsyncIterator.java,remove,public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AsyncIterator.java,run,public void  (){ try { boolean isEof=false; while (!isClosed.get() && !isEof) { try { if (!underlyingIterator.hasNext()) { isEof=true; } else { final T item=underlyingIterator.next(); while (!isClosed.get() && !queue.offer(item 2 TimeUnit.SECONDS)) { } } } catch ( InterruptedException ie) { } } } catch ( Throwable t) { ex.compareAndSet(null t); } finally { readerDone.set(true); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AlleleSubsettingUtils.java,nonEmpty,"private static <I T extends Collection<I>>T  (T collection String message){ nonNull(collection ""The collection is null: "" + message); if (collection.isEmpty()) { throw new IllegalArgumentException(""The collection is empty: "" + message); } else { return collection; } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AlleleSubsettingUtils.java,nonNull,private static <T>T  (final T object String message){ if (object == null) { throw new IllegalArgumentException(message); } return object; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AlleleSubsettingUtils.java,subsetAlleles,"public static GenotypesContext  (final GenotypesContext originalGs final List<Allele> originalAlleles final List<Allele> allelesToKeep){ nonNull(originalGs ""original GenotypesContext must not be null.""); nonNull(allelesToKeep ""allelesToKeep is null.""); nonEmpty(allelesToKeep ""must keep at least one allele.""); validateTrue(allelesToKeep.get(0).isReference() ""First allele must be the reference allele.""); validateTrue(allelesToKeep.stream().allMatch(originalAlleles::contains) ""OriginalAlleles must contain allelesToKeep.""); int indexOfLast=-1; for ( Allele a : allelesToKeep) { validateTrue(indexOfLast < originalAlleles.indexOf(a) ""alleles to keep must maintain the order of the original alleles.""); indexOfLast=originalAlleles.indexOf(a); } final int[] allelesIndex=allelesToKeep.stream().mapToInt(originalAlleles::indexOf).toArray(); final GenotypesContext newGTs=GenotypesContext.create(originalGs.size()); int[] subsettedLikelihoodIndices=subsettedPLIndices(originalAlleles allelesToKeep); for ( final Genotype g : originalGs) { validateTrue(g.getPloidy() == 2 ""only implemented for ploidy 2 for now.""); final int expectedNumLikelihoods=GenotypeLikelihoods.numLikelihoods(allelesToKeep.size() 2); int[] newPLs=null; double newLog10GQ=-1; if (g.hasLikelihoods()) { int[] originalPLs=g.getPL(); if (originalPLs.length != expectedNumLikelihoods) { newPLs=Arrays.stream(subsettedLikelihoodIndices).map(idx -> originalPLs[idx]).toArray(); final int minLikelihood=MathUtil.min(newPLs); for (int i=0; i < expectedNumLikelihoods; i++) { newPLs[i]=newPLs[i] - minLikelihood; } final int indexOfMostLikely=MathUtil.indexOfMin(newPLs); newLog10GQ=GenotypeLikelihoods.getGQLog10FromLikelihoods(indexOfMostLikely GenotypeLikelihoods.fromPLs(newPLs).getAsVector()); } else { newPLs=null; } } final GenotypeBuilder gb; if (newPLs == null) { gb=new GenotypeBuilder(g).noPL().noGQ().alleles(DIPLOID_NO_CALL); } else { gb=new GenotypeBuilder(g).PL(newPLs).log10PError(newLog10GQ); final List<Integer> originalDiploidAlleles=GenotypeLikelihoods.getAlleles(MathUtil.indexOfMin(newPLs) 2); gb.alleles(originalDiploidAlleles.stream().map(allelesToKeep::get).collect(Collectors.toList())); } if (g.hasAD()) { final int[] oldAD=g.getAD(); final int[] newAD=IntStream.range(0 allelesToKeep.size()).map(n -> oldAD[allelesIndex[n]]).toArray(); gb.AD(newAD); } newGTs.add(gb.make()); } return newGTs; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AlleleSubsettingUtils.java,subsetVCToMatchSnp,public static VariantContext  (final VariantContext ctx final Snp snp){ if (ctx.isFiltered()) return null; if (ctx.getReference().length() != 1) return null; final Optional<Byte> referenceAlleleMaybe=Stream.of(snp.getAllele1() snp.getAllele2()).filter(b -> StringUtil.toUpperCase(b) == StringUtil.toUpperCase(ctx.getReference().getBases()[0])).findAny(); if (!referenceAlleleMaybe.isPresent()) return null; final byte refAllele=referenceAlleleMaybe.get(); final byte otherAllele=snp.getAllele1() == refAllele ? snp.getAllele2() : snp.getAllele1(); final Optional<Allele> altAlleleMaybe=ctx.getAlternateAlleles().stream().filter(a -> a.length() == 1 && StringUtil.toUpperCase(a.getBases()[0]) == StringUtil.toUpperCase(otherAllele)).findAny(); if (altAlleleMaybe.isPresent()) { if (ctx.isBiallelic()) return ctx; return AlleleSubsettingUtils.subsetAlleles(ctx Arrays.asList(ctx.getReference() altAlleleMaybe.get())); } final Optional<Allele> nonRefAlleleMaybe=ctx.getAlternateAlleles().stream().filter(a -> a.equals(NON_REF_ALLELE)).findAny(); if (nonRefAlleleMaybe.isPresent()) { final VariantContext vcSubsetted=ctx.isBiallelic() ? ctx : AlleleSubsettingUtils.subsetAlleles(ctx Arrays.asList(ctx.getReference() nonRefAlleleMaybe.get())); return AlleleSubsettingUtils.swapAlleles(vcSubsetted NON_REF_ALLELE Allele.create(otherAllele)); } return null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AlleleSubsettingUtils.java,subsettedPLIndices,public static int[]  (final List<Allele> originalAlleles final List<Allele> newAlleles){ final int[] result=new int[GenotypeLikelihoods.numLikelihoods(newAlleles.size() 2)]; for (int oldPLIndex=0; oldPLIndex < GenotypeLikelihoods.numLikelihoods(originalAlleles.size() 2); oldPLIndex++) { final GenotypeLikelihoods.GenotypeLikelihoodsAllelePair allelePairFromPLIndex=GenotypeLikelihoods.getAllelePair(oldPLIndex); final Allele allele1=originalAlleles.get(allelePairFromPLIndex.alleleIndex1); final Allele allele2=originalAlleles.get(allelePairFromPLIndex.alleleIndex2); final boolean containsOnlyNewAlleles=newAlleles.contains(allele1) && newAlleles.contains(allele2); if (containsOnlyNewAlleles) { final int newPLIndex=GenotypeLikelihoods.calculatePLindex(newAlleles.indexOf(allele1) newAlleles.indexOf(allele2)); result[newPLIndex]=oldPLIndex; } } return result; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AlleleSubsettingUtils.java,swapAlleles,"public static VariantContext  (final VariantContext originalVc final Allele oldAllele final Allele newAllele) throws IllegalArgumentException { if (!originalVc.getAlleles().contains(oldAllele)) throw new IllegalArgumentException(""Couldn't find allele "" + oldAllele + "" in VariantContext ""+ originalVc); final List<Allele> alleles=new ArrayList<>(originalVc.getAlleles()); alleles.set(alleles.indexOf(oldAllele) newAllele); VariantContextBuilder vcBuilder=new VariantContextBuilder(originalVc).alleles(alleles); GenotypesContext newGTs=GenotypesContext.create(originalVc.getGenotypes().size()); for ( final Genotype g : originalVc.getGenotypes()) { if (!g.getAlleles().contains(oldAllele)) { newGTs.add(g); } else { final GenotypeBuilder gb=new GenotypeBuilder(g); gb.alleles(g.getAlleles().stream().map(a -> a.equals(oldAllele) ? newAllele : a).collect(Collectors.toList())); newGTs.add(gb.make()); } } vcBuilder.genotypes(newGTs); return vcBuilder.make(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\AlleleSubsettingUtils.java,validateTrue,private static void  (final boolean condition final String msg){ if (!condition) { throw new IllegalArgumentException(msg); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\BaitDesigner.java,Bait,public  (final String sequence final int start final int end final boolean negative final String name){ super(sequence start end negative name); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\BaitDesigner.java,addBases,public void  (final ReferenceSequence reference final boolean useStrandInfo){ final byte[] tmp=new byte[length()]; System.arraycopy(reference.getBases() getStart() - 1 tmp 0 length()); if (useStrandInfo && isNegativeStrand()) { SequenceUtil.reverseComplement(tmp); } setBases(tmp); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\BaitDesigner.java,calculateStatistics,void  (final IntervalList targets final IntervalList baits){ this.TARGET_TERRITORY=(int)targets.getUniqueBaseCount(); this.TARGET_COUNT=targets.size(); this.BAIT_TERRITORY=(int)baits.getUniqueBaseCount(); this.BAIT_COUNT=baits.size(); this.DESIGN_EFFICIENCY=this.TARGET_TERRITORY / (double)this.BAIT_TERRITORY; final IntervalList tmp=new IntervalList(targets.getHeader()); final OverlapDetector<Interval> detector=new OverlapDetector<Interval>(0 0); detector.addAll(baits.getIntervals() baits.getIntervals()); for ( final Interval target : targets) { final Collection<Interval> overlaps=detector.getOverlaps(target); if (overlaps.isEmpty()) { this.ZERO_BAIT_TARGETS++; } else { for ( final Interval i : overlaps) tmp.add(target.intersect(i)); } } tmp.uniqued(); this.BAIT_TARGET_TERRITORY_INTERSECTION=(int)tmp.getBaseCount(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\BaitDesigner.java,customCommandLineValidation,"@Override protected String[]  (){ final List<String> errors=new ArrayList<String>(); final Pattern p=Pattern.compile(""^[ACGTacgt]*$""); if (LEFT_PRIMER != null && !p.matcher(LEFT_PRIMER).matches()) { errors.add(""Left primer "" + LEFT_PRIMER + "" is not a val"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\BasicInputParser.java,BasicInputParser,public  (final boolean treatGroupedDelimitersAsOne final int wordCount final File... files){ this(treatGroupedDelimitersAsOne files); setWordCount(wordCount); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\BasicInputParser.java,advanceFile,protected void  (){ currentFileName=!fileNames.isEmpty() ? fileNames.remove(0) : null; nextLineNumber=0; nextLine=null; reader=new BufferedLineReader(inputs.remove(0)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\BasicInputParser.java,close,public void  (){ if (reader != null) { reader.close(); } for ( final InputStream stream : inputs) { CloserUtil.close(stream); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\BasicInputParser.java,filesToInputStreams,private static InputStream[]  (final File[] files){ final InputStream[] result=new InputStream[files.length]; for (int i=0; i < files.length; i++) { result[i]=IOUtil.openFileForReading(files[i]); } return result; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\BasicInputParser.java,getCurrentLine,public String  (){ return this.currentLine; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\BasicInputParser.java,getCurrentLineNumber,public int  (){ return currentLineNumber; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\BasicInputParser.java,getFileName,"public String  (){ return this.currentFileName != null ? this.currentFileName : ""(file name unavailable)""; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\BasicInputParser.java,readNextLine,"protected byte[]  (){ try { final String line=reader.readLine(); if (nextLine != null && !isComment(nextLine.getBytes())) { currentLineNumber=nextLineNumber; currentLine=nextLine; } if (line != null) { nextLineNumber++; nextLine=line; return line.getBytes(); } if (!inputs.isEmpty()) { advanceFile(); return readNextLine(); } return null; } catch ( RuntimeIOException ioe) { throw new PicardException(""Error reading from file "" + currentFileName ioe); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\CsvInputParser.java,CsvInputParser,public  (final boolean treatGroupedDelimitersAsOne final File... file){ super(treatGroupedDelimitersAsOne file); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\CsvInputParser.java,isDelimiter,@Override protected boolean  (final byte b){ return b == ' '; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\ClippingUtility.java,adapterTrimIlluminaPairedReads,public static AdapterPair  (final SAMRecord read1 final SAMRecord read2 final int minMatchBases final double maxErrorRate final AdapterPair... adapters){ AdapterPair matched=null; for ( final AdapterPair adapterPair : adapters) { final int index1=findIndexOfClipSequence(getReadBases(read1) adapterPair.get3PrimeAdapterBytes() minMatchBases maxErrorRate); final int index2=findIndexOfClipSequence(getReadBases(read2) adapterPair.get5PrimeAdapterBytesInReadOrder() minMatchBases maxErrorRate); if (index1 == index2) { if (index1 != NO_MATCH) { read1.setAttribute(ReservedTagConstants.XT index1 + 1); read2.setAttribute(ReservedTagConstants.XT index2 + 1); return adapterPair; } else { } } else if (index1 == NO_MATCH || index2 == NO_MATCH) { if (attemptOneSidedMatch(read1 read2 index1 index2 2 * minMatchBases)) { matched=adapterPair; } } else { } } return matched; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\ClippingUtility.java,adapterTrimIlluminaSingleRead,public static AdapterPair  (final SAMRecord read final int minMatchBases final double maxErrorRate final AdapterPair... adapters){ for ( AdapterPair adapter : adapters) { final int indexOfAdapterSequence=findIndexOfClipSequence(getReadBases(read) adapter.get3PrimeAdapterBytes() minMatchBases maxErrorRate); if (indexOfAdapterSequence != NO_MATCH) { read.setAttribute(ReservedTagConstants.XT indexOfAdapterSequence + 1); return adapter; } } return null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\ClippingUtility.java,attemptOneSidedMatch,private static boolean  (final SAMRecord read1 final SAMRecord read2 final int index1 final int index2 final int stricterMinMatchBases){ final int matchedIndex=index1 == NO_MATCH ? index2 : index1; final SAMRecord matchedRead=index1 == NO_MATCH ? read2 : read1; if (matchedRead.getReadLength() - matchedIndex >= stricterMinMatchBases) { if (read1.getReadBases().length > matchedIndex) { read1.setAttribute(ReservedTagConstants.XT matchedIndex + 1); } if (read2.getReadBases().length > matchedIndex) { read2.setAttribute(ReservedTagConstants.XT matchedIndex + 1); } return true; } return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\ClippingUtility.java,findIndexOfClipSequence,public static int  (final byte[] read final byte[] adapterSequence final int minMatch final double maxErrorRate){ if (read == null || read.length < minMatch) return NO_MATCH; final int minClipPosition=0; READ_LOOP: for (int start=read.length - minMatch; start > minClipPosition - 1; --start) { final int length=Math.min(read.length - start adapterSequence.length); final int mismatchesAllowed=(int)(length * maxErrorRate); int mismatches=0; for (int i=0; i < length; ++i) { if (!SequenceUtil.isNoCall(adapterSequence[i]) && !SequenceUtil.basesEqual(adapterSequence[i] read[start + i]) && ++mismatches > mismatchesAllowed) { continue READ_LOOP; } } return start; } return NO_MATCH; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\ClippingUtility.java,getReadBases,private static byte[]  (final SAMRecord read){ if (!read.getReadNegativeStrandFlag()) { return read.getReadBases(); } else { final byte[] reverseComplementedBases=new byte[read.getReadBases().length]; System.arraycopy(read.getReadBases() 0 reverseComplementedBases 0 reverseComplementedBases.length); SequenceUtil.reverseComplement(reverseComplementedBases); return reverseComplementedBases; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\CircularByteBuffer.java,CircularByteBuffer,public  (final int size){ this.bytes=new byte[size]; this.capacity=this.bytes.length; this.bytesAvailableToWrite=this.capacity; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\CircularByteBuffer.java,close,synchronized public void  (){ this.closed=true; notify(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\CircularByteBuffer.java,getBytesAvailableToRead,synchronized public int  (){ return this.bytesAvailableToRead; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\CircularByteBuffer.java,getCapacity,public int  (){ return this.capacity; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\CircularByteBuffer.java,isClosed,synchronized public boolean  (){ return this.closed; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\CircularByteBuffer.java,read,"synchronized public int  (final byte[] bytes final int start final int size){ try { if (this.bytesAvailableToRead == 0 && !closed) wait(); } catch ( final InterruptedException ie) { throw new PicardException(""Interrupted while waiting to read from fifo."" ie); } final int readPos=this.nextReadPos; final int distanceToEnd=this.capacity - readPos; final int available=distanceToEnd < this.bytesAvailableToRead ? distanceToEnd : this.bytesAvailableToRead; final int length=available < size ? available : size; System.arraycopy(this.bytes readPos bytes start length); this.bytesAvailableToRead-=length; this.bytesAvailableToWrite+=length; this.nextReadPos=(readPos + length) % this.capacity; notify(); return length; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\CircularByteBuffer.java,write,"synchronized public int  (final byte[] bytes final int start final int size){ if (closed) throw new IllegalStateException(""Cannot write to closed buffer.""); try { if (this.bytesAvailableToWrite == 0) wait(); } catch ( final InterruptedException ie) { throw new PicardException(""Interrupted while waiting to write to fifo."" ie); } final int writePos=this.nextWritePos; final int distanceToEnd=this.capacity - writePos; final int available=distanceToEnd < this.bytesAvailableToWrite ? distanceToEnd : this.bytesAvailableToWrite; final int length=available < size ? available : size; System.arraycopy(bytes start this.bytes writePos length); this.bytesAvailableToWrite-=length; this.bytesAvailableToRead+=length; this.nextWritePos=(writePos + length) % this.capacity; notify(); return length; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\BedToIntervalList.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsReadable(SEQUENCE_DICTIONARY); IOUtil.assertFileIsWritable(OUTPUT); try { final SAMFileHeader header=new SAMFileHeader(); final SAMSequenceDictionary samSequenceDictionary
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\BedToIntervalList.java,main,public static void  (final String[] args){ new BedToIntervalList().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\DbSnpBitSetUtil.java,DbSnpBitSetUtil,"public  (final File dbSnpFile final SAMSequenceDictionary sequenceDictionary final Collection<VariantType> variantsToMatch final IntervalList intervals final Optional<Log> log){ if (dbSnpFile == null) throw new IllegalArgumentException(""null dbSnpFile""); final Map<DbSnpBitSetUtil Set<VariantType>> tmp=new HashMap<>(); tmp.put(this EnumSet.copyOf(variantsToMatch)); loadVcf(dbSnpFile sequenceDictionary tmp intervals log); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\DbSnpBitSetUtil.java,createSnpAndIndelBitSets,public static DbSnpBitSets  (final File dbSnpFile final SAMSequenceDictionary sequenceDictionary final IntervalList intervals final Optional<Log> log){ final DbSnpBitSets sets=new DbSnpBitSets(); sets.snps=new DbSnpBitSetUtil(); sets.indels=new DbSnpBitSetUtil(); final Map<DbSnpBitSetUtil Set<VariantType>> map=new HashMap<>(); map.put(sets.snps EnumSet.of(VariantType.SNP)); map.put(sets.indels EnumSet.of(VariantType.insertion VariantType.deletion)); loadVcf(dbSnpFile sequenceDictionary map intervals log); return sets; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\DbSnpBitSetUtil.java,isDbSnpSite,public boolean  (final String sequenceName final int pos){ return sequenceToBitSet.get(sequenceName) != null && pos <= sequenceToBitSet.get(sequenceName).length() && sequenceToBitSet.get(sequenceName).get(pos); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\DbSnpBitSetUtil.java,loadVcf,"private static void  (final File dbSnpFile final SAMSequenceDictionary sequenceDictionary final Map<DbSnpBitSetUtil Set<VariantType>> bitSetsToVariantTypes final IntervalList intervals final Optional<Log> log){ final Optional<ProgressLogger> progress=log.map(l -> new ProgressLogger(l (int)1e5 ""Read"" ""variants"")); final VCFFileReader variantReader=new VCFFileReader(dbSnpFile intervals != null); final Iterator<VariantContext> variantIterator; if (intervals != null) { variantIterator=new ByIntervalListVariantContextIterator(variantReader intervals); } else { variantIterator=variantReader.iterator(); } while (variantIterator.hasNext()) { final VariantContext kv=variantIterator.next(); for ( final Map.Entry<DbSnpBitSetUtil Set<VariantType>> tuple : bitSetsToVariantTypes.entrySet()) { final DbSnpBitSetUtil bitset=tuple.getKey(); final Set<VariantType> variantsToMatch=tuple.getValue(); BitSet bits=bitset.sequenceToBitSet.get(kv.getContig()); if (bits == null) { final int nBits; if (sequenceDictionary == null) nBits=kv.getEnd() + 1; else nBits=sequenceDictionary.getSequence(kv.getContig()).getSequenceLength() + 1; bits=new BitSet(nBits); bitset.sequenceToBitSet.put(kv.getContig() bits); } if (variantsToMatch.isEmpty() || (kv.isSNP() && variantsToMatch.contains(VariantType.SNP)) || (kv.isIndel() && variantsToMatch.contains(VariantType.insertion))|| (kv.isIndel() && variantsToMatch.contains(VariantType.deletion))) { for (int i=kv.getStart(); i <= kv.getEnd(); i++) bits.set(i true); } } progress.map(p -> p.record(kv.getContig() kv.getStart())); } CloserUtil.close(variantReader); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\DelimitedTextFileWithHeaderIterator.java,DelimitedTextFileWithHeaderIterator,"public  (final BasicInputParser parser){ this.parser=parser; if (!parser.hasNext()) { throw new PicardException(""No header line found in file "" + parser.getFileName()); } final String[] columnLabels=parser.next(); for (int i=0; i < columnLabels.length; ++i) { columnLabelIndices.put(columnLabels[i] i); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\DelimitedTextFileWithHeaderIterator.java,Row, (final String[] fields final String source){ this.fields=fields; this.currentLine=source; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\DelimitedTextFileWithHeaderIterator.java,close,@Override public void  (){ parser.close(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\DelimitedTextFileWithHeaderIterator.java,columnLabels,public Set<String>  (){ return columnLabelIndices.keySet(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\DelimitedTextFileWithHeaderIterator.java,getColumnNames,public Set<String>  (){ return Collections.unmodifiableSet(this.columnLabelIndices.keySet()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\DelimitedTextFileWithHeaderIterator.java,getCurrentLine,public String  (){ return this.currentLine; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\DelimitedTextFileWithHeaderIterator.java,getCurrentLineNumber,public int  (){ return parser.getCurrentLineNumber(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\DelimitedTextFileWithHeaderIterator.java,getField,"public String  (final String columnLabel){ final Integer key=columnLabelIndices.get(columnLabel); if (key == null) throw new NoSuchElementException(String.format(""column %s in %s"" columnLabel parser.getFileName())); return fields[key]; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\DelimitedTextFileWithHeaderIterator.java,getFields,public String[]  (){ return fields; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\DelimitedTextFileWithHeaderIterator.java,getIntegerField,public Integer  (final String columnLabel){ if (fields[columnLabelIndices.get(columnLabel)] == null) return null; return Integer.parseInt(fields[columnLabelIndices.get(columnLabel)]); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\DelimitedTextFileWithHeaderIterator.java,hasColumn,public boolean  (final String columnLabel){ return columnLabelIndices.containsKey(columnLabel); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\DelimitedTextFileWithHeaderIterator.java,hasNext,@Override public boolean  (){ return parser.hasNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\DelimitedTextFileWithHeaderIterator.java,next,@Override public Row  (){ final String[] fields=parser.next(); final String source=parser.getCurrentLine(); return new Row(fields source); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\DelimitedTextFileWithHeaderIterator.java,remove,@Override public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\FifoBuffer.java,FifoBuffer,public  (){ this(System.in System.out); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\FifoBuffer.java,doWork,@Override protected int  (){ final CircularByteBuffer fifo=new CircularByteBuffer(BUFFER_SIZE); final Thread input=new Thread(new Runnable(){ @Override public void run(){ try { final byte[] buffer=new byte[IO_SIZE]; int read=0; while ((read=inputStream.re
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\FifoBuffer.java,main,public static void  (final String[] args){ new FifoBuffer().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\FifoBuffer.java,run,"@Override public void  (){ final NumberFormat pFmt=NumberFormat.getPercentInstance(); final NumberFormat iFmt=new DecimalFormat(""# ##0""); while (true) { final int capacity=fifo.getCapacity(); final int used=fifo.getBytesAvailableToRead(); final double pct"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\FifoBuffer.java,uncaughtException,"@Override public void  (final Thread t final Throwable e){ this.throwable=e; log.error(e ""Exception caught on thread "" t.getName()); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\GraphUtils.java,Graph,public  (){ nodes=new ArrayList<>(); neighbors=new ArrayList<>(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\GraphUtils.java,addEdge,public void  (Node left Node right){ final int leftIndex=addNode(left); if (left == right) return; final int rightIndex=addNode(right); addNeighbor(leftIndex rightIndex); addNeighbor(rightIndex leftIndex); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\GraphUtils.java,addNeighbor,private void  (final Integer fromNode final Integer toNode){ final List<Integer> fromNodesNeighbors=neighbors.get(fromNode); if (!fromNodesNeighbors.contains(toNode)) { fromNodesNeighbors.add(toNode); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\GraphUtils.java,addNode,public Integer  (final Node singleton){ if (!nodes.contains(singleton)) { nodes.add(singleton); neighbors.add(new ArrayList<>()); } return nodes.indexOf(singleton); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\GraphUtils.java,cluster,public Map<Node Integer>  (){ final int[] cluster=IntStream.range(0 nodes.size()).toArray(); IntStream.range(0 neighbors.size()).forEach(i -> neighbors.get(i).stream().forEach(j -> joinNodes(cluster j i))); return nodes.stream().collect(Collectors.toMap(n -> n n -> cluster[nodes.indexOf(n)])); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\GraphUtils.java,findRepNode,private static int  (final int[] grouping int nodeId){ int representativeUmi=nodeId; while (representativeUmi != grouping[representativeUmi]) { representativeUmi=grouping[representativeUmi]; } while (nodeId != representativeUmi) { int newUmiID=grouping[nodeId]; grouping[nodeId]=representativeUmi; nodeId=newUmiID; } return representativeUmi; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\GraphUtils.java,joinNodes,private static void  (int[] grouping final int nodeId1 final int nodeId2){ final int repNode1=findRepNode(grouping nodeId1); final int repNode2=findRepNode(grouping nodeId2); if (repNode1 == repNode2) return; grouping[repNode1]=repNode2; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\help\HelpConstants.java,getSuperCategoryMap,public static Map<String String>  (){ if (groupToSuperCategory == null) { groupToSuperCategory=new HashMap<>(); groupToSuperCategory.put(DOC_CAT_BASE_CALLING DOC_SUPERCAT_TOOLS); groupToSuperCategory.put(DOC_CAT_DIAGNOSTICS_AND_QC DOC_SUPERCAT_TOOLS); groupToSuperCategory.put(DOC_CAT_INTERVALS_MANIPULATION DOC_SUPERCAT_TOOLS); groupToSuperCategory.put(DOC_CAT_OTHER DOC_SUPERCAT_TOOLS); groupToSuperCategory.put(DOC_CAT_READ_DATA_MANIPULATION DOC_SUPERCAT_TOOLS); groupToSuperCategory.put(DOC_CAT_REFERENCE DOC_SUPERCAT_TOOLS); groupToSuperCategory.put(DOC_CAT_READ_DATA_MANIPULATION DOC_SUPERCAT_TOOLS); groupToSuperCategory.put(DOC_CAT_VARIANT_FILTERING DOC_SUPERCAT_TOOLS); groupToSuperCategory.put(DOC_CAT_VARIANT_EVALUATION DOC_SUPERCAT_TOOLS); groupToSuperCategory.put(DOC_CAT_VARIANT_MANIPULATION DOC_SUPERCAT_TOOLS); groupToSuperCategory.put(DOC_CAT_TEST DOC_SUPERCAT_EXCLUDE); } return groupToSuperCategory; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\help\HelpConstants.java,getSuperCategoryProperty,"public static String  (final String groupName){ return getSuperCategoryMap().getOrDefault(groupName ""other""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\help\PicardHelpDoclet.java,createWorkUnit,@Override protected DocWorkUnit  (final DocumentedFeature documentedFeature final ClassDoc classDoc final Class<?> clazz){ return new DocWorkUnit(new PicardHelpDocWorkUnitHandler(this) documentedFeature classDoc clazz); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\help\PicardHelpDoclet.java,getGroupMap,"@Override protected final Map<String String>  (final DocWorkUnit docWorkUnit){ final Map<String String> root=super.getGroupMap(docWorkUnit); root.put(""supercat"" HelpConstants.getSuperCategoryProperty(docWorkUnit.getGroupName())); return root; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\help\PicardHelpDoclet.java,getIndexTemplateName,@Override public String  (){ return PICARD_FREEMARKER_INDEX_TEMPLATE_NAME; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\help\PicardHelpDoclet.java,start,public static boolean  (final RootDoc rootDoc) throws IOException { return new picard.util.help.PicardHelpDoclet().startProcessDocs(rootDoc); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\help\PicardHelpDocWorkUnitHandler.java,PicardHelpDocWorkUnitHandler,public  (final HelpDoclet doclet){ super(doclet); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\help\PicardHelpDocWorkUnitHandler.java,getTagFilterPrefix,@Override protected String  (){ return PICARD_JAVADOC_TAG_PREFIX; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\help\PicardHelpDocWorkUnitHandler.java,getTemplateName,@Override public String  (final DocWorkUnit workUnit){ return PICARD_FREEMARKER_TEMPLATE_NAME; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IlluminaUtil.java,IlluminaAdapterPair,private  (final String fivePrime final String threePrime){ this.threePrime=threePrime; this.threePrimeBytes=StringUtil.stringToBytes(threePrime); this.fivePrime=fivePrime; this.fivePrimeReadOrder=SequenceUtil.reverseComplement(fivePrime); this.fivePrimeBytes=StringUtil.stringToBytes(fivePrime); this.fivePrimeReadOrderBytes=StringUtil.stringToBytes(fivePrimeReadOrder); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IlluminaUtil.java,barcodeSeqsToString,public static String  (final byte[][] barcodes){ return byteArrayToString(barcodes BARCODE_DELIMITER); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IlluminaUtil.java,byteArrayToString,public static String  (final byte[][] barcodes String delim){ final String[] bcs=new String[barcodes.length]; for (int i=0; i < barcodes.length; i++) { bcs[i]=StringUtil.bytesToString(barcodes[i]); } return stringSeqsToString(bcs delim); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IlluminaUtil.java,convertSolexaQualityAscii_1_1_ToPhredBinary,public static void  (final byte[] solexaQualities){ SolexaQualityConverter.getSingleton().convertSolexaQualityCharsToPhredBinary(solexaQualities); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IlluminaUtil.java,get3PrimeAdapter,public String  (){ return threePrime; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IlluminaUtil.java,get3PrimeAdapterBytes,public byte[]  (){ return threePrimeBytes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IlluminaUtil.java,get3PrimeAdapterBytesInReadOrder,public byte[]  (){ return threePrimeBytes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IlluminaUtil.java,get3PrimeAdapterInReadOrder,public String  (){ return threePrime; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IlluminaUtil.java,get5PrimeAdapter,public String  (){ return fivePrime; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IlluminaUtil.java,get5PrimeAdapterBytes,public byte[]  (){ return fivePrimeBytes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IlluminaUtil.java,get5PrimeAdapterBytesInReadOrder,public byte[]  (){ return fivePrimeReadOrderBytes; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IlluminaUtil.java,get5PrimeAdapterInReadOrder,public String  (){ return fivePrimeReadOrder; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IlluminaUtil.java,getName,public String  (){ return this.name(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IlluminaUtil.java,getSolexaQualityCharFromFourQualities,"public static byte  (final String[] qualities final int cycleNumber final FormatUtil formatter){ int bestQuality=Integer.MIN_VALUE; final int startOffset=(cycleNumber - 1) * 4; for (int i=startOffset; i < startOffset + 4; ++i) { final int quality=formatter.parseInt(qualities[i]); if (quality > bestQuality) { bestQuality=quality; } } final int qualityAsCharacter=bestQuality + SolexaQualityConverter.SOLEXA_ADDEND; if (qualityAsCharacter > 255) { throw new PicardException(""Quality too large: "" + bestQuality); } return (byte)(qualityAsCharacter & 0xff); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IlluminaUtil.java,getTileFromReadName,public static Integer  (final String readName){ final int first=readName.indexOf(':'); if (first > 0) { final int second=readName.indexOf(':' first + 1); if (second > 0) { final int third=readName.indexOf(':' second + 1); if (third > 0) { return Integer.parseInt(readName.substring(second + 1 third)); } } } return null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IlluminaUtil.java,makePhredBinaryFromSolexaQualityAscii_1_3,public static byte[]  (final String solexaQualities final int offset final int length){ final byte[] quals=StringUtil.stringToBytes(solexaQualities offset length); SolexaQualityConverter.getSingleton().convertSolexa_1_3_QualityCharsToPhredBinary(quals); return quals; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IlluminaUtil.java,stringSeqsToString,public static String  (final String[] barcodes String delim){ final StringBuilder sb=new StringBuilder(); for ( final String bc : barcodes) { if (sb.length() > 0) sb.append(delim); sb.append(bc); } return sb.toString(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IntervalListScatterer.java,IntervalListScatterer,public  (final Mode mode){ this.mode=mode; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IntervalListScatterer.java,deduceIdealSplitLength,private int  (final IntervalList uniquedList final int scatterCount){ final int splitWidth=Math.max((int)Math.floor(uniquedList.getBaseCount() / (1.0 * scatterCount)) 1); switch (mode) { case INTERVAL_SUBDIVISION: return splitWidth; case BALANCING_WITHOUT_INTERVAL_SUBDIVISION: case BALANCING_WITHOUT_INTERVAL_SUBDIVISION_WITH_OVERFLOW: final int widestIntervalLength=Collections.max(uniquedList.getIntervals() (o1 o2) -> Integer.valueOf(o1.length()).compareTo(o2.length())).length(); return Math.max(widestIntervalLength splitWidth); default : throw new IllegalStateException(); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IntervalListScatterer.java,scatter,"public List<IntervalList>  (final IntervalList sourceIntervalList final int scatterCount final boolean isUniqued){ if (scatterCount < 1) throw new IllegalArgumentException(""scatterCount < 1""); final IntervalList uniquedList=isUniqued ? sourceIntervalList : sourceIntervalList.uniqued(); final long idealSplitLength=deduceIdealSplitLength(uniquedList scatterCount); System.err.println(""idealSplitLength="" + idealSplitLength); final List<IntervalList> accumulatedIntervalLists=new ArrayList<>(); IntervalList runningIntervalList=new IntervalList(uniquedList.getHeader()); final ArrayDeque<Interval> intervalQueue=new ArrayDeque<>(uniquedList.getIntervals()); long numBasesLeft=uniquedList.getBaseCount(); while (!intervalQueue.isEmpty() && accumulatedIntervalLists.size() < scatterCount - 1) { final Interval interval=intervalQueue.pollFirst(); final long projectedSize=runningIntervalList.getBaseCount() + interval.length(); final double projectedSizeOfRemainingDivisions=(numBasesLeft - runningIntervalList.getBaseCount()) / ((double)(scatterCount - accumulatedIntervalLists.size() - 1)); if (shouldAddToRunningIntervalList(idealSplitLength projectedSize projectedSizeOfRemainingDivisions)) { runningIntervalList.add(interval); } else { switch (mode) { case INTERVAL_SUBDIVISION: final int amountToConsume=(int)(idealSplitLength - runningIntervalList.getBaseCount()); final Interval left=new Interval(interval.getContig() interval.getStart() interval.getStart() + amountToConsume - 1 interval.isNegativeStrand() interval.getName()); final Interval right=new Interval(interval.getContig() interval.getStart() + amountToConsume interval.getEnd() interval.isNegativeStrand() interval.getName()); runningIntervalList.add(left); intervalQueue.addFirst(right); break; case BALANCING_WITHOUT_INTERVAL_SUBDIVISION: case BALANCING_WITHOUT_INTERVAL_SUBDIVISION_WITH_OVERFLOW: if (runningIntervalList.getIntervals().isEmpty()) { runningIntervalList.add(interval); } else { intervalQueue.addFirst(interval); numBasesLeft-=runningIntervalList.getBaseCount(); accumulatedIntervalLists.add(runningIntervalList.uniqued()); runningIntervalList=new IntervalList(uniquedList.getHeader()); } break; } } if (runningIntervalList.getBaseCount() >= idealSplitLength) { numBasesLeft-=runningIntervalList.getBaseCount(); accumulatedIntervalLists.add(runningIntervalList.uniqued()); runningIntervalList=new IntervalList(uniquedList.getHeader()); } } while (!intervalQueue.isEmpty()) { runningIntervalList.add(intervalQueue.pollFirst()); } if (!runningIntervalList.getIntervals().isEmpty()) { accumulatedIntervalLists.add(runningIntervalList.uniqued()); } long maximumIntervalSize=-1  minimumIntervalSize=Integer.MAX_VALUE; for (final IntervalList intervalList : accumulatedIntervalLists) { final long baseCount=intervalList.getBaseCount(); if (baseCount < minimumIntervalSize) minimumIntervalSize=baseCount; if (maximumIntervalSize < baseCount) maximumIntervalSize=baseCount; } return accumulatedIntervalLists; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IntervalListScatterer.java,shouldAddToRunningIntervalList,private boolean  (final long idealSplitLength final long projectedSize final double projectedSizeOfRemainingDivisions){ switch (mode) { case BALANCING_WITHOUT_INTERVAL_SUBDIVISION_WITH_OVERFLOW: return (projectedSize <= idealSplitLength || idealSplitLength < projectedSizeOfRemainingDivisions); default : return (projectedSize <= idealSplitLength); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IntervalListToBed.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); IntervalList intervals=IntervalList.fromFile(INPUT); if (SORT) intervals=intervals.sorted(); try { final BufferedWriter out=IOUtil.openFileForBufferedWri
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\Iterators.java,atomicIteratorOf,public static <E>AtomicIterator<E>  (final Iterator<E> backingIterator){ final Object monitor=new Object(); return () -> { synchronized (monitor) { return backingIterator.hasNext() ? Optional.ofNullable(backingIterator.next()) : Optional.empty(); } } ; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IntervalListTools.java,Action, (final String helpdoc boolean takesSecondInput){ this.helpdoc=helpdoc; this.takesSecondInput=takesSecondInput; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\IntervalListTools.java,IntervalListInputType, (final Collection<String> extensions){ applicableExtensions=extensions; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\LiftOverIntervalList.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsReadable(SEQUENCE_DICTIONARY); IOUtil.assertFileIsReadable(CHAIN); IOUtil.assertFileIsWritable(OUTPUT); if (REJECT != null) IOUtil.assertFileIsWritable(REJECT); final Lift
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\LiftoverUtils.java,allelesToStringList,protected static List<String>  (final List<Allele> alleles){ final List<String> ret=new ArrayList<>(); alleles.forEach(a -> ret.add(a.isNoCall() ? Allele.NO_CALL_STRING : a.getDisplayString())); return ret; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\LiftoverUtils.java,extendOneBase,private static byte[]  (final byte[] bases final byte base){ final byte[] newBases=new byte[bases.length + 1]; System.arraycopy(bases 0 newBases 1 bases.length); newBases[0]=base; return newBases; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\LiftoverUtils.java,fixGenotypes,"protected static GenotypesContext  (final GenotypesContext originals final List<Allele> originalAlleles final List<Allele> newAlleles){ if (originalAlleles.equals(newAlleles)) { return originals; } if (originalAlleles.size() != newAlleles.size()) { throw new IllegalStateException(""Error in allele lists: the original and new allele lists are not the same length: "" + originalAlleles.toString() + "" / ""+ newAlleles.toString()); } final Map<Allele Allele> alleleMap=new HashMap<>(); for (int idx=0; idx < originalAlleles.size(); idx++) { alleleMap.put(originalAlleles.get(idx) newAlleles.get(idx)); } final GenotypesContext fixedGenotypes=GenotypesContext.create(originals.size()); for ( final Genotype genotype : originals) { final List<Allele> fixedAlleles=new ArrayList<>(); for ( final Allele allele : genotype.getAlleles()) { if (allele.isNoCall()) { fixedAlleles.add(allele); } else { Allele newAllele=alleleMap.get(allele); if (newAllele == null) { throw new IllegalStateException(""Allele not found: "" + allele.toString() + ""  ""+ originalAlleles+ ""/ ""+ newAlleles); } fixedAlleles.add(newAllele); } } fixedGenotypes.add(new GenotypeBuilder(genotype).alleles(fixedAlleles).make()); } return fixedGenotypes; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\LiftoverUtils.java,leftAlignVariant,"protected static void  (final VariantContextBuilder builder final int start final int end final List<Allele> alleles final ReferenceSequence referenceSequence){ if (!referenceAlleleMatchesReferenceForIndel(alleles referenceSequence start end)) { throw new IllegalArgumentException(String.format(""Reference allele doesn't match reference at %s:%d-%d"" referenceSequence.getName() start end)); } boolean changesInAlleles=true; final Map<Allele byte[]> alleleBasesMap=new HashMap<>(); alleles.forEach(a -> alleleBasesMap.put(a a.getBases())); int theStart=start; int theEnd=end; while (changesInAlleles) { changesInAlleles=false; if (alleleBasesMap.values().stream().collect(Collectors.groupingBy(a -> a[a.length - 1] Collectors.toSet())).size() == 1 && theEnd > 1) { for ( final Allele allele : alleleBasesMap.keySet()) { alleleBasesMap.put(allele truncateBase(alleleBasesMap.get(allele) true)); } changesInAlleles=true; theEnd--; } if (alleleBasesMap.values().stream().map(a -> a.length).anyMatch(l -> l == 0)) { for ( final Allele allele : alleleBasesMap.keySet()) { final byte extraBase=(theStart > 1) ? referenceSequence.getBases()[theStart - 2] : referenceSequence.getBases()[theEnd]; alleleBasesMap.put(allele extendOneBase(alleleBasesMap.get(allele) extraBase)); } changesInAlleles=true; theStart--; } } while (alleleBasesMap.values().stream().allMatch(a -> a.length >= 2) && alleleBasesMap.values().stream().collect(Collectors.groupingBy(a -> a[0] Collectors.toSet())).size() == 1) { for ( final Allele allele : alleleBasesMap.keySet()) { alleleBasesMap.put(allele truncateBase(alleleBasesMap.get(allele) false)); } theStart++; } builder.start(theStart); builder.stop(theEnd); final Map<Allele Allele> fixedAlleleMap=alleleBasesMap.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey me -> Allele.create(me.getValue() me.getKey().isReference()))); List<Allele> fixedAlleles=alleles.stream().map(fixedAlleleMap::get).collect(Collectors.toList()); builder.alleles(fixedAlleles); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\LiftoverUtils.java,liftSimpleVariantContext,protected static VariantContextBuilder  (VariantContext source Interval target){ if (target == null || source.getReference().length() != target.length()) { return null; } final VariantContextBuilder builder=new VariantContextBuilder(source); builder.chr(target.getContig()); builder.start(target.getStart()); builder.stop(target.getEnd()); return builder; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\LiftoverUtils.java,liftVariant,public static VariantContext  (final VariantContext source final Interval target final ReferenceSequence refSeq final boolean writeOriginalPosition final boolean writeOriginalAlleles){ if (target == null) { return null; } final VariantContextBuilder builder; if (target.isNegativeStrand()) { builder=reverseComplementVariantContext(source target refSeq); } else { builder=liftSimpleVariantContext(source target); } if (builder == null) { return null; } builder.filters(source.getFilters()); builder.log10PError(source.getLog10PError()); builder.attributes(source.getAttributes()); builder.rmAttribute(SWAPPED_ALLELES); if (target.isNegativeStrand()) { builder.attribute(REV_COMPED_ALLELES true); } else { builder.rmAttribute(REV_COMPED_ALLELES); } builder.id(source.getID()); if (writeOriginalPosition) { builder.attribute(LiftoverVcf.ORIGINAL_CONTIG source.getContig()); builder.attribute(LiftoverVcf.ORIGINAL_START source.getStart()); } if (writeOriginalAlleles && !source.getAlleles().equals(builder.getAlleles())) { builder.attribute(LiftoverVcf.ORIGINAL_ALLELES allelesToStringList(source.getAlleles())); } return builder.make(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\LiftoverUtils.java,referenceAlleleMatchesReferenceForIndel,"protected static boolean  (final List<Allele> alleles final ReferenceSequence referenceSequence final int start final int end){ final String refString=StringUtil.bytesToString(referenceSequence.getBases() start - 1 end - start + 1); final Allele refAllele=alleles.stream().filter(Allele::isReference).findAny().orElseThrow(() -> new IllegalStateException(""Error: no reference allele was present"")); return (refString.equalsIgnoreCase(refAllele.getBaseString())); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\LiftoverUtils.java,reverseComplement,private static Allele  (final Allele oldAllele final Interval target final ReferenceSequence referenceSequence final boolean isBiAllelicIndel final boolean addToStart){ if (oldAllele.isSymbolic() || oldAllele.isNoCall()) { return oldAllele; } else if (isBiAllelicIndel) { final StringBuilder alleleBuilder=new StringBuilder(target.getEnd() - target.getStart() + 1); if (addToStart) { alleleBuilder.append((char)referenceSequence.getBases()[target.getStart() - 2]); } alleleBuilder.append(SequenceUtil.reverseComplement(oldAllele.getBaseString().substring(1 oldAllele.length()))); if (!addToStart) { alleleBuilder.append((char)referenceSequence.getBases()[target.getEnd() - 1]); } return Allele.create(alleleBuilder.toString() oldAllele.isReference()); } else { return Allele.create(SequenceUtil.reverseComplement(oldAllele.getBaseString()) oldAllele.isReference()); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\LiftoverUtils.java,reverseComplementAlleles,private static List<Allele>  (final List<Allele> originalAlleles final Interval target final ReferenceSequence refSeq final boolean isBiAllelicIndel final boolean addToStart){ final List<Allele> alleles=new ArrayList<>(); for ( final Allele oldAllele : originalAlleles) { alleles.add(LiftoverUtils.reverseComplement(oldAllele target refSeq isBiAllelicIndel addToStart)); } return alleles; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\LiftoverUtils.java,reverseComplementVariantContext,"protected static VariantContextBuilder  (final VariantContext source final Interval target final ReferenceSequence refSeq){ if (target.isPositiveStrand()) { throw new IllegalArgumentException(""This should only be called for negative strand liftovers""); } if (source.isIndel() && !source.isBiallelic()) { return null; } final List<Allele> origAlleles=new ArrayList<>(source.getAlleles()); final VariantContextBuilder vcb=new VariantContextBuilder(source); vcb.chr(target.getContig()); final boolean addToStart=source.isIndel() && target.getStart() > 1; final int start=target.getStart() - (addToStart ? 1 : 0); vcb.start(start); final int stop=target.getEnd() - (addToStart ? 1 : 0); vcb.stop(stop); vcb.alleles(reverseComplementAlleles(origAlleles target refSeq source.isIndel() addToStart)); if (source.isIndel()) { if (!referenceAlleleMatchesReferenceForIndel(vcb.getAlleles() refSeq start stop)) { return null; } leftAlignVariant(vcb start stop vcb.getAlleles() refSeq); } vcb.genotypes(fixGenotypes(source.getGenotypes() origAlleles vcb.getAlleles())); return vcb; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\LiftoverUtils.java,swapRefAlt,"public static VariantContext  (final VariantContext vc final Collection<String> annotationsToReverse final Collection<String> annotationsToDrop){ if (!vc.isBiallelic() || !vc.isSNP()) { throw new IllegalArgumentException(""swapRefAlt can only process biallelic  SNPS  found "" + vc.toString()); } final VariantContextBuilder swappedBuilder=new VariantContextBuilder(vc); swappedBuilder.attribute(SWAPPED_ALLELES true); swappedBuilder.alleles(Arrays.asList(vc.getAlleles().get(1).getBaseString() vc.getAlleles().get(0).getBaseString())); final Map<Allele Allele> alleleMap=new HashMap<>(); alleleMap.put(vc.getAlleles().get(0) swappedBuilder.getAlleles().get(1)); alleleMap.put(vc.getAlleles().get(1) swappedBuilder.getAlleles().get(0)); final GenotypesContext swappedGenotypes=GenotypesContext.create(vc.getGenotypes().size()); for ( final Genotype genotype : vc.getGenotypes()) { final List<Allele> swappedAlleles=new ArrayList<>(); for ( final Allele allele : genotype.getAlleles()) { if (allele.isNoCall()) { swappedAlleles.add(allele); } else { swappedAlleles.add(alleleMap.get(allele)); } } final GenotypeBuilder builder=new GenotypeBuilder(genotype).alleles(swappedAlleles); if (genotype.hasAD() && genotype.getAD().length == 2) { final int[] ad=ArrayUtils.clone(genotype.getAD()); ArrayUtils.reverse(ad); builder.AD(ad); } else { builder.noAD(); } if (genotype.hasPL() && genotype.getPL().length == 3) { final int[] pl=ArrayUtils.clone(genotype.getPL()); ArrayUtils.reverse(pl); builder.PL(pl); } else { builder.noPL(); } swappedGenotypes.add(builder.make()); } swappedBuilder.genotypes(swappedGenotypes); for ( final String key : vc.getAttributes().keySet()) { if (annotationsToDrop.contains(key)) { swappedBuilder.rmAttribute(key); } else if (annotationsToReverse.contains(key) && !vc.getAttributeAsString(key """").equals(VCFConstants.MISSING_VALUE_v4)) { final double attributeToReverse=vc.getAttributeAsDouble(key -1); if (attributeToReverse < 0 || attributeToReverse > 1) { log.warn(""Trying to reverse attribute "" + key + "" but found value that isn't between 0 and 1: (""+ attributeToReverse+ "") in variant ""+ vc+ "". Results might be wrong.""); } swappedBuilder.attribute(key 1 - attributeToReverse); } } return swappedBuilder.make(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\LiftoverUtils.java,truncateBase,private static byte[]  (final byte[] allele final boolean truncateRightmost){ return Arrays.copyOfRange(allele truncateRightmost ? 0 : 1 truncateRightmost ? allele.length - 1 : allele.length); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,LogMath,private  (final double base){ this.base=base; this.log_of_base=Math.log(base); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,compare,public static int  (final int v1 final int v2){ return (v1 < v2 ? -1 : (v1 == v2 ? 0 : 1)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,divide,"public static double[]  (final double[] numerators final double[] denominators){ if (numerators.length != denominators.length) throw new IllegalArgumentException(""Arrays must be of same length.""); final int len=numerators.length; final double[] result=new double[len]; for (int i=0; i < len; ++i) result[i]=numerators[i] / denominators[i]; return result; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,getLogValue,public double[]  (final double[] nonLogArray){ final double[] logArray=new double[nonLogArray.length]; for (int i=0; i < nonLogArray.length; i++) { logArray[i]=getLogValue(nonLogArray[i]); } return logArray; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,getLog_of_base,public double  (){ return log_of_base; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,getNonLogValue,public double  (final double logValue){ return Math.pow(base logValue); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,indexOfMax,public static int  (final long[] nums){ long max=nums[0]; int index=0; for (int i=1; i < nums.length; ++i) { if (nums[i] > max) { max=nums[i]; index=i; } } return index; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,indexOfMin,public static int  (final double[] nums){ double min=nums[0]; int index=0; for (int i=1; i < nums.length; ++i) { if (nums[i] < min) { min=nums[i]; index=i; } } return index; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,log10_1p,public static double  (final double x){ return log1p(x) / LOG_10_MATH.log_of_base; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,logLikelihoodsToProbs,@Deprecated public static double[]  (final double[] likelihoods){ return pNormalizeLogProbability(likelihoods); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,max,public static long  (final long[] nums){ return nums[indexOfMax(nums)]; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,mean,public double  (final double... logValues){ return sum(logValues) - getLogValue(logValues.length); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,median,"public static double  (final double... in){ if (in.length == 0) { throw new IllegalArgumentException(""Attempting to find the median of an empty array""); } final double[] data=Arrays.copyOf(in in.length); Arrays.sort(data); final int middle=data.length / 2; return data.length % 2 == 1 ? data[middle] : (data[middle - 1] + data[middle]) / 2.0; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,min,public static byte  (final byte[] nums){ byte min=nums[0]; for (int i=1; i < nums.length; ++i) { if (nums[i] < min) min=nums[i]; } return min; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,multiply,"public static double[]  (final double[] lhs final double[] rhs){ if (lhs.length != rhs.length) throw new IllegalArgumentException(""Arrays must be of same length.""); final int len=lhs.length; final double[] result=new double[len]; for (int i=0; i < len; ++i) result[i]=lhs[i] * rhs[i]; return result; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,pNormalizeLogProbability,public static double[]  (final double[] lPosterior){ final double maxLikelihood=max(lPosterior); final double bump=300 - maxLikelihood; final double[] tmp=new double[lPosterior.length]; double total=0; for (int i=0; i < lPosterior.length; ++i) { tmp[i]=pow(10 lPosterior[i] + bump); total+=tmp[i]; } final double maxP=MAX_PROB_BELOW_ONE; final double minP=(1 - MAX_PROB_BELOW_ONE) / (tmp.length - 1); for (int i=0; i < lPosterior.length; ++i) { tmp[i]/=total; if (tmp[i] > maxP) tmp[i]=maxP; else if (tmp[i] < minP) tmp[i]=minP; } return tmp; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,pNormalizeVector,public static double[]  (final double[] pPosterior){ final double[] tmp=new double[pPosterior.length]; final double total=sum(pPosterior); final double maxP=MAX_PROB_BELOW_ONE; final double minP=(1 - MAX_PROB_BELOW_ONE) / (tmp.length - 1); for (int i=0; i < pPosterior.length; ++i) { tmp[i]=pPosterior[i] / total; if (tmp[i] > maxP) tmp[i]=maxP; else if (tmp[i] < minP) tmp[i]=minP; } return tmp; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,percentageOrNull,public static Double  (final Long numerator final Long denominator){ if (numerator != null && denominator != null && denominator != 0) { return numerator.doubleValue() / denominator.doubleValue(); } else { return null; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,product,public double  (final double... logValues){ return MathUtil.sum(logValues); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,promote,public static double[]  (final int[] is){ final double[] ds=new double[is.length]; for (int i=0; i < is.length; ++i) ds[i]=is[i]; return ds; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,round,public static double  (final double num final int precision){ BigDecimal bd=new BigDecimal(num); bd=bd.setScale(precision BigDecimal.ROUND_HALF_UP); return bd.doubleValue(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,seq,public static double[]  (final double from final double to final double by){ if (from < to && by <= 0) return new double[0]; if (from > to && by >= 0) return new double[0]; final int values=1 + (int)Math.floor((to - from) / by); final double[] results=new double[values]; BigDecimal value=new BigDecimal(from); BigDecimal increment=new BigDecimal(by); for (int i=0; i < values; ++i) { results[i]=value.doubleValue(); value=value.add(increment); } return results; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,stddev,public static double  (final double[] in final int start final int stop final double mean){ double total=0; for (int i=start; i < stop; ++i) { total+=(in[i] * in[i]); } return Math.sqrt((total / (stop - start)) - (mean * mean)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\MathUtil.java,sum,public double  (final double... logValues){ final double scalingFactor=max(logValues); double simpleAdditionResult=0; for ( final double v : logValues) { simpleAdditionResult+=getNonLogValue(v - scalingFactor); } return getLogValue(simpleAdditionResult) + scalingFactor; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\QuerySortedReadPairIteratorUtil.java,getNextReadPair,public static ReadPair  (final PeekableIterator<SAMRecord> iterator){ final ReadPair readPair=new ReadPair(); readPair.read1=getNextUsableRead(iterator false); if (readPair.read1 == null) { return null; } final SAMRecord peekedNextRead=getNextUsableRead(iterator true); if (peekedNextRead != null && peekedNextRead.getReadName().equals(readPair.read1.getReadName())) { readPair.read2=getNextUsableRead(iterator false); } return readPair; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\QuerySortedReadPairIteratorUtil.java,getNextUsableRead,private static SAMRecord  (final PeekableIterator<SAMRecord> iterator final boolean justPeek){ while (iterator.hasNext()) { final SAMRecord nextRead=iterator.peek(); if (nextRead.getReadFailsVendorQualityCheckFlag() || nextRead.isSecondaryOrSupplementary()) { iterator.next(); } else { return justPeek ? nextRead : iterator.next(); } } return null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\PropertyUtils.java,loadPropertiesFile,"public static Properties  (final String propertyFilePath final Class<?> clazz){ Utils.nonNull(propertyFilePath); try (final InputStream inputStream=clazz.getClassLoader().getResourceAsStream(propertyFilePath)){ if (inputStream != null) { final Properties properties=new Properties(); properties.load(inputStream); return properties; } else { return null; } } catch ( IOException ex) { throw new RuntimeException(String.format(""IOException loading properties file %s"" propertyFilePath) ex); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\ReflectionUtil.java,copyFromBaseClass,"static public <T S extends T>void  (final T base final S derived){ final Class<T> baseClazz=(Class<T>)base.getClass(); for ( Field f : baseClazz.getFields()) { try { f.set(derived f.get(base)); } catch ( IllegalAccessException e) { throw new RuntimeException(e.getMessage() + ""when trying to access"" + f.getName()); } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\TabbedInputParser.java,TabbedInputParser,public  (boolean treatGroupedDelimitersAsOne File... file){ super(treatGroupedDelimitersAsOne file); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\TabbedInputParser.java,isDelimiter,@Override protected boolean  (final byte b){ return b == '\t'; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\TabbedTextFileWithHeaderParser.java,Row, (final String[] fields final String source){ this.fields=fields; this.currentLine=source; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\TabbedTextFileWithHeaderParser.java,TabbedTextFileWithHeaderParser,"public  (final File file final String[] columnHeaders){ parser=new TabbedInputParser(false file); if (!parser.hasNext()) { throw new PicardException(""No header line found in file "" + file); } for (int i=0; i < columnHeaders.length; ++i) { columnLabelIndices.put(columnHeaders[i] i); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\TabbedTextFileWithHeaderParser.java,close,public void  (){ parser.close(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\TabbedTextFileWithHeaderParser.java,columnLabels,public Set<String>  (){ return columnLabelIndices.keySet(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\TabbedTextFileWithHeaderParser.java,columnLabelsList,public List<String>  (){ return Collections.unmodifiableList(new ArrayList<String>(columnLabelIndices.keySet())); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\TabbedTextFileWithHeaderParser.java,getColumnNames,public Set<String>  (){ return Collections.unmodifiableSet(this.columnLabelIndices.keySet()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\TabbedTextFileWithHeaderParser.java,getCurrentLine,public String  (){ return this.currentLine; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\TabbedTextFileWithHeaderParser.java,getCurrentLineNumber,public int  (){ return parser.getCurrentLineNumber(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\TabbedTextFileWithHeaderParser.java,getField,"public String  (final String columnLabel){ final Integer key=columnLabelIndices.get(columnLabel); if (key == null) throw new NoSuchElementException(String.format(""column %s in %s"" columnLabel parser.getFileName())); return fields[key]; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\TabbedTextFileWithHeaderParser.java,getFields,public String[]  (){ return fields; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\TabbedTextFileWithHeaderParser.java,getIntegerField,public Integer  (final String columnLabel){ if (fields[columnLabelIndices.get(columnLabel)] == null) return null; return Integer.parseInt(fields[columnLabelIndices.get(columnLabel)]); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\TabbedTextFileWithHeaderParser.java,hasColumn,public boolean  (final String columnLabel){ return columnLabelIndices.containsKey(columnLabel); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\TabbedTextFileWithHeaderParser.java,hasNext,@Override public boolean  (){ return parser.hasNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\TabbedTextFileWithHeaderParser.java,iterator,"@Override public CloseableIterator<Row>  (){ if (extantIterator != null) { throw new ConcurrentModificationException(""Only one iterator allowed at a time.""); } extantIterator=new TheIterator(); return extantIterator; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\TabbedTextFileWithHeaderParser.java,next,@Override public Row  (){ final String[] fields=parser.next(); final String source=parser.getCurrentLine(); return new Row(fields source); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\TabbedTextFileWithHeaderParser.java,remove,@Override public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\ScatterIntervalsByNs.java,OutputType, (final String... strings){ acceptedTypes=new HashSet<>(); Collections.addAll(acceptedTypes strings); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\ScatterIntervalsByNs.java,accepts,public Boolean  (final String string){ return acceptedTypes.contains(string); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\ScatterIntervalsByNs.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(REFERENCE_SEQUENCE); IOUtil.assertFileIsWritable(OUTPUT); final ReferenceSequenceFile refFile=ReferenceSequenceFileFactory.getReferenceSequenceFile(REFERENCE_SEQUENCE true); if (!refFile.isIndexed()
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\ScatterIntervalsByNs.java,getReferenceFile,@Override public File  (){ return REFERENCE; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\ScatterIntervalsByNs.java,main,public static void  (final String[] args){ new ScatterIntervalsByNs().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\ScatterIntervalsByNs.java,makeReferenceArgumentCollection,@Override protected ReferenceArgumentCollection  (){ return new ScatterIntervalsByNReferenceArgumentCollection(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\ScatterIntervalsByNs.java,segregateReference,static IntervalList  (final ReferenceSequenceFile refFile final int maxNmerToMerge){ final List<Interval> preliminaryIntervals=new LinkedList<>(); final SAMFileHeader header=new SAMFileHeader(); header.setSequenceDictionary(refFile.getSequenceDictionary()); header.setSortOrder(SAMFileHeader.SortOrder.coordinate); final IntervalList finalIntervals=new IntervalList(header); for ( final SAMSequenceRecord rec : refFile.getSequenceDictionary().getSequences()) { final ReferenceSequence ref=refFile.getSequence(rec.getSequenceName()); final byte[] bytes=ref.getBases(); StringUtil.toUpperCase(bytes); boolean nBlockIsOpen=SequenceUtil.isNoCall(bytes[0]); int start=0; for (int i=0; i < bytes.length; ++i) { locusProgress.record(rec.getSequenceName() i); final boolean currentBaseIsN=SequenceUtil.isNoCall(bytes[i]); if (nBlockIsOpen != currentBaseIsN) { preliminaryIntervals.add(new Interval(rec.getSequenceName() start + 1 i false nBlockIsOpen ? Nmer : ACGTmer)); start=i; nBlockIsOpen=!nBlockIsOpen; } } preliminaryIntervals.add(new Interval(rec.getSequenceName() start + 1 bytes.length false nBlockIsOpen ? Nmer : ACGTmer)); } while (!preliminaryIntervals.isEmpty()) { if (preliminaryIntervals.size() >= 3 && preliminaryIntervals.get(0).getName() == ACGTmer && preliminaryIntervals.get(1).getName() == Nmer && preliminaryIntervals.get(2).getName() == ACGTmer && preliminaryIntervals.get(0).abuts(preliminaryIntervals.get(1)) && preliminaryIntervals.get(1).abuts(preliminaryIntervals.get(2)) && preliminaryIntervals.get(1).length() <= maxNmerToMerge) { final Interval temp=new Interval(preliminaryIntervals.get(0).getContig() preliminaryIntervals.get(0).getStart() preliminaryIntervals.get(2).getEnd() false ACGTmer); for (int i=0; i < 3; ++i) { preliminaryIntervals.remove(0); } preliminaryIntervals.add(0 temp); } else { final Interval remove=preliminaryIntervals.remove(0); finalIntervals.add(remove); intervalProgress.record(remove.getContig() remove.getStart()); } } return finalIntervals; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\ThreadPoolExecutorWithExceptions.java,ThreadPoolExecutorWithExceptions,public  (final int threads){ super(threads threads 0 TimeUnit.SECONDS new LinkedBlockingDeque<>()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\ThreadPoolExecutorWithExceptions.java,afterExecute,@Override protected void  (final Runnable r Throwable t){ if (t == null && r instanceof Future<?>) { try { final Future<?> future=(Future<?>)r; if (future.isDone()) { future.get(); } } catch ( final CancellationException ce) { t=ce; } catch ( final Execut
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\ThreadPoolExecutorWithExceptions.java,beforeExecute,"@Override protected void  (Thread t Runnable r){ super.beforeExecute(t r); t.setUncaughtExceptionHandler((t1 e) -> { throw new PicardException(""Uncaught exception in thread: "" + t1.getName() + "" : ""+ e.getMessage() e); } ); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\RExecutor.java,executeFromClasspath,public static int  (final String rScriptName final String... arguments){ final File scriptFile=writeScriptFile(rScriptName); final int returnCode=executeFromFile(scriptFile arguments); htsjdk.samtools.util.IOUtil.deleteFiles(scriptFile); return returnCode; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\RExecutor.java,executeFromFile,"public static int  (final File scriptFile final String... arguments){ final String[] command=new String[arguments.length + 2]; command[0]=R_EXE; command[1]=scriptFile.getAbsolutePath(); System.arraycopy(arguments 0 command 2 arguments.length); LOG.info(String.format(""Executing R script via command: %s"" CollectionUtil.join(Arrays.asList(command) "" ""))); return ProcessExecutor.execute(command); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\RExecutor.java,writeScriptFile,"private static File  (final String rScriptName){ InputStream scriptStream=null; OutputStream scriptFileStream=null; try { scriptStream=RExecutor.class.getClassLoader().getResourceAsStream(rScriptName); if (scriptStream == null) { throw new IllegalArgumentException(""Script ["" + rScriptName + ""] not found in classpath""); } final File scriptFile=File.createTempFile(""script"" "".R""); scriptFileStream=IOUtil.openFileForWriting(scriptFile); IOUtil.copyStream(scriptStream scriptFileStream); return scriptFile; } catch ( IOException e) { throw new PicardException(""Unexpected exception creating R script file ["" + rScriptName + ""]"" e); } finally { if (scriptStream != null) { try { scriptStream.close(); } catch ( IOException ignored) { } } if (scriptFileStream != null) { try { scriptFileStream.close(); } catch ( IOException ignored) { } } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\UnsignedTypeUtil.java,uByteToInt,public static int  (final byte unsignedByte){ return unsignedByte & 0xFF; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\UnsignedTypeUtil.java,uByteToShort,public static int  (final byte unsignedByte){ return (short)unsignedByte & 0xFF; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\UnsignedTypeUtil.java,uIntToFloat,public static float  (final int unsignedInt){ return Float.intBitsToFloat(unsignedInt); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\UnsignedTypeUtil.java,uIntToLong,public static long  (final int unsignedInt){ return unsignedInt & 0xFFFFFFFFL; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\UnsignedTypeUtil.java,uShortToInt,public static int  (final short unsignedShort){ return unsignedShort & 0xFFFF; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\AccumulateVariantCallingMetrics.java,doWork,"@Override protected int  (){ final String outputPrefix=OUTPUT.getAbsolutePath() + "".""; final File detailOutputFile=new File(outputPrefix + CollectVariantCallingMetrics.VariantCallingDetailMetrics.getFileExtension()); final File summaryOutputFile=new File("
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\ByIntervalListVariantContextIterator.java,ByIntervalListVariantContextIterator,public  (final VCFFileReader reader final IntervalList intervals){ this.reader=reader; this.intervals=intervals.uniqued().iterator(); this.advance(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\ByIntervalListVariantContextIterator.java,advance,private void  (){ while ((currentIterator == null || !currentIterator.hasNext()) && this.intervals.hasNext()) { if (currentIterator != null) currentCloseableIterator.close(); final Interval interval=this.intervals.next(); final Interval previousInterval=this.lastInterval; this.currentCloseableIterator=this.reader.query(interval.getContig() interval.getStart() interval.getEnd()); this.currentIterator=this.currentCloseableIterator.stream().filter(ctx -> null == previousInterval || !overlapsInterval(ctx previousInterval)).iterator(); this.lastInterval=interval; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\ByIntervalListVariantContextIterator.java,hasNext,@Override public boolean  (){ return (this.currentIterator != null && this.currentIterator.hasNext()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\ByIntervalListVariantContextIterator.java,next,@Override public VariantContext  (){ final VariantContext ctx=this.currentIterator.next(); advance(); return ctx; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\ByIntervalListVariantContextIterator.java,overlapsInterval,private boolean  (final VariantContext ctx final Interval interval){ if (!ctx.getContig().equals(interval.getContig())) return false; else if (CoordMath.overlaps(ctx.getStart() ctx.getEnd() interval.getStart() interval.getEnd())) return true; else return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\ByIntervalListVariantContextIterator.java,remove,@Override public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\util\VariantType.java,getVariantTypeFromOrdinal,public static VariantType  (int ordinal){ return VariantType.class.getEnumConstants()[ordinal]; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\CollectVariantCallingMetrics.java,calculateDerivedFields,@Override public void  (){ super.calculateDerivedFields(); HET_HOMVAR_RATIO=numHets / (double)numHomVar; PCT_GQ0_VARIANTS=TOTAL_GQ0_VARIANTS / (double)(numHets + numHomVar); TOTAL_HET_DEPTH=refAlleleObs + altAlleleObs; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\CollectVariantCallingMetrics.java,calculateFromDerivedFields,public void  (){ numHomVar=invertFromRatio(TOTAL_SNPS HET_HOMVAR_RATIO); numHets=TOTAL_SNPS - numHomVar; calculateFromDerivedFields(TOTAL_HET_DEPTH); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\CollectVariantCallingMetrics.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsReadable(DBSNP); if (TARGET_INTERVALS != null) IOUtil.assertFileIsReadable(TARGET_INTERVALS); if (SEQUENCE_DICTIONARY != null) IOUtil.assertFileIsReadable(SEQUENCE_DICTION
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\CollectVariantCallingMetrics.java,foldInto,public static <T extends VariantCallingSummaryMetrics>void  (final T target final Collection<T> metrics){ metrics.forEach(target::merge); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\CollectVariantCallingMetrics.java,getFileExtension,"public static String  (){ return ""variant_calling_detail_metrics""; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\CollectVariantCallingMetrics.java,invertFromRatio,private static long  (final long sum final Double ratio){ return ratio.isNaN() ? 0L : Math.round(sum / (ratio + 1.0)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\CollectVariantCallingMetrics.java,main,public static void  (final String[] args){ new CollectVariantCallingMetrics().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\DepthFilter.java,DepthFilter,public  (final int minDepth){ this.minDepth=minDepth; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\DepthFilter.java,filter,"@Override public String  (final VariantContext ctx final Genotype gt){ if (gt.getDP() < minDepth) return ""LowDP""; else return null; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\CallingMetricAccumulator.java,CallingMetricAccumulator,public  (final DbSnpBitSetUtil.DbSnpBitSets dbsnp){ this.dbsnp=dbsnp; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\CallingMetricAccumulator.java,Result, (final VariantCallingSummaryMetrics summary final Collection<VariantCallingDetailMetrics> details){ this.summary=summary; this.details=details; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\CallingMetricAccumulator.java,accumulate,@Override public void  (final VariantContext vc){ progress.record(vc.getContig() vc.getStart()); if (!isVariantExcluded(vc)) { final String singletonSample=getSingletonSample(vc); updateSummaryMetric(summaryMetric null vc singletonSample != null); vc.getS
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\CallingMetricAccumulator.java,getSingletonSample,protected static String  (final VariantContext vc){ final String[] sampleName=new String[1]; if (vc.getGenotypes().stream().filter(genotype -> genotype.isHet() || genotype.isHomVar()).limit(2).peek(genotype -> sampleName[0]=genotype.getSampleName()).mapToInt(genotype -> genotype.isHet() ? 1 : 2).reduce(Integer::sum).orElse(0) == 1) { return sampleName[0]; } else { return null; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\CallingMetricAccumulator.java,isVariantExcluded,static private boolean  (final VariantContext vc){ return !vc.isVariant() || vc.getGenotypes().stream().allMatch(Genotype::isHomRef); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\CallingMetricAccumulator.java,merge,public static Result  (final Collection<Result> results){ final Collection<VariantCallingDetailMetrics> details=new ArrayList<>(); final Collection<VariantCallingSummaryMetrics> summaries=new ArrayList<>(); results.stream().forEach(result -> { summaries.add(result.summary); details.addAll(result.details); } ); final Map<String List<VariantCallingDetailMetrics>> sampleDetailsMap=details.stream().collect(Collectors.groupingBy(vcDetailMetrics -> vcDetailMetrics.SAMPLE_ALIAS)); final Collection<CollectVariantCallingMetrics.VariantCallingDetailMetrics> collapsedDetails=new ArrayList<>(); sampleDetailsMap.values().stream().forEach(sampleDetails -> { final VariantCallingDetailMetrics collapsed=new VariantCallingDetailMetrics(); VariantCallingDetailMetrics.foldInto(collapsed sampleDetails); collapsedDetails.add(collapsed); collapsed.calculateDerivedFields(); } ); final VariantCallingSummaryMetrics collapsedSummary=new VariantCallingSummaryMetrics(); VariantCallingSummaryMetrics.foldInto(collapsedSummary summaries); collapsedSummary.calculateDerivedFields(); return new Result(collapsedSummary collapsedDetails); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\CallingMetricAccumulator.java,result,public Result  (){ final Collection<VariantCallingDetailMetrics> values=sampleMetricsMap.values(); values.forEach(CollectVariantCallingMetrics.VariantCallingDetailMetrics::calculateDerivedFields); summaryMetric.calculateDerivedFields(); return new Result(summaryMetric values); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\CallingMetricAccumulator.java,setup,public void  (final VCFHeader vcfHeader){ vcfHeader.getGenotypeSamples().stream().forEach(sampleName -> sampleMetricsMap.get(sampleName)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\CallingMetricAccumulator.java,updateDetailMetric,private void  (final VariantCallingDetailMetrics metric final Genotype genotype final VariantContext vc final boolean hasSingletonSample){ updateSummaryMetric(metric genotype vc hasSingletonSample); if (genotype != null && !vc.isFiltered()) { if (genotype.getGQ() == 0) { ++metric.TOTAL_GQ0_VARIANTS; } if (genotype.isHet()) { ++metric.numHets; } else if (genotype.isHomVar()) { ++metric.numHomVar; } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\CallingMetricAccumulator.java,updateSummaryMetric,"private void  (final VariantCallingSummaryMetrics metric final Genotype genotype final VariantContext vc final boolean hasSingletonSample){ if (genotype != null && genotype.isNoCall()) return; if (vc.isFiltered()) { if (vc.isSNP()) metric.FILTERED_SNPS++; else if (vc.isIndel()) metric.FILTERED_INDELS++; return; } if (hasSingletonSample) { ++metric.NUM_SINGLETONS; } if (vc.isBiallelic() && vc.isSNP()) { final boolean isInDbSnp=dbsnp.snps.isDbSnpSite(vc.getContig() vc.getStart()); final boolean isTransition=VariantContextUtils.isTransition(vc); metric.TOTAL_SNPS++; if (isInDbSnp) { metric.NUM_IN_DB_SNP++; if (isTransition) metric.dbSnpTransitions++; else metric.dbSnpTransversions++; } else { if (isTransition) metric.novelTransitions++; else metric.novelTransversions++; } if (genotype != null && genotype.isHet()) { final int[] alleleDepths=genotype.getAD(); if (alleleDepths != null) { final int indexOfRef=vc.getAlleleIndex(vc.getReference()); final int indexOfAlt=(indexOfRef + 1) % 2; metric.refAlleleObs+=alleleDepths[indexOfRef]; metric.altAlleleObs+=alleleDepths[indexOfAlt]; summaryMetric.refAlleleObs+=alleleDepths[indexOfRef]; summaryMetric.altAlleleObs+=alleleDepths[indexOfAlt]; } else { LOG.debug(""Skipping aggregation of genotype due to missing allele depth data: "" genotype "".""); } } } else if (vc.isSNP() && vc.getAlternateAlleles().size() > 1) { metric.TOTAL_MULTIALLELIC_SNPS++; if (dbsnp.snps.isDbSnpSite(vc.getContig() vc.getStart())) metric.NUM_IN_DB_SNP_MULTIALLELIC++; } else if (vc.isIndel() && !vc.isComplexIndel()) { final boolean isInDbSnp=dbsnp.indels.isDbSnpSite(vc.getContig() vc.getStart()); final boolean isInsertion=vc.isSimpleInsertion(); metric.TOTAL_INDELS++; if (isInDbSnp) { metric.NUM_IN_DB_SNP_INDELS++; if (isInsertion) metric.dbSnpInsertions++; else metric.dbSnpDeletions++; } else { if (isInsertion) metric.novelInsertions++; else { metric.novelDeletions++; } } } else if (vc.isComplexIndel()) { metric.TOTAL_COMPLEX_INDELS++; if (dbsnp.indels.isDbSnpSite(vc.getContig() vc.getStart())) metric.NUM_IN_DB_SNP_COMPLEX_INDELS++; } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\FilterApplyingVariantIterator.java,FilterApplyingVariantIterator,public  (final Iterator<VariantContext> iterator final Collection<VariantFilter> filters final Collection<GenotypeFilter> gtFilters){ this.iterator=iterator; this.filters=filters.toArray(new VariantFilter[filters.size()]); this.gtFilters=gtFilters.toArray(new GenotypeFilter[gtFilters.size()]); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\FilterApplyingVariantIterator.java,close,@Override public void  (){ CloserUtil.close(this.iterator); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\FilterApplyingVariantIterator.java,hasNext,@Override public boolean  (){ return this.iterator.hasNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\FilterApplyingVariantIterator.java,next,@Override public VariantContext  (){ final VariantContext ctx=this.iterator.next(); final Set<String> filterStrings=new HashSet<String>(); for ( final VariantFilter filter : this.filters) { final String val=filter.filter(ctx); if (val != null) filterStrin
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\FilterApplyingVariantIterator.java,remove,"@Override public void  (){ throw new UnsupportedOperationException(""remove() not supported by FilterApplyingVariantIterator.""); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\FilterVcf.java,FilterVcf,public  (){ this.CREATE_INDEX=true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\FilterVcf.java,VariantContextJavascriptFilter,"private  (final File scriptFile final VCFHeader header) throws IOException { super(scriptFile header); this.scriptFile=scriptFile; String fname=IOUtil.basename(scriptFile); if (fname.isEmpty()) fname=""JSFILTER""; this.filterName=fname; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\FilterVcf.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); VCFFileReader in=null; VariantContextWriter out=null; try { in=new VCFFileReader(INPUT false); final List<VariantFilter> variantFilters=new ArrayList<>(4
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\FilterVcf.java,filter,@Override public String  (final VariantContext ctx){ return (super.accept(ctx) ? null : this.filterName); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\FilterVcf.java,headerLines,"@Override public List<VCFFilterHeaderLine>  (){ return CollectionUtil.makeList(new VCFFilterHeaderLine(this.filterName ""Variant Filtered by Javascript file "" + this.scriptFile)); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\FilterVcf.java,isVcfOrBcf,private boolean  (final File file){ final String fileName=file.getName(); return fileName.endsWith(IOUtil.VCF_FILE_EXTENSION) || fileName.endsWith(IOUtil.BCF_FILE_EXTENSION); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\FilterVcf.java,main,public static void  (final String[] args){ new FilterVcf().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\FisherStrandFilter.java,FisherStrandFilter,public  (final double maxPhredScalePValue){ this.maxPhredScalePValue=maxPhredScalePValue; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\FisherStrandFilter.java,filter,"@Override public String  (final VariantContext ctx){ final double fs=ctx.getAttributeAsDouble(""FS"" 0); return (fs > maxPhredScalePValue) ? ""StrandBias"" : null; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\FisherStrandFilter.java,headerLines,"@Override public List<VCFFilterHeaderLine>  (){ return CollectionUtil.makeList(new VCFFilterHeaderLine(""StrandBias"" ""Site exhibits excessive allele/strand correlation."")); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\AlleleBalanceFilter.java,AlleleBalanceFilter,public  (final double hetAlleleBalance){ this.hetAlleleBalance=hetAlleleBalance; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\AlleleBalanceFilter.java,filter,@Override public String  (final VariantContext ctx){ if (ctx.getHetCount() == 0) return null; final Map<List<Allele> Counts> countsMap=new HashMap<List<Allele> Counts>(); for ( final Genotype gt : ctx.getGenotypesOrderedByName()) { if (gt.isNoCall() || !g
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\AlleleBalanceFilter.java,headerLines,"@Override public List<VCFFilterHeaderLine>  (){ return CollectionUtil.makeList(new VCFFilterHeaderLine(AB_FILTER ""Heterozygote allele balance below required threshold."")); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\QdFilter.java,QdFilter,public  (final double minimumQd){ this.minimumQd=minimumQd; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\QdFilter.java,filter,"@Override public String  (final VariantContext ctx){ final double qd=ctx.getAttributeAsDouble(""QD"" -1d); if (qd >= 0 && qd < minimumQd) { return FILTER_NAME; } else { return null; } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\QdFilter.java,headerLines,"@Override public List<VCFFilterHeaderLine>  (){ return CollectionUtil.makeList(new VCFFilterHeaderLine(FILTER_NAME ""Site exhibits QD value below a hard limit."")); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\FixVcfHeader.java,customCommandLineValidation,"@Override protected String[]  (){ if (HEADER != null && 0 <= CHECK_FIRST_N_RECORDS) return new String[]{""CHECK_FIRST_N_RECORDS should no be specified when HEADER is specified""}; return super.customCommandLineValidation(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\FixVcfHeader.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); if (HEADER != null) IOUtil.assertFileIsReadable(HEADER); IOUtil.assertFileIsWritable(OUTPUT); final VCFFileReader reader=new VCFFileReader(INPUT false); final VCFHeader outHeader; if (HEADER
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\GenotypeQualityFilter.java,GenotypeQualityFilter,public  (final int minGq){ this.minGq=minGq; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\filter\GenotypeQualityFilter.java,filter,"@Override public String  (final VariantContext ctx final Genotype gt){ if (gt.getGQ() < minGq) return ""LowGQ""; else return null; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GA4GHScheme.java,initiateScheme,@Override protected void  (){ addRow(CallState.MISSING NA TN_ONLY TN_FN FN_ONLY FN_ONLY EMPTY EMPTY EMPTY EMPTY EMPTY EMPTY); addRow(CallState.HOM_REF TN_ONLY TN_ONLY TN_FN FN_ONLY FN_ONLY EMPTY EMPTY EMPTY EMPTY EMPTY EMPTY); addRow(CallState.HET_REF_VAR
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GA4GHSchemeWithMissingAsHomRef.java,initiateScheme,@Override protected void  (){ addRow(CallState.MISSING TN_ONLY TN_ONLY TN_FN FN_ONLY FN_ONLY EMPTY EMPTY EMPTY EMPTY EMPTY EMPTY); addRow(CallState.HOM_REF TN_ONLY TN_ONLY TN_FN FN_ONLY FN_ONLY EMPTY EMPTY EMPTY EMPTY EMPTY EMPTY); addRow(CallState.HET_RE
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\FixVcfHeader.java,enforceSameSamples,"private void  (final VCFHeader readerHeader final VCFHeader inputHeader){ final ArrayList<String> readerSamples=readerHeader.getSampleNamesInOrder(); final ArrayList<String> inputSamples=inputHeader.getSampleNamesInOrder(); if (readerSamples.size() != inputSamples.size()) { throw new PicardException(""The input VCF had a different # of samples than the input VCF header.""); } for (int i=0; i < readerSamples.size(); i++) { if (!readerSamples.get(i).equals(inputSamples.get(i))) { throw new PicardException(String.format(""Mismatch in the %dth sample: '%s' != '%s'"" i readerSamples.get(i) inputSamples.get(i))); } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\FixVcfHeader.java,main,public static void  (final String[] args){ new FixVcfHeader().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceContingencyMetrics.java,GenotypeConcordanceContingencyMetrics,public  (final VariantContext.Type variantType final GenotypeConcordanceCounts concordanceCounts final String truthSample final String callSample final boolean missingSitesFlag){ this.VARIANT_TYPE=variantType; this.TRUTH_SAMPLE=truthSample; this.CALL_SAMPLE=callSample; final GenotypeConcordanceSchemeFactory schemeFactory=new GenotypeConcordanceSchemeFactory(); final GenotypeConcordanceScheme scheme=schemeFactory.getScheme(missingSitesFlag); scheme.validateScheme(); concordanceCounts.validateCountsAgainstScheme(scheme); Map<ContingencyState Long> counts=concordanceCounts.getContingencyStateCounts(scheme); this.TP_COUNT=counts.get(ContingencyState.TP); this.TN_COUNT=counts.get(ContingencyState.TN); this.FP_COUNT=counts.get(ContingencyState.FP); this.FN_COUNT=counts.get(ContingencyState.FN); this.EMPTY_COUNT=counts.get(ContingencyState.EMPTY); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GatherVcfs.java,GatherVcfs,public  (){ CREATE_INDEX=true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GatherVcfs.java,areAllBlockCompressed,private boolean  (final List<File> input){ for ( final File f : input) { if (VCFFileReader.isBCF(f) || !AbstractFeatureReader.hasBlockCompressedExtension(f)) { return false; } } return true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GatherVcfs.java,assertSameSamplesAndValidOrdering,"private static void  (final List<File> inputFiles){ final VCFHeader header=new VCFFileReader(inputFiles.get(0) false).getFileHeader(); final SAMSequenceDictionary dict=header.getSequenceDictionary(); final VariantContextComparator comparator=new VariantContextComparator(header.getSequenceDictionary()); final List<String> samples=header.getGenotypeSamples(); File lastFile=null; VariantContext lastContext=null; for ( final File f : inputFiles) { final VCFFileReader in=new VCFFileReader(f false); try { dict.assertSameDictionary(in.getFileHeader().getSequenceDictionary()); } catch ( final AssertionError e) { log.error(""File #1: "" + inputFiles.get(0)); log.error(""File #2: "" + f); throw e; } final List<String> theseSamples=in.getFileHeader().getGenotypeSamples(); if (!samples.equals(theseSamples)) { final SortedSet<String> s1=new TreeSet<>(samples); final SortedSet<String> s2=new TreeSet<>(theseSamples); s1.removeAll(theseSamples); s2.removeAll(samples); throw new IllegalArgumentException(""VCFs do not have identical sample lists."" + "" Samples unique to first file: "" + s1 + "". Samples unique to ""+ f.getAbsolutePath()+ "": ""+ s2+ "".""); } final CloseableIterator<VariantContext> variantIterator=in.iterator(); if (variantIterator.hasNext()) { final VariantContext currentContext=variantIterator.next(); if (lastContext != null && comparator.compare(lastContext currentContext) >= 0) { throw new IllegalArgumentException(""First record in file "" + f.getAbsolutePath() + "" is not after first record in ""+ ""previous file ""+ lastFile.getAbsolutePath()); } lastContext=currentContext; lastFile=f; } CloserUtil.close(in); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GatherVcfs.java,doWork,"@Override protected int  (){ log.info(""Checking inputs.""); INPUT=IOUtil.unrollFiles(INPUT IOUtil.VCF_EXTENSIONS); for ( final File f : INPUT) IOUtil.assertFileIsReadable(f); IOUtil.assertFileIsWritable(OUTPUT); final SAMSequenceDictionary sequenceDictiona"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GatherVcfs.java,gatherConventionally,"private static void  (final SAMSequenceDictionary sequenceDictionary final boolean createIndex final List<File> inputFiles final File outputFile){ final EnumSet<Options> options=EnumSet.copyOf(VariantContextWriterBuilder.DEFAULT_OPTIONS); if (createIndex) { options.add(Options.INDEX_ON_THE_FLY); } else { options.remove(Options.INDEX_ON_THE_FLY); } final VariantContextWriter out=new VariantContextWriterBuilder().setOptions(options).setOutputFile(outputFile).setReferenceDictionary(sequenceDictionary).build(); final ProgressLogger progress=new ProgressLogger(log 10000); VariantContext lastContext=null; File lastFile=null; VCFHeader firstHeader=null; VariantContextComparator comparator=null; for ( final File f : inputFiles) { log.debug(""Gathering from file: "" f.getAbsolutePath()); final VCFFileReader variantReader=new VCFFileReader(f false); final PeekableIterator<VariantContext> variantIterator=new PeekableIterator<>(variantReader.iterator()); final VCFHeader header=variantReader.getFileHeader(); if (firstHeader == null) { firstHeader=header; out.writeHeader(firstHeader); comparator=new VariantContextComparator(firstHeader.getContigLines()); } if (lastContext != null && variantIterator.hasNext()) { final VariantContext vc=variantIterator.peek(); if (comparator.compare(vc lastContext) <= 0) { throw new IllegalArgumentException(""First variant in file "" + f.getAbsolutePath() + "" is at ""+ vc.getContig()+ "":""+ vc.getStart()+ "" but last variant in earlier file ""+ lastFile.getAbsolutePath()+ "" is at ""+ lastContext.getContig()+ "":""+ lastContext.getStart()); } } while (variantIterator.hasNext()) { lastContext=variantIterator.next(); out.add(lastContext); progress.record(lastContext.getContig() lastContext.getStart()); } lastFile=f; CloserUtil.close(variantIterator); CloserUtil.close(variantReader); } out.close(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GatherVcfs.java,gatherWithBlockCopying,"private static void  (final List<File> vcfs final File output){ try { final FileOutputStream out=new FileOutputStream(output); boolean isFirstFile=true; for ( final File f : vcfs) { log.info(""Gathering "" + f.getAbsolutePath()); final FileInputStream in=new FileInputStream(f); final BlockCompressedInputStream.FileTermination term=BlockCompressedInputStream.checkTermination(f); if (term == BlockCompressedInputStream.FileTermination.DEFECTIVE) { throw new PicardException(f.getAbsolutePath() + "" does not have a valid GZIP block at the end of the file.""); } if (!isFirstFile) { final BlockCompressedInputStream blockIn=new BlockCompressedInputStream(in false); boolean lastByteNewline=true; while (blockIn.available() > 0) { final int blockLength=blockIn.available(); final byte[] blockContents=new byte[blockLength]; final int read=blockIn.read(blockContents); if (blockLength == 0 || read != blockLength) throw new IllegalStateException(""Could not read available bytes from BlockCompressedInputStream.""); int firstNonHeaderByteIndex=-1; for (int i=0; i < read; ++i) { final byte b=blockContents[i]; final boolean thisByteNewline=(b == '\n' || b == '\r'); if (lastByteNewline && !thisByteNewline && b != '#') { firstNonHeaderByteIndex=i; break; } lastByteNewline=thisByteNewline; } if (firstNonHeaderByteIndex >= 0) { final BlockCompressedOutputStream blockOut=new BlockCompressedOutputStream(out null); blockOut.write(blockContents firstNonHeaderByteIndex blockContents.length - firstNonHeaderByteIndex); blockOut.flush(); break; } } } final long currentPos=in.getChannel().position(); final long length=f.length(); final long skipLast=(term == BlockCompressedInputStream.FileTermination.HAS_TERMINATOR_BLOCK) ? BlockCompressedStreamConstants.EMPTY_GZIP_BLOCK.length : 0; final long bytesToWrite=length - skipLast - currentPos; IOUtil.transferByStream(in out bytesToWrite); in.close(); isFirstFile=false; } out.write(BlockCompressedStreamConstants.EMPTY_GZIP_BLOCK); out.close(); } catch ( final IOException ioe) { throw new RuntimeIOException(ioe); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GatherVcfs.java,main,public static void  (final String[] args){ new GatherVcfs().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceSchemeFactory.java,getScheme,public GenotypeConcordanceScheme  (final boolean isMissingHomRef){ if (isMissingHomRef) { return new GA4GHSchemeWithMissingAsHomRef(); } else { return new GA4GHScheme(); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceScheme.java,GenotypeConcordanceScheme,public  (){ initiateScheme(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceScheme.java,addRow,"protected void  (final CallState callState final ContingencyState[]... concordanceStateArrays){ if (concordanceStateArrays.length != TruthState.values().length) { throw new PicardException(""Length mismatch between concordanceStateArrays and TruthState.values()""); } for (int i=0; i < concordanceStateArrays.length; i++) { scheme.put(new TruthAndCallStates(TruthState.values()[i] callState) concordanceStateArrays[i]); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceScheme.java,getConcordanceStateArray,public ContingencyState[]  (final TruthAndCallStates truthAndCallStates){ return this.scheme.get(truthAndCallStates); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceScheme.java,getContingencyStateSet,public Set<ContingencyState>  (final ContingencyState[] contingencyStateArray){ final Set<ContingencyState> contingencyStateSet=new HashSet<ContingencyState>(); Collections.addAll(contingencyStateSet contingencyStateArray); return contingencyStateSet; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceScheme.java,getContingencyStateString,"public String  (final TruthState truthState final CallState callState){ final ContingencyState[] contingencyStateArray=getConcordanceStateArray(truthState callState); return (contingencyStateArray.length == 0) ? ""EMPTY"" : StringUtil.join("" "" contingencyStateArray); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceCounts.java,Ppv,public double  (final GenotypeConcordanceScheme scheme final CallState[] callStateList){ double numerator=0.0; double denominator=0.0; scheme.validateScheme(); for ( final CallState callState : callStateList) { for ( final TruthState truthState : TruthState.values()) { final TruthAndCallStates truthAndCallStates=new TruthAndCallStates(truthState callState); final long count=getCount(truthAndCallStates); for ( final ContingencyState contingencyState : scheme.getConcordanceStateArray(truthAndCallStates)) { if (ContingencyState.TP == contingencyState) { numerator+=count; denominator+=count; } else if (ContingencyState.FP == contingencyState) { denominator+=count; } } } } return (numerator / denominator); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceCounts.java,calculateGenotypeConcordance,public double  (final GenotypeConcordanceScheme scheme final boolean missingSitesFlag){ return calculateGenotypeConcordanceUtil(scheme missingSitesFlag true); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceCounts.java,calculateGenotypeConcordanceUtil,private double  (final GenotypeConcordanceScheme scheme final boolean missingSitesFlag final boolean includeHomRef){ double numerator=0.0; double denominator=0.0; scheme.validateScheme(); final TruthState[] allTruthStates=TruthState.values(); final CallState[] allCallStates=CallState.values(); for ( final TruthState truthState : allTruthStates) { for ( final CallState callState : allCallStates) { if (!missingSitesFlag && isMissing(truthState callState)) { continue; } else if (includeHomRef || isVar(truthState callState)) { final TruthAndCallStates truthAndCallStates=new TruthAndCallStates(truthState callState); final long count=getCount(truthAndCallStates); if (truthState.getCode() == callState.getCode()) { numerator+=count; } denominator+=count; } } } return (denominator > 0.0 ? (numerator / denominator) : Double.NaN); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceCounts.java,calculateNonRefGenotypeConcordance,public double  (final GenotypeConcordanceScheme scheme final boolean missingSitesFlag){ return calculateGenotypeConcordanceUtil(scheme missingSitesFlag false); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceCounts.java,getContingencyStateCounts,public Map<ContingencyState Long>  (final GenotypeConcordanceScheme scheme){ scheme.validateScheme(); final Map<ContingencyState Long> counts=new EnumMap<ContingencyState Long>(ContingencyState.class); for ( final ContingencyState contingencyState : ContingencyState.values()) { counts.put(contingencyState 0L); } for ( final TruthState truthState : TruthState.values()) { for ( final CallState callState : CallState.values()) { final TruthAndCallStates truthAndCallStates=new TruthAndCallStates(truthState callState); final ContingencyState[] contingencyStateArray=scheme.getConcordanceStateArray(truthAndCallStates); for ( final ContingencyState contingencyState : contingencyStateArray) { final long newCount=counts.get(contingencyState) + getCount(truthAndCallStates); counts.put(contingencyState newCount); } } } return counts; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceCounts.java,getContingencyStateSet,private Set<ContingencyState>  (final ContingencyState[] contingencyStateArray){ final Set<ContingencyState> contingencyStateSet=new HashSet<ContingencyState>(); Collections.addAll(contingencyStateSet contingencyStateArray); return contingencyStateSet; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceCounts.java,getCount,public long  (final TruthAndCallStates truthAndCallStates){ final Histogram.Bin<TruthAndCallStates> bin=this.counter.get(truthAndCallStates); return (bin == null ? 0L : (long)bin.getValue()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceCounts.java,getCounterSize,public double  (){ return this.counter.getCount(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceCounts.java,getSensitivity,public double  (final GenotypeConcordanceScheme scheme final TruthState[] truthStateArray){ double numerator=0.0; double denominator=0.0; scheme.validateScheme(); for ( final TruthState truthState : truthStateArray) { for ( final CallState callState : CallState.values()) { final TruthAndCallStates truthAndCallStates=new TruthAndCallStates(truthState callState); final long count=getCount(truthAndCallStates); for ( final ContingencyState contingencyState : scheme.getConcordanceStateArray(truthAndCallStates)) { if (ContingencyState.TP == contingencyState) { numerator+=count; denominator+=count; } else if (ContingencyState.FN == contingencyState) { denominator+=count; } } } } return (numerator / denominator); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceCounts.java,getSpecificity,public double  (final GenotypeConcordanceScheme scheme final TruthState[] truthStateArray){ double numerator=0.0; double denominator=0.0; scheme.validateScheme(); for ( final TruthState truthState : truthStateArray) { for ( final CallState callState : CallState.values()) { final TruthAndCallStates truthAndCallStates=new TruthAndCallStates(truthState callState); final long count=getCount(truthAndCallStates); for ( final ContingencyState contingencyState : scheme.getConcordanceStateArray(truthAndCallStates)) { if (ContingencyState.TN == contingencyState) { numerator+=count; denominator+=count; } else if (ContingencyState.FP == contingencyState) { denominator+=count; } } } } return (numerator / denominator); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceCounts.java,getSum,public long  (){ return getSum(new HashSet<TruthState>(Arrays.asList(TruthState.values())) new HashSet<CallState>(Arrays.asList(CallState.values()))); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceCounts.java,increment,public void  (final TruthAndCallStates truthAndCallStates final double count){ this.counter.increment(truthAndCallStates count); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceCounts.java,isMissing,public boolean  (final TruthState truthState final CallState callState){ return truthState == TruthState.MISSING || callState == CallState.MISSING; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceCounts.java,isVar,public boolean  (final TruthState truthState final CallState callState){ final List<TruthState> listOfTruthStates=Arrays.asList(TruthState.HOM_VAR1 TruthState.HET_REF_VAR1 TruthState.HET_VAR1_VAR2); final List<CallState> listOfCallStates=Arrays.asList(CallState.HET_REF_VAR1 CallState.HET_REF_VAR2 CallState.HET_REF_VAR3 CallState.HET_VAR1_VAR2 CallState.HET_VAR1_VAR3 CallState.HET_VAR3_VAR4 CallState.HOM_VAR1 CallState.HOM_VAR2 CallState.HOM_VAR3); return listOfTruthStates.contains(truthState) || listOfCallStates.contains(callState); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceCounts.java,validateCountsAgainstScheme,"public void  (final GenotypeConcordanceScheme scheme){ final Set<ContingencyState> naContingencyStates=getContingencyStateSet(GenotypeConcordanceScheme.NA); for ( final TruthState truthState : TruthState.values()) { for ( final CallState callState : CallState.values()) { final TruthAndCallStates truthAndCallStates=new TruthAndCallStates(truthState callState); if (0 < getCount(truthAndCallStates)) { final Set<ContingencyState> contingencyStates=getContingencyStateSet(scheme.getConcordanceStateArray(truthAndCallStates)); if (contingencyStates.containsAll(naContingencyStates)) { throw new PicardException(String.format(""Found counts for an illegal set of states: [%s  %s]"" truthState.name() callState.name())); } } } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceStates.java,CallState,private  (final int code){ this.code=code; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceStates.java,TruthAndCallStates,public  (final TruthState truthState final CallState callState){ this.truthState=truthState; this.callState=callState; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceStates.java,TruthState, (final int code){ this.code=code; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceStates.java,compareTo,@Override public int  (final TruthAndCallStates that){ int result=this.truthState.compareTo(that.truthState); if (result == 0) result=this.callState.compareTo(that.callState); return result; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceStates.java,equals,@Override public boolean  (final Object o){ if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; return compareTo((TruthAndCallStates)o) == 0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceStates.java,getCode,public int  (){ return this.code; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceStates.java,getCodeMap,static Map<Integer CallState>  (){ final Map<Integer CallState> map=new HashMap<>(); final CallState callValues[]=CallState.values(); for (int i=0; i < callValues.length; i++) { map.put(callValues[i].code callValues[i]); } return map; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceStates.java,getHet,public static CallState  (int allele0idx int allele1idx){ if (allele0idx > allele1idx) { final int temp=allele0idx; allele0idx=allele1idx; allele1idx=temp; } if (allele0idx == 0) { if (allele1idx == 1) return HET_REF_VAR1; if (allele1idx == 2) return HET_REF_VAR2; if (allele1idx == 3) return HET_REF_VAR3; assert false; return null; } if (allele0idx == 1) { if (allele1idx == 2) return HET_VAR1_VAR2; if (allele1idx == 3) return HET_VAR1_VAR3; assert false; return null; } if (allele0idx == 2 && allele1idx == 3) return HET_VAR3_VAR4; if (allele0idx == 3 && allele1idx == 4) return HET_VAR3_VAR4; assert false; return null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceStates.java,getHom,public static CallState  (final int alleleIdx){ if (alleleIdx == 0) return HOM_REF; if (alleleIdx == 1) return HOM_VAR1; if (alleleIdx == 2) return HOM_VAR2; if (alleleIdx == 3) return HOM_VAR3; assert false; return null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceStates.java,getVar,public static TruthState  (final int allele0idx final int allele1idx){ if (allele0idx == 0 && allele1idx == 1) return HET_REF_VAR1; if (allele0idx == 1 && allele1idx == 0) return HET_REF_VAR1; if (allele0idx == 1 && allele1idx == 2) return HET_VAR1_VAR2; if (allele0idx == 2 && allele1idx == 1) return HET_VAR1_VAR2; assert false; return null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceStates.java,hashCode,@Override public int  (){ int result=truthState.hashCode(); result=31 * result + callState.hashCode(); return result; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordanceSummaryMetrics.java,GenotypeConcordanceSummaryMetrics,public  (final VariantContext.Type variantType final GenotypeConcordanceCounts concordanceCounts final String truthSample final String callSample final boolean missingSitesFlag){ this.VARIANT_TYPE=variantType; this.TRUTH_SAMPLE=truthSample; this.CALL_SAMPLE=callSample; final GenotypeConcordanceSchemeFactory schemeFactory=new GenotypeConcordanceSchemeFactory(); final GenotypeConcordanceScheme scheme=schemeFactory.getScheme(missingSitesFlag); scheme.validateScheme(); concordanceCounts.validateCountsAgainstScheme(scheme); this.HET_SENSITIVITY=concordanceCounts.getSensitivity(scheme GenotypeConcordanceCounts.HET_TRUTH_STATES); this.HET_PPV=concordanceCounts.Ppv(scheme GenotypeConcordanceCounts.HET_CALL_STATES); this.HET_SPECIFICITY=Double.NaN; this.HOMVAR_SENSITIVITY=concordanceCounts.getSensitivity(scheme GenotypeConcordanceCounts.HOM_VAR_TRUTH_STATES); this.HOMVAR_PPV=concordanceCounts.Ppv(scheme GenotypeConcordanceCounts.HOM_VAR_CALL_STATES); this.HOMVAR_SPECIFICITY=Double.NaN; this.VAR_SENSITIVITY=concordanceCounts.getSensitivity(scheme GenotypeConcordanceCounts.VAR_TRUTH_STATES); this.VAR_PPV=concordanceCounts.Ppv(scheme GenotypeConcordanceCounts.VAR_CALL_STATES); this.VAR_SPECIFICITY=concordanceCounts.getSpecificity(scheme GenotypeConcordanceCounts.VAR_TRUTH_STATES); this.GENOTYPE_CONCORDANCE=concordanceCounts.calculateGenotypeConcordance(scheme missingSitesFlag); this.NON_REF_GENOTYPE_CONCORDANCE=concordanceCounts.calculateNonRefGenotypeConcordance(scheme missingSitesFlag); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GvcfMetricAccumulator.java,GvcfMetricAccumulator,public  (final DbSnpBitSetUtil.DbSnpBitSets dbsnp){ super(dbsnp); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GvcfMetricAccumulator.java,accumulate,@Override public void  (final VariantContext vc){ final VariantContext subContext=vc.subContextFromSample(sample); super.accumulate(subContext); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GvcfMetricAccumulator.java,setup,"@Override public void  (final VCFHeader vcfHeader){ final List<String> samples=vcfHeader.getGenotypeSamples(); if (samples == null || samples.size() != 1) { throw new IllegalArgumentException(""Expected to have exactly 1 sample in a GVCF  found "" + ((sampl"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,Alleles,"public  (final OrderedSet<String> allAlleles final String truthAllele1 final String truthAllele2 final String callAllele1 final String callAllele2){ if (truthAllele1 == null && truthAllele2 != null) { throw new IllegalStateException(""truthAllele2 should be null if truthAllele1 is null.""); } if (callAllele1 == null && callAllele2 != null) { throw new IllegalStateException(""callAllele2 should be null if callAllele1 is null.""); } this.allAlleles=allAlleles; this.truthAllele1=(truthAllele1 == null) ? null : this.allAlleles.get(allAlleles.indexOf(truthAllele1)); this.truthAllele2=(truthAllele2 == null) ? null : this.allAlleles.get(allAlleles.indexOf(truthAllele2)); this.callAllele1=(callAllele1 == null) ? null : this.allAlleles.get(allAlleles.indexOf(callAllele1)); this.callAllele2=(callAllele2 == null) ? null : this.allAlleles.get(allAlleles.indexOf(callAllele2)); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,addMissingTruthAndMissingCallStates,public static void  (final double numVariants final long intervalBaseCount final GenotypeConcordanceCounts counter){ final double countMissingMissing=intervalBaseCount - numVariants; final TruthAndCallStates missingMissing=new TruthAndCallStates(TruthState.MISSING CallState.MISSING); counter.increment(missingMissing countMissingMissing); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,addToGenotypes,private void  (final List<Genotype> genotypes final VariantContext ctx final String inputSampleName final String outputSampleName final List<Allele> allAlleles final List<Allele> ctxAlleles final boolean missingSitesHomRef){ if (ctx != null && !ctxAlleles.isEmpty()) { final Genotype genotype=ctx.getGenotype(inputSampleName); final GenotypeBuilder genotypeBuilder=new GenotypeBuilder(genotype); genotypeBuilder.name(outputSampleName); genotypeBuilder.alleles(ctxAlleles); if (!genotype.hasAnyAttribute(VCFConstants.GENOTYPE_KEY)) { genotypeBuilder.attribute(VCFConstants.GENOTYPE_KEY MISSING_VALUE_v4); } genotypes.add(genotypeBuilder.make()); } else { final GenotypeBuilder genotypeBuilder=new GenotypeBuilder(outputSampleName); if (missingSitesHomRef) { genotypeBuilder.alleles(Arrays.asList(allAlleles.get(0) allAlleles.get(0))); } else { genotypeBuilder.alleles(Arrays.asList(Allele.NO_CALL Allele.NO_CALL)); } genotypes.add(genotypeBuilder.make()); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,asList,public List<Allele>  (){ if (allAlleles.isEmpty()) { return Collections.emptyList(); } else { final List<Allele> alleles=new ArrayList<>(this.allAlleles.size()); for (int idx=0; idx < this.allAlleles.size(); idx++) { alleles.add(Allele.create(this.allAlleles.get(idx) idx == 0)); } return alleles; } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,callAlleles,public List<Allele>  (){ if (allAlleles.isEmpty() || this.callAllele1 == null) { return Collections.emptyList(); } else { final Allele callAllele1=Allele.create(this.callAllele1 this.allAlleles.indexOf(this.callAllele1) == 0); final Allele callAllele2=Allele.create(this.callAllele2 this.allAlleles.indexOf(this.callAllele2) == 0); return Arrays.asList(callAllele1 callAllele2); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,classifyVariants,public static boolean  (final Optional<VariantContext> truthContext final String truthSample final Optional<VariantContext> callContext final String callSample final Optional<GenotypeConcordanceCounts> snpCounter final Optional<GenotypeConcordanceCounts> indelCounter final int minGq final int minDp final boolean ignoreFilteredStatus){ final VariantContext.Type truthVariantContextType=truthContext.map(VariantContext::getType).orElse(NO_VARIATION); final VariantContext.Type callVariantContextType=callContext.map(VariantContext::getType).orElse(NO_VARIATION); final TruthAndCallStates truthAndCallStates=determineState(truthContext.orElse(null) truthSample callContext.orElse(null) callSample minGq minDp ignoreFilteredStatus); if (truthVariantContextType == SNP) { if ((callVariantContextType == SNP) || (callVariantContextType == MIXED) || (callVariantContextType == NO_VARIATION)) { snpCounter.ifPresent(counter -> counter.increment(truthAndCallStates)); return true; } } else if (truthVariantContextType == INDEL) { if ((callVariantContextType == INDEL) || (callVariantContextType == MIXED) || (callVariantContextType == NO_VARIATION)) { indelCounter.ifPresent(counter -> counter.increment(truthAndCallStates)); return true; } } else if (truthVariantContextType == MIXED) { if (callVariantContextType == SNP) { snpCounter.ifPresent(counter -> counter.increment(truthAndCallStates)); return true; } else if (callVariantContextType == INDEL) { indelCounter.ifPresent(counter -> counter.increment(truthAndCallStates)); return true; } } else if (truthVariantContextType == NO_VARIATION) { if (callVariantContextType == SNP) { snpCounter.ifPresent(counter -> counter.increment(truthAndCallStates)); return true; } else if (callVariantContextType == INDEL) { indelCounter.ifPresent(counter -> counter.increment(truthAndCallStates)); return true; } } return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,customCommandLineValidation,@Override protected String[]  (){ IOUtil.assertFileIsReadable(TRUTH_VCF); IOUtil.assertFileIsReadable(CALL_VCF); final boolean usingIntervals=this.INTERVALS != null && !this.INTERVALS.isEmpty(); final List<String> errors=new ArrayList<String>(); if (using
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,determineState,"final public static TruthAndCallStates  (final VariantContext truthContext final String truthSample final VariantContext callContext final String callSample final int minGq final int minDp final Boolean ignoreFilteredStatus){ TruthState truthState=null; CallState callState=null; final GenotypeConcordanceStateCodes truthStateCode=getStateCode(truthContext truthSample minGq minDp); if (null != truthStateCode) { truthState=GenotypeConcordanceStates.truthMap.get(truthStateCode.ordinal()); } GenotypeConcordanceStateCodes callStateCode=getStateCode(callContext callSample minGq minDp); if (ignoreFilteredStatus && callStateCode == GenotypeConcordanceStateCodes.VC_FILTERED_CODE) { callStateCode=null; } if (null != callStateCode) { callState=GenotypeConcordanceStates.callMap.get(callStateCode.ordinal()); } final Alleles alleles=normalizeAlleles(truthState == null ? truthContext : null truthSample callState == null ? callContext : null callSample ignoreFilteredStatus); final OrderedSet<String> allAlleles=alleles.allAlleles; final String truthAllele1=alleles.truthAllele1; final String truthAllele2=alleles.truthAllele2; final String callAllele1=alleles.callAllele1; final String callAllele2=alleles.callAllele2; if (null == truthState) { final int allele0idx=allAlleles.indexOf(truthAllele1); final int allele1idx=allAlleles.indexOf(truthAllele2); if (allele0idx == allele1idx) { truthState=TruthState.getHom(allele0idx); } else { truthState=TruthState.getVar(allele0idx allele1idx); } } if (null == callState) { final int allele0idx=allAlleles.indexOf(callAllele1); final int allele1idx=allAlleles.indexOf(callAllele2); if (allele0idx == allele1idx) { callState=CallState.getHom(allele0idx); } else { callState=CallState.getHet(allele0idx allele1idx); } if (null == callState) { throw new IllegalStateException(""This should never happen... Could not classify the call variant: "" + callContext.getGenotype(callSample)); } } return new TruthAndCallStates(truthState callState); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,doWork,@Override protected int  (){ final File summaryMetricsFile=new File(OUTPUT + SUMMARY_METRICS_FILE_EXTENSION); final File detailedMetricsFile=new File(OUTPUT + DETAILED_METRICS_FILE_EXTENSION); final File contingencyMetricsFile=new File(OUTPUT + CONTINGENC
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,getIndelCounter,public GenotypeConcordanceCounts  (){ return indelCounter; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,getSnpCounter,public GenotypeConcordanceCounts  (){ return snpCounter; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,getStateCode,private static GenotypeConcordanceStateCodes  (final VariantContext ctx final String sample final int minGq final int minDp){ if (ctx == null) return MISSING_CODE; else if (ctx.isMixed()) return IS_MIXED_CODE; else if (ctx.isFiltered()) return VC_FILTERED_CODE; else { final Genotype genotype=ctx.getGenotype(sample); if (genotype.isNoCall()) return NO_CALL_CODE; else if (genotype.isFiltered()) return GT_FILTERED_CODE; else if ((genotype.getGQ() != -1) && (genotype.getGQ() < minGq)) return LOW_GQ_CODE; else if ((genotype.getDP() != -1) && (genotype.getDP() < minDp)) return LOW_DP_CODE; else if ((genotype.isMixed())) return NO_CALL_CODE; } return null; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,getStringSuffix,final static String  (final String longerString final String shorterString final String errorMsg){ if (!longerString.startsWith(shorterString)) { throw new IllegalStateException(errorMsg); } return longerString.substring(shorterString.length()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,getVariantContextWriter,private Optional<VariantContextWriter>  (final VCFFileReader truthReader final VCFFileReader callReader){ if (OUTPUT_VCF) { final File outputVcfFile=new File(OUTPUT + OUTPUT_VCF_FILE_EXTENSION); final VariantContextWriterBuilder builder=new VariantContextWriterBuilder().setOutputFile(outputVcfFile).setReferenceDictionary(callReader.getFileHeader().getSequenceDictionary()).setOption(Options.ALLOW_MISSING_FIELDS_IN_HEADER).setOption(Options.INDEX_ON_THE_FLY); final VariantContextWriter writer=builder.build(); final List<String> sampleNames=Arrays.asList(OUTPUT_VCF_CALL_SAMPLE_NAME OUTPUT_VCF_TRUTH_SAMPLE_NAME); final Set<VCFHeaderLine> headerLines=new HashSet<>(); headerLines.addAll(callReader.getFileHeader().getMetaDataInInputOrder()); headerLines.addAll(truthReader.getFileHeader().getMetaDataInInputOrder()); headerLines.add(CONTINGENCY_STATE_HEADER_LINE); writer.writeHeader(new VCFHeader(headerLines sampleNames)); return Optional.of(writer); } else { return Optional.empty(); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,indexExists,private boolean  (final File vcf){ return Tribble.indexFile(vcf).exists() || Tribble.tabixIndexFile(vcf).exists(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,main,public static void  (final String[] args){ new GenotypeConcordance().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,normalizeAlleles,"final protected static Alleles  (final VariantContext truthContext final String truthSample final VariantContext callContext final String callSample final Boolean ignoreFilteredStatus){ final Genotype truthGenotype  callGenotype; if (truthContext == null || truthContext.isMixed() || truthContext.isFiltered()) truthGenotype=null; else truthGenotype=truthContext.getGenotype(truthSample); if (callContext == null || callContext.isMixed() || (!ignoreFilteredStatus && callContext.isFiltered())) callGenotype=null; else callGenotype=callContext.getGenotype(callSample); String truthRef=(truthGenotype != null) ? truthContext.getReference().getBaseString() : null; String callRef=(callGenotype != null) ? callContext.getReference().getBaseString() : null; String truthAllele1=null; String truthAllele2=null; if (null != truthGenotype) { if (truthGenotype.getAlleles().size() != 2) { throw new IllegalStateException(""Genotype for Variant Context: "" + truthContext + "" does not have exactly 2 alleles""); } truthAllele1=truthGenotype.getAllele(0).getBaseString(); truthAllele2=truthGenotype.getAllele(1).getBaseString(); } String callAllele1=null; String callAllele2=null; if (null != callGenotype) { if (callGenotype.getAlleles().size() != 2) { throw new IllegalStateException(""Genotype for Variant Context: "" + callContext + "" does not have exactly 2 alleles""); } callAllele1=callGenotype.getAllele(0).getBaseString(); callAllele2=callGenotype.getAllele(1).getBaseString(); } if ((truthRef != null && callRef != null) && (!truthRef.equals(callRef))) { if (truthRef.length() < callRef.length()) { final String suffix=getStringSuffix(callRef truthRef ""Ref alleles mismatch between: "" + truthContext + "" and ""+ callContext); final int insertIdx=truthRef.length(); truthAllele1=truthAllele1.equals(Allele.NO_CALL_STRING) ? truthAllele1 : spliceOrAppendString(truthAllele1 suffix insertIdx); truthAllele2=truthAllele2.equals(Allele.NO_CALL_STRING) ? truthAllele2 : spliceOrAppendString(truthAllele2 suffix insertIdx); truthRef=truthRef + suffix; } else if (truthRef.length() > callRef.length()) { final String suffix=getStringSuffix(truthRef callRef ""Ref alleles mismatch between: "" + truthContext + "" and ""+ callContext); final int insertIdx=callRef.length(); callAllele1=callAllele1.equals(Allele.NO_CALL_STRING) ? callAllele1 : spliceOrAppendString(callAllele1 suffix insertIdx); callAllele2=callAllele2.equals(Allele.NO_CALL_STRING) ? callAllele2 : spliceOrAppendString(callAllele2 suffix insertIdx); callRef=callRef + suffix; } else { throw new IllegalStateException(""Ref alleles mismatch between: "" + truthContext + "" and ""+ callContext); } } final OrderedSet<String> allAlleles=new OrderedSet<String>(); if (truthGenotype != null || callGenotype != null) { allAlleles.smartAdd(truthGenotype == null ? callRef : truthRef); } if (null != truthGenotype) { allAlleles.smartAdd(truthAllele1); allAlleles.smartAdd(truthAllele2); } if (null != callGenotype) { if (allAlleles.indexOf(callAllele1) > 1 || allAlleles.indexOf(callAllele2) > 1) { allAlleles.remove(2); allAlleles.remove(1); allAlleles.smartAdd(truthAllele2); allAlleles.smartAdd(truthAllele1); } allAlleles.smartAdd(callAllele1); allAlleles.smartAdd(callAllele2); } return new Alleles(allAlleles truthAllele1 truthAllele2 callAllele1 callAllele2); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,outputDetailMetricsFile,public static void  (final VariantContext.Type variantType final MetricsFile<GenotypeConcordanceDetailMetrics ?> genotypeConcordanceDetailMetricsFile final GenotypeConcordanceCounts counter final String truthSampleName final String callSampleName final boolean missingSitesHomRef final boolean outputAllRows){ final GenotypeConcordanceSchemeFactory schemeFactory=new GenotypeConcordanceSchemeFactory(); final GenotypeConcordanceScheme scheme=schemeFactory.getScheme(missingSitesHomRef); scheme.validateScheme(); for ( final TruthState truthState : TruthState.values()) { for ( final CallState callState : CallState.values()) { final long count=counter.getCount(truthState callState); final String contingencyValues=scheme.getContingencyStateString(truthState callState); if (count > 0 || outputAllRows) { final GenotypeConcordanceDetailMetrics detailMetrics=new GenotypeConcordanceDetailMetrics(); detailMetrics.VARIANT_TYPE=variantType; detailMetrics.TRUTH_SAMPLE=truthSampleName; detailMetrics.CALL_SAMPLE=callSampleName; detailMetrics.TRUTH_STATE=truthState; detailMetrics.CALL_STATE=callState; detailMetrics.COUNT=count; detailMetrics.CONTINGENCY_VALUES=contingencyValues; genotypeConcordanceDetailMetricsFile.addMetric(detailMetrics); } } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,smartAdd,public boolean  (final T o){ if (!this.contains(o)) { return add(o); } return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,smartIndexOf,public int  (final T o){ smartAdd(o); return super.indexOf(o); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,spliceOrAppendString,static String  (final String destination final String toInsert final int insertIdx){ if (insertIdx <= destination.length()) { return destination.substring(0 insertIdx) + toInsert + destination.substring(insertIdx); } else { if (destination.length() > 0 && destination.substring(destination.length() - 1).equals(Allele.SPAN_DEL_STRING)) { return destination; } else { return destination + toInsert; } } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,truthAlleles,public List<Allele>  (){ if (allAlleles.isEmpty() || this.truthAllele1 == null) { return Collections.emptyList(); } else { final Allele truthAllele1=Allele.create(this.truthAllele1 this.allAlleles.indexOf(this.truthAllele1) == 0); final Allele truthAllele2=Allele.create(this.truthAllele2 this.allAlleles.indexOf(this.truthAllele2) == 0); return Arrays.asList(truthAllele1 truthAllele2); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\GenotypeConcordance.java,writeVcfTuple,"private void  (final VcfTuple tuple final VariantContextWriter writer final GenotypeConcordanceScheme scheme){ VariantContext truthContext=null  callContext=null; final List<Genotype> genotypes=new ArrayList<>(2); if (tuple.leftVariantContext.isPresent()) { truthContext=tuple.leftVariantContext.get(); } if (tuple.rightVariantContext.isPresent()) { callContext=tuple.rightVariantContext.get(); } if (truthContext != null && truthContext.isSymbolic() || callContext != null && callContext.isSymbolic()) { return; } final Alleles alleles=normalizeAlleles(truthContext TRUTH_SAMPLE callContext CALL_SAMPLE IGNORE_FILTER_STATUS); if (!alleles.allAlleles.isEmpty()) { if (truthContext == null && callContext == null) { throw new IllegalStateException(""Both truth and call contexts are null!""); } final VariantContextBuilder builder; final List<Allele> allAlleles=alleles.asList(); final List<Allele> truthAlleles=alleles.truthAlleles(); final List<Allele> callAlleles=alleles.callAlleles(); final Set<Allele> siteAlleles=new HashSet<>(); siteAlleles.addAll(allAlleles); siteAlleles.remove(Allele.NO_CALL); final VariantContext initialContext=(callContext == null) ? truthContext : callContext; builder=new VariantContextBuilder(initialContext.getSource() initialContext.getContig() initialContext.getStart() initialContext.getEnd() siteAlleles); builder.computeEndFromAlleles(allAlleles initialContext.getStart()); builder.log10PError(initialContext.getLog10PError()); addToGenotypes(genotypes truthContext TRUTH_SAMPLE OUTPUT_VCF_TRUTH_SAMPLE_NAME allAlleles truthAlleles MISSING_SITES_HOM_REF); addToGenotypes(genotypes callContext CALL_SAMPLE OUTPUT_VCF_CALL_SAMPLE_NAME allAlleles callAlleles false); builder.genotypes(genotypes); final TruthAndCallStates state=GenotypeConcordance.determineState(truthContext TRUTH_SAMPLE callContext CALL_SAMPLE MIN_GQ MIN_DP IGNORE_FILTER_STATUS); final ContingencyState[] stateArray=scheme.getConcordanceStateArray(state.truthState state.callState); builder.attribute(CONTINGENCY_STATE_TAG Arrays.asList(stateArray)); writer.add(builder.make()); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\FindMendelianViolations.java,buildDetector,private MendelianViolationDetector  (){ return new MendelianViolationDetector(ImmutableSet.copyOf(SKIP_CHROMS) ImmutableSet.copyOf(MALE_CHROMS) ImmutableSet.copyOf(FEMALE_CHROMS) MIN_HET_FRACTION MIN_GQ MIN_DP generateTrioMetricsBase() ImmutableList.copyOf(parIntervals.get()) progressLogger); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\FindMendelianViolations.java,customCommandLineValidation,"@Override protected String[]  (){ final List<String> errors=new ArrayList<>(); final Set<String> sexChroms=new HashSet<>(); sexChroms.addAll(FEMALE_CHROMS); sexChroms.retainAll(MALE_CHROMS); if (!sexChroms.isEmpty()) errors.add(""The following chromosomes "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\FindMendelianViolations.java,doWork,"@Override protected int  (){ final boolean outputVcfs=VCF_DIR != null; IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsReadable(TRIOS); IOUtil.assertFileIsWritable(OUTPUT); if (outputVcfs) IOUtil.assertDirectoryIsWritable(VCF_DIR); LOG.info(""Loadin"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\FindMendelianViolations.java,generateTrioMetricsBase,"private List<MendelianViolationMetrics>  (){ final List<MendelianViolationMetrics> metrics=new ArrayList<>(); for ( final PedFile.PedTrio trio : pedFile.get().values()) { final MendelianViolationMetrics m=new MendelianViolationMetrics(); m.MOTHER=trio.getMaternalId(); m.FATHER=trio.getPaternalId(); m.OFFSPRING=trio.getIndividualId(); m.FAMILY_ID=trio.getFamilyId(); m.OFFSPRING_SEX=trio.getSex(); metrics.add(m); } final Set<String> allSamples=new HashSet<>(inputHeader.get().getSampleNamesInOrder()); final Iterator<MendelianViolationMetrics> trioIterator=metrics.iterator(); while (trioIterator.hasNext()) { final MendelianViolationMetrics m=trioIterator.next(); final Set<String> trio=CollectionUtil.makeSet(m.MOTHER m.FATHER m.OFFSPRING); trio.removeAll(allSamples); if (!trio.isEmpty()) { LOG.warn(""Removing trio due to the following missing samples in VCF: "" + trio); trioIterator.remove(); } } return metrics; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\FindMendelianViolations.java,parseIntervalLists,"private Set<Interval>  (final Set<String> intervalLists){ final Set<Interval> intervals=new HashSet<>(intervalLists.size()); for ( final String par : intervalLists) { final String[] splits1=par.split("":""); final String[] splits2=splits1[1].split(""-""); intervals.add(new Interval(splits1[0] Integer.parseInt(splits2[0]) Integer.parseInt(splits2[1]))); } return intervals; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\FindMendelianViolations.java,writeAllViolations,"private void  (final MendelianViolationDetector.Result result){ if (VCF_DIR != null) { LOG.info(String.format(""Writing family violation VCFs to %s/"" VCF_DIR.getAbsolutePath())); final VariantContextComparator vcComparator=new VariantContextComparator(inputHeader.get().getContigLines()); final Set<VCFHeaderLine> headerLines=new LinkedHashSet<>(inputHeader.get().getMetaDataInInputOrder()); headerLines.add(new VCFInfoHeaderLine(MendelianViolationDetector.MENDELIAN_VIOLATION_KEY 1 VCFHeaderLineType.String ""Type of mendelian violation."")); headerLines.add(new VCFInfoHeaderLine(MendelianViolationDetector.ORIGINAL_AC VCFHeaderLineCount.A VCFHeaderLineType.Integer ""Original AC"")); headerLines.add(new VCFInfoHeaderLine(MendelianViolationDetector.ORIGINAL_AF VCFHeaderLineCount.A VCFHeaderLineType.Float ""Original AF"")); headerLines.add(new VCFInfoHeaderLine(MendelianViolationDetector.ORIGINAL_AN 1 VCFHeaderLineType.Integer ""Original AN"")); for ( final PedFile.PedTrio trio : pedFile.get().values()) { final File outputFile=new File(VCF_DIR IOUtil.makeFileNameSafe(trio.getFamilyId() + IOUtil.VCF_FILE_EXTENSION)); LOG.info(String.format(""Writing %s violation VCF to %s"" trio.getFamilyId() outputFile.getAbsolutePath())); final VariantContextWriter out=new VariantContextWriterBuilder().setOutputFile(outputFile).unsetOption(INDEX_ON_THE_FLY).build(); final VCFHeader newHeader=new VCFHeader(headerLines CollectionUtil.makeList(trio.getMaternalId() trio.getPaternalId() trio.getIndividualId())); final TreeSet<VariantContext> orderedViolations=new TreeSet<>(vcComparator); orderedViolations.addAll(result.violations().get(trio.getFamilyId())); out.writeHeader(newHeader); orderedViolations.forEach(out::add); out.close(); } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\LiftoverVcf.java,addAndTrack,private void  (final VariantContext toAdd final VariantContext source){ trackLiftedVariantContig(liftedBySourceContig source.getContig()); trackLiftedVariantContig(liftedByDestContig toAdd.getContig()); sorter.add(toAdd); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\LiftoverVcf.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsReadable(REFERENCE_SEQUENCE); IOUtil.assertFileIsReadable(CHAIN); IOUtil.assertFileIsWritable(OUTPUT); IOUtil.assertFileIsWritable(REJECT); final LiftOver liftOver=new Lif
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\LiftoverVcf.java,getReferenceFile,@Override public File  (){ return REFERENCE_SEQUENCE; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\LiftoverVcf.java,makeReferenceArgumentCollection,"@Override protected ReferenceArgumentCollection  (){ return new ReferenceArgumentCollection(){ @Argument(shortName=StandardOptionDefinitions.REFERENCE_SHORT_NAME common=false doc=""The reference sequence (fasta) for the TARGET genome build (i.e.  the new o"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\LiftoverVcf.java,rejectVariant,private void  (final VariantContext ctx final String reason){ rejects.add(new VariantContextBuilder(ctx).filter(reason).make()); failedLiftover++; trackLiftedVariantContig(rejectsByContig ctx.getContig()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\LiftoverVcf.java,trackLiftedVariantContig,private void  (Map<String Long> map String contig){ Long val=map.get(contig); if (val == null) { val=0L; } map.put(contig ++val); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\LiftoverVcf.java,tryToAddVariant,"private void  (final VariantContext vc final ReferenceSequence refSeq final VariantContext source){ if (!refSeq.getName().equals(vc.getContig())) { throw new IllegalStateException(""The contig of the VariantContext  "" + vc.getContig() + ""  doesnt match the ReferenceSequence: ""+ refSeq.getName()); } boolean mismatchesReference=false; for ( final Allele allele : vc.getAlleles()) { if (allele.isReference()) { final byte[] ref=refSeq.getBases(); final String refString=StringUtil.bytesToString(ref vc.getStart() - 1 vc.getEnd() - vc.getStart() + 1); if (!refString.equalsIgnoreCase(allele.getBaseString())) { if (vc.isBiallelic() && vc.isSNP() && refString.equalsIgnoreCase(vc.getAlternateAllele(0).getBaseString())) { if (RECOVER_SWAPPED_REF_ALT) { totalTrackedAsSwapRefAlt++; addAndTrack(LiftoverUtils.swapRefAlt(vc TAGS_TO_REVERSE TAGS_TO_DROP) source); return; } else { totalTrackedAsSwapRefAlt++; } } mismatchesReference=true; } break; } } if (mismatchesReference) { rejects.add(new VariantContextBuilder(source).filter(FILTER_MISMATCHING_REF_ALLELE).attribute(ATTEMPTED_LOCUS String.format(""%s:%d-%d"" vc.getContig() vc.getStart() vc.getEnd())).make()); failedAlleleCheck++; trackLiftedVariantContig(rejectsByContig source.getContig()); } else { addAndTrack(vc source); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MakeSitesOnlyVcf.java,MakeSitesOnlyVcf,public  (){ CREATE_INDEX=true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MakeSitesOnlyVcf.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); final VCFFileReader reader=new VCFFileReader(INPUT false); final VCFHeader inputVcfHeader=new VCFHeader(reader.getFileHeader().getMetaDataInInputOrder())
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MakeSitesOnlyVcf.java,main,public static void  (final String[] args){ new MakeSitesOnlyVcf().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MakeSitesOnlyVcf.java,subsetToSamplesWithOriginalAnnotations,private static VariantContext  (final VariantContext ctx final Set<String> samples){ final VariantContextBuilder builder=new VariantContextBuilder(ctx); final GenotypesContext newGenotypes=ctx.getGenotypes().subsetToSamples(samples); builder.alleles(ctx.getAlleles()); return builder.genotypes(newGenotypes).make(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\MendelianViolationMetrics.java,calculateDerivedFields,@Override public void  (){ TOTAL_MENDELIAN_VIOLATIONS=NUM_DIPLOID_DENOVO + NUM_HOMVAR_HOMVAR_HET + NUM_HOMREF_HOMVAR_HOM+ NUM_HOM_HET_HOM+ NUM_HAPLOID_DENOVO+ NUM_HAPLOID_OTHER+ NUM_OTHER; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\MendelianViolationMetrics.java,getExtension,"public static String  (){ return ""mendelian_violation_metrics""; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\MendelianViolationsByFamily.java,MendelianViolationsByFamily,public  (){ super(s -> new ArrayList<>() true); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MergeVcfs.java,MergeVcfs,public  (){ this.CREATE_INDEX=true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MergeVcfs.java,doWork,@Override protected int  (){ final ProgressLogger progress=new ProgressLogger(log 10000); final List<String> sampleList=new ArrayList<String>(); INPUT=IOUtil.unrollFiles(INPUT IOUtil.VCF_EXTENSIONS); final Collection<CloseableIterator<VariantContext>> ite
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MergeVcfs.java,main,public static void  (final String[] argv){ new MergeVcfs().instanceMainWithExit(argv); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\MendelianViolationDetector.java,MendelianViolation, (final String desc){ this.description=desc; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\MendelianViolationDetector.java,MendelianViolationDetector, (final Set<String> skip_chroms final Set<String> male_chroms final Set<String> female_chroms final double min_het_fraction final int min_gq final int min_dp final List<MendelianViolationMetrics> trios final List<Interval> parIntervals final ProgressLogger logger){ SKIP_CHROMS=skip_chroms; MALE_CHROMS=male_chroms; FEMALE_CHROMS=female_chroms; MIN_HET_FRACTION=min_het_fraction; MIN_GQ=min_gq; MIN_DP=min_dp; this.trios=trios; this.parIntervals=parIntervals; this.logger=logger; familyToViolations=new MendelianViolationsByFamily(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\MendelianViolationDetector.java,Result, (final Collection<MendelianViolationMetrics> metrics final MendelianViolationsByFamily violations){ this.metrics=metrics; this.violations=violations; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\MendelianViolationDetector.java,accumulate,@Override public void  (final VariantContext ctx){ logger.record(ctx.getContig() ctx.getStart()); final String variantChrom=ctx.getContig(); final int variantPos=ctx.getStart(); if (ctx.isFiltered()) return; if (!ctx.isVariant()) return; if (SKIP_CHROMS.c
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\MendelianViolationDetector.java,getDescription,public String  (){ return description; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\MendelianViolationDetector.java,isInPseudoAutosomalRegion,private boolean  (final String chr final int pos){ for ( final Interval par : parIntervals) { if (par.getContig().equals(chr) && pos >= par.getStart() && pos <= par.getEnd()) return true; } return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\MendelianViolationDetector.java,isMendelianViolation,private boolean  (final Genotype p1 final Genotype p2 final Genotype off){ final Allele offAllele1=off.getAllele(0); final Allele offAllele2=off.getAllele(1); if (p1.getAlleles().contains(offAllele1) && p2.getAlleles().contains(offAllele2)) return false; if (p2.getAlleles().contains(offAllele1) && p1.getAlleles().contains(offAllele2)) return false; return true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\MendelianViolationDetector.java,isVariant,private boolean  (final Genotype... gts){ for ( final Genotype gt : gts) { if (gt.isCalled() && !gt.isHomRef()) return true; } return false; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\MendelianViolationDetector.java,merge,public static MendelianViolationDetector.Result  (final Collection<MendelianViolationDetector.Result> results){ final Collection<Collection<MendelianViolationMetrics>> metricCollections=new ArrayList<>(); final Collection<MendelianViolationsByFamily> violationCollections=new ArrayList<>(); for ( final MendelianViolationDetector.Result result : results) { metricCollections.add(result.metrics()); violationCollections.add(result.violations()); } return new MendelianViolationDetector.Result(mergeMetrics(metricCollections) mergeViolations(violationCollections)); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\MendelianViolationDetector.java,mergeMetrics,"private static Collection<MendelianViolationMetrics>  (final Collection<Collection<MendelianViolationMetrics>> resultsToReduce){ final Collection<MendelianViolationMetrics> allMetrics=new ArrayList<>(); resultsToReduce.forEach(allMetrics::addAll); final Map<String List<MendelianViolationMetrics>> sampleToMetricsMap=allMetrics.stream().collect(Collectors.groupingBy(m -> String.format(""%s|%s|%s|%s"" m.FAMILY_ID m.FATHER m.MOTHER m.OFFSPRING))); return sampleToMetricsMap.values().stream().map(a -> (MendelianViolationMetrics)new MendelianViolationMetrics().merge(a)).collect(Collectors.<MendelianViolationMetrics List<MendelianViolationMetrics>>toCollection(ArrayList<MendelianViolationMetrics>::new)); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\MendelianViolationDetector.java,mergeViolations,private static MendelianViolationsByFamily  (final Collection<MendelianViolationsByFamily> resultsToReduce){ final MendelianViolationsByFamily masterFamilyViolationsMap=new MendelianViolationsByFamily(); for ( final Map<String Collection<VariantContext>> childFamilyViolationsMap : resultsToReduce) { for ( final String childFamily : childFamilyViolationsMap.keySet()) { masterFamilyViolationsMap.get(childFamily).addAll(childFamilyViolationsMap.get(childFamily)); } } return masterFamilyViolationsMap; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\MendelianViolationDetector.java,metrics,public Collection<MendelianViolationMetrics>  (){ return metrics; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\MendelianViolationDetector.java,result,@Override public Result  (){ return new Result(trios familyToViolations); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\MendelianViolations\MendelianViolationDetector.java,violations,MendelianViolationsByFamily  (){ return violations; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\PairedVariantSubContextIterator.java,PairedVariantSubContextIterator,public  (final Iterator<VariantContext> leftIterator final String leftSample final Iterator<VariantContext> rightIterator final String rightSample final SAMSequenceDictionary dict){ this.leftIterator=new PeekableIterator<>(leftIterator); this.leftSample=leftSample; this.rightIterator=new PeekableIterator<>(rightIterator); this.rightSample=rightSample; this.comparator=new VariantContextComparator(dict); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\PairedVariantSubContextIterator.java,VcfTuple, (final VariantContext leftVariantContext final Optional<VariantContext> rightVariantContext){ this(Optional.of(leftVariantContext) rightVariantContext); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\PairedVariantSubContextIterator.java,hasNext,@Override public boolean  (){ return this.leftIterator.hasNext() || this.rightIterator.hasNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\PairedVariantSubContextIterator.java,next,"@Override public VcfTuple  (){ if (!hasNext()) throw new IllegalStateException(""next() called while hasNext() is false.""); final Optional<VariantContext> leftVariantContext=this.leftIterator.hasNext() ? Optional.of(this.leftIterator.peek()) : Optional.emp"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\PairedVariantSubContextIterator.java,remove,@Override public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantAccumulatorExecutor.java,MultiException,public  (final List<Throwable> childrenExceptions){ this.childrenExceptions=childrenExceptions; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantAccumulatorExecutor.java,MultiThreadedChunkBased,public  (final int numThreads final VariantIteratorProducer vcIteratorProducer final VariantProcessor.AccumulatorGenerator<A R> accumulatorGenerator){ this.executor=Executors.newFixedThreadPool(numThreads); this.vcIterators=Iterators.atomicIteratorOf(vcIteratorProducer.iterators()); this.numThreads=numThreads; this.accumulatorGenerator=accumulatorGenerator; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantAccumulatorExecutor.java,Worker, (final VariantProcessor.Accumulator processor){ this.processor=processor; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantAccumulatorExecutor.java,accumulators,public synchronized Collection<A>  (){ return Collections.unmodifiableCollection(accumulators); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantAccumulatorExecutor.java,awaitCompletion,"@Override public void  () throws InterruptedException { if (!started) { throw new IllegalStateException(""This method can be called only after the executor has been started.""); } else { executor.awaitTermination(Long.MAX_VALUE TimeUnit.DAYS); if (!children"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantAccumulatorExecutor.java,getMessage,"@Override public String  (){ return ""Children threads encountered exceptions:\n"" + Joiner.on(""\n\t"").join(FluentIterable.from(childrenExceptions).transform(throwable -> throwable.getMessage())); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantAccumulatorExecutor.java,run,@Override public void  (){ try { Optional<CloseableIterator<VariantContext>> readerMaybe; while ((readerMaybe=vcIterators.next()).isPresent()) { final CloseableIterator<VariantContext> reader=readerMaybe.get(); while (reader.hasNext()) processor.accumulat
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantAccumulatorExecutor.java,start,@Override public synchronized void  (){ started=true; for (int i=0; i < numThreads; i++) { final A accumulator=accumulatorGenerator.build(); accumulators.add(accumulator); executor.submit(new Worker(accumulator)); } executor.shutdown(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\util\PredicateFilterDecoratingClosableIterator.java,PredicateFilterDecoratingClosableIterator,"public  (final CloseableIterator<T> underlyingIterator final Collection<Predicate<T>> predicates){ Preconditions.checkArgument(!predicates.isEmpty() ""predicates must not be empty""); Iterator<T> nestedPredicateIterator=underlyingIterator; for ( final Predicate<T> predicate : predicates) { nestedPredicateIterator=Iterators.filter(nestedPredicateIterator predicate); } filteredIterator=nestedPredicateIterator; this.underlyingIterator=underlyingIterator; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\util\PredicateFilterDecoratingClosableIterator.java,close,@Override public void  (){ underlyingIterator.close(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\util\PredicateFilterDecoratingClosableIterator.java,hasNext,@Override public boolean  (){ return filteredIterator.hasNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\util\PredicateFilterDecoratingClosableIterator.java,next,@Override public T  (){ return filteredIterator.next(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\util\PredicateFilterDecoratingClosableIterator.java,remove,@Override public void  (){ underlyingIterator.remove(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantIteratorProducer.java,NonUniqueVariantPredicate, (final VcfFileSegment sourceSegment){ this.sourceSegment=sourceSegment; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantIteratorProducer.java,Threadsafe," (final VcfFileSegmentGenerator segmenter final List<File> vcfs final IntervalList intervals){ if (intervals != null) { final List<Interval> uniques=intervals.uniqued(false).getIntervals(); this.intervalsOfInterestDetector=new OverlapDetector<>(0 0); intervalsOfInterestDetector.addAll(uniques uniques); } else { intervalsOfInterestDetector=null; } final VcfFileSegmentGenerator interestingSegmentSegmenter=intervalsOfInterestDetector == null ? segmenter : VcfFileSegmentGenerator.excludingNonOverlaps(segmenter intervalsOfInterestDetector); segments=new ArrayList<>(); for ( final File vcf : vcfs) { for ( final VcfFileSegment segment : interestingSegmentSegmenter.forVcf(vcf)) { segments.add(segment); } } for ( final VcfFileSegment segment : segments) { final Interval segmentInterval=segment.correspondingInterval(); final OverlapDetector<VcfFileSegment> vcfSpecificDetector=multiSegmentDetectorPerFile.get(segment.vcf()); if (vcfSpecificDetector.getOverlaps(segmentInterval).isEmpty()) { vcfSpecificDetector.addLhs(segment new Interval(segment.contig() segment.start() segment.stop())); } else { throw new IllegalArgumentException(String.format(""Provided segmenting strategy produced overlapping intervals; %s overlaps with: %s"" segment Joiner.on(""  "").join(vcfSpecificDetector.getOverlaps(segmentInterval)))); } } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantIteratorProducer.java,apply,"@Override public boolean  (final VariantContext vc){ final boolean include=!intervalsOfInterestDetector.getOverlaps(new Interval(vc.getContig() vc.getStart() vc.getEnd())).isEmpty(); if (!include) LOG.debug(""Filtering variant at "" vc.getContig() "":"" vc.ge"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantIteratorProducer.java,byHundredMegabaseChunks,public static VariantIteratorProducer  (final List<File> vcfs){ return new Threadsafe(VcfFileSegmentGenerator.byWholeContigSubdividingWithWidth(ONE_HUNDRED_MILLION) vcfs null); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantIteratorProducer.java,byHundredMegabaseChunksWithOnTheFlyFilteringByInterval,public static VariantIteratorProducer  (final List<File> vcfs final IntervalList intervalList){ return new Threadsafe(VcfFileSegmentGenerator.byWholeContigSubdividingWithWidth(ONE_HUNDRED_MILLION) vcfs intervalList); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantIteratorProducer.java,close,@Override public void  (){ final Iterator<VCFFileReader> i=allReaders.iterator(); while (i.hasNext()) { i.next().close(); i.remove(); } } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantIteratorProducer.java,initialValue,"@Override protected CollectionUtil.DefaultingMap<File VCFFileReader>  (){ return new CollectionUtil.DefaultingMap<>(file -> { final VCFFileReader reader=new VCFFileReader(file); LOG.debug(String.format(""Producing a reader of %s for %s."" file Thread.curren"
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantIteratorProducer.java,iteratorForSegment,private CloseableIterator<VariantContext>  (final VcfFileSegment segment){ final CloseableIterator<VariantContext> query=localVcfFileReaders.get().get(segment.vcf()).query(segment.contig() segment.start() segment.stop()); final Collection<Predicate<VariantContext>> filters=new ArrayList<>(); if (intervalsOfInterestDetector != null) { filters.add(new OverlapsPredicate()); } filters.add(new NonUniqueVariantPredicate(segment)); return new PredicateFilterDecoratingClosableIterator<>(query filters); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantIteratorProducer.java,iterators,@Override public Iterable<CloseableIterator<VariantContext>>  (){ return FluentIterable.from(segments).transform(this::iteratorForSegment); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\RenameSampleInVcf.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); final VCFFileReader in=new VCFFileReader(INPUT); final VCFHeader header=in.getFileHeader(); if (header.getGenotypeSamples().size() > 1) { throw new Illeg
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\RenameSampleInVcf.java,main,public static void  (final String[] args){ new RenameSampleInVcf().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantProcessor.java,Builder, (final AccumulatorGenerator<A R> accumulatorGenerator){ this.accumulatorGenerator=accumulatorGenerator; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VariantProcessor.java,VariantProcessor, (final ResultMerger<RESULT> merger final VariantAccumulatorExecutor<ACCUMULATOR RESULT> executor){ this.merger=merger; this.executor=executor; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegment.java,SequenceSizedChunk,private  (final SAMSequenceRecord sequence final File vcf){ this.sequence=sequence; this.vcf=vcf; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegment.java,contig,@Override public String  (){ return sequence.getSequenceName(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegment.java,correspondingInterval,public Interval  (){ return new Interval(contig() start() stop()); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegment.java,ofWholeSequence,static VcfFileSegment  (final SAMSequenceRecord sequence final File vcf){ return new SequenceSizedChunk(sequence vcf); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegment.java,start,@Override public int  (){ return 1; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegment.java,stop,@Override public int  (){ return sequence.getSequenceLength(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegment.java,toString,"@Override public String  (){ return vcf().getAbsolutePath() + ""::"" + sequence.getSequenceName()+ "":1-""+ sequence.getSequenceLength(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegment.java,vcf,@Override public File  (){ return vcf; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegmentGenerator.java,VcfFileSegmentSubdivider,private  (final VcfFileSegment basis){ this.basis=basis; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegmentGenerator.java,WidthLimitingDecorator,private  (final VcfFileSegmentGenerator underlyingStrategy final long maximumWidth){ this.underlyingStrategy=underlyingStrategy; this.width=maximumWidth - 1; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegmentGenerator.java,apply,@Override public Iterable<? extends VcfFileSegment>  (final VcfFileSegment vcfFileSegment){ return new VcfFileSegmentSubdivider(vcfFileSegment); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegmentGenerator.java,byWholeContigSubdividingWithWidth,public static VcfFileSegmentGenerator  (final long segmentWidth){ return WidthLimitingDecorator.wrapping(ByWholeContig.getInstance() segmentWidth); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegmentGenerator.java,contig,@Override public String  (){ return basis.contig(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegmentGenerator.java,excludingNonOverlaps,"public static <T>VcfFileSegmentGenerator  (final VcfFileSegmentGenerator strategy final OverlapDetector<T> overlaps){ return new VcfFileSegmentGenerator(){ @Override public Iterable<VcfFileSegment> forVcf( final File vcf){ return FluentIterable.from(strategy.forVcf(vcf)).filter(new Predicate<VcfFileSegment>(){ @Override public boolean apply( final VcfFileSegment segment){ final boolean keep=!overlaps.getOverlaps(new Interval(segment.contig() segment.start() segment.stop())).isEmpty(); if (!keep) { LOG.debug(String.format(""Ignoring segment because it does not overlap with detector  %s::%s:%s-%s"" segment.vcf().getName() segment.contig() segment.start() segment.stop())); } return keep; } } ); } } ; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegmentGenerator.java,forVcf,@Override public Iterable<VcfFileSegment>  (final File vcf){ return FluentIterable.from(underlyingStrategy.forVcf(vcf)).transformAndConcat(new Function<VcfFileSegment Iterable<? extends VcfFileSegment>>(){ @Override public Iterable<? extends VcfFileSegmen
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegmentGenerator.java,getInstance,public static ByWholeContig  (){ return singleton; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegmentGenerator.java,hasNext,@Override public boolean  (){ return nextStart <= basis.stop(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegmentGenerator.java,iterator,@Override public Iterator<VcfFileSegment>  (){ return new Iterator<VcfFileSegment>(){ int nextStart=basis.start(); @Override public boolean hasNext(){ return nextStart <= basis.stop(); } @Override public VcfFileSegment next(){ final int start=nextStart; f
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegmentGenerator.java,next,@Override public VcfFileSegment  (){ final int start=nextStart; final VcfFileSegment ret=new VcfFileSegment(){ @Override public int start(){ return start; } @Override public int stop(){ return Ints.checkedCast(Math.min(start + width basis.stop())); } @Ove
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegmentGenerator.java,readSequences,private static List<SAMSequenceRecord>  (final File vcf){ final VCFFileReader reader=new VCFFileReader(vcf); final VCFHeader header=reader.getFileHeader(); final SAMSequenceDictionary dict=header.getSequenceDictionary(); reader.close(); return dict.getSequences(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegmentGenerator.java,remove,@Override public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegmentGenerator.java,start,@Override public int  (){ return start; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegmentGenerator.java,stop,@Override public int  (){ return Ints.checkedCast(Math.min(start + width basis.stop())); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegmentGenerator.java,vcf,@Override public File  (){ return basis.vcf(); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\processor\VcfFileSegmentGenerator.java,wrapping,public static WidthLimitingDecorator  (final VcfFileSegmentGenerator basis final long maximumWidth){ return new WidthLimitingDecorator(basis maximumWidth); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\SortVcf.java,SortVcf,public  (){ this.CREATE_INDEX=true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\SortVcf.java,collectFileReadersAndHeaders,"private void  (final List<String> sampleList SAMSequenceDictionary samSequenceDictionary){ for ( final File input : INPUT) { final VCFFileReader in=new VCFFileReader(input false); final VCFHeader header=in.getFileHeader(); final SAMSequenceDictionary dict=in.getFileHeader().getSequenceDictionary(); if (dict == null || dict.isEmpty()) { if (null == samSequenceDictionary) { throw new IllegalArgumentException(""Sequence dictionary was missing or empty for the VCF: "" + input.getAbsolutePath() + "" Please add a sequence dictionary to this VCF or specify SEQUENCE_DICTIONARY.""); } header.setSequenceDictionary(samSequenceDictionary); } else { if (null == samSequenceDictionary) { samSequenceDictionary=dict; } else { try { samSequenceDictionary.assertSameDictionary(dict); } catch ( final AssertionError e) { throw new IllegalArgumentException(e); } } } if (sampleList.isEmpty()) { sampleList.addAll(header.getSampleNamesInOrder()); } else { if (!sampleList.equals(header.getSampleNamesInOrder())) { throw new IllegalArgumentException(""Input file "" + input.getAbsolutePath() + "" has sample names that don't match the other files.""); } } inputReaders.add(in); inputHeaders.add(header); } } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\SortVcf.java,doWork,@Override protected int  (){ final List<String> sampleList=new ArrayList<String>(); for ( final File input : INPUT) IOUtil.assertFileIsReadable(input); if (SEQUENCE_DICTIONARY != null) IOUtil.assertFileIsReadable(SEQUENCE_DICTIONARY); SAMSequenceDictionar
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\SortVcf.java,main,public static void  (final String[] args){ new SortVcf().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\SortVcf.java,sortInputs,"private SortingCollection<VariantContext>  (final List<VCFFileReader> readers final VCFHeader outputHeader){ final ProgressLogger readProgress=new ProgressLogger(log 25000 ""read"" ""records""); final SortingCollection<VariantContext> sorter=SortingCollection.newInstance(VariantContext.class new VCFRecordCodec(outputHeader VALIDATION_STRINGENCY != ValidationStringency.STRICT) outputHeader.getVCFRecordComparator() MAX_RECORDS_IN_RAM TMP_DIR); int readerCount=1; for ( final VCFFileReader reader : readers) { log.info(""Reading entries from input file "" + readerCount); for ( final VariantContext variantContext : reader) { sorter.add(variantContext); readProgress.record(variantContext.getContig() variantContext.getStart()); } reader.close(); readerCount++; } return sorter; } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\SortVcf.java,writeSortedOutput,"private void  (final VCFHeader outputHeader final SortingCollection<VariantContext> sortedOutput){ final ProgressLogger writeProgress=new ProgressLogger(log 25000 ""wrote"" ""records""); final EnumSet<Options> options=CREATE_INDEX ? EnumSet.of(Options.INDEX_ON_THE_FLY) : EnumSet.noneOf(Options.class); final VariantContextWriter out=new VariantContextWriterBuilder().setReferenceDictionary(outputHeader.getSequenceDictionary()).setOptions(options).setOutputFile(OUTPUT).build(); out.writeHeader(outputHeader); for ( final VariantContext variantContext : sortedOutput) { out.add(variantContext); writeProgress.record(variantContext.getContig() variantContext.getStart()); } out.close(); } "
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\VcfFormatConverter.java,VcfFormatConverter,public  (){ this.CREATE_INDEX=true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\VcfFormatConverter.java,doWork,@Override protected int  (){ final ProgressLogger progress=new ProgressLogger(LOG 10000); IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); final VCFFileReader reader=new VCFFileReader(INPUT REQUIRE_INDEX); final VCFHeader header=ne
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\VcfFormatConverter.java,main,public static void  (final String[] argv){ new VcfFormatConverter().instanceMainWithExit(argv); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\UpdateVcfSequenceDictionary.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsReadable(SEQUENCE_DICTIONARY); IOUtil.assertFileIsWritable(OUTPUT); final SAMSequenceDictionary samSequenceDictionary=SAMSequenceDictionaryExtractor.extractDictionary(SEQU
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\UpdateVcfSequenceDictionary.java,main,public static void  (final String[] args){ new UpdateVcfSequenceDictionary().instanceMainWithExit(args); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\SplitVcfs.java,SplitVcfs,public  (){ this.CREATE_INDEX=true; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\SplitVcfs.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); final ProgressLogger progress=new ProgressLogger(log 10000); final VCFFileReader fileReader=new VCFFileReader(INPUT); final VCFHeader fileHeader=fileReader.getFileHeader(); final SAMSequence
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\SplitVcfs.java,main,public static void  (final String[] argv){ new SplitVcfs().instanceMainWithExit(argv); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\VcfUtils.java,isVariantFile,static public boolean  (final File file){ final String name=file.getName(); return name.endsWith(IOUtil.VCF_FILE_EXTENSION) || name.endsWith(IOUtil.COMPRESSED_VCF_FILE_EXTENSION) || name.endsWith(IOUtil.BCF_FILE_EXTENSION); } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\VcfToIntervalList.java,doWork,@Override protected int  (){ IOUtil.assertFileIsReadable(INPUT); IOUtil.assertFileIsWritable(OUTPUT); final IntervalList intervalList=VCFFileReader.fromVcf(INPUT INCLUDE_FILTERED); intervalList.uniqued().write(OUTPUT); return 0; } 
C:\Users\User\Desktop\Thesis\picard\src\main\java\picard\vcf\VcfToIntervalList.java,main,public static void  (final String[] argv){ new VcfToIntervalList().instanceMainWithExit(argv); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\CollectSequencingArtifactMetricsTest.java,areMetricsEqual,private boolean  (final File expectedBase final File actualBase final String extension){ return MetricsFile.areMetricsEqual(new File(expectedBase + extension) new File(actualBase + extension)); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\CollectSequencingArtifactMetricsTest.java,assertAllFilesEqual,"private void  (final File expectedBase final File actualBase){ Assert.assertTrue(areMetricsEqual(expectedBase actualBase SequencingArtifactMetrics.PRE_ADAPTER_SUMMARY_EXT) ""Pre-Adapter summary files differ.""); Assert.assertTrue(areMetricsEqual(expectedBase actualBase SequencingArtifactMetrics.PRE_ADAPTER_DETAILS_EXT) ""Pre-Adapter details files differ.""); Assert.assertTrue(areMetricsEqual(expectedBase actualBase SequencingArtifactMetrics.BAIT_BIAS_SUMMARY_EXT) ""Bait-Bias summary files differ.""); Assert.assertTrue(areMetricsEqual(expectedBase actualBase SequencingArtifactMetrics.BAIT_BIAS_DETAILS_EXT) ""Bait-bias details files differ.""); Assert.assertTrue(areMetricsEqual(expectedBase actualBase SequencingArtifactMetrics.ERROR_SUMMARY_EXT) ""Error-summary files differ.""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\CollectSequencingArtifactMetricsTest.java,getCommandLineProgramName,@Override public String  (){ return CollectSequencingArtifactMetrics.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\ConvertSequencingArtifactToOxoGTest.java,areMetricsEqual,private static <T extends MetricBase>boolean  (MetricsFile<T ?> metricFile1 MetricsFile<T ?> metricFile2 final String[] columnsToCompare) throws NoSuchFieldException { if (metricFile1.getMetrics().size() != metricFile2.getMetrics().size()) return false; if (metricFile1.getMetrics().isEmpty()) return true; T firstMetric1=metricFile1.getMetrics().get(0); for ( final String column : columnsToCompare) { if (!metricFile1.getMetricsColumnLabels().contains(column)) return false; if (!metricFile2.getMetricsColumnLabels().contains(column)) return false; final Field f=firstMetric1.getClass().getField(column); List<String> metric1Values=metricFile1.getMetrics().stream().map(m -> { try { return f.get(m).toString(); } catch ( IllegalAccessException e) { e.printStackTrace(); } return null; } ).collect(Collectors.toList()); List<String> metric2Values=metricFile2.getMetrics().stream().map(m -> { try { return f.get(m).toString(); } catch ( IllegalAccessException e) { e.printStackTrace(); } return null; } ).collect(Collectors.toList()); if (!metric1Values.equals(metric2Values)) return false; } return true; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\CollectSequencingArtifactMetricsTest.java,runAnalysis,"private void  (final String testCase final String... extraArgs) throws IOException { final File actual=new File(globalTempOutputDir testCase); final File expected=new File(TEST_CASES testCase); final Map<String String> args=new HashMap<String String>(); args.put(""INPUT"" TEST_SAM.getAbsolutePath()); args.put(""OUTPUT"" actual.getAbsolutePath()); args.put(""REFERENCE_SEQUENCE"" REFERENCE.getAbsolutePath()); args.put(""MINIMUM_INSERT_SIZE"" ""30""); args.put(""MAXIMUM_INSERT_SIZE"" ""30""); args.put(""CONTEXT_SIZE"" ""0""); for ( final String extraArg : extraArgs) { final String[] kv=extraArg.split(""=""); args.put(kv[0] kv[1]); } runPicardCommandLine(args); assertAllFilesEqual(expected actual); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\CollectSequencingArtifactMetricsTest.java,setUp,"@BeforeTest public void  () throws IOException { globalTempOutputDir=IOUtil.createTempDir(""artifactMetrics."" "".tmp""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\CollectSequencingArtifactMetricsTest.java,tearDown,@AfterTest public void  () throws IOException { IOUtil.deleteDirectoryTree(globalTempOutputDir); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\CollectSequencingArtifactMetricsTest.java,testContext,"@Test public void  () throws IOException { runAnalysis(""with_context"" ""CONTEXT_SIZE=1""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\CollectSequencingArtifactMetricsTest.java,testDbSnp,"@Test public void  () throws IOException { runAnalysis(""with_dbsnp"" ""DB_SNP="" + DB_SNP); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\CollectSequencingArtifactMetricsTest.java,testIntervalList,"@Test public void  () throws IOException { runAnalysis(""with_intervals"" ""INTERVALS="" + INTERVALS); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\CollectSequencingArtifactMetricsTest.java,testLargerContext,"@Test public void  () throws IOException { runAnalysis(""with_larger_context"" ""CONTEXT_SIZE=2""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\CollectSequencingArtifactMetricsTest.java,testNoBqCutoff,"@Test public void  () throws IOException { runAnalysis(""no_bq_cutoff"" ""MINIMUM_QUALITY_SCORE=0""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\CollectSequencingArtifactMetricsTest.java,testNoMqCutoff,"@Test public void  () throws IOException { runAnalysis(""no_mq_cutoff"" ""MINIMUM_MAPPING_QUALITY=0""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\CollectSequencingArtifactMetricsTest.java,testUnmappedMate,"@Test public void  () throws IOException { runAnalysis(""unmapped_mate"" ""MINIMUM_INSERT_SIZE=0"" ""MAXIMUM_INSERT_SIZE=0""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\ConvertSequencingArtifactToOxoGTest.java,testEquivalence,"@Test public void  () throws IOException  NoSuchFieldException { final File input=SAM_FILE; final File outputFileOxoG=File.createTempFile(""test"" "".oxo_g_metrics"" TEST_DATA_DIR); outputFileOxoG.deleteOnExit(); final File outputFileArtifacts=File.createTemp"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\AbstractWgsMetricsCollectorTest.java,testForCollectorWithoutData,@Test public void  (){ long[] templateQualHistogram=new long[127]; long[] templateHistogramArray=new long[11]; CollectWgsMetrics collectWgsMetrics=new CollectWgsMetrics(); AbstractWgsMetricsCollector collector=new AbstractWgsMetricsCollector(collectWgsMet
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\AbstractWgsMetricsCollectorTest.java,testForExceptionWithNegativeCoverage,@Test(expectedExceptions=IllegalArgumentException.class) public void  (){ CollectWgsMetrics collectWgsMetrics=new CollectWgsMetrics(); new AbstractWgsMetricsCollector(collectWgsMetrics -10 createIntervalList()){ @Override public void addInfo( AbstractLocu
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\AbstractWgsMetricsCollectorTest.java,testForRefBaseN,"@Test public void  (){ byte[] refBasis={'A' 'C' 'C' 'T' 'A' 'N' 'G' 'T' 'N' 'N'}; ReferenceSequence ref=new ReferenceSequence(""test"" 0 refBasis); CollectWgsMetrics collectWgsMetrics=new CollectWgsMetrics(); AbstractWgsMetricsCollector collector=new Abstra"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\AbstractWgsMetricsCollectorTest.java,testForSetCounter,@Test public void  (){ CollectWgsMetrics collectWgsMetrics=new CollectWgsMetrics(); AbstractWgsMetricsCollector collector=new AbstractWgsMetricsCollector(collectWgsMetrics 10 createIntervalList()){ @Override public void addInfo( AbstractLocusInfo info  Re
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\AbstractWgsMetricsCollectorTest.java,testForStop,@Test public void  (){ CollectWgsMetrics collectWgsMetrics=new CollectWgsMetrics(); collectWgsMetrics.STOP_AFTER=10; AbstractWgsMetricsCollector collector=new AbstractWgsMetricsCollector(collectWgsMetrics 10 createIntervalList()){ @Override public void ad
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\TransitionTest.java,allTransitions,@DataProvider public Iterator<Object[]>  (){ return Stream.of(Transition.values()).map(t -> new Object[]{t}).iterator(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\TransitionTest.java,badBases,@DataProvider public Object[][]  (){ return new Object[][]{{Character.MIN_VALUE} {Transition.Base.A.base - 1} {'Z'} {Character.MAX_VALUE}}; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\TransitionTest.java,testIdentityAfterTwoComplement,"@Test(dataProvider=""allTransitions"") public void  (final Transition transition){ Assert.assertEquals(transition.complement().complement() transition); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\TransitionTest.java,testInvalidCall,"@Test(dataProvider=""badBases"" expectedExceptions=IllegalArgumentException.class) public void  (final char wrongBase){ Transition.transitionOf('A' wrongBase); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\TransitionTest.java,testInvalidRef,"@Test(dataProvider=""badBases"" expectedExceptions=IllegalArgumentException.class) public void  (final char wrongBase){ Transition.transitionOf(wrongBase 'A'); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\artifacts\TransitionTest.java,testTransitionOfSelf,"@Test(dataProvider=""allTransitions"") public void  (final Transition transition){ final Transition ofSelf=Transition.transitionOf(transition.ref() transition.call()); Assert.assertEquals(ofSelf transition); Assert.assertSame(ofSelf transition); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectGcBiasMetricsTest.java,build,"public File  (final List<SAMRecordSetBuilder> setBuilder final File unsortedSam final SAMFileHeader header) throws IOException { final File sortedSam=VcfTestUtils.createTemporaryIndexedFile(""CollectGcBias"" "".bam""); final SAMFileWriter writer=new SAMFileWriterFactory().setCreateIndex(true).makeBAMWriter(header false unsortedSam); for ( final SAMRecordSetBuilder subSetBuilder : setBuilder) { for ( final SAMRecord record : subSetBuilder) { writer.addAlignment(record); } } writer.close(); final SortSam sorter=new SortSam(); final String[] args=new String[]{""INPUT="" + unsortedSam.getAbsolutePath() ""OUTPUT="" + sortedSam.getAbsolutePath() ""SORT_ORDER=coordinate""}; sorter.instanceMain(args); return sortedSam; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectGcBiasMetricsTest.java,getCommandLineProgramName,public String  (){ return CollectGcBiasMetrics.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectGcBiasMetricsTest.java,runCheckingNoSEQTest,"@Test public void  () throws IOException { final File input=new File(""testdata/picard/metrics/chrM_NO_SEQ.sam""); final File summaryOutfile=File.createTempFile(""test"" "".gc_bias.summary_metrics""); final File detailsOutfile=File.createTempFile(""test"" "".gc_bi"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectGcBiasMetricsTest.java,runGcBias,"public void  (final File input final String referenceFile final File summaryOutfile final File detailsOutfile final boolean nonDups) throws IOException { final File pdf=File.createTempFile(""test"" "".pdf""); pdf.deleteOnExit(); final int windowSize=100; final double minGenFraction=1.0E-5; final boolean biSulfiteSeq=false; final boolean assumeSorted=false; final String[] args=new String[]{""INPUT="" + input.getAbsolutePath() ""OUTPUT="" + detailsOutfile.getAbsolutePath() ""REFERENCE_SEQUENCE="" + referenceFile ""SUMMARY_OUTPUT="" + summaryOutfile.getAbsolutePath() ""CHART_OUTPUT="" + pdf.getAbsolutePath() ""SCAN_WINDOW_SIZE="" + windowSize ""MINIMUM_GENOME_FRACTION="" + minGenFraction ""IS_BISULFITE_SEQUENCED="" + biSulfiteSeq ""LEVEL=ALL_READS"" ""LEVEL=SAMPLE"" ""LEVEL=READ_GROUP"" ""ASSUME_SORTED="" + assumeSorted ""ALSO_IGNORE_DUPLICATES="" + nonDups}; runPicardCommandLine(args); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectGcBiasMetricsTest.java,runGcBiasMultiLevelTest,"@Test public void  () throws IOException { final File outfile=File.createTempFile(""test"" "".gc_bias.summary_metrics""); final File detailsOutfile=File.createTempFile(""test"" "".gc_bias.detail_metrics""); outfile.deleteOnExit(); detailsOutfile.deleteOnExit(); r"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectGcBiasMetricsTest.java,runNonDupsComparisonTest,"@Test public void  () throws IOException { final File inputFileWithDuplicates=new File(""testdata/picard/metrics/chrMReads.sam""); final File detailsOutfile=File.createTempFile(""test"" "".gc_bias_detail_metrics""); final File summaryOutfile=File.createTempFile"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectGcBiasMetricsTest.java,runWindowsComparisonTest,"@Test public void  () throws IOException { final File outfile=File.createTempFile(""test"" "".gc_bias_summary_metrics""); final File allChrOutFile=File.createTempFile(""testAllChr"" "".gc_bias_summary_metrics""); final File detailsOutfile=File.createTempFile(""tes"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectGcBiasMetricsTest.java,setupBuilder,"@BeforeTest void  () throws IOException { tempSamFileChrM_O=VcfTestUtils.createTemporaryIndexedFile(""CollectGcBias"" "".bam""); tempSamFileAllChr=VcfTestUtils.createTemporaryIndexedFile(""CollectGcBias"" "".bam""); final File tempSamFileUnsorted=VcfTestUtils.cre"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectGcBiasMetricsTest.java,setupTest1,"public void  (final int ID final String readGroupId final SAMReadGroupRecord readGroupRecord final String sample final String library final SAMFileHeader header final SAMRecordSetBuilder setBuilder) throws IOException { final String separator="":""; final int contig1=0; final int contig2=1; readGroupRecord.setSample(sample); readGroupRecord.setPlatform(platform); readGroupRecord.setLibrary(library); readGroupRecord.setPlatformUnit(readGroupId); header.addReadGroup(readGroupRecord); setBuilder.setReadGroup(readGroupRecord); setBuilder.setUseNmFlag(true); setBuilder.setHeader(header); final int max=800; final int min=1; final Random rg=new Random(5); for (int i=0; i < NUM_READS; i++) { final int start=rg.nextInt(max) + min; final String newReadName=READ_NAME + separator + ID+ separator+ i; if (i != NUM_READS - 1) { setBuilder.addPair(newReadName contig1 start + ID start + ID + LENGTH); } else { setBuilder.addPair(newReadName contig2 start + ID start + ID + LENGTH); } } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectGcBiasMetricsTest.java,setupTest2,"public void  (final int ID final String readGroupId final SAMReadGroupRecord readGroupRecord final String sample final String library final SAMFileHeader header final SAMRecordSetBuilder setBuilder) throws IOException { final String separator="":""; final int contig1=0; final int contig2=1; final int contig3=2; readGroupRecord.setSample(sample); readGroupRecord.setPlatform(platform); readGroupRecord.setLibrary(library); readGroupRecord.setPlatformUnit(readGroupId); setBuilder.setReadGroup(readGroupRecord); setBuilder.setUseNmFlag(true); setBuilder.setHeader(header); final int max=800; final int min=1; final Random rg=new Random(5); for (int i=0; i < NUM_READS; i++) { final int start=rg.nextInt(max) + min; final String newReadName=READ_NAME + separator + ID+ separator+ i; if (i <= NUM_READS / 3) { setBuilder.addPair(newReadName contig1 start + ID start + ID + LENGTH); } else if (i < (NUM_READS - (NUM_READS / 3))) { setBuilder.addPair(newReadName contig2 start + ID start + ID + LENGTH); } else { setBuilder.addPair(newReadName contig3 start + ID start + ID + LENGTH); } } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectInsertSizeMetricsTest.java,getCommandLineProgramName,public String  (){ return CollectInsertSizeMetrics.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectInsertSizeMetricsTest.java,test,"@Test public void  () throws IOException { final File input=new File(TEST_DATA_DIR ""insert_size_metrics_test.sam""); final File outfile=File.createTempFile(""test"" "".insert_size_metrics""); final File pdf=File.createTempFile(""test"" "".pdf""); outfile.deleteOnE"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectInsertSizeMetricsTest.java,testHistogramWidthIsSetProperly,"@Test public void  () throws IOException { final File input=new File(TEST_DATA_DIR ""insert_size_metrics_test.sam""); final File outfile=File.createTempFile(""test"" "".insert_size_metrics""); final File pdf=File.createTempFile(""test"" "".pdf""); outfile.deleteOnE"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectInsertSizeMetricsTest.java,testMultipleOrientationsForHistogram,"@Test public void  () throws IOException { final File output=new File(""testdata/picard/analysis/directed/CollectInsertSizeMetrics"" ""multiple_orientation.sam.insert_size_metrics""); final File pdf=File.createTempFile(""test"" "".pdf""); pdf.deleteOnExit(); fina"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectInsertSizeMetricsTest.java,testWdithOfMetrics,"@Test public void  () throws IOException { final File testSamFile=File.createTempFile(""CollectInsertSizeMetrics"" "".bam"" TEST_DATA_DIR); testSamFile.deleteOnExit(); final SAMRecordSetBuilder setBuilder=new SAMRecordSetBuilder(true SAMFileHeader.SortOrder.c"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectAlignmentSummaryMetricsTest.java,getCommandLineProgramName,public String  (){ return CollectAlignmentSummaryMetrics.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectAlignmentSummaryMetricsTest.java,test,"@Test public void  () throws IOException { final File input=new File(TEST_DATA_DIR ""summary_alignment_stats_test.sam""); final File reference=new File(TEST_DATA_DIR ""summary_alignment_stats_test.fasta""); final File outfile=File.createTempFile(""alignmentMet"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectAlignmentSummaryMetricsTest.java,testBisulfite,"@Test public void  () throws IOException { final File input=new File(TEST_DATA_DIR ""summary_alignment_bisulfite_test.sam""); final File reference=new File(TEST_DATA_DIR ""summary_alignment_stats_test.fasta""); final File outfile=File.createTempFile(""alignmen"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectAlignmentSummaryMetricsTest.java,testBisulfiteButNot,"@Test public void  () throws IOException { final File input=new File(TEST_DATA_DIR ""summary_alignment_bisulfite_test.sam""); final File reference=new File(TEST_DATA_DIR ""summary_alignment_stats_test.fasta""); final File outfile=File.createTempFile(""alignmen"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectAlignmentSummaryMetricsTest.java,testChimeras,"@Test public void  () throws IOException { final File input=new File(TEST_DATA_DIR ""summary_alignment_stats_test_chimeras.sam""); final File reference=new File(TEST_DATA_DIR ""summary_alignment_stats_test.fasta""); final File outfile=File.createTempFile(""ali"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectAlignmentSummaryMetricsTest.java,testMultipleLevelsOfMetrics,"@Test public void  () throws IOException { final File input=new File(TEST_DATA_DIR ""summary_alignment_stats_test_multiple.sam""); final File outfile=File.createTempFile(""alignmentMetrics"" "".txt""); outfile.deleteOnExit(); final String[] args=new String[]{""I"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectAlignmentSummaryMetricsTest.java,testNoReference,"@Test public void  () throws IOException { final File input=new File(TEST_DATA_DIR ""summary_alignment_stats_test.sam""); final File outfile=File.createTempFile(""alignmentMetrics"" "".txt""); outfile.deleteOnExit(); final String[] args=new String[]{""INPUT="" + "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectAlignmentSummaryMetricsTest.java,testZeroLengthReads,"@Test public void  () throws IOException { final File input=new File(TEST_DATA_DIR ""summary_alignment_stats_test2.sam""); final File outfile=File.createTempFile(""alignmentMetrics"" "".txt""); outfile.deleteOnExit(); final String[] args=new String[]{""INPUT="" +"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectJumpingLibraryMetricsTest.java,testCollectJumpingLibraryMetrics,"@Test public void  () throws IOException { final File outfile=File.createTempFile(""CollectJumpingLibraryMetricsTest"" "".txt""); outfile.deleteOnExit(); final String[] args=new String[]{""INPUT="" + SAM_FILE.getAbsolutePath() ""OUTPUT="" + outfile.getAbsolutePat"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectQualityYieldMetricsTest.java,getCommandLineProgramName,public String  (){ return CollectQualityYieldMetrics.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectQualityYieldMetricsTest.java,test,"@Test public void  () throws IOException { final File input=new File(TEST_DATA_DIR ""insert_size_metrics_test.sam""); final File outfile=File.createTempFile(""test"" "".quality_yield_metrics""); outfile.deleteOnExit(); final String[] args=new String[]{""INPUT="" "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectOxoGMetricsTest.java,getCollectOxoGMetrics,private static CollectOxoGMetrics  (final int minimumInsertSize final int maximumInsertSize final int contextSize final HashSet<String> context){ final CollectOxoGMetrics collectOxoGMetrics=new CollectOxoGMetrics(); collectOxoGMetrics.MINIMUM_INSERT_SIZE=minimumInsertSize; collectOxoGMetrics.MAXIMUM_INSERT_SIZE=maximumInsertSize; collectOxoGMetrics.CONTEXT_SIZE=contextSize; collectOxoGMetrics.CONTEXTS=context; return collectOxoGMetrics; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectOxoGMetricsTest.java,rightOptions,"@DataProvider(name=""RightOptions"") public static Object[][]  (){ final HashSet<String> rightContext1=new HashSet<>(); rightContext1.add(""ACC""); final HashSet<String> rightContext2=new HashSet<>(); rightContext2.add(""AACAA""); rightContext2.add(""ATCAT""); re"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectOxoGMetricsTest.java,testCollectOxoGMetrics,"@Test public void  () throws IOException { final File outputFile=File.createTempFile(""test"" "".oxo_g_metrics"" TEST_DATA_DIR); outputFile.deleteOnExit(); final String[] args=new String[]{""INPUT="" + SAM_FILE.getAbsolutePath() ""OUTPUT="" + outputFile.getAbsolu"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectOxoGMetricsTest.java,testCollectOxoGMetricsLongContext,"@Test public void  () throws IOException { final File outputFile=File.createTempFile(""test"" "".oxo_g_metrics"" TEST_DATA_DIR); outputFile.deleteOnExit(); final String[] args=new String[]{""INPUT="" + SAM_FILE.getAbsolutePath() ""OUTPUT="" + outputFile.getAbsolu"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectOxoGMetricsTest.java,testCollectOxoGMetricsShortContext,"@Test public void  () throws IOException { final File outputFile=File.createTempFile(""test"" "".oxo_g_metrics"" TEST_DATA_DIR); outputFile.deleteOnExit(); final String[] args=new String[]{""INPUT="" + SAM_FILE.getAbsolutePath() ""OUTPUT="" + outputFile.getAbsolu"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectOxoGMetricsTest.java,testNegativeCustomCommandLineValidation,"@Test(dataProvider=""WrongOptions"") public void  (final int minimumInsertSize final int maximumInsertSize final int contextSize final HashSet<String> context final String expectedMessage) throws Exception { final CollectOxoGMetrics collectOxoGMetrics=getCo"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectOxoGMetricsTest.java,testPositiveCustomCommandLineValidation,"@Test(dataProvider=""RightOptions"") public void  (final int minimumInsertSize final int maximumInsertSize final int contextSize final HashSet<String> context) throws Exception { final CollectOxoGMetrics collectOxoGMetrics=getCollectOxoGMetrics(minimumInser"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectOxoGMetricsTest.java,wrongOptions,"@DataProvider(name=""WrongOptions"") public static Object[][]  (){ final HashSet<String> wrongContext1=new HashSet<>(); wrongContext1.add(""AAC""); final HashSet<String> wrongContext2=new HashSet<>(); wrongContext2.add(""AAGAA""); wrongContext2.add(""ATCAT""); fi"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectRnaSeqMetricsTest.java,getCommandLineProgramName,public String  (){ return CollectRnaSeqMetrics.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectRnaSeqMetricsTest.java,getRefFlatFile,"public File  (String sequence) throws Exception { final String[] refFlatFields=new String[RefFlatColumns.values().length]; refFlatFields[RefFlatColumns.GENE_NAME.ordinal()]=""myGene""; refFlatFields[RefFlatColumns.TRANSCRIPT_NAME.ordinal()]=""myTranscript""; refFlatFields[RefFlatColumns.CHROMOSOME.ordinal()]=sequence; refFlatFields[RefFlatColumns.STRAND.ordinal()]=""+""; refFlatFields[RefFlatColumns.TX_START.ordinal()]=""49""; refFlatFields[RefFlatColumns.TX_END.ordinal()]=""500""; refFlatFields[RefFlatColumns.CDS_START.ordinal()]=""74""; refFlatFields[RefFlatColumns.CDS_END.ordinal()]=""400""; refFlatFields[RefFlatColumns.EXON_COUNT.ordinal()]=""2""; refFlatFields[RefFlatColumns.EXON_STARTS.ordinal()]=""49 249""; refFlatFields[RefFlatColumns.EXON_ENDS.ordinal()]=""200 500""; final File refFlatFile=File.createTempFile(""tmp."" "".refFlat""); refFlatFile.deleteOnExit(); final PrintStream refFlatStream=new PrintStream(refFlatFile); refFlatStream.println(StringUtil.join(""\t"" refFlatFields)); refFlatStream.close(); return refFlatFile; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectRnaSeqMetricsTest.java,rRnaIntervalsFiles,"@DataProvider(name="" "") public static Object[][] rRnaIntervalsFiles() throws IOException { return new Object[][]{{null} {File.createTempFile(""tmp.rRna."" "".interval_list"")}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectRnaSeqMetricsTest.java,testBasic,"@Test public void  () throws Exception { final String sequence=""chr1""; final String ignoredSequence=""chrM""; final SAMRecordSetBuilder builder=new SAMRecordSetBuilder(true SAMFileHeader.SortOrder.coordinate); builder.setRandomSeed(0); final int sequenceInd"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectRnaSeqMetricsTest.java,testMultiLevel,"@Test public void  () throws Exception { final String sequence=""chr1""; final String ignoredSequence=""chrM""; final SAMRecordSetBuilder builder=new SAMRecordSetBuilder(true SAMFileHeader.SortOrder.coordinate false); builder.setRandomSeed(0); final int seque"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectRnaSeqMetricsTest.java,testNoIntevalsNoFragPercentage,"@Test(dataProvider=""rRnaIntervalsFiles"") public void  (final File rRnaIntervalsFile) throws Exception { final SAMRecordSetBuilder builder=new SAMRecordSetBuilder(true SAMFileHeader.SortOrder.coordinate); if (rRnaIntervalsFile != null) { final IntervalList"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectRnaSeqMetricsTest.java,testTranscriptionStrandMetrics,"@Test public void  () throws Exception { final String sequence=""chr1""; final String ignoredSequence=""chrM""; final SAMRecordSetBuilder builder=new SAMRecordSetBuilder(true SAMFileHeader.SortOrder.coordinate); builder.setRandomSeed(0); builder.setReadLength"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectMultipleMetricsTest.java,getCommandLineProgramName,public String  (){ return CollectMultipleMetrics.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectMultipleMetricsTest.java,runGcTest,"public void  (final File input) throws IOException { final File outfile=File.createTempFile(""test"" """"); final String referenceFile=""testdata/picard/quality/chrM.reference.fasta""; outfile.deleteOnExit(); final String[] args=new String[]{""INPUT="" + input.getAbsolutePath() ""OUTPUT="" + outfile.getAbsolutePath() ""REFERENCE_SEQUENCE="" + referenceFile ""METRIC_ACCUMULATION_LEVEL="" + MetricAccumulationLevel.ALL_READS.name() ""PROGRAM=null"" ""PROGRAM="" + CollectMultipleMetrics.Program.CollectAlignmentSummaryMetrics.name() ""PROGRAM="" + CollectMultipleMetrics.Program.CollectInsertSizeMetrics.name() ""PROGRAM="" + CollectMultipleMetrics.Program.CollectGcBiasMetrics.name()}; Assert.assertEquals(runPicardCommandLine(args) 0); final MetricsFile<GcBiasSummaryMetrics Comparable<?>> output=new MetricsFile<GcBiasSummaryMetrics Comparable<?>>(); output.read(new FileReader(outfile + "".gc_bias.summary_metrics"")); for ( final GcBiasSummaryMetrics metrics : output.getMetrics()) { if (metrics.ACCUMULATION_LEVEL.equals(ACCUMULATION_LEVEL_ALL_READS)) { Assert.assertEquals(metrics.TOTAL_CLUSTERS 300); Assert.assertEquals(metrics.ALIGNED_READS 600); Assert.assertEquals(metrics.AT_DROPOUT 7.234062); Assert.assertEquals(metrics.GC_DROPOUT 4.086217); Assert.assertEquals(metrics.GC_NC_0_19 0.0); Assert.assertEquals(metrics.GC_NC_20_39 1.06826); Assert.assertEquals(metrics.GC_NC_40_59 0.987036); Assert.assertEquals(metrics.GC_NC_60_79 0.0); Assert.assertEquals(metrics.GC_NC_80_100 0.0); } else { Assert.fail(""Unexpected metric: "" + metrics); } } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectMultipleMetricsTest.java,setup,"void  (final int numReads final String readName final int ID final String readGroupId final SAMReadGroupRecord readGroupRecord final String sample final String library final SAMFileHeader header final SAMRecordSetBuilder setBuilder) throws IOException { final String separator="":""; readGroupRecord.setSample(sample); readGroupRecord.setPlatform(platform); readGroupRecord.setLibrary(library); readGroupRecord.setPlatformUnit(readGroupId); header.addReadGroup(readGroupRecord); setBuilder.setReadGroup(readGroupRecord); setBuilder.setUseNmFlag(true); setBuilder.setHeader(header); final int max=15000; final int min=1; final Random rg=new Random(5); for (int i=0; i < numReads; i++) { final int start=rg.nextInt(max) + min; final String newReadName=readName + separator + ID+ separator+ i; setBuilder.addPair(newReadName 0 start + ID start + ID + 99); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectMultipleMetricsTest.java,setupBuilder,"@BeforeTest void  () throws IOException { final int numReads=100; final String flowCellBarcode=""TESTBARCODE""; tempSamFile=File.createTempFile(""CollectGcBias"" "".bam"" TEST_DIR); final File tempSamIndex=new File(tempSamFile.getAbsolutePath().replace(""bam"" ""b"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectMultipleMetricsTest.java,testAlignmentSummaryViaMultipleMetrics,"@Test public void  () throws IOException { final File input=new File(TEST_DATA_DIR ""summary_alignment_stats_test.sam""); final File reference=new File(TEST_DATA_DIR ""summary_alignment_stats_test.fasta""); final File outfile=File.createTempFile(""alignmentMet"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectMultipleMetricsTest.java,testGcBiasMetrics,@Test public void  () throws IOException { runGcTest(tempSamFile); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectMultipleMetricsTest.java,testInsertSize,"@Test public void  () throws IOException { final File input=new File(TEST_DATA_DIR ""insert_size_metrics_test.sam""); final File outfile=File.createTempFile(""test"" """"); final File reference=new File(TEST_DATA_DIR ""summary_alignment_stats_test.fasta""); final"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTest.java,getCommandLineProgramName,public String  (){ return CollectWgsMetrics.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTest.java,setupBuilder,"@BeforeTest void  () throws IOException { final String readName=""TESTBARCODE""; tempSamFile=VcfTestUtils.createTemporaryIndexedFile(""CollectWgsMetrics"" "".bam""); final File tempSamFileUnsorted=File.createTempFile(""CollectWgsMetrics"" "".bam"" TEST_DIR); tempSa"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTest.java,testExclusions,"@Test(dataProvider=""wgsAlgorithm"") public void  (final String useFastAlgorithm) throws IOException { final File reference=new File(""testdata/picard/sam/merger.fasta""); final File tempSamFile=VcfTestUtils.createTemporaryIndexedFile(""CollectWgsMetrics"" "".ba"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTest.java,testGiantDeletion,"@Test(dataProvider=""wgsAlgorithm"") public void  (final String useFastAlgorithm) throws IOException { final File reference=new File(""testdata/picard/quality/chrM.reference.fasta""); final File testSamFile=VcfTestUtils.createTemporaryIndexedFile(""CollectWgsM"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTest.java,testLargeIntervals,"@Test(dataProvider=""wgsAlgorithm"") public void  (final String useFastAlgorithm) throws IOException { final File input=new File(TEST_DIR ""forMetrics.sam""); final File outfile=File.createTempFile(""test"" "".wgs_metrics""); outfile.deleteOnExit(); final File re"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTest.java,testMetricsFromWGS,"@Test(dataProvider=""wgsDataProvider"") public void  (final File input final File outfile final String referenceFile final String useFastAlgorithm) throws IOException { outfile.deleteOnExit(); final int sampleSize=1000; final String[] args=new String[]{""INP"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTest.java,testPoorQualityBases,"@Test(dataProvider=""wgsAlgorithm"") public void  (final String useFastAlgorithm) throws IOException { final File reference=new File(""testdata/picard/quality/chrM.reference.fasta""); final File testSamFile=VcfTestUtils.createTemporaryIndexedFile(""CollectWgsM"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTest.java,wgsAlgorithm,"@DataProvider(name="" "") public Object[][] wgsAlgorithm(){ return new Object[][]{{""false""} {""true""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTest.java,wgsDataProvider,"@DataProvider(name="" "") public Object[][] wgsDataProvider(){ final String referenceFile=""testdata/picard/quality/chrM.reference.fasta""; return new Object[][]{{tempSamFile outfile referenceFile ""false""} {tempSamFile outfile referenceFile ""true""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTestUtils.java,createIntervalList,static IntervalList  (){ return new IntervalList(new SAMFileHeader()); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTestUtils.java,createReadEndsIterator,static AbstractLocusIterator  (String exampleSam){ final List<SamRecordFilter> filters=new ArrayList<>(); final CountingFilter dupeFilter=new CountingDuplicateFilter(); final CountingFilter mapqFilter=new CountingMapQFilter(0); filters.add(new SecondaryAlignmentFilter()); filters.add(mapqFilter); filters.add(dupeFilter); SamReader samReader=createSamReader(exampleSam); AbstractLocusIterator iterator=new EdgeReadIterator(samReader); iterator.setSamFilters(filters); iterator.setMappingQualityScoreCutoff(0); iterator.setIncludeNonPfReads(false); return iterator; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTestUtils.java,createReferenceSequenceFile,"static ReferenceSequenceFile  (String referenceString){ final SAMSequenceRecord record=new SAMSequenceRecord(""ref"" referenceString.length()); final SAMSequenceDictionary dictionary=new SAMSequenceDictionary(); dictionary.addSequence(record); return new ReferenceSequenceFile(){ boolean done=false; @Override public SAMSequenceDictionary getSequenceDictionary(){ return dictionary; } @Override public ReferenceSequence nextSequence(){ if (!done) { done=true; return getSequence(record.getSequenceName()); } return null; } @Override public void reset(){ done=false; } @Override public boolean isIndexed(){ return false; } @Override public ReferenceSequence getSequence( String contig){ if (contig.equals(record.getSequenceName())) { return new ReferenceSequence(record.getSequenceName() 0 referenceString.getBytes()); } else { return null; } } @Override public ReferenceSequence getSubsequenceAt( String contig  long start  long stop){ return null; } @Override public String toString(){ return null; } @Override public void close() throws IOException { } } ; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTestUtils.java,createSamReader,static SamReader  (String samExample){ ByteArrayInputStream inputStream=new ByteArrayInputStream(samExample.getBytes()); return SamReaderFactory.makeDefault().open(SamInputResource.of(inputStream)); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTestUtils.java,createTestSAM,"private static void  (String testSamName) throws IOException { final File testDir=new File(""testdata/picard/analysis/directed/CollectHsMetrics/""); final File reference=new File(""testdata/picard/quality/chrM.reference.fasta""); final String readGroupId=""TestReadGroup""; final String sample=""TestSample""; final String platform=""Illumina""; final String library=""TestLibrary""; final int numReads=1; final int readLength=10; File samFile=File.createTempFile(testSamName "".bam"" testDir); final SAMRecordSetBuilder setBuilder=createTestSAMBuilder(reference readGroupId sample platform library); setBuilder.setReadLength(readLength); IntStream.range(0 numReads).forEach(i -> setBuilder.addPair(""MediocreBaseQ"" + i 0 1 200 false false readLength + ""M"" readLength + ""M"" false true 40)); final SAMFileWriter writer=new SAMFileWriterFactory().setCreateIndex(true).makeBAMWriter(setBuilder.getHeader() false samFile); setBuilder.forEach(writer::addAlignment); writer.close(); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTestUtils.java,createTestSAMBuilder,protected static SAMRecordSetBuilder  (final File reference final String readGroupId final String sample final String platform final String library){ final SAMFileHeader header=new SAMFileHeader(); try { header.setSequenceDictionary(SAMSequenceDictionaryExtractor.extractDictionary(reference.toPath())); header.setSortOrder(SAMFileHeader.SortOrder.unsorted); } catch ( final SAMException e) { e.printStackTrace(); } final SAMReadGroupRecord readGroupRecord=new SAMReadGroupRecord(readGroupId); readGroupRecord.setSample(sample); readGroupRecord.setPlatform(platform); readGroupRecord.setLibrary(library); readGroupRecord.setPlatformUnit(readGroupId); header.addReadGroup(readGroupRecord); final SAMRecordSetBuilder setBuilder=new SAMRecordSetBuilder(true SAMFileHeader.SortOrder.coordinate true 100); setBuilder.setReadGroup(readGroupRecord); setBuilder.setUseNmFlag(true); setBuilder.setHeader(header); return (setBuilder); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTestUtils.java,getReferenceSequenceFileWalker,"static ReferenceSequenceFileWalker  (){ String referenceString="">ref\nACCTACGTTCAATATTCTTC""; return getReferenceSequenceFileWalker(referenceString); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTestUtils.java,getSequence,@Override public ReferenceSequence  (String contig){ if (contig.equals(record.getSequenceName())) { return new ReferenceSequence(record.getSequenceName() 0 referenceString.getBytes()); } else { return null; } } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTestUtils.java,getSequenceDictionary,@Override public SAMSequenceDictionary  (){ return dictionary; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTestUtils.java,getSubsequenceAt,@Override public ReferenceSequence  (String contig long start long stop){ return null; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTestUtils.java,isIndexed,@Override public boolean  (){ return false; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTestUtils.java,main,"public static void  (String[] args){ try { createTestSAM(""TestSam""); } catch ( IOException e) { ; } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTestUtils.java,nextSequence,@Override public ReferenceSequence  (){ if (!done) { done=true; return getSequence(record.getSequenceName()); } return null; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTestUtils.java,reset,@Override public void  (){ done=false; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsTestUtils.java,toString,@Override public String  (){ return null; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsWithNonZeroCoverageTest.java,getCommandLineProgramName,public String  (){ return CollectWgsMetricsWithNonZeroCoverage.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsWithNonZeroCoverageTest.java,testNoCoverage,"@Test public void  () throws IOException { final File reference=new File(""testdata/picard/quality/chrM.reference.fasta""); final File testSamFile=File.createTempFile(""CollectWgsMetrics"" "".bam"" TEST_DIR); testSamFile.deleteOnExit(); final SAMRecordSetBuilde"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsWithNonZeroCoverageTest.java,testPoorQualityBases,"@Test public void  () throws IOException { final File reference=new File(""testdata/picard/quality/chrM.reference.fasta""); final File testSamFile=File.createTempFile(""CollectWgsMetrics"" "".bam"" TEST_DIR); testSamFile.deleteOnExit(); final SAMRecordSetBuilde"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsWithNonZeroCoverageTest.java,testWithIntervals,"@Test public void  () throws IOException { final File input=new File(TEST_DIR ""forMetrics.sam""); final File outfile=File.createTempFile(""test"" "".wgs_metrics""); final File pdffile=File.createTempFile(""test"" "".wgs_metrics.pdf""); final File ref=new File(TEST"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CollectWgsMetricsWithNonZeroCoverageTest.java,testWithoutIntervals,"@Test public void  () throws IOException { final File input=new File(TEST_DIR ""forMetrics.sam""); final File outfile=File.createTempFile(""test"" "".wgs_metrics""); final File pdffile=File.createTempFile(""test"" "".wgs_metrics.pdf""); final File ref=new File(TEST"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\directed\CollectHsMetricsTest.java,getCommandLineProgramName,@Override public String  (){ return CollectHsMetrics.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\directed\CollectHsMetricsTest.java,runCollectHsMetricsTest,"@Test(dataProvider=""collectHsMetricsDataProvider"") public void  (final String input final String targetIntervals final int minimumMappingQuality final int minimumBaseQuality final boolean clipOverlappingReads final int totalReads final int pfUqBasesAligne"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\directed\CollectHsMetricsTest.java,targetedIntervalDataProvider,"@DataProvider(name=""collectHsMetricsDataProvider"") public Object[][]  (){ final String referenceFile=TEST_DIR + ""/chrM.fasta""; final String intervals=TEST_DIR + ""/chrM.interval_list""; final String twoSmallIntervals=TEST_DIR + ""/two-small.interval_list""; r"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\directed\CollectHsMetricsTest.java,testCoverageHistogram,"@Test public void  () throws IOException { final String input=TEST_DIR + ""/single-short-read.sam""; final String targetIntervals=TEST_DIR + ""/two-small.interval_list""; final int minimumMappingQuality=20; final int minimumBaseQuality=20; final boolean clipO"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\FastWgsMetricsCollectorTest.java,generateRecord,private SAMRecord  (String name){ SAMRecord record=new SAMRecord(new SAMFileHeader()); record.setReadName(name); record.setBaseQualities(highQualities); record.setReadBases(refBases); return record; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\FastWgsMetricsCollectorTest.java,setUp,"@BeforeTest public void  (){ String referenceString="">chrM\nACCTACGTTCAATATTCTTCACCTACGTTCAATATTCTTCACCTACGTTCAATATTCTTCACCTACGTTCAATATTCTTCACCTACGTTCAATATTCTTC""; ref=new ReferenceSequence(""chrM"" 0 referenceString.getBytes()); sequence=new SAMSequenceReco"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\FastWgsMetricsCollectorTest.java,testAddInfoForCapping,@Test public void  (){ CollectWgsMetrics collectWgsMetrics=new CollectWgsMetrics(); FastWgsMetricsCollector collector=new FastWgsMetricsCollector(collectWgsMetrics 1 createIntervalList()); AbstractLocusInfo<EdgingRecordAndOffset> firstInfo=new AbstractLoc
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\FastWgsMetricsCollectorTest.java,testAddInfoForOverlap,@Test public void  (){ CollectWgsMetrics collectWgsMetrics=new CollectWgsMetrics(); FastWgsMetricsCollector collector=new FastWgsMetricsCollector(collectWgsMetrics 100 createIntervalList()); AbstractLocusInfo<EdgingRecordAndOffset> firstInfo=new AbstractL
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\FastWgsMetricsCollectorTest.java,testAddInfoForQuality,@Test public void  () throws Exception { CollectWgsMetrics collectWgsMetrics=new CollectWgsMetrics(); FastWgsMetricsCollector collector=new FastWgsMetricsCollector(collectWgsMetrics 100 createIntervalList()); AbstractLocusInfo<EdgingRecordAndOffset> first
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\FastWgsMetricsCollectorTest.java,testAddInfoWithoutOverlap,@Test public void  (){ CollectWgsMetrics collectWgsMetrics=new CollectWgsMetrics(); FastWgsMetricsCollector collector=new FastWgsMetricsCollector(collectWgsMetrics 100 createIntervalList()); AbstractLocusInfo<EdgingRecordAndOffset> firstInfo=new AbstractL
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\FastWgsMetricsCollectorTest.java,testForBaseQualityHetSens,@Test public void  (){ CollectWgsMetrics collectWgsMetrics=new CollectWgsMetrics(); collectWgsMetrics.INCLUDE_BQ_HISTOGRAM=true; FastWgsMetricsCollector collector=new FastWgsMetricsCollector(collectWgsMetrics 10 createIntervalList()); AbstractLocusInfo<Ed
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\FastWgsMetricsCollectorTest.java,testForCollectorWithoutData,@Test public void  (){ long[] templateQualHistogram=new long[127]; long[] templateHistogramArray=new long[11]; CollectWgsMetrics collectWgsMetrics=new CollectWgsMetrics(); FastWgsMetricsCollector collector=new FastWgsMetricsCollector(collectWgsMetrics 10 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\FastWgsMetricsCollectorTest.java,testForComplicatedCigar,@Test public void  (){ CollectWgsMetrics collectWgsMetrics=new CollectWgsMetrics(); FastWgsMetricsCollector collector=new FastWgsMetricsCollector(collectWgsMetrics 100 createIntervalList()); AbstractLocusIterator sli=createReadEndsIterator(exampleSamTwoRe
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\FastWgsMetricsCollectorTest.java,testForExcludedForQualityHistogramArray,@Test public void  (){ CollectWgsMetrics collectWgsMetrics=new CollectWgsMetrics(); collectWgsMetrics.INCLUDE_BQ_HISTOGRAM=true; FastWgsMetricsCollector collector=new FastWgsMetricsCollector(collectWgsMetrics 100 createIntervalList()); AbstractLocusInfo<E
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\FastWgsMetricsCollectorTest.java,testForHistogramArray,@Test public void  (){ CollectWgsMetrics collectWgsMetrics=new CollectWgsMetrics(); FastWgsMetricsCollector collector=new FastWgsMetricsCollector(collectWgsMetrics 10 createIntervalList()); long[] templateHistogramArray={0 1 3 0 0 0 0 0 0 0 0}; AbstractLo
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\directed\CollectTargetedMetricsTest.java,getCommandLineProgramName,@Override public String  (){ return CollectTargetedPcrMetrics.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MergeableMetricBaseTest.java,TestCanMerge,@Test public void  (){ final TestMergeableMetric instance1=new TestMergeableMetric(); instance1.unboxedInt=1; final TestDerivedMergableMetric instance2=new TestDerivedMergableMetric(); instance2.unboxedInt=2; instance1.merge(instance2); Assert.assertEqual
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MergeableMetricBaseTest.java,TestMergingDerivedClass,@Test public void  (){ final TestMergeableMetric instance1=new TestMergeableMetric(); final TestDerivedMergableMetric instance2=new TestDerivedMergableMetric(); instance1.merge(instance2); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MergeableMetricBaseTest.java,TestMergingSuperClass,@Test(expectedExceptions=IllegalArgumentException.class) public void  (){ final TestMergeableMetric instance1=new TestMergeableMetric(); final TestDerivedMergableMetric instance2=new TestDerivedMergableMetric(); instance2.merge(instance1); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MergeableMetricBaseTest.java,testIllegalClass,@Test(expectedExceptions=IllegalStateException.class) public void  (){ final TestMergeableMetricIllegal illegal1=new TestMergeableMetricIllegal()  illegal2=new TestMergeableMetricIllegal(); illegal1.merge(illegal2); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\directed\CollectTargetedMetricsTest.java,runCollectTargetedMetricsTest,"@Test(dataProvider=""targetedIntervalDataProvider"") public void  (final File input final File outfile final File perTargetOutfile final String referenceFile final String targetIntervals final int sampleSize) throws IOException { final String[] args=new Str"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MergeableMetricBaseTest.java,testMerging,@Test public void  (){ final TestMergeableMetric metric1=new TestMergeableMetric()  metric2=new TestMergeableMetric(); metric1.merge(metric2); Assert.assertEquals(metric1.boxedInt (Integer)2); Assert.assertEquals(metric1.unboxedInt 4); Assert.assertEquals
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MergeableMetricBaseTest.java,testMergingANull,"@Test public void  (){ final TestMergeableMetric metric1=new TestMergeableMetric()  metric2=new TestMergeableMetric(); metric1.mustBeEqualString=""goodbye""; metric2.mustBeEqualString=null; Assert.assertTrue(metric1.canMerge(metric2)); metric1.merge(metric2"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MergeableMetricBaseTest.java,testMergingUnequalBoolean,@Test(expectedExceptions=IllegalStateException.class) public void  (){ final TestMergeableMetric metric1=new TestMergeableMetric()  metric2=new TestMergeableMetric(); metric1.mustBeEqualUnboxedBoolean=true; Assert.assertFalse(metric1.canMerge(metric2)); m
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MergeableMetricBaseTest.java,testMergingUnequalDouble,@Test(expectedExceptions=IllegalStateException.class) public void  (){ final TestMergeableMetric metric1=new TestMergeableMetric()  metric2=new TestMergeableMetric(); metric1.mustBeEqualDouble=1D; Assert.assertFalse(metric1.canMerge(metric2)); metric1.mer
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\directed\CollectTargetedMetricsTest.java,setupBuilder,"@BeforeTest void  () throws IOException { final String readName=""TESTBARCODE""; tempSamFile=VcfTestUtils.createTemporaryIndexedFile(""CollectTargetedMetrics"" "".bam""); final File tempSamFileUnsorted=VcfTestUtils.createTemporaryIndexedFile(""CollectTargetedMet"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MergeableMetricBaseTest.java,testMergingUnequalString,"@Test(expectedExceptions=IllegalStateException.class) public void  (){ final TestMergeableMetric metric1=new TestMergeableMetric()  metric2=new TestMergeableMetric(); metric1.mustBeEqualString=""goodbye""; Assert.assertFalse(metric1.canMerge(metric2)); metr"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\directed\CollectTargetedMetricsTest.java,targetedIntervalDataProvider,"@DataProvider(name="" "") public Object[][] targetedIntervalDataProvider(){ return new Object[][]{{tempSamFile outfile perTargetOutfile referenceFile singleIntervals 1000} {tempSamFile outfile perTargetOutfile referenceFile emptyIntervals 1000}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MergeableMetricBaseTest.java,testMergingWithRestrictedMembers,@Test public void  (){ final TestMergeableMetricWithRestrictedMembers metric1=new TestMergeableMetricWithRestrictedMembers()  metric2=new TestMergeableMetricWithRestrictedMembers(); metric1.merge(metric2); Assert.assertEquals(metric1.boxedInt (Integer)2);
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\directed\CollectTargetedMetricsTest.java,testCoverageGetTotalOverflow,"@Test public void  (){ final Interval interval=new Interval(""chr1"" 1 2); final TargetMetricsCollector.Coverage coverage=new TargetMetricsCollector.Coverage(interval 0); for (int offset=0; offset <= interval.length(); offset++) { coverage.addBase(offset In"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MergeableMetricBaseTest.java,testMergingWithRestrictedMembersUsingBaseClass,@Test public void  (){ final MergeableMetricBase metric1=new TestMergeableMetricWithRestrictedMembers()  metric2=new TestMergeableMetricWithRestrictedMembers(); metric1.merge(metric2); Assert.assertEquals(((TestMergeableMetricWithRestrictedMembers)metric1
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\directed\CollectTargetedMetricsTest.java,testRawBqDistributionWithSoftClips,"@Test() public void  () throws IOException { final String input=TEST_DATA_DIR + ""chrMReadsWithClips.sam""; final File outFile=File.createTempFile(""test"" "".TargetedMetrics_Coverage""); outFile.deleteOnExit(); final String[] args=new String[]{""TARGET_INTERVAL"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CounterManagerTest.java,setUp,@BeforeTest public void  (){ secondTestCounterManager=new CounterManager(arrayLength readLength); secondTestCounterManager.setOffset(OFFSET); secondCounter=secondTestCounterManager.newCounter(); testCounterManager=new CounterManager(arrayLength readLength
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CounterManagerTest.java,testCounterInc,"@Test public void  (){ Assert.assertEquals(2 testCounter.get(OFFSET) ""Test method increment:""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CounterManagerTest.java,testForCheckIncrement,@Test public void  (){ CounterManager testCounterManager=new CounterManager(arrayLength readLength); testCounterManager.setOffset(0); CounterManager.Counter counter=testCounterManager.newCounter(); for (int i=0; i < 10; i++) { counter.increment(1); } int[
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CounterManagerTest.java,testForCleanCounterAfter,"@Test public void  (){ testCounterManager.checkOutOfBounds(88); Assert.assertEquals(0 testCounter.get(88) ""The value of the array with index 0 must be 1 after clean:""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CounterManagerTest.java,testForClearCounter,"@Test public void  (){ testCounterManager.clear(); Assert.assertEquals(0 testCounter.get(OFFSET) ""The value of the array with index 0 must be 0 after clear manager:""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CounterManagerTest.java,testForCorrectCounterAfterRebase,"@Test public void  (){ secondTestCounterManager.checkOutOfBounds(11); Assert.assertEquals(1 secondCounter.get(11) ""The value of the array with index 0 must be 1 after rebase:""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CounterManagerTest.java,testForCorrectOffsetAfterRebase,"@Test public void  (){ secondTestCounterManager.checkOutOfBounds(11); Assert.assertEquals(11 secondTestCounterManager.getOffset() ""After rebase offset must be new int""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CounterManagerTest.java,testForOutOfBoundCounter,"@Test public void  (){ secondTestCounterManager.checkOutOfBounds(44); Assert.assertEquals(44 secondTestCounterManager.getOffset() ""New offset after clear must be 44:""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CounterManagerTest.java,testForWrongIndexInGet,@Test(expectedExceptions=IndexOutOfBoundsException.class) public void  (){ testCounter.get(40); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\CounterManagerTest.java,testForWrongIndexInInc,@Test(expectedExceptions=IndexOutOfBoundsException.class) public void  (){ testCounter.increment(40); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\replicates\CollectIndependentReplicatesMetricTest.java,convertSamToBam,"private static File  (final String sam) throws IOException { final MergeSamFiles msf=new MergeSamFiles(); final File bam=new File(bamOutDir sam.replaceAll(""sam$"" ""bam"")); final int returnCode=msf.instanceMain(new String[]{""INPUT="" + (new File(testdir sam).getAbsolutePath()) ""CREATE_INDEX=true"" ""OUTPUT="" + bam.getAbsolutePath()}); Assert.assertEquals(returnCode 0); return bam; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\replicates\CollectIndependentReplicatesMetricTest.java,prepareBams,@BeforeTest public void  () throws IOException { sams.keySet().stream().forEach(key -> { try { bams.put(key convertSamToBam(sams.get(key))); bams.get(key).deleteOnExit(); } catch ( IOException e) { e.printStackTrace(); } } ); bamOutDir.deleteOnExit(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\replicates\CollectIndependentReplicatesMetricTest.java,simpleTest,"@Test(dataProvider="" s"") public void simpleTest(final String vcf final String bam final Map<String Object> fieldValueMap) throws IOException  NoSuchFieldException  IllegalAccessException { final CollectIndependentReplicateMetrics est=new CollectIndependen"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\replicates\CollectIndependentReplicatesMetricTest.java,simpleTestsData,"@DataProvider(name=""simpleTests"") public Iterator<Object[]>  (){ final List<Object[]> tests=new ArrayList<>(3); { final Map<String Object> map=new LinkedHashMap<>(); map.put(""nSites"" 3); map.put(""nDuplicateSets"" 3); map.put(""nMismatchingUMIsInCoOrientedBi"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\replicates\CollectIndependentReplicatesMetricTest.java,tearDown,@AfterTest public void  (){ TestUtil.recursiveDelete(bamOutDir); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MultiLevelCollectorTest.java,RecordCountMultiLevelCollector,public  (final Set<MetricAccumulationLevel> accumulationLevels final List<SAMReadGroupRecord> samRgRecords){ setup(accumulationLevels samRgRecords); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MultiLevelCollectorTest.java,RecordCountPerUnitCollector,"public  (final String sample final String library final String readGroup){ metric=new TotalNumberMetric(); metric.SAMPLE=sample; metric.LIBRARY=library; metric.READ_GROUP=readGroup; unitsToMetrics.put(noneOrStr(sample) + ""_"" + noneOrStr(library)+ ""_""+ noneOrStr(readGroup) metric); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MultiLevelCollectorTest.java,TestArg,public  (final SAMRecord samRecord final ReferenceSequence refSeq){ this.samRecord=samRecord; this.refSeq=refSeq; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MultiLevelCollectorTest.java,acceptRecord,@Override public void  (final TestArg args){ numProcessed+=1; metric.TALLY+=1; if (metric.SAMPLE != null) { Assert.assertEquals(metric.SAMPLE args.samRecord.getReadGroup().getSample()); } if (metric.LIBRARY != null) { Assert.assertEquals(metric.LIBRARY ar
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MultiLevelCollectorTest.java,addMetricsToFile,@Override public void  (final MetricsFile<TotalNumberMetric Integer> totalNumberMetricIntegerMetricsFile){ totalNumberMetricIntegerMetricsFile.addMetric(metric); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MultiLevelCollectorTest.java,finish,@Override public void  (){ metric.FINISHED=true; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MultiLevelCollectorTest.java,getNumProcessed,public int  (){ return numProcessed; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MultiLevelCollectorTest.java,getUnitsToMetrics,public Map<String TotalNumberMetric>  (){ return unitsToMetrics; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MultiLevelCollectorTest.java,makeArg,@Override protected TestArg  (final SAMRecord samRec final ReferenceSequence refSeq){ return new TestArg(samRec refSeq); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MultiLevelCollectorTest.java,makeChildCollector,@Override protected PerUnitMetricCollector<TotalNumberMetric Integer TestArg>  (final String sample final String library final String readGroup){ return new RecordCountPerUnitCollector(sample library readGroup); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MultiLevelCollectorTest.java,multilevelCollectorTest,"@Test(dataProvider=""variedAccumulationLevels"") public void  (final Set<MetricAccumulationLevel> accumulationLevels){ final SamReader in=SamReaderFactory.makeDefault().open(TESTFILE); final RecordCountMultiLevelCollector collector=new RecordCountMultiLevel"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MultiLevelCollectorTest.java,noneOrStr,"public String  (final String str){ final String out; if (str == null) { out=""""; } else { out=str; } return out; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\MultiLevelCollectorTest.java,variedAccumulationLevels,"@DataProvider(name="" "") public Object[][] variedAccumulationLevels(){ return new Object[][]{{makeSet(MetricAccumulationLevel.ALL_READS)} {makeSet(MetricAccumulationLevel.ALL_READS MetricAccumulationLevel.SAMPLE)} {makeSet(MetricAccumulationLevel.SAMPLE Me"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\WgsMetricsTest.java,buildIntervalList,"private IntervalList  (final int start final int end){ final SAMFileHeader header=new SAMFileHeader(); header.addSequence(new SAMSequenceRecord(""CONTIG"" 100000000)); final IntervalList intervals=new IntervalList(header); if (0 < start) intervals.add(new Interval(""CONTIG"" start end)); return intervals; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\WgsMetricsTest.java,emptyDepthHistogram,private Histogram<Integer>  (){ return new Histogram<>(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\WgsMetricsTest.java,emptyMetrics,private CollectWgsMetrics.WgsMetrics  (){ return new CollectWgsMetrics.WgsMetrics(buildIntervalList(-1 -1) emptyDepthHistogram() emptyDepthHistogram() 0 0 0 0 0 0 0 1000000 null -1); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\WgsMetricsTest.java,singleDepthHistogram,private Histogram<Integer>  (final int depth final int count){ final Histogram<Integer> histogram=new Histogram<>(); histogram.increment(depth count); return histogram; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\WgsMetricsTest.java,singleDepthMetrics,private CollectWgsMetrics.WgsMetrics  (final int depth final int countScale final int start){ final int count=100000 * countScale; final int totalExcluded=(10 + 20 + 30+ 40+ 50+ 60) * countScale; return new CollectWgsMetrics.WgsMetrics(buildIntervalList(start start) singleDepthHistogram(depth count) singleDepthHistogram(depth count) 10d * countScale / count 20d * countScale / count 30d * countScale / count 40d * countScale / count 50d * countScale / count 60d * countScale / count totalExcluded / (double)(count + totalExcluded) 1000000 null -1); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\WgsMetricsTest.java,testMergeOverlappingIntervals,@Test(expectedExceptions={PicardException.class}) public void  (){ singleDepthMetrics(1 1 1).merge(singleDepthMetrics(1 1 1)); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\WgsMetricsTest.java,testWgsMetricsMerge,"@Test(dataProvider="" DataProvider"") public void testWgsMetricsMerge(final CollectWgsMetrics.WgsMetrics left final CollectWgsMetrics.WgsMetrics right final CollectWgsMetrics.WgsMetrics expected){ left.merge(right); left.calculateDerivedFields(); Assert.ass"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\WgsMetricsTest.java,testWgsMetricsMergeDataProvider,"@DataProvider(name="" "") public Object[][] testWgsMetricsMergeDataProvider(){ return new Object[][]{{emptyMetrics() emptyMetrics() emptyMetrics()} {emptyMetrics() singleDepthMetrics(1 1 1) singleDepthMetrics(1 1 1)} {singleDepthMetrics(1 1 1) emptyMetrics("
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\WgsMetricsTest.java,twoSiteDepthHistogram,private Histogram<Integer>  (final int depth1 final int count1 final int depth2 final int count2){ final Histogram<Integer> histogram=new Histogram<>(); if (0 < depth1) histogram.increment(depth1 count1); if (0 < depth2) histogram.increment(depth2 count2); return histogram; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\WgsMetricsTest.java,twoSiteDepthMetrics,private CollectWgsMetrics.WgsMetrics  (final int depth1 final int countScale1 final int depth2 final int countScale2 final int start){ final int count1=100000 * countScale1; final int count2=100000 * countScale2; final int count=count1 + count2; final int countScale=countScale1 + countScale2; final int totalExcluded=(10 + 20 + 30+ 40+ 50+ 60) * countScale; return new CollectWgsMetrics.WgsMetrics(buildIntervalList(start start + 1) twoSiteDepthHistogram(depth1 count1 depth2 count2) twoSiteDepthHistogram(depth1 count1 depth2 count2) 10d * countScale / count 20d * countScale / count 30d * countScale / count 40d * countScale / count 50d * countScale / count 60d * countScale / count totalExcluded / (double)(count + totalExcluded) 100000 null -1); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\TheoreticalSensitivityTest.java,hetSensDataProvider,"@DataProvider(name="" "") public Object[][] hetSensDataProvider(){ final File wgsMetricsFile=new File(TEST_DIR ""test_Solexa-332667.wgs_metrics""); final File targetedMetricsFile=new File(TEST_DIR ""test_25103070136.targeted_pcr_metrics""); return new Object[]["
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\TheoreticalSensitivityTest.java,testCentralLimitTheorem,@Test public void  () throws Exception { final double[] weights={1.0 1.0 1.0}; final TheoreticalSensitivity.RouletteWheel wheel=new TheoreticalSensitivity.RouletteWheel(weights); final int sampleSize=1000; final int numSummands=100; final double muSingleD
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\TheoreticalSensitivityTest.java,testDeterministicQualityAndDepth,@Test public void  () throws Exception { final double logOddsThreshold=0.0; final double tolerance=0.001; final int sampleSize=1; for (int q=5; q < 10; q++) { for (int n=5; n < 10; n++) { final double minAltCount=10 * n * Math.log10(2) / q; double expecte
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\TheoreticalSensitivityTest.java,testHetAltDepthDistribution,@Test public void  () throws Exception { final int N=6; final double p=0.5; final List<ArrayList<Double>> distribution=TheoreticalSensitivity.hetAltDepthDistribution(N); for (int n=0; n < N - 1; n++) { for (int m=0; m <= n; m++) { int binomialCoefficient=
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\TheoreticalSensitivityTest.java,testHetSensDistributions,@Test public void  () throws Exception { final double tolerance=0.02; final double expectedResult=.9617; final int maxDepth=500; final double[] depthDistribution=new double[maxDepth + 1]; final double[] qualityDistribution=new double[50]; final Scanner sc
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\TheoreticalSensitivityTest.java,testHetSensTargeted,"@Test(dataProvider=""hetSensDataProvider"") public void  (final double expected final File metricsFile) throws Exception { final double tolerance=0.000_000_01; final MetricsFile Metrics=new MetricsFile(); Metrics.read(new FileReader(metricsFile)); final Lis"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\TheoreticalSensitivityTest.java,testProportionsAboveThresholds,@Test public void  () throws Exception { final List<ArrayList<Integer>> sums=new ArrayList<ArrayList<Integer>>(); sums.add(new ArrayList<Integer>(Arrays.asList(0 0 0))); sums.add(new ArrayList<Integer>(Arrays.asList(10 10))); sums.add(new ArrayList<Intege
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\TheoreticalSensitivityTest.java,testRouletteWheel,@Test public void  () throws Exception { final double[] deterministicWeights={0.0 1.0 0.0}; final TheoreticalSensitivity.RouletteWheel deterministicWheel=new TheoreticalSensitivity.RouletteWheel(deterministicWeights); for (int n=0; n < 10; n++) Assert.ass
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\cmdline\CommandLineProgramStartupErrorLogTest.java,doWork,@Override public int  (){ return 0; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\cmdline\CommandLineProgramStartupErrorLogTest.java,testNoStartupErrorLog,@Test public void  (){ ByteArrayOutputStream stderrStream=new ByteArrayOutputStream(); PrintStream newStderr=new PrintStream(stderrStream); PrintStream oldStderr=System.err; System.setErr(newStderr); CommandLineProgram clp=new MockCLP(); try { clp.instanc
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\cmdline\CommandLineProgramStartupErrorLogTest.java,testNoStartupOutputLog,@Test public void  (){ ByteArrayOutputStream stdoutStream=new ByteArrayOutputStream(); PrintStream newStdout=new PrintStream(stdoutStream); PrintStream oldStdout=System.out; System.setOut(newStdout); CommandLineProgram clp=new MockCLP(); try { clp.instanc
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\WgsMetricsProcessorImplTest.java,setUp,@BeforeTest public void  (){ progress=new ProgressLogger(Log.getInstance(WgsMetricsProcessorImpl.class)); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\WgsMetricsProcessorImplTest.java,testForExitAfter,@Test public void  (){ AbstractLocusIterator iterator=createReadEndsIterator(exampleSamOneRead); CollectWgsMetrics collectWgsMetrics=new CollectWgsMetrics(); collectWgsMetrics.STOP_AFTER=16; AbstractWgsMetricsCollector collector=new FastWgsMetricsCollecto
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\WgsMetricsProcessorImplTest.java,testForFilteredBases,@Test public void  (){ AbstractLocusIterator iterator=createReadEndsIterator(exampleSamOneRead); CollectWgsMetrics collectWgsMetrics=new CollectWgsMetrics(); FastWgsMetricsCollector collector=new FastWgsMetricsCollector(collectWgsMetrics 100 createInterva
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\analysis\WgsMetricsProcessorImplTest.java,testForProcessFile,@Test public void  (){ AbstractLocusIterator iterator=createReadEndsIterator(exampleSamOneRead); CollectWgsMetrics collectWgsMetrics=new CollectWgsMetrics(); FastWgsMetricsCollector collector=new FastWgsMetricsCollector(collectWgsMetrics 100 createInterva
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\cmdline\PicardCommandLineTest.java,TestPicardPublic,"@Test public void  (){ PicardCommandLine picardCommandLine=new PicardCommandLine(); picardCommandLine.instanceMain(new String[]{""""}); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\cmdline\PicardCommandLineTest.java,testLaunchAllCommandLineProgramsWithBarclayParser,"@Test public void  (){ PicardCommandLine.processAllCommandLinePrograms(Collections.singletonList(""picard"") ( Class<CommandLineProgram> clazz  CommandLineProgramProperties clProperties) -> { if (null != clProperties) { try { final Object commandLineProgram"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\cmdline\PicardCommandLineTest.java,testPrintUsage,"@Test public void  (){ Assert.assertEquals(new PicardCommandLine().instanceMain(new String[]{""-h""}) 1); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\cmdline\PicardCommandLineTest.java,testProcessCommandLinePrograms,"@Test public void  (){ final List<Class<CommandLineProgram>> allCLPs=new ArrayList<>(); PicardCommandLine.processAllCommandLinePrograms(Collections.singletonList(""picard"") ( Class<CommandLineProgram> clazz  CommandLineProgramProperties clProperties) -> { "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CheckFingerprintTest.java,badData,"@DataProvider(name="" "") public Object[][] badData(){ return new Object[][]{{TEST_INPUT_VCF_EMPTY TEST_OUTPUT TEST_GENOTYPES_VCF1 SUBSETTED_HAPLOTYPE_DATABASE_FOR_TESTING} {TEST_INPUT_VCF_NO_FILE TEST_OUTPUT TEST_GENOTYPES_VCF1 SUBSETTED_HAPLOTYPE_DATABASE"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CheckFingerprintTest.java,getCommandLineProgramName,@Override public String  (){ return CheckFingerprint.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CheckFingerprintTest.java,mkTemp,@BeforeClass private void  (){ if (!tempFolder.exists()) { tempFolder.mkdir(); } } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CheckFingerprintTest.java,rmTemp,@AfterClass private void  (){ IOUtil.deleteDirectoryTree(tempFolder); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CheckFingerprintTest.java,samsToFingerprint,"@DataProvider(name="" "") Object[][] samsToFingerprint(){ return new Object[][]{{NA12891_r1_sam na12891_fp} {NA12892_r1_sam na12891_fp}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CheckFingerprintTest.java,setup,"@BeforeClass public void  () throws IOException { NA12891_named_NA12892_vcf=VcfTestUtils.createTemporaryIndexedVcfFromInput(new File(TEST_DATA_DIR ""NA12891_named_NA12892.vcf"") ""fingerprint""); NA12892_1_vcf=VcfTestUtils.createTemporaryIndexedVcfFromInput(n"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CheckFingerprintTest.java,testBadData,"@Test(dataProvider=""badData"" expectedExceptions={MalformedFeatureFile.class SAMException.class}) public void  (final String inputVcf final String outputLoc final String genotypesFile final File haplotypeFile){ String[] args=new String[]{""I="" + inputVcf ""O"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CheckFingerprintTest.java,testBaseOutput,"@Test public void  (){ String[] args=new String[]{""I="" + TEST_INPUT_VCF1 ""O="" + TEST_OUTPUT ""G="" + TEST_GENOTYPES_VCF1 ""H="" + SUBSETTED_HAPLOTYPE_DATABASE_FOR_TESTING}; Assert.assertEquals(runPicardCommandLine(args) 0); Assert.assertTrue(MetricsFile.areMe"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CheckFingerprintTest.java,testCheckFingerprintNoRg,"@Test(dataProvider=""samsToFingerprint"") void  (File file File genotypes) throws IOException { tester(true file genotypes); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CheckFingerprintTest.java,testCheckFingerprintSam,"@Test(dataProvider=""samsToFingerprint"") void  (File file File genotypes) throws IOException { tester(false file genotypes); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CheckFingerprintTest.java,testCheckFingerprintVcf,"@Test(dataProvider=""vcfsToFingerprint"") void  (File file File genotypes) throws IOException { tester(false file genotypes); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CheckFingerprintTest.java,testIdentifyContaminant,"@Test public void  (){ final File mixture=new File(TEST_DATA_DIR ""NA128791_in_NA12892.25_PCT.sam""); final File contaminant=new File(TEST_DATA_DIR ""NA12891.over.fingerprints.r2.sam""); final File contaminated=new File(TEST_DATA_DIR ""NA12892.over.fingerprint"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CheckFingerprintTest.java,testSummaryAndDetailOutputs,"@Test public void  (){ String[] args=new String[]{""I="" + TEST_INPUT_VCF1 ""S="" + TEST_DATA_DIR + ""/tempCheckFPDir/summary"" ""D="" + TEST_DATA_DIR + ""/tempCheckFPDir/detail"" ""G="" + TEST_GENOTYPES_VCF1 ""H="" + SUBSETTED_HAPLOTYPE_DATABASE_FOR_TESTING}; Assert.a"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CheckFingerprintTest.java,tester,"private File  (boolean ignoreRG File file File genotypes) throws IOException { final List<String> args=new ArrayList<>(); final File outputSummary=File.createTempFile(""fingerprint"" ""summary_metrics""); outputSummary.deleteOnExit(); final File outputDetail=File.createTempFile(""fingerprint"" ""detail_metrics""); outputSummary.deleteOnExit(); args.add(""INPUT="" + file.getAbsolutePath()); args.add(""G="" + genotypes.getAbsolutePath()); if (ignoreRG) args.add(""IGNORE_RG=true""); args.add(""H="" + HAPLOTYPE_MAP.getAbsolutePath()); args.add(""SUMMARY_OUTPUT="" + outputSummary.getAbsolutePath()); args.add(""DETAIL_OUTPUT="" + outputDetail.getAbsolutePath()); Assert.assertEquals(runPicardCommandLine(args) 0); Assert.assertTrue(outputSummary.exists() ""Expected output file "" + outputSummary.getAbsolutePath() + "" to exist.""); Assert.assertTrue(outputDetail.exists() ""Expected output file "" + outputDetail.getAbsolutePath() + "" to exist.""); return outputSummary; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CheckFingerprintTest.java,vcfsToFingerprint,"@DataProvider(name="" "") Object[][] vcfsToFingerprint(){ return new Object[][]{{NA12891_named_NA12892_vcf na12892_fp} {NA12892_1_vcf na12892_fp}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fastq\BamToBfqTest.java,inputs,"@DataProvider(name="" "") public static Object[][] inputs() throws IOException { return new Object[][]{{INPUT_BAM false ""bam_to_bfq_test""} {INPUT_BAM true ""bam_to_bfq_paired_test""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fastq\BamToBfqTest.java,testBamToBfq,"@Test(dataProvider=""inputs"") public void  (final File input final boolean isPairedRun final String outputFilePrefix) throws IOException { final File analysisDir=IOUtil.createTempDir(""BamToBfqTest"" "".dir""); try { final String[] args=new String[]{""INPUT="" +"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\FingerprintCheckerTest.java,pLohData,"@DataProvider(name=""pLoH"") public Iterator<Object[]>  (){ final List<Object[]> listOfDoubles=new ArrayList<>(); for (int i=1; i < 20; i++) { listOfDoubles.add(new Object[]{i / 40D}); } return listOfDoubles.iterator(); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\FingerprintCheckerTest.java,queryableData,"@DataProvider(name="" "") public Iterator<Object[]> queryableData() throws IOException { List<Object[]> tests=new ArrayList<>(); tests.add(new Object[]{new File(TEST_DATA_DIR ""NA12891.fp.vcf"") false}); tests.add(new Object[]{new File(TEST_DATA_DIR ""NA12891."
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\FingerprintCheckerTest.java,setup,@BeforeClass public void  (){ hb.addSnp(snp); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\FingerprintCheckerTest.java,testCheckFingerprintsFail,"@Test(dataProvider=""checkFingerprintsSamDataProviderFail"" expectedExceptions=PicardException.class) public void  (final File samFile1 final File samFile2 final boolean expectedMatch){ final String[] args={""EXPECT_ALL_GROUPS_TO_MATCH=true"" ""LOD_THRESHOLD=-"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\FingerprintCheckerTest.java,testCheckFingerprintsSam,"@Test(dataProvider=""checkFingerprintsSamDataProvider"") public void  (final File samFile1 final File samFile2 final boolean expectedMatch final boolean silent){ final String[] args={""EXPECT_ALL_GROUPS_TO_MATCH=true"" ""LOD_THRESHOLD=-1"" ""H="" + SUBSETTED_HAPL"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\FingerprintCheckerTest.java,testCheckFingerprintsSamDataProvider,"@DataProvider(name=""checkFingerprintsSamDataProvider"") public Object[][]  (){ final File na12891_r1=new File(TEST_DATA_DIR ""NA12891.over.fingerprints.r1.sam""); final File na12891_r2=new File(TEST_DATA_DIR ""NA12891.over.fingerprints.r2.sam""); final File na"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\FingerprintCheckerTest.java,testCheckFingerprintsSamDataProviderFail,"@DataProvider(name=""checkFingerprintsSamDataProviderFail"") public Object[][]  (){ final File na12891_r1=new File(TEST_DATA_DIR ""NA12891.over.fingerprints.r1.sam""); final File na12892_r1=new File(TEST_DATA_DIR ""NA12892.over.fingerprints.r1.sam""); final Fil"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\FingerprintCheckerTest.java,testCheckFingerprintsVcf,"@Test(dataProvider=""checkFingerprintsVcfDataProvider"") public void  (final File vcfFile final File genotypesFile final String observedSampleAlias final String expectedSampleAlias final double llExpectedSample final double llRandomSample final double lodEx"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\FingerprintCheckerTest.java,testCheckFingerprintsVcfDataProvider,"@DataProvider(name=""checkFingerprintsVcfDataProvider"") public Object[][]  (){ return new Object[][]{{new File(TEST_DATA_DIR ""NA12891.vcf"") new File(TEST_DATA_DIR ""NA12891.fp.vcf"") ""NA12891"" ""NA12891"" -0.021280 -1.026742 1.005462} {new File(TEST_DATA_DIR """
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\FingerprintCheckerTest.java,testFingerprintVcf,"@Test(dataProvider=""checkFingerprintsVcfDataProvider"") public void  (final File vcfFile final File genotypesFile final String observedSampleAlias final String expectedSampleAlias final double llExpectedSample final double llRandomSample final double lodEx"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\FingerprintCheckerTest.java,testMatchResults,"@Test(dataProvider=""pLoH"") public void  (final double pLoH){ final Fingerprint fpObserved=new Fingerprint(""test"" null ""noop""); final Fingerprint fpExpected=new Fingerprint(""test"" null ""noop""); final HaplotypeProbabilities hpHet=new HaplotypeProbabilitiesF"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\FingerprintCheckerTest.java,testQueryable,"@Test(dataProvider=""queryableData"") public void  (final File vcf boolean expectedQueryable){ try (VCFFileReader reader=new VCFFileReader(vcf false)){ Assert.assertEquals(reader.isQueryable() expectedQueryable); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\FingerprintCheckerTest.java,testRandomSublist,@Test public void  () throws Exception { final List<Integer> list=new ArrayList<>(); list.add(1); list.add(2); list.add(3); Assert.assertEquals(list FingerprintChecker.randomSublist(list 3)); Assert.assertEquals(list FingerprintChecker.randomSublist(list 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\FingerprintCheckerTest.java,testTerminateOnBadFile,"@Test(expectedExceptions=PicardException.class) public void  (){ final FingerprintChecker fpChecker=new FingerprintChecker(SUBSETTED_HAPLOTYPE_DATABASE_FOR_TESTING); final File badSam=new File(TEST_DATA_DIR ""aligned_queryname_sorted.sam""); fpChecker.finge"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\FingerprintCheckerTest.java,testWriteFingerprint,"@Test public void  () throws IOException { final File haplotype_db=new File(TEST_DATA_DIR ""haplotypeMap_small.vcf""); final File vcfInput=new File(TEST_DATA_DIR ""testSample_small.vcf""); final File fasta=new File(TEST_DATA_DIR ""reference.fasta""); final File"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,bamFilesLBs,"@DataProvider(name="" "") public Object[][] bamFilesLBs(){ return new Object[][]{{NA12891_r1 NA12891_r2 0} {NA12891_r1 NA12892_r1 0} {NA12892_r2 NA12891_r2 0} {NA12892_r2 NA12891_r1 0} {NA12891_r1 NA12891_named_NA12892_r1_sam 1} {NA12892_r1 NA12891_named_NA"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,bamFilesRGs,"@DataProvider(name="" "") public Object[][] bamFilesRGs(){ return new Object[][]{{NA12891_r1 NA12891_r2 false 0 (NA12891_r1_RGs + NA12891_r2_RGs) * (NA12891_r1_RGs + NA12891_r2_RGs)} {NA12891_r1 NA12892_r1 false 0 (NA12891_r1_RGs + NA12892_r1_RGs) * (NA1289"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,bamFilesSMs,"@DataProvider(name="" "") public Object[][] bamFilesSMs(){ return new Object[][]{{NA12891_r1 NA12891_r2 0 1} {NA12891_r1 NA12892_r1 0 2} {NA12892_r2 NA12891_r2 0 2} {NA12892_r2 NA12891_named_NA12892_r1 0 1} {NA12891_r2 NA12891_named_NA12892_r1 1 2} {NA12892"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,bamFilesSources,"@DataProvider(name="" "") public Object[][] bamFilesSources(){ return new Object[][]{{NA12891_r1 NA12891_r2 0} {NA12892_r1 NA12892_r2 0} {NA12891_r1 NA12892_r1 0} {NA12892_r2 NA12891_r2 0} {NA12892_r2 NA12891_named_NA12892_r1 1} {NA12891_r2 NA12891_named_NA"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,canWriteToDevNull,"@Test public void  () throws IOException { File f=new File(""/dev/null""); Assert.assertTrue(f.canRead()); final OutputStream stream=new FileOutputStream(f); final BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(stream)); writer.write(""Just "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,checkFilesData,"@DataProvider(name="" "") public Iterator<Object[]> checkFilesData(){ List<Object[]> tests=new ArrayList<>(); tests.add(new Object[]{Arrays.asList(NA12891_1_vcf NA12892_1_vcf NA12891_g_vcf NA12892_g_vcf) 0 4 * 4 false}); tests.add(new Object[]{Arrays.asList"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,checkPathsData,"@DataProvider(name="" "") public Iterator<Object[]> checkPathsData() throws IOException { List<Object[]> tests=new ArrayList<>(); final File fofn=File.createTempFile(""crosscheck"" "".fofn"" TEST_DATA_DIR); fofn.deleteOnExit(); PrintWriter writer=new PrintWrite"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,checkSampleMapFailuresData,"@Test(dataProvider="" "" expectedExceptions=IllegalArgumentException.class) public void checkSampleMapFailuresData(final File inputSampleMap final File secondInputSampleMap) throws IOException { File metrics=File.createTempFile(""Fingerprinting"" ""test.crossc"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,checkSamplesCrosscheckAllData,"@DataProvider(name="" "") public Iterator<Object[]> checkSamplesCrosscheckAllData(){ List<Object[]> tests=new ArrayList<>(); tests.add(new Object[]{Arrays.asList(NA12891_1_vcf NA12892_1_vcf) Arrays.asList(NA12891_g_vcf NA12892_g_vcf) 0 2 2 true}); tests.add"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,checkSamplesCrosscheckAllWithMappingData,"@DataProvider public Iterator<Object[]>  (){ List<Object[]> tests=new ArrayList<>(); File NA12892_to_NA12891=new File(TEST_DATA_DIR ""NA12892_to_NA12891.txt""); File NotThere_to_NA12892=new File(TEST_DATA_DIR ""NotThere_to_NA12891.txt""); tests.add(new Object"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,checkSamplesData,"@DataProvider(name="" "") public Iterator<Object[]> checkSamplesData(){ List<Object[]> tests=new ArrayList<>(); tests.add(new Object[]{Arrays.asList(NA12891_1_vcf NA12892_1_vcf) Arrays.asList(NA12891_g_vcf NA12892_g_vcf) 0 2 true}); tests.add(new Object[]{A"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,doTest,private void  (final String[] args final File metrics final int expectedRetVal final int expectedNMetrics final CrosscheckMetric.DataType expectedType final boolean expectAllMatch) throws IOException { final CrosscheckFingerprints crossChecker=new CrosscheckFingerprints(); Assert.assertEquals(crossChecker.instanceMain(args) expectedRetVal); final MetricsFile<CrosscheckMetric Comparable<?>> metricsOutput=new MetricsFile<>(); metricsOutput.read(new FileReader(metrics)); Assert.assertFalse(metricsOutput.getMetrics().stream().anyMatch(m -> m.DATA_TYPE != expectedType)); Assert.assertFalse(metricsOutput.getMetrics().stream().anyMatch(m -> m.LOD_SCORE_NORMAL_TUMOR == null)); Assert.assertFalse(metricsOutput.getMetrics().stream().anyMatch(m -> m.LOD_SCORE == null)); Assert.assertFalse(metricsOutput.getMetrics().stream().anyMatch(m -> m.LOD_SCORE_TUMOR_NORMAL == null)); if (expectAllMatch) { Assert.assertTrue(metricsOutput.getMetrics().stream().allMatch(m -> m.RESULT == CrosscheckMetric.FingerprintResult.INCONCLUSIVE || m.RESULT.isMatch() == m.LEFT_SAMPLE.equals(m.RIGHT_SAMPLE))); } else if (expectedRetVal == 0) { Assert.assertTrue(metricsOutput.getMetrics().stream().allMatch(m -> m.RESULT == CrosscheckMetric.FingerprintResult.INCONCLUSIVE || m.RESULT.isExpected())); } else { Assert.assertTrue(metricsOutput.getMetrics().stream().anyMatch(m -> !m.RESULT.isExpected())); } Assert.assertEquals(metricsOutput.getMetrics().size() expectedNMetrics); if (!metricsOutput.getMetrics().isEmpty() && expectedType != CrosscheckMetric.DataType.READGROUP) { Assert.assertTrue(metricsOutput.getMetrics().stream().anyMatch(m -> m.RESULT != CrosscheckMetric.FingerprintResult.INCONCLUSIVE)); } for ( final String fieldName : lookupMap.get(expectedType)) { try { final Field field=CrosscheckMetric.class.getField(fieldName); Assert.assertTrue(metricsOutput.getMetrics().stream().allMatch(m -> { try { return field.get(m) != FingerprintIdDetails.multipleValuesString && field.get(m) != null; } catch ( IllegalAccessException e) { e.printStackTrace(); return false; } } )); } catch ( NoSuchFieldException e) { e.printStackTrace(); assert false; } } } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,setup,@BeforeClass public void  () throws IOException { NA12891_r1=SamTestUtils.createIndexedBam(NA12891_r1_sam NA12891_r1_sam); NA12891_r2=SamTestUtils.createIndexedBam(NA12891_r2_sam NA12891_r2_sam); NA12891_named_NA12892_r1=SamTestUtils.createIndexedBam(NA12
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,testCheckFiles,"@Test(dataProvider=""checkFilesData"") public void  (final List<File> files final int expectedRetVal final int numberOfSamples boolean ExpectAllMatch) throws IOException { File metrics=File.createTempFile(""Fingerprinting"" ""test.crosscheck_metrics""); metrics"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,testCheckPaths,"@Test(dataProvider=""checkPathsData"") public void  (final List<String> paths final String haploypeMap final int expectedRetVal final int numberOfSamples boolean ExpectAllMatch) throws IOException { File metrics=File.createTempFile(""Fingerprinting"" ""test.cr"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckReadGroupFingerprintsTest.java,bamFilesLBs,"@DataProvider(name="" "") public Object[][] bamFilesLBs(){ return new Object[][]{{NA12891_r1 NA12891_r2 0 true} {NA12891_r1 NA12892_r1 0 false} {NA12892_r2 NA12891_r2 0 false} {NA12892_r2 NA12891_r1 0 false} {NA12891_r1 NA12891_named_NA12892_r1_sam 1 true} "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,testCheckSamples,"@Test(dataProvider=""checkSamplesData"") public void  (final List<File> files1 final List<File> files2 final int expectedRetVal final int numberOfSamples boolean ExpectAllMatch) throws IOException { File metrics=File.createTempFile(""Fingerprinting"" ""test.cr"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckReadGroupFingerprintsTest.java,bamFilesRGs,"@DataProvider(name="" "") public Object[][] bamFilesRGs(){ return new Object[][]{{NA12891_r1 NA12891_r2 false 0 NA12891_r1_RGs + NA12891_r2_RGs} {NA12891_r1 NA12892_r1 false 0 NA12891_r1_RGs + NA12892_r1_RGs} {NA12891_r1 NA12892_r2 false 0 NA12891_r1_RGs + "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckReadGroupFingerprintsTest.java,bamFilesSMs,"@DataProvider(name="" "") public Object[][] bamFilesSMs(){ return new Object[][]{{NA12891_r1 NA12891_r2 0 1 true} {NA12891_r1 NA12892_r1 0 2 false} {NA12892_r2 NA12891_r2 0 2 false} {NA12892_r2 NA12891_named_NA12892_r1 0 1 true} {NA12891_r2 NA12891_named_NA"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,testCrossCheckLBs,"@Test(dataProvider=""bamFilesLBs"") public void  (final File file1 final File file2 final int expectedRetVal) throws IOException { File metrics=File.createTempFile(""Fingerprinting"" ""NA1291.LB.crosscheck_metrics""); metrics.deleteOnExit(); final String[] args"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckReadGroupFingerprintsTest.java,bamFilesSources,"@DataProvider(name="" "") public Object[][] bamFilesSources(){ return new Object[][]{{NA12891_r1 NA12891_r2 0} {NA12892_r1 NA12892_r2 0} {NA12891_r1 NA12892_r1 0} {NA12892_r2 NA12891_r2 0} {NA12892_r2 NA12891_named_NA12892_r1 1} {NA12891_r2 NA12891_named_NA"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckReadGroupFingerprintsTest.java,canWriteToDevNull,"@Test public void  () throws IOException { File f=new File(""/dev/null""); Assert.assertTrue(f.canRead()); final OutputStream stream=new FileOutputStream(f); final BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(stream)); writer.write(""Just "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,testCrossCheckLBsWithClustering,"@Test public void  () throws IOException { File metrics=File.createTempFile(""Fingerprinting"" ""NA1291.LB.crosscheck_metrics""); metrics.deleteOnExit(); { final String[] args=new String[]{""INPUT="" + NA12891_r1.getAbsolutePath() ""INPUT="" + NA12891_r2.getAbsol"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckReadGroupFingerprintsTest.java,doMatrixTest,"private void  (final String[] args final File metrics final int expectedRetVal final int expectedNMetrics final boolean expectAllMatch) throws IOException { final CrosscheckReadGroupFingerprints crossChecker=new CrosscheckReadGroupFingerprints(); Assert.assertEquals(crossChecker.instanceMain(args) expectedRetVal); Assert.assertTrue(metrics.canRead()); try (Stream<String> lines=Files.lines(metrics.toPath() Charset.defaultCharset())){ long numOfLines=lines.count() - 1; Assert.assertEquals(numOfLines expectedNMetrics); } if (expectAllMatch) { try (Stream<String> lines=Files.lines(metrics.toPath() Charset.defaultCharset())){ lines.skip(1).forEach(s -> { final List<String> strings=Arrays.asList(s.split(""\t"")); strings.subList(1 strings.size()).forEach(str -> Assert.assertTrue(Double.parseDouble(str) > 0D ""expected positive value  found: "" + str)); } ); } } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,testCrossCheckRGs,"@Test(dataProvider=""bamFilesRGs"") public void  (final File file1 final File file2 final boolean expectAllMatch final int expectedRetVal final int expectedNMetrics) throws IOException { File metrics=File.createTempFile(""Fingerprinting"" ""NA1291.RG.crosschec"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,testCrossCheckSMs,"@Test(dataProvider=""bamFilesSMs"") public void  (final File file1 final File file2 final int expectedRetVal final int numberOfSamples) throws IOException { File metrics=File.createTempFile(""Fingerprinting"" ""NA1291.SM.crosscheck_metrics""); metrics.deleteOnE"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,testCrossCheckSources,"@Test(dataProvider=""bamFilesSources"") public void  (final File file1 final File file2 final int expectedRetVal) throws IOException { File metrics=File.createTempFile(""Fingerprinting"" ""NA1291.Sources.crosscheck_metrics""); metrics.deleteOnExit(); final Stri"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckReadGroupFingerprintsTest.java,doTest,private void  (final String[] args final File metrics final int expectedRetVal final int expectedNMetrics final CrosscheckMetric.DataType expectedType final boolean expectAllMatch) throws IOException  NoSuchFieldException { final CrosscheckReadGroupFingerprints crossChecker=new CrosscheckReadGroupFingerprints(); Assert.assertEquals(crossChecker.instanceMain(args) expectedRetVal); final MetricsFile<CrosscheckMetric Comparable<?>> metricsOutput=new MetricsFile<>(); metricsOutput.read(new FileReader(metrics)); Assert.assertTrue(metricsOutput.getMetrics().stream().allMatch(m -> m.DATA_TYPE == expectedType)); Assert.assertTrue(metricsOutput.getMetrics().stream().allMatch(m -> m.LOD_SCORE_NORMAL_TUMOR != null)); Assert.assertTrue(metricsOutput.getMetrics().stream().allMatch(m -> m.LOD_SCORE != null)); Assert.assertTrue(metricsOutput.getMetrics().stream().allMatch(m -> m.LOD_SCORE_TUMOR_NORMAL != null)); if (expectAllMatch) { Assert.assertTrue(metricsOutput.getMetrics().stream().allMatch(m -> m.RESULT == CrosscheckMetric.FingerprintResult.INCONCLUSIVE || m.RESULT.isMatch() == m.LEFT_SAMPLE.equals(m.RIGHT_SAMPLE))); } else if (expectedRetVal == 0) { Assert.assertTrue(metricsOutput.getMetrics().stream().allMatch(m -> m.RESULT == CrosscheckMetric.FingerprintResult.INCONCLUSIVE || m.RESULT.isExpected())); } else { Assert.assertTrue(metricsOutput.getMetrics().stream().anyMatch(m -> !m.RESULT.isExpected())); } Assert.assertEquals(metricsOutput.getMetrics().size() expectedNMetrics); if (!metricsOutput.getMetrics().isEmpty() && expectedType != CrosscheckMetric.DataType.READGROUP) { Assert.assertTrue(metricsOutput.getMetrics().stream().anyMatch(m -> m.RESULT != CrosscheckMetric.FingerprintResult.INCONCLUSIVE)); } for ( final String fieldName : lookupMap.get(expectedType)) { final Field field=CrosscheckMetric.class.getField(fieldName); Assert.assertTrue(metricsOutput.getMetrics().stream().allMatch(m -> { try { return field.get(m) != multipleValuesString && field.get(m) != null; } catch ( IllegalAccessException e) { e.printStackTrace(); return false; } } )); } } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckReadGroupFingerprintsTest.java,newParametersData,"@DataProvider(name="" "") public Object[][] newParametersData(){ return new Object[][]{{""CROSSCHECK_BY="" + CrosscheckMetric.DataType.LIBRARY} {""CROSSCHECK_BY="" + CrosscheckMetric.DataType.SAMPLE} {""CROSSCHECK_BY="" + CrosscheckMetric.DataType.FILE} {""MATRIX_"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,testSecondInputCheckAll,"@Test(dataProvider=""checkSamplesCrosscheckAllData"") public void  (final List<File> files1 final List<File> files2 final int expectedRetVal final int numberOfSamples1 final int numberOfSamples2 boolean ExpectAllMatch) throws IOException { File metrics=File"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckReadGroupFingerprintsTest.java,setup,@BeforeClass public void  () throws IOException { NA12891_r1=SamTestUtils.createIndexedBam(NA12891_r1_sam NA12891_r1_sam); NA12891_r2=SamTestUtils.createIndexedBam(NA12891_r2_sam NA12891_r2_sam); NA12891_named_NA12892_r1=SamTestUtils.createIndexedBam(NA12
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckFingerprintsTest.java,testSecondInputCheckAllWithMapping,"@Test(dataProvider=""checkSamplesCrosscheckAllWithMappingData"") public void  (final List<File> files1 final List<File> files2 final File inputSampleMap final File secondInputSampleMap final int expectedRetVal final int numberOfSamples1 final int numberOfSa"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckReadGroupFingerprintsTest.java,testCannotUseNewParameters,"@Test(dataProvider=""newParametersData"") public void  (final String extraParameter){ final File file1=NA12891_r1; final File file2=NA12892_r1; final String[] args=new String[]{""INPUT="" + file1.getAbsolutePath() ""INPUT="" + file2.getAbsolutePath() ""HAPLOTYPE"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckReadGroupFingerprintsTest.java,testCrossCheckLBs,"@Test(dataProvider=""bamFilesLBs"") public void  (final File file1 final File file2 final int expectedRetVal final boolean expectAllMatch) throws IOException { File metrics=File.createTempFile(""Fingerprinting"" ""NA1291.LB.crosscheck_metrics""); metrics.delete"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckReadGroupFingerprintsTest.java,testCrossCheckRGs,"@Test(dataProvider=""bamFilesRGs"") public void  (final File file1 final File file2 final boolean expectAllMatch final int expectedRetVal final int expectedNMetrics) throws IOException  NoSuchFieldException { File metrics=File.createTempFile(""Fingerprinting"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\CrosscheckReadGroupFingerprintsTest.java,testCrossCheckSMs,"@Test(dataProvider=""bamFilesSMs"") public void  (final File file1 final File file2 final int expectedRetVal final int numberOfSamples final boolean expectedAllMatch) throws IOException { File metrics=File.createTempFile(""Fingerprinting"" ""NA1291.SM.crossche"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\ClusterCrosscheckMetricsTest.java,getCommandLineProgramName,@Override public String  (){ return ClusterCrosscheckMetrics.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\ClusterCrosscheckMetricsTest.java,testSimpleCluster,"@Test public void  () throws IOException { File metrics=File.createTempFile(""Fingerprinting"" ""NA1291_and_NA12892.RG.crosscheck_metrics""); metrics.deleteOnExit(); final String[] args=new String[]{""INPUT="" + NA12891_r1_sam.getAbsolutePath() ""INPUT="" + NA128"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CheckIlluminaDirectoryTest.java,basedirDoesntExistTest,"@Test(expectedExceptions=SAMException.class) public void  (){ final String[] args=makeCheckerArgs(new File(""a_made_up_file/in_some_weird_location"") 1 ""76T76T"" new IlluminaDataType[]{IlluminaDataType.Position} new ArrayList<>() false false); runPicardComma"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CheckIlluminaDirectoryTest.java,createSingleLocsFile,"private void  (){ try { final File singleLocsFile=new File(intensityDir AbstractIlluminaPositionFileReader.S_LOCS_FILE); final FileWriter writer=new FileWriter(singleLocsFile); writer.write(""This is a test string.""); writer.close(); } catch ( final IOException e) { e.printStackTrace(); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CheckIlluminaDirectoryTest.java,differentSizedBclTest,@Test public void  (){ final int lane=5; final List<Integer> tiles=makeList(1 2 3 4); final int[] cycles=IlluminaFileUtilTest.cycleRange(1 50); final IlluminaDataType[] dataTypes=new IlluminaDataType[]{BaseCalls IlluminaDataType.QualityScores}; makeFiles(
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CheckIlluminaDirectoryTest.java,getCommandLineProgramName,public String  (){ return CheckIlluminaDirectory.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CheckIlluminaDirectoryTest.java,makeCheckerArgs,"public String[]  (final File basecallDir final int lane final String readStructure final IlluminaDataType[] dataTypes final List<Integer> filterTiles final boolean makeFakeFiles final boolean createSymLinks){ final String[] dataTypeArgs=new String[dataTypes.length + filterTiles.size() + 5]; dataTypeArgs[0]=""B="" + basecallDir; dataTypeArgs[1]=StandardOptionDefinitions.LANE_SHORT_NAME + ""="" + lane; dataTypeArgs[2]=""RS="" + readStructure; dataTypeArgs[3]=""F="" + makeFakeFiles; dataTypeArgs[4]=""X="" + createSymLinks; for (int i=0; i < dataTypes.length; i++) { dataTypeArgs[i + 5]=""DT="" + dataTypes[i]; } if (!filterTiles.isEmpty()) { final int start=dataTypes.length + 5; for (int i=start; i < dataTypeArgs.length; i++) { dataTypeArgs[i]=""T="" + filterTiles.get(i - start); } } return dataTypeArgs; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CheckIlluminaDirectoryTest.java,makeFiles,public void  (final SupportedIlluminaFormat[] formats final int lane final List<Integer> tiles final int[] cycles){ for ( final IlluminaFileUtil.SupportedIlluminaFormat format : formats) { IlluminaFileUtilTest.makeFiles(format intensityDir lane tiles cycles); } } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CheckIlluminaDirectoryTest.java,makeMap,"public static Map<Integer List<Integer>>  (final List<Integer> lanes final List<List<Integer>> tiles){ final Map<Integer List<Integer>> map=new HashMap<>(); if (lanes.size() != tiles.size()) { throw new IllegalArgumentException(""Number of lanes ("" + lanes + "") does not equal number of tiles!""); } for (int i=0; i < lanes.size(); i++) { map.put(lanes.get(i) tiles.get(i)); } return map; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CheckIlluminaDirectoryTest.java,negativeTestData,"@DataProvider(name="" "") public Object[][] negativeTestData(){ return new Object[][]{{new SupportedIlluminaFormat[]{Bcl Filter} new IlluminaDataType[]{BaseCalls IlluminaDataType.QualityScores IlluminaDataType.PF IlluminaDataType.Position IlluminaDataType.B"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CheckIlluminaDirectoryTest.java,negativeTests,"@Test(dataProvider=""negativeTestData"") public void  (final IlluminaFileUtil.SupportedIlluminaFormat[] formats final IlluminaDataType[] dataTypes final List<String> filesToDelete final List<String> filesToEmpty final int lane final List<Integer> tiles fina"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CheckIlluminaDirectoryTest.java,noSymlinkLocsTest,@Test public void  (){ symlinkTest(false); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CheckIlluminaDirectoryTest.java,positiveTestData,"@DataProvider(name="" "") public Object[][] positiveTestData(){ return new Object[][]{{new SupportedIlluminaFormat[]{Bcl Locs Pos Filter} new IlluminaDataType[]{BaseCalls IlluminaDataType.QualityScores IlluminaDataType.Position IlluminaDataType.PF} 3 makeLi"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CheckIlluminaDirectoryTest.java,positiveTests,"@Test(dataProvider=""positiveTestData"") public void  (final IlluminaFileUtil.SupportedIlluminaFormat[] formats final IlluminaDataType[] dataTypes final int lane final List<Integer> tiles final int[] cycles final String readStructure final List<Integer> fil"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CheckIlluminaDirectoryTest.java,setUp,"@BeforeMethod private void  () throws Exception { illuminaDir=IOUtil.createTempDir(""ift_test"" ""IlluminaDir""); interopDir=new File(illuminaDir ""InterOp""); if (!interopDir.exists() && !interopDir.mkdir()) { throw new RuntimeException(""Couldn't make interop "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CheckIlluminaDirectoryTest.java,symlinkLocsTest,@Test public void  (){ symlinkTest(true); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CheckIlluminaDirectoryTest.java,symlinkTest,"public void  (Boolean createSymlinks){ final List<Integer> tileList=makeList(1101 1102 1103 2101 2102 2103); final int lane=5; makeFiles(new SupportedIlluminaFormat[]{Bcl} lane tileList IlluminaFileUtilTest.cycleRange(1 50)); String[] args=makeCheckerArgs(basecallDir lane ""50T"" new IlluminaDataType[]{Position} new ArrayList<>() false createSymlinks); writeTileMetricsOutFile(makeMap(makeList(lane) makeList(tileList))); createSingleLocsFile(); if (createSymlinks) { final File intensityLaneDir=new File(intensityDir IlluminaFileUtil.longLaneStr(lane)); intensityLaneDir.mkdirs(); } Assert.assertEquals(runPicardCommandLine(args) 0); args=makeCheckerArgs(basecallDir lane ""50T"" new IlluminaDataType[]{IlluminaDataType.Position} new ArrayList<>() false true); Assert.assertEquals(runPicardCommandLine(args) 0); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CheckIlluminaDirectoryTest.java,tearDown,@AfterMethod private void  (){ IOUtil.deleteDirectoryTree(dataDir); IOUtil.deleteDirectoryTree(basecallDir); IOUtil.deleteDirectoryTree(intensityDir); IOUtil.deleteDirectoryTree(illuminaDir); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CheckIlluminaDirectoryTest.java,writeFileOfSize,public void  (final File file final int size){ try { final BufferedWriter writer=new BufferedWriter(new FileWriter(file)); for (int i=0; i < size; i++) { final int toWrite=Math.min(1000 size); final char[] writeBuffer=new char[toWrite]; for (int j=0; j < writeBuffer.length; j++) { writeBuffer[j]=(char)(Math.random() * 150); } writer.write(writeBuffer); } writer.flush(); writer.close(); } catch ( final Exception exc) { throw new RuntimeException(exc); } } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CheckIlluminaDirectoryTest.java,writeTileMetricsOutFile,"public File  (final File interopDir final byte versionNumber final byte recordSize final Map<Integer List<Integer>> lanesToTiles){ final File tileMetricsOut=new File(interopDir ""TileMetricsOut.bin""); if (!tileMetricsOut.exists()) { try { if (!tileMetricsOut.createNewFile()) { throw new PicardException(""Could not create tileMetricsOut file("" + tileMetricsOut.getAbsolutePath() + "")""); } } catch ( final IOException e) { throw new PicardException(""IOException creating tileMetricsOut file ("" + tileMetricsOut + "") for writing!"" e); } } int totalEntries=0; for ( final Map.Entry<Integer List<Integer>> l2t : lanesToTiles.entrySet()) { totalEntries+=l2t.getValue().size(); } final MappedByteBuffer buf; try { final RandomAccessFile raf=new RandomAccessFile(tileMetricsOut ""rw""); final FileChannel channel=raf.getChannel(); buf=channel.map(FileChannel.MapMode.READ_WRITE 0 2 + 10 * totalEntries); buf.order(ByteOrder.LITTLE_ENDIAN); buf.put(versionNumber); buf.put(recordSize); for ( final int lane : lanesToTiles.keySet()) { for ( final int tile : lanesToTiles.get(lane)) { buf.putShort((short)lane); buf.putShort((short)tile); buf.putShort((short)0); buf.putFloat(0F); } } buf.force(); CloserUtil.close(channel); CloserUtil.close(raf); } catch ( final IOException e) { throw new PicardException(""IOException writing tileMetricsOut file ("" + tileMetricsOut + "")"" e); } return tileMetricsOut; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\HaplotypeMapTest.java,haplotypeMapForWriting,"@DataProvider(name="" "") public Object[][] haplotypeMapForWriting(){ SAMFileHeader header=new SAMFileHeader(); header.setSortOrder(SAMFileHeader.SortOrder.coordinate); SAMSequenceDictionary sd=new SAMSequenceDictionary(); sd.addSequence(new SAMSequenceReco"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\HaplotypeMapTest.java,haplotypeMapReaderData,"@DataProvider(name="" "") public Object[][] haplotypeMapReaderData(){ return new Object[][]{{TEST_MAP} {TEST_VCF_MAP}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\HaplotypeMapTest.java,testEquivalenceHapDBandVCF,@Test public void  (){ final HaplotypeMap mapHapDB=new HaplotypeMap(TEST_MAP); final HaplotypeMap mapVCF=new HaplotypeMap(TEST_VCF_MAP); for ( final HaplotypeBlock haplotypeBlock : mapHapDB.getHaplotypes()) { final Snp firstSnp=haplotypeBlock.getFirstSnp(
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\HaplotypeMapTest.java,testHaplotypeMapReader,"@Test(dataProvider=""haplotypeMapReaderData"") public void  (final File file){ final HaplotypeMap map=new HaplotypeMap(file); Assert.assertEquals(map.getHaplotypes().size() 23 ""Wrong number of haplotypes returned.""); Assert.assertEquals(map.getAllSnps().siz"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\HaplotypeMapTest.java,testHaplotypeMapWriteToVcf,"@Test(dataProvider=""haplotypeMapForWriting"") public void  (final HaplotypeMap haplotypeMap) throws Exception { final File temp=File.createTempFile(""haplotypeMap"" "".vcf""); temp.deleteOnExit(); haplotypeMap.writeAsVcf(temp TEST_FASTA); final VCFFileReader r"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\HaplotypeMapTest.java,testHaplotypeMapWriter,"@Test(dataProvider=""haplotypeMapForWriting"") public void  (final HaplotypeMap haplotypeMap) throws Exception { File temp=File.createTempFile(""haplotypeMap"" ""txt""); temp.deleteOnExit(); haplotypeMap.writeToFile(temp); BufferedReader reader=new BufferedRead"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\HaplotypeProbabilitiesTest.java,dataTestHaplotypeProbabilitiesFromContaminatorSequenceAddToProbs,"@DataProvider(name="" "") public Object[][] dataTestHaplotypeProbabilitiesFromContaminatorSequenceAddToProbs(){ return new Object[][]{{new HaplotypeProbabilitiesFromContaminatorSequence(hb1 .1) snp1 0 0} {new HaplotypeProbabilitiesFromContaminatorSequence(h"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\HaplotypeProbabilitiesTest.java,dataTestHaplotypeProbabilitiesFromSequenceAddToProbs,"@DataProvider(name="" "") public Object[][] dataTestHaplotypeProbabilitiesFromSequenceAddToProbs(){ return new Object[][]{{new HaplotypeProbabilitiesFromSequence(hb1) snp1 new byte[]{} 7} {new HaplotypeProbabilitiesFromSequence(hb1) snp1 new byte[]{'A'} 7} "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\HaplotypeProbabilitiesTest.java,dataTestpEvidenceGivenPriorFromGLs,"@DataProvider(name="" "") public Object[][] dataTestpEvidenceGivenPriorFromGLs(){ return new Object[][]{new Object[]{new HaplotypeProbabilitiesFromGenotypeLikelihoods(hb1) Collections.singletonList(snp1) Collections.singletonList(false) Collections.singleto"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\HaplotypeProbabilitiesTest.java,initializeHaplotypeBlock,"@BeforeTest public static void  (){ snp1=new Snp(""SNP1"" ""test"" 1 (byte)'A' (byte)'T' 0.25 Collections.<String>emptyList()); snp2=new Snp(""SNP2"" ""test"" 2 (byte)'A' (byte)'G' 0.5 Collections.<String>emptyList()); hb1=new HaplotypeBlock(.25); hb1.addSnp(snp1"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\HaplotypeProbabilitiesTest.java,testHaplotypeProbabilitiesFromContaminatorSequenceAddToProbs,"@Test(dataProvider=""dataTestHaplotypeProbabilitiesFromContaminatorSequenceAddToProbs"") public void  (final HaplotypeProbabilitiesFromContaminatorSequence hp final Snp snp final int nAlt final int nTotal) throws Exception { final byte qual=7; for (int i=0;"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\HaplotypeProbabilitiesTest.java,testHaplotypeProbabilitiesFromSequenceAddToProbs,"@Test(dataProvider=""dataTestHaplotypeProbabilitiesFromSequenceAddToProbs"") public void  (final HaplotypeProbabilitiesFromSequence hp final Snp snp final byte[] bases final int qual) throws Exception { for ( final byte base : bases) { hp.addToProbs(snp bas"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\HaplotypeProbabilitiesTest.java,testpEvidenceGivenPriorFromGLs,"@Test(dataProvider=""dataTestpEvidenceGivenPriorFromGLs"") public void  (final HaplotypeProbabilitiesFromGenotypeLikelihoods hp final List<Snp> snps final List<Boolean> swaps final List<double[]> GLs) throws Exception { for (int i=0; i < snps.size(); ++i) {"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\HaplotypeProbabilityOfNormalGivenTumorTest.java,testGetLikelihoods,"@Test(dataProvider="" Data"") public void testGetLikelihoods(final double pLoH final double[] tumorLikelihood final double[] normalLikelihood) throws Exception { final HaplotypeProbabilities hp=new HaplotypeProbabilitiesFromGenotype(snp hb tumorLikelihood[0"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\fingerprint\HaplotypeProbabilityOfNormalGivenTumorTest.java,testGetLikelihoodsData,"@DataProvider(name="" "") public Iterator<Object[]> testGetLikelihoodsData(){ final List<Object[]> testData=new ArrayList<>(); testData.add(new Object[]{0.0 new double[]{1 0 0} new double[]{1 0 0}}); testData.add(new Object[]{0.0 new double[]{0 1 0} new dou"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,getCommandLineProgramName,public String  (){ return ExtractIlluminaBarcodes.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,getQualityTestData,"@DataProvider(name=""qualityBarcodeData"") public Object[][]  (){ return new Object[][]{{16 0 1 0 ""Barcode has good quality  1 match""} {25 0 0 0 ""Barcode has quality failures  no matches""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,runIt,private MetricsFile<ExtractIlluminaBarcodes.BarcodeMetric Integer>  (final List<String> args final File metricsFile) throws Exception { Assert.assertEquals(runPicardCommandLine(args) 0); final MetricsFile<ExtractIlluminaBarcodes.BarcodeMetric Integer> retval=new MetricsFile<>(); retval.read(new FileReader(metricsFile)); return retval; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,setUp,"@BeforeTest private void  () throws Exception { basecallsDir=File.createTempFile(""eib."" "".tmp""); Assert.assertTrue(basecallsDir.delete()); Assert.assertTrue(basecallsDir.mkdir()); IOUtil.copyDirectoryTree(SINGLE_DATA_DIR basecallsDir); dual=File.createTem"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,tearDown,@AfterTest private void  (){ IOUtil.deleteDirectoryTree(basecallsDir); IOUtil.deleteDirectoryTree(dual); IOUtil.deleteDirectoryTree(qual); IOUtil.deleteDirectoryTree(noSymlink); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,testBarcodeMatching,"@Test public void  () throws Exception { final int lane=1; final int barcodePosition=26; final MetricsFile<ExtractIlluminaBarcodes.BarcodeMetric Integer> metricsFile=runIt(lane ""25T8B25T""); ExtractIlluminaBarcodes.BarcodeMetric metricOne=null; ExtractIllu"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,testCbclDualBarcodes,"@Test public void  () throws Exception { final File metricsFile=File.createTempFile(""cbcl."" "".metrics""); metricsFile.deleteOnExit(); final String[] args=new String[]{""BASECALLS_DIR="" + cbcl.getAbsolutePath() + ""/BaseCalls"" ""LANE="" + 1 ""METRICS_FILE="" + me"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,testDualBarcodes,"@Test public void  () throws Exception { final File metricsFile=File.createTempFile(""dual."" "".metrics""); metricsFile.deleteOnExit(); final String[] args=new String[]{""BASECALLS_DIR="" + dual.getAbsolutePath() ""LANE="" + 1 ""METRICS_FILE="" + metricsFile.getPa"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,testNoLocsSymlink,"@Test public void  () throws Exception { final File metricsFile=File.createTempFile(""dual."" "".metrics""); metricsFile.deleteOnExit(); final String[] args=new String[]{""BASECALLS_DIR="" + noSymlink.getAbsolutePath() ""LANE="" + 1 ""METRICS_FILE="" + metricsFile "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,testNonWritableOutputFile,"@Test public void  () throws Exception { final File existingFile=new File(basecallsDir ""s_1_1101_barcode.txt.gz""); try { existingFile.setReadOnly(); final String readStructure=""25T8B25T""; final int lane=1; final File metricsFile=File.createTempFile(""eib."""
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,testPairedEndWithBarcodeAndMolecularIndicies,"@Test public void  () throws Exception { final MetricsFile<ExtractIlluminaBarcodes.BarcodeMetric Integer> metricsFile=runIt(1 ""4M21T8B21T4M""); Assert.assertEquals(metricsFile.getMetrics().get(0).PERFECT_MATCHES 5); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,testPairedEndWithBarcodeOnFirstEnd,"@Test public void  () throws Exception { final MetricsFile<ExtractIlluminaBarcodes.BarcodeMetric Integer> metricsFile=runIt(1 ""25T8B25T""); Assert.assertEquals(metricsFile.getMetrics().get(0).PERFECT_MATCHES 5); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,testPairedEndWithBarcodeOnSecondEnd,"@Test public void  () throws Exception { final MetricsFile<ExtractIlluminaBarcodes.BarcodeMetric Integer> metricsFile=runIt(1 ""25T25T8B""); Assert.assertEquals(metricsFile.getMetrics().get(12).PERFECT_MATCHES 1); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,testParsing,private void  (final IlluminaDataProviderFactory factory final ReadStructure readStructure final ExtractIlluminaBarcodes.BarcodeMetric metricACAGTG final int barcodePosition){ int numReads=0; final BaseIlluminaDataProvider dataProvider=factory.makeDataProvider(); while (dataProvider.hasNext()) { final ClusterData cluster=dataProvider.next(); if (metricACAGTG.BARCODE.equals(cluster.getMatchedBarcode())) { ++numReads; } Assert.assertEquals(cluster.getRead(readStructure.templates.getIndices()[0]).getQualities().length barcodePosition - 1); Assert.assertEquals(cluster.getRead(readStructure.templates.getIndices()[0]).getBases().length barcodePosition - 1); } Assert.assertEquals(numReads metricACAGTG.READS); dataProvider.close(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,testQualityBarcodes,"@Test(dataProvider=""qualityBarcodeData"") public void  (final int quality final int maxMismatches final int perfectMatches final int oneMismatch final String testName) throws Exception { final File metricsFile=File.createTempFile(""qual."" "".metrics""); metri"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,testSingleEndWithBarcodeAtEnd,"@Test public void  () throws Exception { final MetricsFile<ExtractIlluminaBarcodes.BarcodeMetric Integer> metricsFile=runIt(1 ""25T8B""); Assert.assertEquals(metricsFile.getMetrics().get(0).PERFECT_MATCHES 5); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,testSingleEndWithBarcodeAtEndAndMolecularIndicies,"@Test public void  () throws Exception { final MetricsFile<ExtractIlluminaBarcodes.BarcodeMetric Integer> metricsFile=runIt(1 ""4M21T8B""); Assert.assertEquals(metricsFile.getMetrics().get(0).PERFECT_MATCHES 5); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,testSingleEndWithBarcodeAtStart,"@Test public void  () throws Exception { final MetricsFile<ExtractIlluminaBarcodes.BarcodeMetric Integer> metricsFile=runIt(1 ""8B25T""); Assert.assertEquals(metricsFile.getMetrics().get(11).PERFECT_MATCHES 1); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ExtractIlluminaBarcodesTest.java,testSingleEndWithBarcodeAtStartAndMolecularIndicies,"@Test public void  () throws Exception { final MetricsFile<ExtractIlluminaBarcodes.BarcodeMetric Integer> metricsFile=runIt(1 ""8B4M21T""); Assert.assertEquals(metricsFile.getMetrics().get(11).PERFECT_MATCHES 1); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToFastqTest.java,compareFastqs,private void  (File testDataDir File outputSam String filename){ File f1=new File(outputSam.getParentFile() filename); File f2=new File(testDataDir filename); FastqReader reader1=new FastqReader(f1); List<FastqRecord> reads=new ArrayList<>(); FastqReader reader2=new FastqReader(f2); for ( FastqRecord record : reader1) { reads.add(record); } for ( FastqRecord record : reader2) { Assert.assertTrue(reads.contains(record)); } } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToFastqTest.java,convertParamsFile,"private void  (String libraryParamsFile int concatNColumnFields File testDataDir File outputDir File libraryParams List<File> outputPrefixes) throws FileNotFoundException { try (LineReader reader=new BufferedLineReader(new FileInputStream(new File(testDataDir libraryParamsFile)))){ final PrintWriter writer=new PrintWriter(libraryParams); final String header=reader.readLine(); writer.println(header + ""\tOUTPUT_PREFIX""); while (true) { final String line=reader.readLine(); if (line == null) { break; } final String[] fields=line.split(""\t""); final File outputPrefix=new File(outputDir StringUtil.join("""" Arrays.copyOfRange(fields 0 concatNColumnFields))); outputPrefixes.add(outputPrefix); writer.println(line + ""\t"" + outputPrefix); } writer.close(); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToFastqTest.java,getCommandLineProgramName,public String  (){ return IlluminaBasecallsToFastq.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToFastqTest.java,runStandardTest,"private void  (final int lane final String jobName final String libraryParamsFile final int concatNColumnFields final String readStructureString final File baseCallsDir final File testDataDir) throws Exception { final File outputDir=File.createTempFile(jobName "".dir""); try { outputDir.delete(); outputDir.mkdir(); outputDir.deleteOnExit(); final File libraryParams=new File(outputDir libraryParamsFile); libraryParams.deleteOnExit(); final List<File> outputPrefixes=new ArrayList<File>(); convertParamsFile(libraryParamsFile concatNColumnFields testDataDir outputDir libraryParams outputPrefixes); runPicardCommandLine(new String[]{""BASECALLS_DIR="" + baseCallsDir ""LANE="" + lane ""RUN_BARCODE=HiMom"" ""READ_STRUCTURE="" + readStructureString ""MULTIPLEX_PARAMS="" + libraryParams ""MACHINE_NAME=machine1"" ""FLOWCELL_BARCODE=abcdeACXX"" ""MAX_READS_IN_RAM_PER_TILE=100""}); final ReadStructure readStructure=new ReadStructure(readStructureString); for ( final File outputSam : outputPrefixes) { for (int i=1; i <= readStructure.templates.length(); ++i) { final String filename=outputSam.getName() + ""."" + i+ "".fastq""; IOUtil.assertFilesEqual(new File(outputSam.getParentFile() filename) new File(testDataDir filename)); } for (int i=1; i <= readStructure.sampleBarcodes.length(); ++i) { final String filename=outputSam.getName() + "".barcode_"" + i+ "".fastq""; IOUtil.assertFilesEqual(new File(outputSam.getParentFile() filename) new File(testDataDir filename)); } for (int i=1; i <= readStructure.molecularBarcode.length(); ++i) { final String filename=outputSam.getName() + "".index_"" + i+ "".fastq""; IOUtil.assertFilesEqual(new File(outputSam.getParentFile() filename) new File(testDataDir filename)); } } } finally { TestUtil.recursiveDelete(outputDir); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToFastqTest.java,testCbclConvert,"@Test public void  () throws Exception { runStandardTest(1 ""dualBarcode."" ""barcode_double.params"" 2 ""151T8B8B151T"" TEST_DATA_DIR_WITH_CBCLS DUAL_CBCL_TEST_DATA_DIR); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToFastqTest.java,testDeMultiplexed,"@Test public void  () throws Exception { runStandardTest(1 ""multiplexedBarcode."" ""mp_barcode.params"" 1 ""25T8B25T"" BASECALLS_DIR TEST_DATA_DIR); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToFastqTest.java,testDeMultiplexedWithIndex,"@Test public void  () throws Exception { runStandardTest(1 ""multiplexedBarcodeWithIndex."" ""mp_barcode.params"" 1 ""25T8B4M21T"" BASECALLS_DIR TEST_DATA_DIR_WITH_4M); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToFastqTest.java,testDeMultiplexedWithtwoIndexes,"@Test public void  () throws Exception { runStandardTest(1 ""multiplexedBarcodeWithTwoIndexes."" ""mp_barcode.params"" 1 ""25T8B4M4M17T"" BASECALLS_DIR TEST_DATA_DIR_WITH_4M4M); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToFastqTest.java,testDualBarcodes,"@Test public void  () throws Exception { runStandardTest(1 ""dualBarcode."" ""barcode_double.params"" 2 ""25T8B8B25T"" DUAL_BASECALLS_DIR DUAL_TEST_DATA_DIR); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToFastqTest.java,testHiseqxSingleLocs,"@Test public void  () throws Exception { runStandardTest(1 ""hiseqxSingleLocs."" ""barcode_double.params"" 2 ""25T8B8B25T"" TEST_DATA_HISEQX_SINGLE_LOCS HISEQX_TEST_DATA_DIR); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToFastqTest.java,testMultiplexWithIlluminaReadNameHeaders,"@Test public void  () throws Exception { final File outputDir=File.createTempFile(""testMultiplexRH."" "".dir""); try { outputDir.delete(); outputDir.mkdir(); outputDir.deleteOnExit(); final String filePrefix=""testMultiplexRH""; final File outputPrefix=new Fil"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToFastqTest.java,testNonBarcoded,"@Test public void  () throws Exception { final String suffix="".1.fastq""; final File outputFastq1=File.createTempFile(""nonBarcoded."" suffix); outputFastq1.deleteOnExit(); final String outputPrefix=outputFastq1.getAbsolutePath().substring(0 outputFastq1.get"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CollectIlluminaBasecallingMetricsTest.java,runIt,"private MetricsFile<IlluminaBasecallingMetrics Integer>  (final int lane final String readStructure final File basecallsDir final File barcodesDir final boolean isIndexed) throws Exception { final File metricsFile=File.createTempFile(""cibm."" "".metrics""); metricsFile.deleteOnExit(); ArrayList<String> argsList=new ArrayList<String>(); argsList.add(""BASECALLS_DIR="" + basecallsDir.getPath()); if (null != barcodesDir) argsList.add(""BARCODES_DIR="" + barcodesDir.getPath()); argsList.add(""LANE="" + lane); argsList.add(""OUTPUT="" + metricsFile.getPath()); if (readStructure != null) argsList.add(""READ_STRUCTURE="" + readStructure); if (isIndexed) argsList.add(""INPUT="" + new File(basecallsDir.getPath() ""barcodeData."" + lane).getPath()); final String[] args=new String[argsList.size()]; argsList.toArray(args); Assert.assertEquals(new CollectIlluminaBasecallingMetrics().instanceMain(args) 0); final MetricsFile<IlluminaBasecallingMetrics Integer> retval=new MetricsFile<IlluminaBasecallingMetrics Integer>(); retval.read(new FileReader(metricsFile)); return retval; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CollectIlluminaBasecallingMetricsTest.java,setUp,"@BeforeTest private void  () throws Exception { rootTestDir=File.createTempFile(""cibm."" "".tmp""); Assert.assertTrue(rootTestDir.delete()); Assert.assertTrue(rootTestDir.mkdir()); for ( final File source : TEST_DATA_DIR.listFiles()) { if (source.isDirectory"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CollectIlluminaBasecallingMetricsTest.java,tearDown,@AfterTest private void  (){ IOUtil.deleteDirectoryTree(rootTestDir); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CollectIlluminaBasecallingMetricsTest.java,testIndexedRunLane1,"@Test(dataProvider="" DataProvider"") public void testIndexedRunLane1(final boolean useBarcodesDir) throws Exception { final File barcodesDir=(useBarcodesDir) ? new File(rootTestDir ""/25T8B25T/barcodes_dir"") : null; final MetricsFile<IlluminaBasecallingMetr"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CollectIlluminaBasecallingMetricsTest.java,testIndexedRunLane1DataProvider,"@DataProvider(name="" "") public Object[][] testIndexedRunLane1DataProvider(){ return new Object[][]{{true} {false}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CollectIlluminaBasecallingMetricsTest.java,testNonIndexedRunLane1,"@Test public void  () throws Exception { final MetricsFile<IlluminaBasecallingMetrics Integer> metricsFile=runIt(1 ""125T125T"" new File(rootTestDir ""125T125T/Data/Intensities/BaseCalls"") null false); final IlluminaBasecallingMetrics laneMetric=metricsFile."
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\CollectIlluminaBasecallingMetricsTest.java,testNovaseqIndexedRun,"@Test public void  () throws Exception { final MetricsFile<IlluminaBasecallingMetrics Integer> metricsFile=runIt(1 ""151T8B8B151T"" new File(""testdata/picard/illumina/151T8B8B151T_cbcl/Data/Intensities/BaseCalls"") null true); final IlluminaBasecallingMetric"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,getCommandLineProgramName,public String  (){ return IlluminaBasecallsToSam.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,runStandardTest,"private void  (final int lane final String jobName final String libraryParamsFile final int concatNColumnFields final String readStructure final File baseCallsDir final File testDataDir final Integer tile) throws Exception { final Path outputDir=Files.createTempDirectory(jobName); try { final String tilePrefix=(tile != null) ? tile + ""."" : """"; final File libraryParams=new File(outputDir.toFile() libraryParamsFile); libraryParams.deleteOnExit(); final List<File> samFiles=new ArrayList<File>(); final LineReader reader=new BufferedLineReader(new FileInputStream(new File(testDataDir libraryParamsFile))); final PrintWriter writer=new PrintWriter(libraryParams); final String header=reader.readLine(); writer.println(header + ""\tOUTPUT""); while (true) { final String line=reader.readLine(); if (line == null) { break; } final String[] fields=line.split(""\t""); final File outputSam=new File(outputDir.toFile() StringUtil.join("""" Arrays.copyOfRange(fields 0 concatNColumnFields)) + "".sam""); outputSam.deleteOnExit(); samFiles.add(new File(outputSam.getParentFile() tilePrefix + outputSam.getName())); writer.println(line + ""\t"" + outputSam); } writer.close(); reader.close(); List<String> args=new ArrayList<>(); args.add(""BASECALLS_DIR="" + baseCallsDir); args.add(""LANE="" + lane); args.add(""RUN_BARCODE=HiMom""); args.add(""READ_STRUCTURE="" + readStructure); args.add(""LIBRARY_PARAMS="" + libraryParams); if (tile != null) { args.add(""PROCESS_SINGLE_TILE="" + tile); } Assert.assertEquals(runPicardCommandLine(args) 0); for ( final File outputSam : samFiles) { IOUtil.assertFilesEqual(outputSam new File(testDataDir outputSam.getName())); } } finally { TestUtil.recursiveDelete(outputDir.toFile()); Files.delete(outputDir); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testCbclConvert,"@Test public void  () throws Exception { runStandardTest(1 ""cbclConvert."" ""barcode_double.params"" 2 ""151T8B8B151T"" TEST_DATA_DIR_WITH_CBCLS DUAL_CBCL_TEST_DATA_DIR); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testCbclConvertSingleTile,"@Test public void  () throws Exception { runStandardTest(1 ""cbclConvert."" ""barcode_double.params"" 2 ""151T8B8B151T"" TEST_DATA_DIR_WITH_CBCLS DUAL_CBCL_TEST_DATA_DIR 1102); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testCorruptDataReturnCode,"@Test(groups={""broken""}) public void  () throws Exception { boolean exceptionThrown=false; try { runStandardTest(9 ""dualBarcode."" ""negative_test.params"" 2 ""30T8B8B"" BASECALLS_DIR TEST_DATA_DIR); } catch ( Throwable e) { exceptionThrown=true; } finally { A"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testDualBarcodes,"@Test public void  () throws Exception { runStandardTest(1 ""dualBarcode."" ""barcode_double.params"" 2 ""25T8B8B25T"" DUAL_BASECALLS_DIR DUAL_TEST_DATA_DIR); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testDualBarcodesSingleTile,"@Test public void  () throws Exception { runStandardTest(1 ""dualBarcode."" ""barcode_double.params"" 2 ""25T8B8B25T"" DUAL_BASECALLS_DIR DUAL_TEST_DATA_DIR 1101); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testHiseqxSingleLocs,"@Test public void  () throws Exception { runStandardTest(1 ""hiseqxSingleLocs."" ""barcode_double.params"" 2 ""25T8B8B25T"" TEST_DATA_HISEQX_SINGLE_LOCS HISEQX_TEST_DATA_DIR); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testMultiplexed,"@Test public void  () throws Exception { runStandardTest(1 ""multiplexedBarcode."" ""barcode.params"" 1 ""25T8B25T"" BASECALLS_DIR TEST_DATA_DIR); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testMultiplexedWith4M4MIndex,"@Test public void  () throws Exception { runStandardTest(1 ""multiplexedBarcode2."" ""barcode.params"" 1 ""25T8B4M4M17T"" BASECALLS_DIR TEST_DATA_DIR_WITH_4M4M_INDEX); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testMultiplexedWith4MIndex,"@Test public void  () throws Exception { runStandardTest(1 ""multiplexedBarcode."" ""barcode.params"" 1 ""25T8B4M21T"" BASECALLS_DIR TEST_DATA_DIR_WITH_4M_INDEX); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testMultiplexedWithAlternateBarcodeName,"@Test public void  () throws Exception { runStandardTest(1 ""singleBarcodeAltName."" ""multiplexed_positive_rgtags.params"" 1 ""25T8B25T"" BASECALLS_DIR TEST_DATA_DIR); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testNonBarcoded,"@Test public void  () throws Exception { final File outputBam=File.createTempFile(""nonBarcoded."" "".sam""); outputBam.deleteOnExit(); final int lane=1; Assert.assertEquals(runPicardCommandLine(new String[]{""BASECALLS_DIR="" + BASECALLS_DIR ""LANE="" + lane ""RE"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testNonBarcodedTileSubset,"@Test public void  () throws Exception { final File outputBam=File.createTempFile(""nonBarcoded."" "".sam""); outputBam.deleteOnExit(); final int lane=1; Assert.assertEquals(runPicardCommandLine(new String[]{""BASECALLS_DIR="" + BASECALLS_DIR ""LANE="" + lane ""RE"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testNonBarcodedWithDualMoleclarIndex,"@Test public void  () throws Exception { final File outputBam=File.createTempFile(""nonBarcodedWithDualMI."" "".sam""); outputBam.deleteOnExit(); final int lane=1; Assert.assertEquals(runPicardCommandLine(new String[]{""BASECALLS_DIR="" + BASECALLS_DIR ""LANE="" "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testNonBarcodedWithMolecularIndex,"@Test public void  () throws Exception { final File outputBam=File.createTempFile(""nonBarcodedWithMI."" "".sam""); outputBam.deleteOnExit(); final int lane=1; Assert.assertEquals(runPicardCommandLine(new String[]{""BASECALLS_DIR="" + BASECALLS_DIR ""LANE="" + la"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testNonBarcodedWithTagPerMolecularIndexDual,"@Test public void  () throws Exception { final File outputBam=File.createTempFile(""nonBarcodedWithDualMI."" "".sam""); outputBam.deleteOnExit(); final int lane=1; Assert.assertEquals(runPicardCommandLine(new String[]{""BASECALLS_DIR="" + BASECALLS_DIR ""LANE="" "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testNonBarcodedWithTagPerMolecularIndexDualFourMolecularIndexes,"@Test public void  () throws Exception { final File outputBam=File.createTempFile(""nonBarcodedWithDualMI."" "".sam""); outputBam.deleteOnExit(); final int lane=1; Assert.assertEquals(runPicardCommandLine(new String[]{""BASECALLS_DIR="" + BASECALLS_DIR ""LANE="" "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testNonBarcodedWithTagPerMolecularIndexDualTooFewTags,"@Test public void  () throws Exception { final File outputBam=File.createTempFile(""nonBarcodedWithDualMI."" "".sam""); outputBam.deleteOnExit(); final int lane=1; Assert.assertEquals(runPicardCommandLine(new String[]{""BASECALLS_DIR="" + BASECALLS_DIR ""LANE="" "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testNonBarcodedWithTagPerMolecularIndexDualTooManyTags,"@Test public void  () throws Exception { final File outputBam=File.createTempFile(""nonBarcodedWithDualMI."" "".sam""); outputBam.deleteOnExit(); final int lane=1; Assert.assertEquals(runPicardCommandLine(new String[]{""BASECALLS_DIR="" + BASECALLS_DIR ""LANE="" "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testNonBarcodedWithTagPerMolecularIndexIsNUll,"@Test public void  () throws Exception { final File outputBam=File.createTempFile(""nonBarcodedWithMI."" "".sam""); outputBam.deleteOnExit(); final int lane=1; Assert.assertEquals(runPicardCommandLine(new String[]{""BASECALLS_DIR="" + BASECALLS_DIR ""LANE="" + la"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamTest.java,testTileNumberComparator,"@Test public void  (){ Assert.assertTrue(IlluminaBasecallsConverter.TILE_NUMBER_COMPARATOR.compare(100 10) < 0 """"); Assert.assertTrue(IlluminaBasecallsConverter.TILE_NUMBER_COMPARATOR.compare(20 200) > 0 """"); Assert.assertTrue(IlluminaBasecallsConverter.T"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamAdapterClippingTest.java,getCommandLineProgramName,public String  (){ return IlluminaBasecallsToSam.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamAdapterClippingTest.java,getIlluminaBasecallsToSamTestData,"@DataProvider(name=""data"") private Object[][]  (){ return new Object[][]{{""1"" ""125T125T"" null null 32} {""2"" ""125T125T"" null null 108} {""1"" ""125T125T"" ""ACGTACGTACGTACGT"" ""ACGTACGTACGTACGT"" 0} {""2"" ""125T125T"" ""ACGTACGTACGTACGT"" ""ACGTACGTACGTACGT"" 0} {""1"" ""1"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaBasecallsToSamAdapterClippingTest.java,testBasic,"@Test(dataProvider=""data"") public void  (final String LANE final String readStructure final String fivePrimerAdapter final String threePrimerAdapter final int expectedNumClippedRecords) throws Exception { final File samFile=File.createTempFile(""."" + LANE "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaLaneMetricsCollectorTest.java,buildOutputFile,"private static File  (final File directory final String prefix final String extension){ return new File(directory String.format(""%s.%s"" prefix extension)); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaLaneMetricsCollectorTest.java,testCollectIlluminaLaneMetrics,"@Test(dataProvider="" "") public void testCollectIlluminaLaneMetrics(final String testRun final ReadStructure readStructure final boolean isNovaSeq) throws Exception { for ( final boolean useReadStructure : Arrays.asList(true false)) { final File runDirecto"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaLaneMetricsCollectorTest.java,testCollectIlluminaLaneMetricsDataProvider,"@DataProvider(name=""testCollectIlluminaLaneMetrics"") public Object[][]  (){ return new Object[][]{{""A7LE0"" new ReadStructure(""25T8B8B25T"") false} {""C2MFAACXX"" new ReadStructure(""95T101T"") false} {""H7BATADXX"" new ReadStructure(""76T8B76T"") false} {""H7H7RADX"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaLaneMetricsCollectorTest.java,testLaneMetricsDataProvider,"@DataProvider(name=""testLaneMetrics"") public Object[][]  (){ return new Object[][]{{""130321_SL-MAK_0035_FC000000000-A306B""} {""130318_SL-HBB_0226_BFCC1WYMACXX""} {""130401_SL-HAC_0022_BH07PBADXX""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaLaneMetricsCollectorTest.java,testMissingPhasingValuesSilent,"@Test public void  () throws IOException { final ReadStructure readStructure=new ReadStructure(""151T8B8B151T""); for ( final boolean useReadStructure : Arrays.asList(true false)) { final File runDirectory=TEST_MISSING_PHASING_DIRECTORY; final CollectIllumi"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaLaneMetricsCollectorTest.java,testMissingPhasingValuesStrict,"@Test(expectedExceptions=PicardException.class) public void  (){ final ReadStructure readStructure=new ReadStructure(""151T8B8B151T""); for ( final boolean useReadStructure : Arrays.asList(true false)) { final File runDirectory=TEST_MISSING_PHASING_DIRECTOR"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\IlluminaLaneMetricsCollectorTest.java,testWriteLaneMetrics,"@Test(dataProvider=""testLaneMetrics"") public void  (final String testRun) throws Exception { for ( final boolean useReadStructure : Arrays.asList(true false)) { final CollectIlluminaLaneMetrics clp=new CollectIlluminaLaneMetrics(); clp.OUTPUT_DIRECTORY=IO"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,BasesAndQuals,public  (final byte[] bases final byte[] quals final Integer maskStart){ this.bases=bases; this.quals=quals; this.maskedQuals=qualsMaskedFrom(maskStart); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,basesToString,"public String  (){ final StringBuilder sb=new StringBuilder(bases.length); for ( final byte base : bases) { switch (base) { case A: sb.append(""A ""); break; case C: sb.append(""C ""); break; case G: sb.append(""G ""); break; case T: sb.append(""T ""); break; case P: sb.append("". ""); break; default : throw new RuntimeException(""THIS SHOULD NOT HAPPEN! Bad byte in bases!""); } } return sb.toString(); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,boxArr,public static Integer[]  (final int[] ints){ final Integer[] boxArr=new Integer[ints.length]; for (int i=0; i < boxArr.length; i++) { boxArr[i]=ints[i]; } return boxArr; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,compareClusterToBclData,"public void  (final ClusterData cluster final BclData bclData final int clusterNum final int countNum){ final byte[][] bases=bclData.getBases(); final byte[][] qualities=bclData.getQualities(); Assert.assertEquals(bases.length cluster.getNumReads() ""At cluster num "" + clusterNum); Assert.assertEquals(qualities.length cluster.getNumReads() ""At cluster num "" + clusterNum); final StringBuilder baseBuilder=new StringBuilder(); final StringBuilder qualBuilder=new StringBuilder(); final StringBuilder barcode=new StringBuilder(); baseBuilder.append(""new byte[]{""); for (int i=0; i < bases.length; i++) { final byte[] subBase=bases[i]; final byte[] subQual=qualities[i]; for (int j=0; j < subBase.length; j++) { if ((char)subBase[j] == '.') { baseBuilder.append('P'); } else { baseBuilder.append((char)subBase[j]); } baseBuilder.append("" ""); qualBuilder.append(subQual[j]); qualBuilder.append("" ""); if (i == 1) { if ((char)subBase[j] == '.') { barcode.append('P'); } else { barcode.append((char)subBase[j]); } } } } baseBuilder.deleteCharAt(baseBuilder.length() - 1); qualBuilder.deleteCharAt(qualBuilder.length() - 1); baseBuilder.append(""} \n new byte[]{""); baseBuilder.append(qualBuilder.toString()); baseBuilder.append(""} \n \""""); baseBuilder.append(barcode.toString()); baseBuilder.append(""\""""); for (int i=0; i < cluster.getNumReads(); i++) { if (!Arrays.equals(bases[i] cluster.getRead(i).getBases())) { System.out.println(cluster.getLane() + "" : "" + cluster.getTile()+ "" : ""+ clusterNum); System.out.println(baseBuilder.toString()); } Assert.assertEquals(bases[i] cluster.getRead(i).getBases() "" Bases differ for read "" + i + "" at cluster num ""+ clusterNum+ "" at cluster count ""+ countNum); Assert.assertEquals(qualities[i] cluster.getRead(i).getQualities() "" Qualities differ for read "" + i + "" at cluster num ""+ clusterNum+ "" at cluster count ""+ countNum); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,copyBcls,"public static void  (final File srcLaneDir final File dstDir){ final File[] listFiles=srcLaneDir.listFiles(); for ( final File dir : listFiles) { if (dir.isDirectory()) { File cycleDir=null; for ( final File file : dir.listFiles()) { if (file.getName().endsWith("".bcl"")) { if (cycleDir == null) { cycleDir=new File(dstDir dir.getName()); if (!cycleDir.mkdir()) { throw new RuntimeException(""Couldn't make directory ("" + cycleDir.getAbsolutePath() + "")""); } } IOUtil.copyFile(file new File(cycleDir file.getName())); } } } } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,deleteBclFiles,"public static void  (final File laneDirectory final String readStructure){ final ReadStructure rs=new ReadStructure(readStructure); int index=1; for ( final ReadDescriptor rd : rs.descriptors) { if (rd.type == ReadType.S) { for (int i=index; i < index + rd.length; i++) { final File cycleDir=new File(laneDirectory ""C"" + i + "".1""); final File[] cycleFiles=cycleDir.listFiles(); for ( final File toDelete : cycleFiles) { if (!toDelete.delete()) { throw new RuntimeException(""Couldn't delete file "" + toDelete.getAbsolutePath()); } } } } index+=rd.length; } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,eamssDataNo10GSeries,"@DataProvider(name="" "") public Object[][] eamssDataNo10GSeries(){ return new Object[][]{{new BasesAndQuals(new byte[]{G G G G G G G G G} new byte[]{13 7 35 32 31 33 31 26 29} null)} {new BasesAndQuals(new byte[]{G G G G G G G G G} new byte[]{13 7 35 26 18"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,eamssParsingTestNoGSeries,"@Test(dataProvider=""eamssDataNo10GSeries"") public void  (final BasesAndQuals bq){ testEamss(bq); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,eamssParsingTestWithGSeries,"@Test(dataProvider=""eamssDataWithGSeries"") public void  (final BasesAndQuals bq){ testEamss(bq); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,eamssTestDat,"@DataProvider(name=""eamssDataWithGSeries"") public Object[][]  (){ return new Object[][]{{new BasesAndQuals(new byte[]{A C G G T G G G G G G G G G A C T} new byte[]{7 8 33 7 12 33 16 17 2 2 32 35 35 35 2 15 9} 5)} {new BasesAndQuals(new byte[]{A C G G T G "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,fullBclParserTest,"@Test(dataProvider=""tileMaps"") public void  (final int[] tiles final int size final int seekAfter final int newTileIndex final int orderedTileIndex){ fullBclParserTestImpl(TEST_DATA_DIR READ_STRUCTURE tiles size seekAfter newTileIndex orderedTileIndex fal"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BinTdUtil.java,clusterData,public static Map<Integer ClusterData>  (final int lane final List<Integer> tiles final String readStructure final IlluminaDataType... dataTypes){ final List<Integer> sortedTiles=new ArrayList<Integer>(tiles); Collections.sort(sortedTiles); final Map<Integer ClusterData> data=new HashMap<Integer ClusterData>(); int offset=0; for ( final int tile : sortedTiles) { final String key=ltStr(lane tile); final List<ClusterData> cds=goldData.get(key); final List<Integer> readNos=goldIndices.get(key); final int size=goldSizes.get(key); for (int i=0; i < cds.size(); i++) { data.put(offset + readNos.get(i) selectiveCopyCd(cds.get(i) readStructure dataTypes)); } offset+=size; } return data; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BinTdUtil.java,copyIntensities,private static FourChannelIntensityData  (final FourChannelIntensityData toCopy final int start final int length){ final FourChannelIntensityData fcid=new FourChannelIntensityData(length); System.arraycopy(toCopy.getA() start fcid.getA() 0 length); System.arraycopy(toCopy.getC() start fcid.getC() 0 length); System.arraycopy(toCopy.getG() start fcid.getG() 0 length); System.arraycopy(toCopy.getT() start fcid.getT() 0 length); return fcid; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BinTdUtil.java,copyReadData,public static ReadData[]  (final ReadStructure rs final IlluminaDataType[] dts final ClusterData toCopy){ boolean doBases=false; boolean doQuals=false; for ( final IlluminaDataType dt : dts) { switch (dt) { case BaseCalls: doBases=true; break; case QualityScores: doQuals=true; break; } } if (!doBases && !doQuals) return null; final ReadData rdToCopy=toCopy.getRead(0); final ReadData[] rds=new ReadData[rs.nonSkips.length()]; int index=0; int baseIndex=0; for (int i=0; i < rs.descriptors.size(); i++) { final ReadDescriptor readDesc=rs.descriptors.get(i); if (readDesc.type != ReadType.S) { final ReadData curRead=new ReadData(readDesc.type); if (doBases) { final byte[] bases=Arrays.copyOfRange(rdToCopy.getBases() baseIndex baseIndex + readDesc.length); curRead.setBases(bases); } if (doQuals) { final byte[] quals=Arrays.copyOfRange(rdToCopy.getQualities() baseIndex baseIndex + readDesc.length); curRead.setQualities(quals); } rds[index++]=curRead; } baseIndex+=readDesc.length; } return rds; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BinTdUtil.java,ltStr,"public static final String  (final int lane final int tile){ return ""s_"" + lane + ""_""+ tile; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BinTdUtil.java,makeCd,public static ClusterData  (final int lane final int tile final int xCoord final int yCoord final boolean pf final byte[] bases final byte[] qualities final String matchedBarcode){ final ReadData rd=new ReadData(); rd.setBases(Arrays.copyOf(bases bases.length)); rd.setQualities(Arrays.copyOf(qualities bases.length)); rd.setReadType(ReadType.T); final ClusterData cd=new ClusterData(rd); cd.setLane(lane); cd.setTile(tile); cd.setX(xCoord); cd.setY(yCoord); cd.setPf(pf); cd.setMatchedBarcode(matchedBarcode); return cd; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BinTdUtil.java,selectiveCopyCd,public static ClusterData  (final ClusterData toCopy final String readStructure final IlluminaDataType... dataTypes){ final ReadStructure rs=new ReadStructure(readStructure); final ReadData[] rd=copyReadData(rs dataTypes toCopy); final ClusterData cd=new ClusterData(rd); cd.setTile(toCopy.getTile()); cd.setLane(toCopy.getLane()); for ( final IlluminaDataType idt : dataTypes) { switch (idt) { case Position: cd.setX(toCopy.getX()); cd.setY(toCopy.getY()); break; case PF: cd.setPf(toCopy.isPf()); break; case Barcodes: cd.setMatchedBarcode(toCopy.getMatchedBarcode()); break; default : break; } } return cd; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,fullBclParserTestImpl,"public void  (final File dir final String readStructure final int[] tiles final int size final int seekAfter final int newTileIndex final int orderedTileIndex final boolean multiTile){ final ReadStructure rs=new ReadStructure(readStructure); final OutputMapping outputMapping=new OutputMapping(rs); final IlluminaFileUtil util=new IlluminaFileUtil(dir.getParentFile() LANE); final PerTilePerCycleFileUtil bclFileUtil=(PerTilePerCycleFileUtil)util.getUtil(IlluminaFileUtil.SupportedIlluminaFormat.Bcl); final MultiTileBclFileUtil multiTileBclFileUtil=(MultiTileBclFileUtil)util.getUtil(IlluminaFileUtil.SupportedIlluminaFormat.MultiTileBcl); final List<Integer> tileIntegers=new ArrayList<Integer>(); for ( final int tile : tiles) { tileIntegers.add(tile); } final BclParser bclParser; if (multiTile) { final File bci=new File(MULTI_TILE_DATA_DIR ""s_"" + LANE + "".bci""); bclParser=new MultiTileBclParser(dir LANE multiTileBclFileUtil.getFiles(tileIntegers outputMapping.getOutputCycles()) outputMapping true new BclQualityEvaluationStrategy(BclQualityEvaluationStrategy.ILLUMINA_ALLEGED_MINIMUM_QUALITY) new TileIndex(bci)); } else { bclParser=new BclParser(dir LANE bclFileUtil.getFiles(tileIntegers outputMapping.getOutputCycles()) outputMapping new BclQualityEvaluationStrategy(BclQualityEvaluationStrategy.ILLUMINA_ALLEGED_MINIMUM_QUALITY)); } final Map<Integer ClusterData> testData=BinTdUtil.clusterData(LANE Arrays.asList(boxArr(tiles)) readStructure DATA_TYPES); int count=0; int readNum=0; while (bclParser.hasNext()) { final BclData bclData=bclParser.next(); if (testData.containsKey(readNum)) { compareClusterToBclData(testData.get(readNum) bclData readNum count); } if (count == seekAfter) { bclParser.seekToTile(tiles[newTileIndex]); readNum=(orderedTileIndex * TILE_SIZES); } else { readNum++; } count++; } Assert.assertEquals(count size); bclParser.close(); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,fullBclParserTestWBadDeletedSkips,"@Test(dataProvider=""tileMaps"" expectedExceptions=RuntimeException.class) public void  (final int[] tiles final int size final int seekAfter final int newTileIndex final int orderedTileIndex){ fullBclParserTestWDeletedSkipsImpl(tiles size seekAfter newTile"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,fullBclParserTestWDeletedSkips,"@Test(dataProvider=""tileMaps"") public void  (final int[] tiles final int size final int seekAfter final int newTileIndex final int orderedTileIndex){ fullBclParserTestWDeletedSkipsImpl(tiles size seekAfter newTileIndex orderedTileIndex READ_STRUCTURE_WSKI"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,fullBclParserTestWDeletedSkipsImpl,"public void  (final int[] tiles final int size final int seekAfter final int newTileIndex final int orderedTileIndex final String readStructure){ final File basecallDir=IOUtil.createTempDir(""bclParserTest"" ""BaseCalls""); Exception exc=null; try { final File l001=new File(basecallDir ""L001""); if (!l001.mkdir()) { throw new RuntimeException(""Couldn't make lane dir "" + l001.getAbsolutePath()); } copyBcls(TEST_DATA_DIR l001); deleteBclFiles(l001 readStructure); fullBclParserTestImpl(l001 READ_STRUCTURE_WSKIPS tiles size seekAfter newTileIndex orderedTileIndex false); } catch ( final Exception thrExc) { exc=thrExc; } finally { IOUtil.deleteDirectoryTree(basecallDir); } if (exc != null) { if (exc.getClass() == PicardException.class) { throw new PicardException(exc.getMessage()); } throw new RuntimeException(exc); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,fullBclParserTestWPartiallyDeletedSkips,"@Test(dataProvider=""tileMaps"") public void  (final int[] tiles final int size final int seekAfter final int newTileIndex final int orderedTileIndex){ fullBclParserTestWDeletedSkipsImpl(tiles size seekAfter newTileIndex orderedTileIndex READ_STRUCTURE_WSKI"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,fullBclParserTestWSkips,"@Test(dataProvider=""tileMaps"") public void  (final int[] tiles final int size final int seekAfter final int newTileIndex final int orderedTileIndex){ fullBclParserTestImpl(TEST_DATA_DIR READ_STRUCTURE_WSKIPS tiles size seekAfter newTileIndex orderedTileIn"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,fullMTBclParserTest,public void  (final int[] tiles final int size final int seekAfter final int newTileIndex final int orderedTileIndex){ fullBclParserTestImpl(MULTI_TILE_DATA_DIR READ_STRUCTURE tiles size seekAfter newTileIndex orderedTileIndex true); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,getMultiTileMaps,"@DataProvider(name=""multiTileMaps"") public Object[][]  (){ return new Object[][]{{new int[]{11101 11102 11103} 341292 -1 -1 -1}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,getTileMaps,"@DataProvider(name=""tileMaps"") public Object[][]  (){ return new Object[][]{{new int[]{1101 1201 2101} 180 -1 -1 -1} {new int[]{1101 2101 1201} 180 -1 -1 -1} {new int[]{2101 1201} 120 -1 -1 -1} {new int[]{1101 2101} 120 -1 -1 -1} {new int[]{1101} 60 -1 -1"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,qualsMaskedFrom,private byte[]  (final Integer maskStart){ final byte[] maskedQuals=Arrays.copyOf(quals quals.length); if (maskStart != null) { for (int i=maskStart; i < maskedQuals.length; i++) { maskedQuals[i]=BclParser.MASKING_QUALITY; } } return maskedQuals; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,qualsToString,"public String  (final byte[] qualsToConvert){ final StringBuilder sb=new StringBuilder(bases.length); for ( final byte qual : qualsToConvert) { sb.append(String.valueOf((int)qual)); sb.append("" ""); } return sb.toString(); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,testEamss,public void  (final BasesAndQuals bq){ final byte[] bases=Arrays.copyOf(bq.bases bq.bases.length); final byte[] quals=Arrays.copyOf(bq.quals bq.quals.length); BclParser.runEamssForReadInPlace(bases quals); Assert.assertEquals(bases bq.bases); Assert.assertEquals(quals bq.maskedQuals); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\BclParserTest.java,toString,"public String  (){ return ""BasesAndQuals( "" + basesToString() + ""  ""+ qualsToString(quals)+ ""  ""+ qualsToString(maskedQuals)+ "")""; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\CycleIlluminaFileMapTest.java,constructPathString,"private static String  (int lane int cycle){ return TEST_DATA_DIR + ""/"" + laneToDir(lane)+ ""/C""+ cycle+ "".1""; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\CycleIlluminaFileMapTest.java,iteratorTestData,"@DataProvider(name="" "") public Object[][] iteratorTestData(){ return new Object[][]{new Object[]{TEST_DATA_DIR 1 1101 "".bcl"" makeList(new File(TEST_DATA_DIR + ""/C1.1"" ""s_1_1101.bcl"") new File(TEST_DATA_DIR + ""/C2.1"" ""s_1_1101.bcl"") new File(TEST_DATA_DIR "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\CycleIlluminaFileMapTest.java,laneToDir,"private static String  (int lane){ String outStr=String.valueOf(lane); while (outStr.length() < 3) { outStr=""0"" + outStr; } return ""L"" + outStr; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\fakers\BclFileFakerTest.java,testFileLengthMatchesHeaderLength,"@Test public void  () throws Exception { final File fakeFile=File.createTempFile(""BclFileFakerTest"" "".bcl""); fakeFile.deleteOnExit(); new BclFileFaker().fakeFile(fakeFile 100000); final BclReader bclReader=new BclReader(fakeFile new BclQualityEvaluationSt"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\fakers\BclFileFakerTest.java,testGZFileIsActuallyGZipped,"@Test public void  () throws Exception { final File fakeFile=File.createTempFile(""BclFileFakerTest"" "".bcl.gz""); fakeFile.deleteOnExit(); new BclFileFaker().fakeFile(fakeFile 100000); new BclReader(fakeFile new BclQualityEvaluationStrategy(BclQualityEvalua"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\FilterParserTest.java,allTilesToValues,public static final Boolean[]  (Integer[] tiles){ Boolean[][] values=new Boolean[tiles.length][]; for (int i=0; i < tiles.length; i++) { values[i]=tileToValue(tiles[i]); } return arrayFlatten(values); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\FilterParserTest.java,arrayFlatten,public static final <T>T[]  (final T[][] arrays){ int total=0; for ( T[] arr : arrays) { total+=arr.length; } int resultIndex=0; final T[] result=(T[])Array.newInstance(arrays[0][0].getClass() total); for (int i=0; i < arrays.length; i++) { System.arraycopy(arrays[i] 0 result resultIndex arrays[i].length); resultIndex+=arrays[i].length; } return result; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\FilterParserTest.java,arrayToList,public static final List<Integer>  (final Integer[] array){ final List<Integer> list=new ArrayList<Integer>(); for ( int item : array) { list.add(item); } return list; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\FilterParserTest.java,failingVerifyTiles,"@DataProvider(name="" "") public Object[][] failingVerifyTiles(){ return new Object[][]{{new Integer[]{1} new Integer[]{2}} {new Integer[]{2} new Integer[]{1}} {new Integer[]{4} new Integer[]{5}} {new Integer[]{1 4} new Integer[]{1 3 4}} {new Integer[]{2 3}"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\FilterParserTest.java,passingParserTest,"@Test(dataProvider=""passingTiles"") public void  (Integer[] tiles){ final IlluminaFileUtil fUtil=new IlluminaFileUtil(BaseCallsDir 1); final Boolean[] values=allTilesToValues(tiles); final List<Integer> tileList=arrayToList(tiles); final FilterParser fp=ne"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\FilterParserTest.java,passingSeekingParserTest,"@Test(dataProvider=""seekToTile"") public void  (int skipBefore int tileToSkipTo Integer[] tiles Boolean[][] expectedValues){ final IlluminaFileUtil fUtil=new IlluminaFileUtil(BaseCallsDir 1); final Boolean[] values=arrayFlatten(expectedValues); final List<"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\FilterParserTest.java,passingTiles,"@DataProvider(name="" "") public Object[][] passingTiles(){ return new Object[][]{{new Integer[]{1}} {new Integer[]{2}} {new Integer[]{4}} {new Integer[]{1 4}} {new Integer[]{2 3}} {new Integer[]{1 2 3 4}}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\FilterParserTest.java,seekToTile,"@DataProvider(name="" "") public Object[][] seekToTile(){ return new Object[][]{{0 2 new Integer[]{2} new Boolean[][]{s_1_0002_filter}} {4 4 new Integer[]{1 4} new Boolean[][]{new Boolean[]{F F T F} s_1_0004_filter}} {0 3 new Integer[]{2 3} new Boolean[][]{"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\FilterParserTest.java,tileToValue,"public static final Boolean[]  (int tile){ switch (tile) { case 1: return s_1_0001_filter; case 2: return s_1_0002_filter; case 3: return s_1_0003_filter; case 4: return s_1_0004_filter; } throw new RuntimeException(""You shouldn't reach this statement!""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\FilterParserTest.java,verifyDataTest,"@Test(dataProvider=""failingVerifyTiles"" expectedExceptions=PicardException.class) public void  (final Integer[] initTiles final Integer[] verifyTiles){ final IlluminaFileUtil fUtil=new IlluminaFileUtil(BaseCallsDir 1); final List<Integer> initTileList=arr"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaDataProviderFactoryTest.java,TestFactory,public  (final File basecallDirectory final int lane final ReadStructure readStructure final IlluminaDataType... dataTypes){ super(basecallDirectory lane readStructure new BclQualityEvaluationStrategy(BclQualityEvaluationStrategy.ILLUMINA_ALLEGED_MINIMUM_QUALITY) dataTypes); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaDataProviderTest.java,badData,"@DataProvider(name="" "") public Object[][] badData(){ return new Object[][]{{""Bad Lane(5)"" 5 60 makeList(1101 1201 2101) new IlluminaDataType[]{IlluminaDataType.Barcodes} ""25T8B25T"" BINARY_TD_LOCATION} {""Bad Read Structure(25TB25T)"" 4 60 makeList(1101 1201"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaDataProviderTest.java,barcodeParsingTest,"@Test public void  (){ runBarcodeParsingTest(new IlluminaDataProviderFactory(BINARY_TD_LOCATION 1 new ReadStructure(""25T8B25T"") bclQualityEvaluationStrategy IlluminaDataType.BaseCalls IlluminaDataType.Barcodes)); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaDataProviderTest.java,binaryData,"@DataProvider(name="" "") public Object[][] binaryData(){ return new Object[][]{{""Bustard Parsing Test(25T8B25T) w/Clocs"" 1 180 makeList(1101 1201 2101) new IlluminaDataType[]{IlluminaDataType.Barcodes} ""25T8B25T"" 0 0 BINARY_TD_LOCATION} {""Bustard Parsing T"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaDataProviderTest.java,compareBasesAndQuals,private void  (final ReadData rd1 final ReadData rd2 final String testName){ Assert.assertEquals(rd1.getBases() rd2.getBases() testName); Assert.assertEquals(rd1.getQualities() rd2.getQualities() testName); Assert.assertEquals(rd1.getReadType() rd2.getReadType()); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaDataProviderTest.java,comparePositionalData,private void  (final ClusterData cd1 final ClusterData cd2 final String testName){ Assert.assertEquals(cd1.getLane() cd2.getLane() testName); Assert.assertEquals(cd1.getTile() cd2.getTile() testName); Assert.assertEquals(cd1.getX() cd2.getX() testName); Assert.assertEquals(cd1.getY() cd2.getY() testName); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaDataProviderTest.java,compareReadData,private void  (final ClusterData cd1 final ClusterData cd2 final String testName){ comparePositionalData(cd1 cd2 testName); Assert.assertEquals(cd1.getNumReads() cd2.getNumReads()); for (int i=0; i < cd1.getNumReads(); i++) { compareBasesAndQuals(cd1.getRead(i) cd2.getRead(i) testName); } Assert.assertEquals(cd1.getMatchedBarcode() cd2.getMatchedBarcode() testName); Assert.assertEquals(cd1.isPf().booleanValue() cd2.isPf().booleanValue() testName); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaDataProviderTest.java,getDataTypes,private IlluminaDataType[]  (final IlluminaDataType[] extraDataTypes){ final IlluminaDataType[] dts; if (extraDataTypes == null) { dts=DEFAULT_DATA_TYPES; } else { dts=Arrays.copyOf(DEFAULT_DATA_TYPES DEFAULT_DATA_TYPES.length + extraDataTypes.length); System.arraycopy(extraDataTypes 0 dts DEFAULT_DATA_TYPES.length extraDataTypes.length); } return dts; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaDataProviderTest.java,runBarcodeParsingTest,public void  (final IlluminaDataProviderFactory factory){ int total=0; final BaseIlluminaDataProvider dataProvider=factory.makeDataProvider(); while (dataProvider.hasNext()) { final ClusterData cluster=dataProvider.next(); final String matchedBarcode=cluster.getMatchedBarcode(); if (matchedBarcode != null) { Assert.assertEquals(matchedBarcode new String(cluster.getRead(1).getBases())); } if (total > 10) { break; } total++; } dataProvider.close(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaDataProviderTest.java,runTest,"private void  (final String testName final int size final Map<Integer ClusterData> readNoToClusterData final int seekAfterFirstRead final int seekTestDataReadOffset final BaseIlluminaDataProvider dataProvider) throws Exception { int count=0; int readNum=0; while (dataProvider.hasNext()) { final ClusterData cluster=dataProvider.next(); if (readNoToClusterData.containsKey(readNum)) { compareReadData(cluster readNoToClusterData.get(readNum) testName + "" cluster num "" + readNum); } if (seekAfterFirstRead != 0 && count == 0) { dataProvider.seekToTile(seekAfterFirstRead); readNum+=seekTestDataReadOffset; } readNum++; count++; } Assert.assertEquals(count size testName); dataProvider.close(); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaDataProviderTest.java,testIlluminaDataProviderBclMethod,"@Test(dataProvider=""binaryData"") public void  (final String testName final int lane final int size final List<Integer> tiles final IlluminaDataType[] extraDataTypes final String illuminaConfigStr final int seekAfterFirstRead final int seekTestDataReadOffs"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaDataProviderTest.java,testIlluminaDataProviderMissingDatas,"@Test(dataProvider=""badData"" expectedExceptions={PicardException.class IllegalArgumentException.class}) public void  (final String testName final int lane final int size final List<Integer> tiles final IlluminaDataType[] actualDts final String illuminaCon"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTilePerCycleParserTest.java,MockCycledIlluminaData,public  (){ this.values=new ArrayList<String>(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTilePerCycleParserTest.java,MockPerTileCycleParser,public  (final File directory final int lane final CycleIlluminaFileMap tilesToCycleFiles final OutputMapping outputMapping){ super(directory lane tilesToCycleFiles outputMapping); expectedOutputLengths=outputMapping.getOutputReadLengths(); this.initialize(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTilePerCycleParserTest.java,addValue,public void  (final String value){ values.add(value); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTilePerCycleParserTest.java,basicIterationTest,@Test public void  (){ final List<String> expectedValues=getFileNames(DEFAULT_TILES); final PerTileCycleParser<MockCycledIlluminaData> parser=makeParser(); int index=0; while (parser.hasNext()) { index=compareValues(parser.next().values expectedValues ind
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTilePerCycleParserTest.java,compareValues,"private int  (final List<String> parserValues final List<String> expectedValues int index){ for ( final String parserValue : parserValues) { Assert.assertTrue(index < expectedValues.size()); Assert.assertEquals(parserValue expectedValues.get(index) ""With index "" + index); ++index; } return index; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTilePerCycleParserTest.java,getFileNames,public List<String>  (final List<Integer> tiles){ final List<String> fileNames=new ArrayList<String>(); for ( final Integer tile : tiles) { for (int i=1; i <= MAX_CYCLE; i++) { fileNames.add(str_del(tile i)); } } return fileNames; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTilePerCycleParserTest.java,getIlluminaFileMaps,public CycleIlluminaFileMap  (final List<Integer> tiles final int[] cycles){ final CycleIlluminaFileMap cycleFileMap=new CycleIlluminaFileMap(); for ( final int cycle : cycles) { final IlluminaFileMap fileMap=new IlluminaFileMap(); for ( final Integer tile : tiles) { fileMap.put(tile new File(str_del(tile cycle))); } cycleFileMap.put(cycle fileMap); } return cycleFileMap; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTilePerCycleParserTest.java,getValues,public List<String>  (){ return values; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTilePerCycleParserTest.java,hasNext,@Override public boolean  (){ return currentCycle < MAX_CYCLE; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTilePerCycleParserTest.java,initialize,@Override public void  (){ seekToTile(currentTile); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTilePerCycleParserTest.java,makeCycleFileParser,@Override protected CycleFilesParser<MockCycledIlluminaData>  (final List<File> files){ return new CycleFilesParser<MockCycledIlluminaData>(){ int currentCycle=0; @Override public void close(){ } @Override public MockCycledIlluminaData next(){ final MockC
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTilePerCycleParserTest.java,makeParser,"public PerTileCycleParser<MockCycledIlluminaData>  (){ final CycleIlluminaFileMap fileMap=getIlluminaFileMaps(DEFAULT_TILES CYCLES); return new MockPerTileCycleParser(new File(""FakeFile"") 1 fileMap OUTPUT_MAPPING); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTilePerCycleParserTest.java,next,@Override public MockCycledIlluminaData  (){ final MockCycledIlluminaData ild=new MockCycledIlluminaData(); if (!hasNext()) { throw new NoSuchElementException(); } ild.addValue(str_del(files.get(currentCycle++))); return ild; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTilePerCycleParserTest.java,seekingIterationTest,"@Test(dataProvider=""seekingTests"") public void  (final Integer seekPos1 final Integer newTile1 final Integer seekPos2 final Integer newTile2){ final List<String> expectedValues=getFileNames(DEFAULT_TILES); final PerTileCycleParser<MockCycledIlluminaData> "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTilePerCycleParserTest.java,seekingTests,"@DataProvider(name="" "") public Object[][] seekingTests(){ return new Object[][]{{1 3 null null} {22 1 null null} {38 2 null null} {75 4 null null} {1 3 70 1} {1 3 45 2} {12 2 59 4} {45 3 70 3} {14 1 5 2}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTilePerCycleParserTest.java,str_del,"public static String  (final Object... objects){ String out=objects[0].toString(); for (int i=1; i < objects.length; i++) { out+=""_"" + objects[i]; } return out; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTilePerCycleParserTest.java,supportedTypes,public Set<IlluminaDataType>  (){ return null; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTileParserTest.java,DummyDt,public  (final Integer value){ this.value=value; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTileParserTest.java,MockPerTileParser,public  (final IlluminaFileMap tilesToFiles){ super(tilesToFiles); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTileParserTest.java,basicIterationTest,"@Test public void  (){ final IlluminaFileMap fm=new IlluminaFileMap(); fm.put(1 new File(""s_1_1"")); fm.put(2 new File(""s_1_2"")); fm.put(3 new File(""s_1_3"")); fm.put(4 new File(""s_1_4"")); fm.put(5 new File(""s_1_5"")); final PerTileParser<DummyDt> ddts=new M"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTileParserTest.java,failVerifyTestMissingTile,@Test(expectedExceptions=PicardException.class) public void  (){ final PerTileParser<DummyDt> ddts=new MockPerTileParser(FILE_MAP); ddts.verifyData(makeList(1 2 4 5) null); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTileParserTest.java,failVerifyTestTooManyTiles,@Test(expectedExceptions=PicardException.class) public void  (){ final PerTileParser<DummyDt> ddts=new MockPerTileParser(FILE_MAP); ddts.verifyData(makeList(1 2 3 4 5 6) null); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTileParserTest.java,hasNext,@Override public boolean  (){ return values.hasNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTileParserTest.java,makeTileIterator,@Override protected CloseableIterator<DummyDt>  (final File file){ return new CloseableIterator<DummyDt>(){ private final Iterator<Integer> values=FILE_TO_VALUE.get(file.getName()).iterator(); @Override public void close(){ } @Override public boolean hasN
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTileParserTest.java,missingTileTest,"@Test(expectedExceptions=PicardException.class dataProvider=""missingTiles"") public void  (final Integer missingTile){ final PerTileParser<DummyDt> ddts=new MockPerTileParser(FILE_MAP); ddts.seekToTile(missingTile); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTileParserTest.java,missingTiles,"@DataProvider(name="" "") public Object[][] missingTiles(){ return new Object[][]{{-1} {10} {Integer.MAX_VALUE} {Integer.MIN_VALUE}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTileParserTest.java,next,@Override public DummyDt  (){ return new DummyDt(values.next()); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTileParserTest.java,passVerifyTest,@Test public void  (){ final PerTileParser<DummyDt> ddts=new MockPerTileParser(FILE_MAP); ddts.verifyData(makeList(1 2 3 4 5) null); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTileParserTest.java,remove,@Override public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTileParserTest.java,seekToTileTest,"@Test(dataProvider=""seekingTests"") public void  (Integer firstSeekPos Integer firstTile Integer secondSeekPos Integer secondTile){ final PerTileParser<DummyDt> ddts=new MockPerTileParser(FILE_MAP); for (int i=1; i <= firstSeekPos; i++) { Assert.assertTrue"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTileParserTest.java,seekingTests,"@DataProvider(name="" "") public Object[][] seekingTests(){ return new Object[][]{{1 4 null null} {15 1 null null} {25 3 null null} {24 5 null null} {1 3 10 1} {1 3 15 2} {12 2 15 4} {6 3 12 5} {14 5 25 2}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PerTileParserTest.java,supportedTypes,@Override public Set<IlluminaDataType>  (){ return null; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\AbstractIlluminaPositionFileReaderTest.java,MockPositionFileReader,"public  (final int lane final int tile final float[] xCoords final float[] yCoords){ super(new File(""s_"" + lane + ""_""+ tile+ ""_pos.txt.gz"")); this.xCoords=xCoords; this.yCoords=yCoords; currentCluster=0; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\AbstractIlluminaPositionFileReaderTest.java,hasNext,@Override public boolean  (){ return currentCluster < xCoords.length; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\AbstractIlluminaPositionFileReaderTest.java,invalidFileNames,"@DataProvider(name="" "") public Object[][] invalidFileNames(){ return new Object[][]{{""whatever.locs""} {""whatever.clocs""} {""whatever.pos""} {""s_1.clocs""} {""s__2.clocs""} {""s_1_4.Notclocs""} {""a_1_4.pos""} {""a_1_4.pos.txt""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\AbstractIlluminaPositionFileReaderTest.java,invalidFileNamesTest,"@Test(expectedExceptions=PicardException.class dataProvider=""invalidFileNames"") public void  (final String fileName){ final int lane=3; final int tile=4; final AbstractIlluminaPositionFileReader reader=new MockPositionFileReader(fileName 0 0 null null); }"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\AbstractIlluminaPositionFileReaderTest.java,invalidPositions,"@DataProvider(name="" "") public Object[][] invalidPositions(){ return new Object[][]{{new float[]{0f 5f -11f} new float[]{1f 12f 13f}} {new float[]{-15.05f} new float[]{19801f}} {new float[]{10.05f 3f 8f} new float[]{-120899.723f 4f 9f}} {new float[]{9.0f "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\AbstractIlluminaPositionFileReaderTest.java,invalidReaderTest,"@Test(expectedExceptions=IllegalArgumentException.class dataProvider=""invalidPositions"") public void  (float[] xCoords float[] yCoords){ final int lane=3; final int tile=4; final AbstractIlluminaPositionFileReader reader=new MockPositionFileReader(lane ti"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\AbstractIlluminaPositionFileReaderTest.java,iteratorRemoveTest,"@Test(expectedExceptions=UnsupportedOperationException.class) public void  (){ final AbstractIlluminaPositionFileReader reader=new MockPositionFileReader(""s_1_1_pos.txt"" 0 0 null null); reader.remove(); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\AbstractIlluminaPositionFileReaderTest.java,makeExceptionMsg,"@Override protected String  (){ return ""Abstract IlluminaPositionFileReaderTest currentCluster="" + currentCluster; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\AbstractIlluminaPositionFileReaderTest.java,unsafeNextInfo,@Override protected PositionInfo  (){ PositionInfo pi=new PositionInfo(xCoords[currentCluster] yCoords[currentCluster] getLane() getTile()); ++currentCluster; return pi; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\AbstractIlluminaPositionFileReaderTest.java,validReaderTest,@Test public void  (){ final int lane=2; final int tile=8; final AbstractIlluminaPositionFileReader reader=new MockPositionFileReader(lane tile X_COORDS Y_COORDS); int index=0; while (reader.hasNext()) { AbstractIlluminaPositionFileReader.PositionInfo pi=
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PosParserTest.java,TestResult,public  (final int lane final int tile final float xPos final float yPos final int xQseqCoord final int yQSeqCoord){ this.lane=lane; this.tile=tile; this.xPos=xPos; this.yPos=yPos; this.xQSeqCoord=xQseqCoord; this.yQSeqCoord=yQSeqCoord; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PosParserTest.java,compareResults,"public static void  (final TestResult tr final PositionalData pd final int index){ Assert.assertEquals(tr.xQSeqCoord pd.getXCoordinate() "" At index "" + index); Assert.assertEquals(tr.yQSeqCoord pd.getYCoordinate() "" At index "" + index); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PosParserTest.java,makeTestResults,public static List<TestResult>  (final int lane final int tile final float[] xyPos final int[] xyQseq){ final ArrayList<TestResult> results=new ArrayList<TestResult>(); for (int i=0; i < xyPos.length; i+=2) { results.add(new TestResult(lane tile xyPos[i] xyPos[i + 1] xyQseq[i] xyQseq[i + 1])); } return results; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PosParserTest.java,multiTileData,"@DataProvider(name="" "") public Object[][] multiTileData(){ return new Object[][]{{makeList(1 2 3) null makeList(S_1_1_POS S_1_2_POS S_1_3_POS)} {makeList(1 2 3) 1 makeList(S_1_1_POS S_1_2_POS S_1_3_POS)} {makeList(1 3) 0 makeList(S_1_1_POS S_1_3_POS)} {ma"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PosParserTest.java,multiTileDataTest,"@Test(dataProvider=""multiTileData"") public void  (final List<Integer> tiles final Integer startingTileIndex final List<File> files){ final IlluminaFileMap fm=new IlluminaFileMap(); for (int i=0; i < tiles.size(); i++) { fm.put(tiles.get(i) files.get(i)); "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PosParserTest.java,singleTileData,"@DataProvider(name="" "") public Object[][] singleTileData(){ return new Object[][]{{1 1 S_1_1_POS} {1 null S_1_1_POS} {3202 3202 S_9_3202_POS} {3202 null S_9_3202_POS}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\PosParserTest.java,singleTileDataTest,"@Test(dataProvider=""singleTileData"") public void  (final int tile final Integer startingTile final File file){ final IlluminaFileMap fm=new IlluminaFileMap(); fm.put(tile file); final PosParser parser=(startingTile == null) ? new PosParser(fm IlluminaFile"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,assertDefaults,"public void  (final IlluminaFileUtil fileUtil final Integer lane final List<SupportedIlluminaFormat> formatsToTest){ if (lane == null) { Assert.assertEquals(fileUtil.getLane() DEFAULT_LANE); } else { Assert.assertEquals(new Integer(fileUtil.getLane()) lane); } Assert.assertEquals(fileUtil.getUtil(SupportedIlluminaFormat.Barcode).getTiles() DEFAULT_TILES); Assert.assertEquals(fileUtil.getUtil(SupportedIlluminaFormat.Bcl).getTiles() DEFAULT_TILES); Assert.assertEquals(fileUtil.getUtil(SupportedIlluminaFormat.Pos).getTiles() DEFAULT_TILES); Assert.assertEquals(fileUtil.getUtil(SupportedIlluminaFormat.Locs).getTiles() DEFAULT_TILES); Assert.assertEquals(fileUtil.getUtil(SupportedIlluminaFormat.Clocs).getTiles() DEFAULT_TILES); Assert.assertEquals(fileUtil.getUtil(SupportedIlluminaFormat.Filter).getTiles() DEFAULT_TILES); final Set<Integer> detectedCycles=((PerTilePerCycleFileUtil)fileUtil.getUtil(SupportedIlluminaFormat.Bcl)).getDetectedCycles(); Assert.assertEquals(detectedCycles.size() DEFAULT_CYCLES.length); int i=0; for ( final Integer cycle : detectedCycles) { Assert.assertEquals(cycle.intValue() DEFAULT_CYCLES[i++] ""Elements differ at index "" + i); } Assert.assertEquals(fileUtil.getActualTiles(formatsToTest) DEFAULT_TILES); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,cycleRange,public static int[]  (final int end){ return cycleRange(1 end); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,deleteRelativeFiles,public final void  (final List<String> relativeFilesToDelete){ deleteRelativeFiles(intensityDir relativeFilesToDelete); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,emptyRelativeFiles,"public static void  (final File baseFile final List<String> relativeFilesToDelete){ for ( final String relativeFile : relativeFilesToDelete) { final File actualFile=new File(baseFile relativeFile); if (!actualFile.exists()) { throw new RuntimeException(""Trying to empty a non-existent file"" + actualFile.getAbsolutePath()); } if (actualFile.isDirectory()) { throw new RuntimeException(""Trying to empty a directory("" + actualFile.getAbsolutePath() + "")""); } else { if (!actualFile.delete()) { throw new RuntimeException(""Couldn't remove previous file when emptying("" + actualFile.getAbsolutePath() + "")""); } else { try { if (!actualFile.createNewFile()) { throw new RuntimeException(""Couldn't create empty file: "" + actualFile.getAbsolutePath() + "")""); } } catch ( final IOException ioe) { throw new RuntimeException(ioe); } } } if (!actualFile.exists()) { throw new PicardException(""File should exist: "" + actualFile); } } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,invalidLaneForLTRegex,"@Test(dataProvider=""invalidLanes"" expectedExceptions=PicardException.class) public void  (final int lane){ ParameterizedFileUtil.makeLaneTileRegex("".test"" lane); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,invalidLanes,"@DataProvider(name="" "") public Object[][] invalidLanes(){ return new Object[][]{{-1000} {-10} {-1}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,laneDir,"private static String  (final int lane){ String ldir=String.valueOf(lane); while (ldir.length() < 3) { ldir=""0"" + ldir; } return ""L"" + ldir; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,longTile,"private static String  (final int tile final boolean makeLong){ if (makeLong) { String lt=String.valueOf(tile); while (lt.length() < 4) { lt=""0"" + lt; } return lt; } else { return String.valueOf(tile); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,makeCycleFileList,"private static List<String>  (final File dir final String ext final int lane final int[] cycles final boolean longFmt final int... tiles){ final List<String> files=new ArrayList<String>(); final File laneDir=new File(dir laneDir(lane)); for ( final int cycle : cycles) { final File cycleDir=new File(laneDir ""C"" + cycle + "".1""); for ( final Integer tile : tiles) { files.add(cycleDir + ""/s_"" + lane+ ""_""+ longTile(tile longFmt)+ ext); } } return files; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,makeFiles,"public static void  (final SupportedIlluminaFormat format final File intensityDir final int lane final List<Integer> tiles final int[] cycles final String compression){ String laneDir=String.valueOf(lane); while (laneDir.length() < 3) { laneDir=""0"" + laneDir; } laneDir=""L"" + laneDir; final File basecallDir=new File(intensityDir ""BaseCalls""); final File basecallLaneDir=new File(basecallDir laneDir); final File intensityLaneDir=new File(intensityDir laneDir); switch (format) { case Barcode: makePerTileFiles(basecallDir lane tiles maybeAddExt(""_barcode.txt"" compression) true); break; case Pos: makePerTileFiles(intensityDir lane tiles maybeAddExt(""_pos.txt"" compression) false); break; case Locs: makePerTileFiles(intensityLaneDir lane tiles maybeAddExt("".locs"" null) false); break; case Clocs: makePerTileFiles(intensityLaneDir lane tiles maybeAddExt("".clocs"" null) false); break; case Filter: makePerTileFiles(basecallLaneDir lane tiles maybeAddExt("".filter"" null) true); break; case Bcl: makePerTilePerCycleFiles(basecallLaneDir lane tiles cycles "".bcl""); break; } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,makePerTileFile,"public File  (final File parentDir final int lane final int tile final String extension final String compression final boolean longFormat){ return new File(parentDir ""s_"" + lane + ""_""+ longTile(tile longFormat)+ extension+ (compression != null ? compression : """")); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,makePerTileFiles,"private static void  (final File parentDir final int lane final List<Integer> tiles final String ext final boolean longName){ if (!parentDir.exists()) { if (!parentDir.mkdir()) { throw new RuntimeException(""Couldn't create directory "" + parentDir.getAbsolutePath()); } } for ( final Integer tile : tiles) { writeNonEmptyFile(new File(parentDir ""s_"" + lane + ""_""+ longTile(tile longName)+ ext)); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,makePerTilePerCycleFilePath,"public File  (final File parentDir final int lane final int tile final int cycle final String extension){ return new File(parentDir ""C"" + cycle + "".1/s_""+ lane+ ""_""+ tile+ extension); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,makePerTilePerCycleFiles,"private static void  (final File parentDir final int lane final List<Integer> tiles final int[] cycles final String ext){ if (!parentDir.exists()) { if (!parentDir.mkdir()) { throw new RuntimeException(""Couldn't create directory "" + parentDir.getAbsolutePath()); } } for ( final int cycle : cycles) { final File cycleDir=new File(parentDir ""C"" + cycle + "".1""); if (!cycleDir.exists()) { if (!cycleDir.mkdir()) { throw new RuntimeException(""Couldn't create directory "" + cycleDir.getAbsolutePath()); } } for ( final Integer tile : tiles) { writeNonEmptyFile(new File(cycleDir ""s_"" + lane + ""_""+ tile+ ext)); } } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,maybeAddExt,private static String  (final String fileExt final String compressionExt){ if (compressionExt != null) { return fileExt + compressionExt; } else { return fileExt; } } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,missingCycleDataRanges,"@DataProvider(name="" "") public Object[][] missingCycleDataRanges(){ return new Object[][]{{makeList(new Range(10 15))} {makeList(new Range(9 12) new Range(14 15))}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,missingTileFormats,"@DataProvider(name="" "") public Object[][] missingTileFormats(){ return new Object[][]{{1 makeList(SupportedIlluminaFormat.Bcl SupportedIlluminaFormat.Barcode) makeList(SupportedIlluminaFormat.Bcl SupportedIlluminaFormat.Barcode) makeList(""BaseCalls/s_1_00"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,missingTileTest,"@Test(dataProvider=""missingTileFormats"") public void  (final int lane final List<SupportedIlluminaFormat> formats final List<SupportedIlluminaFormat> formatsToGetTiles final List<String> relativeFilesToDelete final String compression){ for ( final Support"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,notMatchingRegexTest,"@Test(dataProvider=""validLanesInvalidRegexes"") public void  (final int lane final String ltExample){ regexMatches(ParameterizedFileUtil.makeLaneTileRegex("".test"" lane) ltExample false); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,passNewUtilTest,"@Test public void  (){ for ( final SupportedIlluminaFormat format : SupportedIlluminaFormat.values()) { makeFiles(format intensityDir DEFAULT_LANE DEFAULT_TILES DEFAULT_CYCLES); makeFiles(format intensityDir DEFAULT_LANE + 1 DEFAULT_TILES DEFAULT_CYCLES """
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,passingVerifyTest,"@Test public void  (){ for ( final SupportedIlluminaFormat format : SupportedIlluminaFormat.values()) { makeFiles(format intensityDir DEFAULT_LANE DEFAULT_TILES DEFAULT_CYCLES); makeFiles(format intensityDir DEFAULT_LANE + 1 DEFAULT_TILES DEFAULT_CYCLES """
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,perTileFileUtils,"@DataProvider(name=""perTileFileFormats"") public Object[][]  (){ return new Object[][]{{SupportedIlluminaFormat.Locs null false laneDir(DEFAULT_LANE)} {SupportedIlluminaFormat.Clocs null false laneDir(DEFAULT_LANE)} {SupportedIlluminaFormat.Pos "".gz"" false"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,perTileFileUtilsTest,"@Test(dataProvider=""perTileFileFormats"") public void  (final SupportedIlluminaFormat format final String compression final boolean longFormat final String parentDir){ makeFiles(format intensityDir DEFAULT_LANE DEFAULT_TILES DEFAULT_CYCLES compression); fi"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,perTilePerCycleFileFormats,"@DataProvider(name="" "") public Object[][] perTilePerCycleFileFormats(){ return new Object[][]{{SupportedIlluminaFormat.Bcl ""BaseCalls/"" + laneDir(DEFAULT_LANE) DEFAULT_CYCLES false false} {SupportedIlluminaFormat.Bcl ""BaseCalls/"" + laneDir(DEFAULT_LANE) c"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,perTilePerCycleFileUtilsMissingCycleTest,"@Test(expectedExceptions=PicardException.class dataProvider=""missingCycleDataRanges"") public void  (final List<Range> cycleRangesToMake){ final SupportedIlluminaFormat format=SupportedIlluminaFormat.Bcl; for ( final Range range : cycleRangesToMake) { make"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,perTilePerCycleFileUtilsTest,"@Test(dataProvider=""perTilePerCycleFileFormats"") public void  (final SupportedIlluminaFormat format final String parentDir final int[] cycles final boolean createEarlySkippedCycles final boolean createLateSkippedCycles){ if (createEarlySkippedCycles) { ma"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,regexMatches,public void  (final String regex final String toMatch final boolean expectedResult){ final Pattern pt=Pattern.compile(regex); final Matcher ma=pt.matcher(toMatch); Assert.assertEquals(ma.matches() expectedResult); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,regexTests,"@Test(dataProvider=""validLanes"") public void  (final int lane final String ltExample){ regexMatches(ParameterizedFileUtil.makeLaneTileRegex("".test"" lane) ltExample); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,setUp,"@BeforeMethod private void  () throws Exception { intensityDir=IOUtil.createTempDir(""ift_test"" ""Intensities""); basecallDir=new File(intensityDir ""BaseCalls""); if (!basecallDir.mkdir()) { throw new RuntimeException(""Couldn't make basecalls dir "" + basecall"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,tearDown,@AfterMethod private void  (){ IOUtil.deleteDirectoryTree(intensityDir); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,testDefaultPerTilePerCycleUtil,public void  (final PerTilePerCycleFileUtil pcfu final File parentDir final int[] cycles){ final CycleIlluminaFileMap cfm=pcfu.getFiles(cycles); final CycleIlluminaFileMap cfmWTiles=pcfu.getFiles(DEFAULT_TILES cycles); final CycleIlluminaFileMap cfmNoCycles; if (Arrays.equals(cycles DEFAULT_CYCLES)) { cfmNoCycles=pcfu.getFiles(); } else { cfmNoCycles=null; } Assert.assertEquals(cfm.size() cycles.length); for ( final int cycle : cycles) { final IlluminaFileMap tFileIter=cfm.get(cycle); final IlluminaFileMap tFileIter2=cfmWTiles.get(cycle); final IlluminaFileMap tFileIter3; if (cfmNoCycles != null) { tFileIter3=cfmNoCycles.get(cycle); } else { tFileIter3=null; } for ( final Integer tile : DEFAULT_TILES) { final File tcFile=tFileIter.get(tile); final File tcFile2=tFileIter2.get(tile); Assert.assertEquals(tcFile.getAbsolutePath() tcFile2.getAbsolutePath()); if (tFileIter3 != null) { final File tfFile3=tFileIter3.get(tile); Assert.assertEquals(tcFile.getAbsolutePath() tfFile3.getAbsolutePath()); } Assert.assertEquals(tcFile makePerTilePerCycleFilePath(parentDir DEFAULT_LANE tile cycle pcfu.extension)); Assert.assertTrue(tcFile.exists()); Assert.assertTrue(tcFile.length() > 0); } } } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,testDefaultPerTileUtil,public void  (final PerTileFileUtil ptfu final String compression final boolean longFormat final File parentDir){ final IlluminaFileMap fm=ptfu.getFiles(); final IlluminaFileMap fmWTiles=ptfu.getFiles(DEFAULT_TILES); Assert.assertEquals(fm.size() DEFAULT_TILES.size()); for ( final Integer tile : DEFAULT_TILES) { final File tFile=fm.get(tile); final File tFile2=fmWTiles.get(tile); Assert.assertEquals(tFile.getAbsolutePath() tFile2.getAbsolutePath()); Assert.assertEquals(tFile makePerTileFile(parentDir DEFAULT_LANE tile ptfu.extension compression longFormat)); Assert.assertTrue(tFile.exists()); Assert.assertTrue(tFile.length() > 0); } final List<Integer> tiles=new ArrayList<Integer>(DEFAULT_TILE_TEST_SUBSET); final IlluminaFileMap subsetMap=ptfu.getFiles(DEFAULT_TILE_TEST_SUBSET); for ( final Integer tile : subsetMap.keySet()) { tiles.remove(tile); Assert.assertTrue(DEFAULT_TILE_TEST_SUBSET.contains(tile)); final File tFile=subsetMap.get(tile); Assert.assertEquals(tFile makePerTileFile(parentDir DEFAULT_LANE tile ptfu.extension compression longFormat)); Assert.assertTrue(tFile.exists()); Assert.assertTrue(tFile.length() > 0); } Assert.assertTrue(tiles.isEmpty()); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,testHasCbcls,"@Test(dataProvider="" DataProvider"") public void testHasCbcls(final int lane final boolean createCbclDir final boolean createCbcl final boolean expectedResult) throws IOException { final File basecallsDir=IOUtil.createTempDir(""basecalls"" """"); basecallsDir."
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,testHasCbclsDataProvider,"@DataProvider(name="" "") public Object[][] testHasCbclsDataProvider(){ return new Object[][]{{1 true true true} {1 true false false} {1 false false false} {-1 false false false}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,testSubsetDefaultPerTilePerCycleUtil,public void  (final PerTilePerCycleFileUtil pcfu final File parentDir final int[] cycles){ final List<Integer> tiles=new ArrayList<Integer>(DEFAULT_TILE_TEST_SUBSET); final CycleIlluminaFileMap subsetMap=pcfu.getFiles(DEFAULT_TILE_TEST_SUBSET cycles); final CycleIlluminaFileMap cfmNoCycles; if (Arrays.equals(cycles DEFAULT_CYCLES)) { cfmNoCycles=pcfu.getFiles(DEFAULT_TILE_TEST_SUBSET); } else { cfmNoCycles=null; } for ( final int cycle : cycles) { final IlluminaFileMap tFileIter=subsetMap.get(cycle); final IlluminaFileMap tFileIter2; if (cfmNoCycles != null) { tFileIter2=cfmNoCycles.get(cycle); } else { tFileIter2=null; } for ( final Integer tile : subsetMap.get(cycle).keySet()) { Assert.assertTrue(DEFAULT_TILE_TEST_SUBSET.contains(tile)); tiles.remove(tile); final File tcFile=tFileIter.get(tile); if (tFileIter2 != null) { Assert.assertEquals(tcFile tFileIter2.get(tile)); } Assert.assertEquals(tcFile makePerTilePerCycleFilePath(parentDir DEFAULT_LANE tile cycle pcfu.extension)); Assert.assertTrue(tcFile.exists()); Assert.assertTrue(tcFile.length() > 0); } } Assert.assertTrue(tiles.isEmpty()); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,validLanes,"@DataProvider(name="" "") public Object[][] validLanes(){ return new Object[][]{{0 ""s_0_1111.test""} {1 ""s_1_23.test""} {10 ""s_10_1.test""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,validLanesInvalidRegexes,"@DataProvider(name="" "") public Object[][] validLanesInvalidRegexes(){ return new Object[][]{{0 ""s_-0_111""} {1 ""s_1_A3""} {10 ""s_-100_1""} {20 ""s_21_1""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\IlluminaFileUtilTest.java,writeNonEmptyFile,"private static void  (final File file){ try { final OutputStream outputStream=new DataOutputStream(new FileOutputStream(file)); final int expectedLength=10; outputStream.write(expectedLength); for (int i=-3; i < expectedLength; i++) outputStream.write(0x0); outputStream.close(); } catch ( final IOException e) { throw new RuntimeException(""Exception trying to create non-empty file!"" e); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\BclReaderTest.java,call,@Override public Void  () throws Exception { final BclReader reader=new BclReader(even_i ? QUAL_1FAILING_BCL_FILE : QUAL_0FAILING_BCL_FILE bclQualityEvaluationStrategy false); Assert.assertEquals(reader.numClustersPerCycle[0] expectedBases.length); while 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\BclReaderTest.java,failingFileTest,"@Test(expectedExceptions=PicardException.class dataProvider=""failingFiles"") public void  (final File failingFile){ final BclQualityEvaluationStrategy bclQualityEvaluationStrategy=new BclQualityEvaluationStrategy(BclQualityEvaluationStrategy.ILLUMINA_ALLEG"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\BclReaderTest.java,failingFiles,"@DataProvider(name="" "") public Object[][] failingFiles(){ return new Object[][]{{QUAL_0FAILING_BCL_FILE} {QUAL_1FAILING_BCL_FILE} {new File(TestDataDir ""SomeNoneExistentFile.bcl"")} {FILE_TOO_LONG} {FILE_TOO_SHORT}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\BclReaderTest.java,lowQualityAndFailingTest,@Test(expectedExceptions=PicardException.class) public void  () throws ExecutionException  InterruptedException { final BclQualityEvaluationStrategy bclQualityEvaluationStrategy=new BclQualityEvaluationStrategy(BclQualityEvaluationStrategy.ILLUMINA_ALLEGE
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\BclReaderTest.java,lowQualityButPassingTest,@Test public void  () throws ExecutionException  InterruptedException { final BclQualityEvaluationStrategy bclQualityEvaluationStrategy=new BclQualityEvaluationStrategy(1); final Collection<Callable<Void>> callables=new LinkedList<Callable<Void>>(); for (
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\BclReaderTest.java,qualsAsBytes,public byte[]  (){ final byte[] byteVals=new byte[expectedQuals.length]; for (int i=0; i < byteVals.length; i++) { byteVals[i]=(byte)expectedQuals[i]; } return byteVals; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\BclReaderTest.java,readValidFile,@Test public void  (){ final BclQualityEvaluationStrategy bclQualityEvaluationStrategy=new BclQualityEvaluationStrategy(BclQualityEvaluationStrategy.ILLUMINA_ALLEGED_MINIMUM_QUALITY); final BclReader reader=new BclReader(PASSING_BCL_FILE bclQualityEvaluat
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\CbclReaderTest.java,testEmptyTile,"@Test public void  (){ final Map<Integer File> filters=new HashMap<>(); filters.put(1101 TILE_1101_FILTER); final LocsFileReader locsFileReader=new LocsFileReader(new File(""testdata/picard/illumina/readerTests/s_1_6.locs"")); List<AbstractIlluminaPositionF"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\CbclReaderTest.java,testMissingTile,"@Test(expectedExceptions=PicardException.class) public void  (){ final Map<Integer File> filters=new HashMap<>(); filters.put(1101 TILE_1101_FILTER); final LocsFileReader locsFileReader=new LocsFileReader(new File(""testdata/picard/illumina/readerTests/s_1"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\CbclReaderTest.java,testReadValidFile,"@Test public void  (){ final Map<Integer File> filters=new HashMap<>(); filters.put(1101 TILE_1101_FILTER); final LocsFileReader locsFileReader=new LocsFileReader(new File(""testdata/picard/illumina/readerTests/s_1_6.locs"")); final List<AbstractIlluminaPos"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\ClocsFileReaderTest.java,multiBinMixedEmptyBinTest,@Test public void  (){ final ClocsFileReader clocsReader=new ClocsFileReader(MBCF_W_EMPTY_BINS_THROUGHOUT); int tdIndex=0; int nextIndex=MULTI_BIN_INDICES[tdIndex]; for (int i=0; i < MULTI_BIN_EXPECTED_NUM_VALUES; i++) { Assert.assertTrue(clocsReader.hasN
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\ClocsFileReaderTest.java,multiBinPassingClocsFiles,"@DataProvider(name="" "") public Object[][] multiBinPassingClocsFiles(){ return new Object[][]{{MULTI_BIN_PASSING_CLOCS_FILE 0 2102} {MBCF_W_EMPTY_BINS_AT_START 2 2103} {MBCF_W_EMPTY_BINS_AT_END 0 2104}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\ClocsFileReaderTest.java,multiBinTest,"@Test(dataProvider=""multiBinPassingClocsFiles"") public void  (final File multiBinPassingClocsFile final int binShift final int tile){ final ClocsFileReader clocsReader=new ClocsFileReader(multiBinPassingClocsFile); int tdIndex=0; int nextIndex=MULTI_BIN_I"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\ClocsFileReaderTest.java,multiRowFileTest,"@Test public void  (){ final ClocsFileReader clocsReader=new ClocsFileReader(MBCF_MULTI_ROW_FILE); int tdIndex=0; int nextIndex=MULTI_ROW_INDICES[tdIndex]; for (int i=1; i <= 39891; i++) { Assert.assertTrue(clocsReader.hasNext() "" i == "" + i); final Abstr"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\ClocsFileReaderTest.java,singleBinTest,@Test public void  (){ final ClocsFileReader clocsReader=new ClocsFileReader(PASSING_CLOCS_FILE); for (int i=0; i < PosFileReaderTest.PassingPosFloatCoord.length; i++) { Assert.assertTrue(clocsReader.hasNext()); final AbstractIlluminaPositionFileReader.Po
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\FilterFileReaderTest.java,failingFilesForPicardException,"@DataProvider(name="" "") public Object[][] failingFilesForPicardException(){ return new Object[][]{{""pf_failing1.filter""} {""pf_failing2.filter""} {""pf_tooLarge.filter""} {""pf_tooShort.filter""} {""pf_badOpeningBytes.filter""} {""pf_badVersionBytes.filter""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\FilterFileReaderTest.java,failingFilesForSAMException,"@DataProvider(name="" "") public Object[][] failingFilesForSAMException(){ return new Object[][]{{""pf_nonExistentFile.filter""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\FilterFileReaderTest.java,readFakedFile,"@Test void  () throws Exception { final File fakeFile=File.createTempFile(""FilterFileFakerTest"" "".filter""); fakeFile.deleteOnExit(); new FilterFileFaker().fakeFile(fakeFile 100); final FilterFileReader reader=new FilterFileReader(fakeFile); Assert.assertE"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\FilterFileReaderTest.java,readInvalidValuesForPicardException,"@Test(dataProvider=""failingFilesForPicardException"" expectedExceptions=PicardException.class) public void  (final String failingFile){ final FilterFileReader reader=new FilterFileReader(new File(TEST_DATA_DIR failingFile)); while (reader.hasNext()) { read"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\FilterFileReaderTest.java,readInvalidValuesForSAMException,"@Test(dataProvider=""failingFilesForSAMException"" expectedExceptions=SAMException.class) public void  (final String failingFile){ final FilterFileReader reader=new FilterFileReader(new File(TEST_DATA_DIR failingFile)); while (reader.hasNext()) { reader.nex"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\FilterFileReaderTest.java,readPastEnd,@Test(expectedExceptions=NoSuchElementException.class) public void  (){ final FilterFileReader reader=new FilterFileReader(PASSING_FILTER_FILE); for (int i=0; i < reader.numClusters; i++) { reader.next(); } Assert.assertEquals(false reader.hasNext()); rea
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\FilterFileReaderTest.java,readValidFile,@Test public void  (){ final FilterFileReader reader=new FilterFileReader(PASSING_FILTER_FILE); Assert.assertEquals(reader.numClusters expectedPfs.length); for (int i=0; i < reader.numClusters; i++) { Assert.assertEquals(reader.hasNext() true); Assert.ass
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\LocsFileReaderTest.java,invalidFiles,"@DataProvider(name="" "") public Object[][] invalidFiles(){ return new Object[][]{{""s_1_7.locs""} {""s_1_8.locs""} {""s_1_9.locs""} {""s_1_10.locs""} {""s_f2af.locs""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\LocsFileReaderTest.java,invalidFilesTest,"@Test(expectedExceptions=PicardException.class dataProvider=""invalidFiles"") public void  (final String fileName){ final LocsFileReader reader=new LocsFileReader(new File(TestDir fileName)); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\LocsFileReaderTest.java,passingFileTest,@Test public void  (){ final LocsFileReader reader=new LocsFileReader(LocsFile); int tdIndex=0; int nextIndex=Indices[tdIndex]; for (int i=0; i < NumValues; i++) { Assert.assertTrue(reader.hasNext()); final AbstractIlluminaPositionFileReader.PositionInfo 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ReadStructureTest.java,invalidReadStructures,"@DataProvider(name="" "") public Object[][] invalidReadStructures(){ return new Object[][]{{"""" new ArrayList<ReadDescriptor>()} {""0T"" makeList(rd(0 T))} {""-1T"" makeList(rd(-1 T))} {""0S"" makeList(rd(0 S))} {""0M"" makeList(rd(0 M))} {""-1B"" makeList(rd(-1 B))} "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ReadStructureTest.java,invalidReadStructuresFromList,"@DataProvider(name="" "") public Object[][] invalidReadStructuresFromList(){ int numTests=0; for ( final Object[] args : invalidReadStructures()) { if (args[1] != null) ++numTests; } final Object[][] outObjs=new Object[numTests][2]; numTests=0; for ( final "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ReadStructureTest.java,rd,public ReadDescriptor  (final int length final ReadType rt){ return new ReadDescriptor(length rt); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ReadStructureTest.java,substructureToReadStructureData,"@DataProvider(name=""substructuresToReadStructureData"") public Object[][]  (){ return new Object[][]{{new ReadStructure(""10T10T"").templates ""10T10T""} {new ReadStructure(""10T4M10T"").templates ""10T10T""} {new ReadStructure(""10T8B10T"").nonSkips ""10T8B10T""} {ne"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ReadStructureTest.java,substructureToReadStructureNegativeData,"@DataProvider(name="" "") public Object[][] substructureToReadStructureNegativeData(){ return new Object[][]{{new ReadStructure(""10T"").sampleBarcodes} {new ReadStructure(""10M"").sampleBarcodes} {new ReadStructure(""10T"").molecularBarcode} {new ReadStructure("""
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ReadStructureTest.java,testInvalidReadStructureFromList,"@Test(dataProvider=""invalidReadStructuresFromList"" expectedExceptions=IllegalArgumentException.class) public void  (final String rsString final List<ReadDescriptor> descriptors){ final ReadStructure readStructure=new ReadStructure(descriptors); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ReadStructureTest.java,testInvalidReadStructureFromString,"@Test(dataProvider=""invalidReadStructures"" expectedExceptions=IllegalArgumentException.class) public void  (final String rsString final List<ReadDescriptor> descriptors){ final ReadStructure readStructure=new ReadStructure(rsString); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ReadStructureTest.java,testReadStructure,"private void  (final ReadStructure readStructure final String structureString final List<ReadDescriptor> descriptors final int numTemplates final int numBarcodes final int numSkips final int numMolecularIndexes){ Assert.assertEquals(readStructure.toString() structureString); int totalCycles=0; int tIndex=0; int bIndex=0; int sIndex=0; int mIndex=0; for (int i=0; i < descriptors.size(); i++) { Assert.assertEquals(readStructure.descriptors.get(i) descriptors.get(i)); switch (readStructure.descriptors.get(i).type) { case T: Assert.assertEquals(i readStructure.templates.getIndices()[tIndex++]); break; case B: Assert.assertEquals(i readStructure.sampleBarcodes.getIndices()[bIndex++]); break; case S: Assert.assertEquals(i readStructure.skips.getIndices()[sIndex++]); break; case M: Assert.assertEquals(i readStructure.molecularBarcode.getIndices()[mIndex++]); break; default : Assert.fail(""Unrecognized read type: "" + readStructure.descriptors.get(i).type); } totalCycles+=readStructure.descriptors.get(i).length; } Assert.assertEquals(readStructure.totalCycles totalCycles); Assert.assertEquals(readStructure.sampleBarcodes.length() numBarcodes); Assert.assertEquals(readStructure.templates.length() numTemplates); Assert.assertEquals(readStructure.molecularBarcode.length() numMolecularIndexes); Assert.assertEquals(readStructure.skips.length() numSkips); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ReadStructureTest.java,testSubstructureToReadStructure,"@Test(dataProvider=""substructureToReadStructureNegativeData"" expectedExceptions=IllegalArgumentException.class) public void  (final ReadStructure.Substructure substructure){ substructure.toReadStructure().toString(); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ReadStructureTest.java,testValidStructuresFromList,"@Test(dataProvider=""validReadStructures"") public void  (final String rsString final List<ReadDescriptor> descriptors final int numTemplates final int numBarcodes final int numSkips final int numMolecularIndexes){ final ReadStructure readStructure=new Read"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ReadStructureTest.java,testValidStructuresFromString,"@Test(dataProvider=""validReadStructures"") public void  (final String rsString final List<ReadDescriptor> descriptors final int numTemplates final int numBarcodes final int numSkips final int numMolecularIndexes){ final ReadStructure readStructure=new Read"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\ReadStructureTest.java,validReadStructures,"@DataProvider(name="" "") public Object[][] validReadStructures(){ return new Object[][]{{""2T"" makeList(rd(2 T)) 1 0 0 0} {""1234B"" makeList(rd(1234 B)) 0 1 0 0} {Integer.MAX_VALUE + ""S"" makeList(rd(Integer.MAX_VALUE S)) 0 0 1 0} {Integer.MAX_VALUE + ""M"" mak"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\TileMetricsUtilTest.java,createTestDirs,"private Path  (int numCycleMetricsFiles boolean baseMetricsFile) throws IOException { Path baseDir=Files.createTempDirectory(""TileMetricsUtilTest""); Path baseOpDir=Files.createDirectory(baseDir.resolve(TileMetricsUtil.INTEROP_SUBDIRECTORY_NAME)); IntStream.range(1 numCycleMetricsFiles + 1).forEach(i -> { try { Path cycleDir=Files.createDirectory(baseOpDir.resolve(""C"" + i + "".1"")); if (i == numCycleMetricsFiles) { Files.createFile(cycleDir.resolve(TileMetricsUtil.TILE_METRICS_OUT_FILE_NAME)); } } catch ( IOException e) { e.printStackTrace(); } } ); if (baseMetricsFile) { Files.createFile(baseOpDir.resolve(TileMetricsUtil.TILE_METRICS_OUT_FILE_NAME)); } return baseDir; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\TileMetricsUtilTest.java,testFindTileMetrics,@Test public void  () throws IOException { Path baseDir=createTestDirs(0 true); File tileMetricsFile=TileMetricsUtil.renderTileMetricsFileFromBasecallingDirectory(baseDir.toFile() 0 false); Assert.assertEquals(tileMetricsFile.getAbsolutePath() baseDir.res
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\TileMetricsUtilTest.java,testFindTileMetricsNovaSeqInBaseInterOp,@Test public void  () throws IOException { Path baseDir=createTestDirs(1 true); File tileMetricsFile=TileMetricsUtil.renderTileMetricsFileFromBasecallingDirectory(baseDir.toFile() 1 true); Assert.assertEquals(tileMetricsFile.getAbsolutePath() baseDir.reso
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\TileMetricsUtilTest.java,testFindTileMetricsNovaSeqInCycleDirs,@Test public void  () throws IOException { Path baseDir=createTestDirs(2 false); File tileMetricsFile=TileMetricsUtil.renderTileMetricsFileFromBasecallingDirectory(baseDir.toFile() 2 true); Assert.assertEquals(tileMetricsFile.getAbsolutePath() baseDir.res
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\TileMetricsUtilTest.java,testMissingTileMetrics,@Test(expectedExceptions=IllegalStateException.class) public void  () throws IOException { Path baseDir=createTestDirs(0 false); TileMetricsUtil.renderTileMetricsFileFromBasecallingDirectory(baseDir.toFile() 0 false); IOUtil.deleteDirectoryTree(baseDir.to
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\PosFileReaderTest.java,comparePositionInfo,"public static void  (final AbstractIlluminaPositionFileReader.PositionInfo pi final float xPos final float yPos final int xQSeqCoord final int yQSeqCoord final int lane final int tile final int index){ Assert.assertEquals(pi.xPos xPos ""Differs at index: "" + index); Assert.assertEquals(pi.yPos yPos ""Differs at index: "" + index); Assert.assertEquals(pi.xQseqCoord xQSeqCoord ""Differs at index: "" + index); Assert.assertEquals(pi.yQseqCoord yQSeqCoord ""Differs at index: "" + index); Assert.assertEquals(pi.lane lane ""Differs at index: "" + index); Assert.assertEquals(pi.tile tile ""Differs at index: "" + index); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\PosFileReaderTest.java,failingDataPosFileTest,"@Test(dataProvider=""invalidDataFiles"" expectedExceptions=PicardException.class) public void  (final File file){ final PosFileReader pfr=new PosFileReader(file); try { while (pfr.hasNext()) { pfr.next(); } } finally { pfr.close(); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\PosFileReaderTest.java,failingNamePosFileTest,@Test(expectedExceptions=PicardException.class) public void  (){ final PosFileReader pfr=new PosFileReader(InvalidNamePosFile); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\PosFileReaderTest.java,invalidDataFiles,"@DataProvider(name="" "") public Object[][] invalidDataFiles(){ return new Object[][]{{new File(TestDir ""s_1_1101_pos.txt"")} {new File(TestDir ""s_1_1102_pos.txt"")} {new File(TestDir ""s_1_1103_pos.txt"")}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\PosFileReaderTest.java,validPosFileTest,@Test public void  (){ final PosFileReader pfr=new PosFileReader(PassingPosFile); for (int i=0; i < PassingPosFloatCoord.length; i++) { Assert.assertTrue(pfr.hasNext()); final AbstractIlluminaPositionFileReader.PositionInfo pi=pfr.next(); comparePositionI
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\PosFileReaderTest.java,zeroLengthFileTest,"@Test public void  (){ final PosFileReader pfr=new PosFileReader(new File(TestDir ""s_1_1104_pos.txt"")); Assert.assertFalse(pfr.hasNext()); pfr.close(); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\MMapBackedIteratorFactoryTest.java,FileTestDef,public  (final int headerSize final BinaryFileIterator<T> bbIter){ this.headerSize=headerSize; this.bbIter=bbIter; this.numElements=fileAsBytes(headerSize FileLength - 1).length / bbIter.getElementSize(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\MMapBackedIteratorFactoryTest.java,NoHeaderTestIter,public  (final Buffer buf){ this.buf=buf; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\MMapBackedIteratorFactoryTest.java,fileAsByteBuffer,public ByteBuffer  (final int headerSize){ final byte[] bytes=fileAsBytes(headerSize FileLength - 1); final ByteBuffer bb=ByteBuffer.allocate(bytes.length); bb.put(bytes); bb.position(0); bb.order(ByteOrder.LITTLE_ENDIAN); return bb; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\MMapBackedIteratorFactoryTest.java,fileAsBytes,public byte[]  (final int start final int end){ final int[] bInts={0x31 0x22 0x41 0x01 0x45 0x6E 0x64 0x4F 0x66 0x48 0x65 0x61 0x64 0x65 0x72 0x42 0x6F 0x64 0x79 0x50 0x61 0x72 0x74 0x6F 0x66 0x54 0x68 0x65 0x46 0x69 0x6C 0x65 0x37 0x37 0x0A 0x45 0x6E 0x64 0x43 0x6F 0x6D 0x6D 0x75 0x6E 0x69 0x63 0x61 0x74 0x69 0x6F 0x6E}; final int total=end - start + 1; final byte[] bytes=new byte[total]; for (int i=0; i < total; i++) { bytes[i]=(byte)bInts[start + i]; } return bytes; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\MMapBackedIteratorFactoryTest.java,getTestIterator,@Override public Iterator<Float>  (final ByteBuffer byteBuffer){ return new NoHeaderTestIter<Float>(byteBuffer){ @Override public Float next(){ return byteBuffer.getFloat(); } } ; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\MMapBackedIteratorFactoryTest.java,hasNext,public boolean  (){ return buf.hasRemaining(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\MMapBackedIteratorFactoryTest.java,headerAsByteBuffer,public ByteBuffer  (final int headerSize){ final byte[] bytes=fileAsBytes(0 headerSize - 1); final ByteBuffer bb=ByteBuffer.allocate(bytes.length); bb.put(bytes); bb.position(0); bb.order(ByteOrder.LITTLE_ENDIAN); return bb; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\MMapBackedIteratorFactoryTest.java,invalidFileSizeTests,"@Test(expectedExceptions=PicardException.class dataProvider=""invalidFileSizes"") public void  (final int headerSize final int expectedElements){ final BinaryFileIterator<Integer> bbIter=MMapBackedIteratorFactory.getIntegerIterator(headerSize BinFile); bbIt"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\MMapBackedIteratorFactoryTest.java,invalidFileSizes,"@DataProvider(name="" "") public Object[][] invalidFileSizes(){ return new Object[][]{{1 12} {3 11}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\MMapBackedIteratorFactoryTest.java,negativeHeaderTest,@Test(expectedExceptions=PicardException.class) public void  (){ final BinaryFileIterator<Integer> bbIter=MMapBackedIteratorFactory.getIntegerIterator(-1 BinFile); bbIter.getHeaderBytes(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\MMapBackedIteratorFactoryTest.java,next,@Override public Float  (){ return byteBuffer.getFloat(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\MMapBackedIteratorFactoryTest.java,onlyHeaderTest,@Test public void  (){ final BinaryFileIterator<Integer> bbIter=MMapBackedIteratorFactory.getIntegerIterator((int)BinFile.length() BinFile); Assert.assertEquals(bbIter.getHeaderBytes() headerAsByteBuffer((int)BinFile.length())); Assert.assertFalse(bbIter.
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\MMapBackedIteratorFactoryTest.java,remove,public void  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\MMapBackedIteratorFactoryTest.java,test,public void  (){ final ByteBuffer testBuffer=fileAsByteBuffer(headerSize); if (headerSize > 0) { final ByteBuffer headerBuffer=headerAsByteBuffer(headerSize); testHeaderBytes(headerBuffer bbIter.getHeaderBytes()); } bbIter.assertTotalElementsEqual(numElements); final Iterator<T> testIter=getTestIterator(testBuffer); while (hasNext(testIter bbIter)) { Assert.assertEquals(testIter.next() bbIter.next()); } } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\MMapBackedIteratorFactoryTest.java,testHeaderBytes,"public void  (final ByteBuffer bb1 final ByteBuffer bb2){ Assert.assertTrue(bb1.equals(bb2) ""Header bytes are not equal! "" + bb1.toString() + "" != ""+ bb2.toString()); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\MMapBackedIteratorFactoryTest.java,testValidConfigurations,"@Test(dataProvider=""validTestDefs"") public void  (final FileTestDef ftd){ ftd.test(); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\MMapBackedIteratorFactoryTest.java,tooLargeHeaderTest,@Test(expectedExceptions=PicardException.class) public void  (){ final BinaryFileIterator<Integer> bbIter=MMapBackedIteratorFactory.getIntegerIterator(FileLength + 10 BinFile); bbIter.getHeaderBytes(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\illumina\parser\readers\MMapBackedIteratorFactoryTest.java,validTestDefs,"@DataProvider(name="" "") public Object[][] validTestDefs(){ return new Object[][]{{new FileTestDef<Integer>(15 MMapBackedIteratorFactory.getIntegerIterator(15 BinFile)){ @Override public Iterator<Integer> getTestIterator( final ByteBuffer byteBuffer){ fina"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\IntelInflaterDeflaterLoadTest.java,checkIntelSupported,"private void  (final String componentName){ if (!SystemUtils.IS_OS_LINUX && !SystemUtils.IS_OS_MAC) { throw new SkipException(componentName + "" is not available on this platform""); } if (SystemUtils.OS_ARCH != null && SystemUtils.OS_ARCH.equals(""ppc64le"")) { throw new SkipException(componentName + "" is not available for this architecture""); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\IntelInflaterDeflaterLoadTest.java,testIntelDeflaterIsAvailable,"@Test public void  (){ checkIntelSupported(""IntelDeflater""); Assert.assertTrue(new IntelDeflater().load(null) ""Intel shared library was not loaded. This could be due to a configuration error  or your system might not support it.""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\IntelInflaterDeflaterLoadTest.java,testIntelInflaterIsAvailable,"@Test public void  (){ checkIntelSupported(""IntelInflater""); Assert.assertTrue(new IntelInflater().load(null) ""Intel shared library was not loaded. This could be due to a configuration error  or your system might not support it.""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\reference\NonNFastaSizeTest.java,noIntervals,"@Test public void  () throws IOException { final File input=new File(REFERENCE); final File outfile=File.createTempFile(""nonNcount"" "".txt""); outfile.deleteOnExit(); final String[] args=new String[]{""INPUT="" + input.getAbsolutePath() ""OUTPUT="" + outfile.ge"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\reference\NonNFastaSizeTest.java,withIntervals,"@Test public void  () throws IOException { final File input=new File(REFERENCE); final File outfile=File.createTempFile(""nonNcount"" "".txt""); final File intervals=new File(""testdata/picard/reference/test.intervals""); outfile.deleteOnExit(); final String[] "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\pedigree\PedFileTest.java,testFromSexMap,"@Test(dataProvider="" DataProvider"") public void testFromSexMap(final Collection<String> females final Collection<String> males) throws Exception { final Map<String Sex> data=new HashMap<String Sex>(); for ( final String sample : females) { data.put(sample"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\pedigree\PedFileTest.java,testFromSexMapDataProvider,"@DataProvider() public Object[][]  (){ return new Object[][]{new Object[]{Arrays.asList() Arrays.asList()} new Object[]{Arrays.asList(""female1"" ""female2"" ""female3"") Arrays.asList(""male1"" ""male2"" ""male3"")} new Object[]{Arrays.asList(""female1"" ""female2"" ""fe"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\metrics\CollectRrbsMetricsTest.java,chrMReads,"@Test public void  () throws Exception { final MetricsFile<RrbsSummaryMetrics ?> metricsFile=getSummaryFile(CHR_M_SAM CHR_M_REFERENCE rootTestDir + ""/READ_TEST"" new ArrayList<String>()); final RrbsSummaryMetrics metrics=metricsFile.getMetrics().get(0); As"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\metrics\CollectRrbsMetricsTest.java,getSummaryFile,"private MetricsFile<RrbsSummaryMetrics ?>  (final String input final String reference final String prefix final List<String> sequences) throws Exception { final List<String> argList=new ArrayList<String>(); argList.add(""INPUT="" + input); argList.add(""METRICS_FILE_PREFIX="" + prefix); argList.add(""REFERENCE="" + reference); for ( final String sequence : sequences) { argList.add(""SEQUENCE_NAMES="" + sequence); } final String[] args=new String[argList.size()]; argList.toArray(args); Assert.assertEquals(new CollectRrbsMetrics().instanceMain(args) 0); final MetricsFile<RrbsSummaryMetrics ?> retVal=new MetricsFile<RrbsSummaryMetrics Integer>(); retVal.read(new FileReader(prefix + "".rrbs_summary_metrics"")); return retVal; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\metrics\CollectRrbsMetricsTest.java,setUp,"@BeforeTest private void  () throws Exception { rootTestDir=File.createTempFile(""crmt."" "".tmp""); Assert.assertTrue(rootTestDir.delete()); Assert.assertTrue(rootTestDir.mkdir()); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\metrics\CollectRrbsMetricsTest.java,tearDown,@AfterTest private void  (){ IOUtil.deleteDirectoryTree(rootTestDir); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CleanSamTest.java,getCommandLineProgramName,public String  (){ return CleanSam.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CleanSamTest.java,testCleanSam,"@Test(dataProvider="" DataProvider"") public void testCleanSam(final String samFile final String expectedCigar) throws IOException { final File cleanedFile=File.createTempFile(samFile + ""."" "".sam""); cleanedFile.deleteOnExit(); final String[] args=new String"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CleanSamTest.java,testCleanSamDataProvider,"@DataProvider(name="" "") public Object[][] testCleanSamDataProvider(){ return new Object[][]{{""simple_fits.sam"" ""100M""} {""simple_overhang.sam"" ""99M1S""} {""fits_with_deletion.sam"" ""91M2D9M""} {""overhang_with_deletion.sam"" ""91M2D8M1S""} {""trailing_insertion.sam"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CleanSamTest.java,testCleanSamTester,"@Test(dataProvider="" DataProvider"") public void testCleanSamTester(final String originalCigar final String expectedCigar final int defaultChromosomeLength final int alignStart) throws IOException { final CleanSamTester cleanSamTester=new CleanSamTester(ex"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CleanSamTest.java,testCleanSamTesterDataProvider,"@DataProvider(name="" "") public Object[][] testCleanSamTesterDataProvider(){ return new Object[][]{{""100M"" ""100M"" 101 2} {""100M"" ""99M1S"" 101 3} {""91M2D9M"" ""91M2D9M"" 102 1} {""91M2D9M"" ""91M2D8M1S"" 101 1} {""99M1I"" ""99M1I"" 101 3} {""90M10I"" ""90M10I"" 101 3}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CompareSAMsTest.java,getCommandLineProgramName,public String  (){ return CompareSAMs.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CompareSAMsTest.java,testBiggerSequenceDictionaries,"@Test public void  (){ testHelper(""bigger_seq_dict.sam"" ""bigger_seq_dict.sam"" 2 0 0 0 0 0 0 true); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CompareSAMsTest.java,testGroupWithSameCoordinate,"@Test public void  (){ testHelper(""group_same_coord.sam"" ""group_same_coord_diff_order.sam"" 3 0 0 0 0 1 2 false); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CompareSAMsTest.java,testGroupWithSameCoordinateAndNoMatchInOther,"@Test public void  (){ testHelper(""group_same_coord.sam"" ""diff_coords.sam"" 0 5 0 0 0 0 0 false); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CompareSAMsTest.java,testGroupWithSameCoordinateSamePosition,"@Test public void  (){ testHelper(""genomic_sorted_same_position.sam"" ""genomic_sorted_same_position.sam"" 2 0 0 0 0 0 0 true); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CompareSAMsTest.java,testHasNonPrimary,"@Test public void  (){ testHelper(""genomic_sorted.sam"" ""has_non_primary.sam"" 2 0 0 0 0 0 0 true); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CompareSAMsTest.java,testHelper,private void  (final String f1 final String f2 final int expectedMatch final int expectedDiffer final int expectedUnmappedBoth final int expectedUnmappedLeft final int expectedUnmappedRight final int expectedMissingLeft final int expectedMissingRight final boolean areEqual){ final String[] samFiles={new File(TEST_FILES_DIR f1).getAbsolutePath() new File(TEST_FILES_DIR f2).getAbsolutePath()}; CompareSAMs compareSAMs=new CompareSAMs(); compareSAMs.instanceMain(samFiles); Assert.assertEquals(compareSAMs.areEqual() areEqual); Assert.assertEquals(compareSAMs.getMappingsMatch() expectedMatch); Assert.assertEquals(compareSAMs.getMappingsDiffer() expectedDiffer); Assert.assertEquals(compareSAMs.getUnmappedBoth() expectedUnmappedBoth); Assert.assertEquals(compareSAMs.getUnmappedLeft() expectedUnmappedLeft); Assert.assertEquals(compareSAMs.getUnmappedRight() expectedUnmappedRight); Assert.assertEquals(compareSAMs.getMissingLeft() expectedMissingLeft); Assert.assertEquals(compareSAMs.getMissingRight() expectedMissingRight); final String[] samFilesReversed={new File(TEST_FILES_DIR f2).getAbsolutePath() new File(TEST_FILES_DIR f1).getAbsolutePath()}; compareSAMs=new CompareSAMs(); compareSAMs.instanceMain(samFilesReversed); Assert.assertEquals(compareSAMs.areEqual() areEqual); Assert.assertEquals(compareSAMs.getMappingsMatch() expectedMatch); Assert.assertEquals(compareSAMs.getMappingsDiffer() expectedDiffer); Assert.assertEquals(compareSAMs.getUnmappedBoth() expectedUnmappedBoth); Assert.assertEquals(compareSAMs.getUnmappedLeft() expectedUnmappedRight); Assert.assertEquals(compareSAMs.getUnmappedRight() expectedUnmappedLeft); Assert.assertEquals(compareSAMs.getMissingLeft() expectedMissingRight); Assert.assertEquals(compareSAMs.getMissingRight() expectedMissingLeft); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CompareSAMsTest.java,testIdentical,"@Test public void  (){ testHelper(""genomic_sorted.sam"" ""genomic_sorted.sam"" 2 0 0 0 0 0 0 true); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CompareSAMsTest.java,testMoreOnOneSide,"@Test public void  (){ testHelper(""genomic_sorted_5.sam"" ""genomic_sorted_5_plus.sam"" 3 2 0 0 0 3 0 false); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CompareSAMsTest.java,testSequenceDictionariesDifferent1,"@Test public void  (){ testHelper(""genomic_sorted.sam"" ""chr21.sam"" 0 0 0 0 0 0 0 false); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CompareSAMsTest.java,testSequenceDictionariesDifferent2,"@Test public void  (){ testHelper(""genomic_sorted.sam"" ""bigger_seq_dict.sam"" 0 0 0 0 0 0 0 false); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CompareSAMsTest.java,testSortsDifferent,"@Test public void  (){ testHelper(""genomic_sorted.sam"" ""unsorted.sam"" 0 0 0 0 0 0 0 false); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CompareSAMsTest.java,testUnmapped1,"@Test public void  (){ testHelper(""genomic_sorted.sam"" ""unmapped_first.sam"" 1 0 0 0 1 0 0 false); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CompareSAMsTest.java,testUnmapped2,"@Test public void  (){ testHelper(""genomic_sorted.sam"" ""unmapped_second.sam"" 1 0 0 0 1 0 0 false); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CompareSAMsTest.java,testUnmapped3,"@Test public void  (){ testHelper(""unmapped_first.sam"" ""unmapped_second.sam"" 0 0 0 1 1 0 0 false); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CompareSAMsTest.java,testUnmapped4,"@Test public void  (){ testHelper(""unmapped_first.sam"" ""unmapped_first.sam"" 1 0 1 0 0 0 0 true); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CompareSAMsTest.java,testUnsorted1,"@Test public void  (){ testHelper(""unsorted.sam"" ""unsorted.sam"" 2 0 0 0 0 0 0 true); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CompareSAMsTest.java,testUnsorted2,"@Test public void  (){ testHelper(""unsorted.sam"" ""unsorted2.sam"" 0 1 0 0 0 0 1 false); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\AbstractAlignmentMergerTest.java,tesOverlappedReadClippingWithNonOverlappedReads,"@Test public void  (){ final SAMRecordSetBuilder set=new SAMRecordSetBuilder(); set.setReadLength(110); final List<SAMRecord> recs=set.addPair(""q1"" 0 100 200 false false ""110M"" ""110M"" false true 30); final SAMRecord r1=recs.get(0); final SAMRecord r2=recs"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\AbstractAlignmentMergerTest.java,testBasicOverlappedReadClipping,"@Test public void  (){ final SAMRecordSetBuilder set=new SAMRecordSetBuilder(); set.setReadLength(110); final List<SAMRecord> recs=set.addPair(""q1"" 0 100 90 false false ""110M"" ""110M"" false true 30); final SAMRecord r1=recs.get(0); final SAMRecord r2=recs."
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\AbstractAlignmentMergerTest.java,testOverlappedReadClippingWithExistingSoftClipping,"@Test public void  (){ final SAMRecordSetBuilder set=new SAMRecordSetBuilder(); set.setReadLength(120); final List<SAMRecord> recs=set.addPair(""q1"" 0 100 95 false false ""110M10S"" ""15S105M"" false true 30); final SAMRecord r1=recs.get(0); final SAMRecord r2"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\AbstractAlignmentMergerTest.java,testOverlappedReadClippingWithExistingSoftClippingAndHardClipping,"@Test public void  (){ final SAMRecordSetBuilder set=new SAMRecordSetBuilder(); set.setReadLength(120); final List<SAMRecord> recs=set.addPair(""q1"" 0 100 95 false false ""110M10S5H"" ""5H15S105M"" false true 30); final SAMRecord r1=recs.get(0); final SAMRecor"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\AddCommentsToBamTest.java,getCommandLineProgramName,public String  (){ return AddCommentsToBam.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\AddCommentsToBamTest.java,runIt,"private void  (final File inputFile final File outputFile final String[] commentList){ final List<String> args=new ArrayList<String>(Arrays.asList(""INPUT="" + inputFile.getAbsolutePath() ""OUTPUT="" + outputFile.getAbsolutePath())); for ( final String comment : commentList) { args.add(""COMMENT="" + comment); } runPicardCommandLine(args); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\AddCommentsToBamTest.java,testAddCommentsToBam,"@Test public void  () throws Exception { final File outputFile=File.createTempFile(""addCommentsToBamTest."" BamFileIoUtils.BAM_FILE_EXTENSION); outputFile.deleteOnExit(); runIt(INPUT_FILE outputFile commentList); final SAMFileHeader newHeader=SamReaderFact"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\AddCommentsToBamTest.java,testUsingNewlines,"@Test(expectedExceptions=IllegalArgumentException.class) public void  () throws Exception { final File outputFile=File.createTempFile(""addCommentsToBamTest.mewLine"" BamFileIoUtils.BAM_FILE_EXTENSION); outputFile.deleteOnExit(); runIt(SAM_FILE outputFile n"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\AddCommentsToBamTest.java,testUsingSam,"@Test(expectedExceptions=PicardException.class) public void  () throws Exception { final File outputFile=File.createTempFile(""addCommentsToBamTest.samFile"" BamFileIoUtils.BAM_FILE_EXTENSION); outputFile.deleteOnExit(); runIt(SAM_FILE outputFile commentLis"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\DownsampleSamTest.java,ValidArgumentsTestProvider,"@DataProvider(name="" "") public Object[][] ValidArgumentsTestProvider(){ final List<Object[]> objects=new ArrayList<>(); for ( final Strategy strategy : Strategy.values()) for ( final Integer seed : new Integer[]{1 null}) for (double i=0.3; i <= 1; i+=.1) "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\DownsampleSamTest.java,getCommandLineProgramName,@Override public String  (){ return DownsampleSam.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\DownsampleSamTest.java,setupBuilder,"@BeforeTest void  () throws IOException { final int numReads=10000; final String flowCellBarcode=""TESTBARCODE""; final String separator="":""; final int lane=1; final int tile=2203; final Random rg=new Random(31); setBuilder.setReadGroup(readGroupRecord); se"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\DownsampleSamTest.java,tearDown,@AfterTest private void  (){ IOUtil.deleteDirectoryTree(tempDir); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\DownsampleSamTest.java,testDownsampleStrategies,"@Test(dataProvider=""ValidArgumentsTestProvider"") public void  (final double fraction final Strategy strategy final Integer seed) throws IOException { testDownsampleWorker(tempSamFile fraction strategy.name() seed); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\DownsampleSamTest.java,testDownsampleWorker,"private void  (final File samFile final double fraction final String strategy final Integer seed) throws IOException { final File downsampled=File.createTempFile(""DownsampleSam"" "".bam"" tempDir); final String[] args=new String[]{""INPUT="" + samFile.getAbsolutePath() ""OUTPUT="" + downsampled.getAbsolutePath() ""PROBABILITY="" + fraction ""STRATEGY="" + strategy ""RANDOM_SEED="" + ((seed == null) ? ""null"" : seed.toString()) ""CREATE_INDEX=true""}; Assert.assertEquals(runPicardCommandLine(args) 0); final ValidateSamFile validateSamFile=new ValidateSamFile(); validateSamFile.INPUT=downsampled; Assert.assertEquals(validateSamFile.doWork() 0); if (seed != null) { TestNGUtil.assertGreaterThan(SamTestUtil.countSamTotalRecord(downsampled) fraction * .8 * SamTestUtil.countSamTotalRecord(samFile)); TestNGUtil.assertLessThan(SamTestUtil.countSamTotalRecord(downsampled) fraction * 1.2 * SamTestUtil.countSamTotalRecord(samFile)); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CreateSequenceDictionaryTest.java,getCommandLineProgramName,public String  (){ return CreateSequenceDictionary.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CreateSequenceDictionaryTest.java,testBasic,"@Test public void  () throws Exception { final File outputDict=File.createTempFile(""CreateSequenceDictionaryTest."" "".dict""); outputDict.delete(); outputDict.deleteOnExit(); final String[] argv={""REFERENCE="" + BASIC_FASTA ""OUTPUT="" + outputDict ""TRUNCATE_N"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CreateSequenceDictionaryTest.java,testDefaultOutputFile,"@Test public void  () throws Exception { final File expectedDict=new File(TEST_DATA_DIR + ""/sam"" ""basic.dict""); expectedDict.deleteOnExit(); Assert.assertFalse(expectedDict.exists()); final String[] argv={""REFERENCE="" + BASIC_FASTA ""TRUNCATE_NAMES_AT_WHIT"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CreateSequenceDictionaryTest.java,testForEquivalence,"@Test public void  () throws Exception { final File outputDict=File.createTempFile(""CreateSequenceDictionaryTest."" "".dict""); outputDict.delete(); final String[] argv={""REFERENCE="" + EQUIVALENCE_TEST_FASTA ""OUTPUT="" + outputDict ""TRUNCATE_NAMES_AT_WHITESPA"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\CreateSequenceDictionaryTest.java,testNonUniqueSequenceName,"@Test(expectedExceptions=PicardException.class) public void  () throws Exception { final File outputDict=File.createTempFile(""CreateSequenceDictionaryTest."" "".dict""); outputDict.deleteOnExit(); final String[] argv={""REFERENCE="" + DUPLICATE_FASTA ""OUTPUT="""
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\DuplicationMetricsTest.java,emptyMetrics,"private DuplicationMetrics  (){ final DuplicationMetrics metric=new DuplicationMetrics(); metric.LIBRARY=""LIBRARY""; metric.UNPAIRED_READS_EXAMINED=0; metric.READ_PAIRS_EXAMINED=0; metric.SECONDARY_OR_SUPPLEMENTARY_RDS=0; metric.UNMAPPED_READS=0; metric.UNPAIRED_READ_DUPLICATES=0; metric.READ_PAIR_DUPLICATES=0; metric.READ_PAIR_OPTICAL_DUPLICATES=0; metric.calculateDerivedFields(); return metric; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\DuplicationMetricsTest.java,infiniteLoopFromGithub_1146,@Test(timeOut=1000) public void  (){ DuplicationMetrics.estimateLibrarySize(357087883 357087881); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\DuplicationMetricsTest.java,nonEmptyMetrics,"private DuplicationMetrics  (final int scale){ final DuplicationMetrics metric=new DuplicationMetrics(); metric.LIBRARY=""LIBRARY""; metric.UNPAIRED_READS_EXAMINED=1000 * scale; metric.READ_PAIRS_EXAMINED=1000 * scale; metric.SECONDARY_OR_SUPPLEMENTARY_RDS=scale; metric.UNMAPPED_READS=10 * scale; metric.UNPAIRED_READ_DUPLICATES=100 * scale; metric.READ_PAIR_DUPLICATES=110 * scale; metric.READ_PAIR_OPTICAL_DUPLICATES=10 * scale; metric.calculateDerivedFields(); return metric; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\DuplicationMetricsTest.java,testMerge,"@Test(dataProvider="" DataProvider"") public void testMerge(final DuplicationMetrics left final DuplicationMetrics right final DuplicationMetrics expected){ left.merge(right); left.calculateDerivedFields(); Assert.assertEquals(left.LIBRARY expected.LIBRARY)"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\DuplicationMetricsTest.java,testMergeDataProvider,"@DataProvider(name="" "") public Object[][] testMergeDataProvider(){ return new Object[][]{{emptyMetrics() emptyMetrics() emptyMetrics()} {emptyMetrics() nonEmptyMetrics(1) nonEmptyMetrics(1)} {nonEmptyMetrics(1) emptyMetrics() nonEmptyMetrics(1)} {nonEmpty"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FixMateInformationTest.java,getCommandLineProgramName,public String  (){ return FixMateInformation.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FixMateInformationTest.java,ignoreMissingMateExceptionTest,@Test(expectedExceptions=SAMException.class) public void  () throws IOException { missingMateTestHelper(false); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FixMateInformationTest.java,ignoreMissingMateTest,@Test public void  () throws IOException { Assert.assertEquals(missingMateTestHelper(true) 0); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FixMateInformationTest.java,missingMateTestHelper,"public int  (final boolean ignoreMissingMates) throws IOException { final File inSamFile=new File(TEST_DATA_DIR MISSING_MATE_TEST); final File outSamFile=File.createTempFile(""outMissingMateTest"" ""sam""); outSamFile.deleteOnExit(); final String[] args=new String[]{""INPUT="" + inSamFile.getAbsolutePath() ""OUTPUT="" + outSamFile.getAbsolutePath() ""IGNORE_MISSING_MATES="" + ignoreMissingMates}; return new FixMateInformation().instanceMain(args); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\GatherBamFilesTest.java,getCommandLineProgramName,public String  (){ return GatherBamFiles.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\GatherBamFilesTest.java,sanityCheckTheGathering,"@Test public void  () throws Exception { final File outputFile=File.createTempFile(""gatherBamFilesTest.samFile."" BamFileIoUtils.BAM_FILE_EXTENSION); outputFile.deleteOnExit(); final List<String> args=new ArrayList<String>(); for ( final File splitBam : SP"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\GatherBamFilesTest.java,testTheGathering,"@Test public void  () throws Exception { final File outputFile=File.createTempFile(""gatherBamFilesTest.samFile."" BamFileIoUtils.BAM_FILE_EXTENSION); outputFile.deleteOnExit(); final List<String> args=new ArrayList<String>(); for ( final File splitBam : SP"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FilterSamReadsTest.java,badArgumentCombinationsdata,"@DataProvider(name="" "") public Object[][] badArgumentCombinationsdata(){ return new Object[][]{{FilterSamReads.Filter.includeJavascript ""READ_LIST_FILE""} {FilterSamReads.Filter.excludeAligned ""READ_LIST_FILE""} {FilterSamReads.Filter.includeAligned ""READ_L"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FilterSamReadsTest.java,dataTestDebugOption,"@DataProvider(name="" "") public Object[][] dataTestDebugOption(){ return new Object[][]{{null false} {true true} {false false}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FilterSamReadsTest.java,dataTestJsFilter,"@DataProvider(name="" "") public Object[][] dataTestJsFilter(){ return new Object[][]{{TEST_DIR + ""aligned.sam"" TEST_DIR + ""FilterSamReads/filterOddStarts.js"" 3} {TEST_DIR + ""aligned.sam"" TEST_DIR + ""FilterSamReads/filterReadsWithout5primeSoftClip.js"" 0}}; "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FilterSamReadsTest.java,dataTestPairedIntervalFilter,"@DataProvider(name="" "") public Object[][] dataTestPairedIntervalFilter(){ return new Object[][]{{TEST_DIR + ""FilterSamReads/filter1.interval_list"" 4} {TEST_DIR + ""FilterSamReads/filter2.interval_list"" 0}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FilterSamReadsTest.java,dataTestReadFilter,"@DataProvider(name="" "") public Object[][] dataTestReadFilter(){ List<String> reads=Arrays.asList(""mapped_pair_chr1"" ""prove_one_of_pair"" ""one_of_pair""); return new Object[][]{{FilterSamReads.Filter.includeReadList reads 3 * 2} {FilterSamReads.Filter.exclud"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FilterSamReadsTest.java,dataTestTagFilter,"@DataProvider(name="" "") public Object[][] dataTestTagFilter(){ return new Object[][]{{""testdata/picard/sam/aligned.sam"" ""RG"" ""0"" true 8} {""testdata/picard/sam/aligned.sam"" ""RG"" ""0"" false 0} {""testdata/picard/sam/aligned.sam"" ""CB"" ""ACG"" false 3} {""testdata"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FilterSamReadsTest.java,getCommandLineProgramName,@Override public String  (){ return FilterSamReads.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FilterSamReadsTest.java,getReadCount,private long  (FilterSamReads filterTest) throws Exception { final SamReader samReader=SamReaderFactory.makeDefault().open(filterTest.OUTPUT); long count=StreamSupport.stream(samReader.spliterator() false).count(); samReader.close(); return count; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FilterSamReadsTest.java,setUp,"@BeforeTest public void  () throws IOException { builder.setReadLength(READ_LENGTH); builder.addPair(""mapped_pair_chr1"" 0 1 151); builder.addPair(""mapped_pair_chr2"" 1 1 151); builder.addPair(""prove_one_of_pair"" 0 1000 1000); builder.addPair(""one_of_pair"" "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FilterSamReadsTest.java,setupProgram,private FilterSamReads  (final File inputFile final File inputSam final FilterSamReads.Filter filter) throws Exception { return setupProgram(inputFile inputSam filter null); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FilterSamReadsTest.java,testBadArgumentCombinations,"@Test(dataProvider=""badArgumentCombinationsdata"") public void  (final FilterSamReads.Filter filter final String fileArgument) throws IOException { final File dummyFile=File.createTempFile(TEST_DIR ""dummy""); dummyFile.deleteOnExit(); try (final FileWriter "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FilterSamReadsTest.java,testDebugOption,"@Test(dataProvider=""dataTestDebugOption"") public void  (Boolean writeDebugReads boolean isDebugFileExpected) throws Exception { final File inputSam=new File(""testdata/picard/sam/aligned.sam""); final File javascriptFile=new File(""testdata/picard/sam/Filter"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FilterSamReadsTest.java,testJavaScriptFilters,"@Test(dataProvider=""dataTestJsFilter"") public void  (final String samFilename final String javascriptFilename final int expectNumber) throws Exception { final File inputSam=new File(samFilename); final File javascriptFile=new File(javascriptFilename); Fil"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FilterSamReadsTest.java,testPairedIntervalFilter,"@Test(dataProvider=""dataTestPairedIntervalFilter"") public void  (final String intervalFilename final int expectNumber) throws Exception { final File inputSam=VcfTestUtils.createTemporaryIndexedFile(""testSam"" "".bam""); final SAMFileWriter writer=new SAMFile"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FilterSamReadsTest.java,testReadFilters,"@Test(dataProvider=""dataTestReadFilter"") public void  (final FilterSamReads.Filter filterType final List<String> readList final int expectNumber) throws Exception { final File inputSam=File.createTempFile(""testSam"" "".sam"" new File(TEST_DIR)); inputSam.del"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FilterSamReadsTest.java,testTagFilter,"@Test(dataProvider=""dataTestTagFilter"") public void  (final String samFilename final String tag final String tagValue final boolean includeReads final int expectNumber) throws Exception { final File inputSam=new File(samFilename); final FilterSamReads fil"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,badFormatFiles,"@DataProvider(name="" "") public Object[][] badFormatFiles(){ return new Object[][]{{""bad-format/bad-qual-header.txt""} {""bad-format/bad-seq-header.txt""} {""bad-format/extra-line.txt""} {""bad-format/too-many-quals.txt""} {""bad-format/1lines.txt""} {""bad-format/2"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,badPairNames,"@DataProvider(name="" "") public Object[][] badPairNames(){ return new Object[][]{{"""" """"} {""aa/1"" ""bb/2""} {""aa"" ""bb""} {""aa/1"" ""aa""} {""aa"" ""aa/2""} {""aa/1"" ""aa/1""} {""aa/2"" ""aa/2""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,badPairedFiles,"@DataProvider(name="" "") public Object[][] badPairedFiles(){ return new Object[][]{{""ok-paired/pair1.txt"" ""bad-paired/pair2-one-more-record.txt""} {""bad-paired/pair1-one-more-record.txt"" ""ok-paired/pair2.txt""} {""ok-paired/pair1.txt"" ""bad-paired/pair2-badnum"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,badVersionFiles,"@DataProvider(name="" "") public Object[][] badVersionFiles(){ return new Object[][]{{""fastq-sanger/sanger_full_range_as_sanger-63.fastq"" FastqQualityFormat.Illumina} {""fastq-solexa/s_1_sequence.txt"" FastqQualityFormat.Illumina}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,beforeClass,"@BeforeClass public static void  () throws IOException { final File dummyFile=newTempFile(""dummy""); freader1=new FastqReader(dummyFile); freader2=new FastqReader(dummyFile); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,convertFile,"private File  (final String fastqFilename1 final String fastqFilename2 final FastqQualityFormat version final boolean permissiveFormat final boolean useSequentialFastqs) throws IOException { final File fastq1=new File(TEST_DATA_DIR fastqFilename1); final File fastq2=(fastqFilename2 != null) ? new File(TEST_DATA_DIR fastqFilename2) : null; final File samFile=newTempSamFile(fastq1.getName()); final List<String> args=new ArrayList<String>(); args.add(""FASTQ="" + fastq1.getAbsolutePath()); args.add(""OUTPUT="" + samFile.getAbsolutePath()); args.add(""QUALITY_FORMAT="" + version); args.add(""READ_GROUP_NAME=rg""); args.add(""SAMPLE_NAME=s1""); if (fastqFilename2 != null) args.add(""FASTQ2="" + fastq2.getAbsolutePath()); if (permissiveFormat) args.add(""ALLOW_AND_IGNORE_EMPTY_LINES=true""); if (useSequentialFastqs) args.add(""USE_SEQUENTIAL_FASTQS=true""); Assert.assertEquals(runPicardCommandLine(args) 0); return samFile; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,convertFileAndVerifyRecordCount,private void  (final int expectedCount final String fastqFilename1 final String fastqFilename2 final FastqQualityFormat version final boolean permissiveFormat final boolean useSequentialFastqs) throws IOException { final File samFile=convertFile(fastqFilename1 fastqFilename2 version permissiveFormat useSequentialFastqs); final SamReader samReader=SamReaderFactory.makeDefault().open(samFile); final SAMRecordIterator iterator=samReader.iterator(); int actualCount=0; while (iterator.hasNext()) { iterator.next(); actualCount++; } samReader.close(); Assert.assertEquals(actualCount expectedCount); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,getCommandLineProgramName,public String  (){ return FastqToSam.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,newTempFile,"private static File  (final String filename) throws IOException { final File file=File.createTempFile(filename "".tmp""); file.deleteOnExit(); return file; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,newTempSamFile,"private static File  (final String filename) throws IOException { final File file=File.createTempFile(filename "".sam""); file.deleteOnExit(); return file; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,okPairNames,"@DataProvider(name="" "") public Object[][] okPairNames(){ return new Object[][]{{""aa/1"" ""aa/2""} {""aa"" ""aa""} {""aa/bb"" ""aa/bb""} {""aa/bb/"" ""aa/bb/""} {""aa/bb/1"" ""aa/bb/2""} {""aa/bb/cc/dd/ee/ff/1"" ""aa/bb/cc/dd/ee/ff/2""} {""////1"" ""////2""} {""/"" ""/""} {""////"" ""////"""
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,okPairedFiles,"@DataProvider(name="" "") public Object[][] okPairedFiles(){ return new Object[][]{{""ok-paired/pair1.txt"" ""ok-paired/pair2.txt"" FastqQualityFormat.Standard} {""fastq-illumina/s_1_1_sequence.txt"" ""fastq-illumina/s_1_2_sequence.txt"" FastqQualityFormat.Illumina"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,okVersionFiles,"@DataProvider(name="" "") public Object[][] okVersionFiles(){ return new Object[][]{{""fastq-sanger/5k-v1-Rhodobacter_LW1.sam.fastq"" FastqQualityFormat.Standard} {""fastq-sanger/5k-30BB2AAXX.3.aligned.sam.fastq"" FastqQualityFormat.Standard} {""fastq-sanger/san"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,permissiveFormatFiles,"@DataProvider(name="" "") public Object[][] permissiveFormatFiles(){ return new Object[][]{{""permissive-format/pair1.txt"" ""permissive-format/pair2.txt"" FastqQualityFormat.Standard} {""permissive-format/s_1_1_sequence.txt"" ""permissive-format/s_1_2_sequence.tx"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,readPairNameBad,"@Test(dataProvider=""badPairNames"" expectedExceptions=PicardException.class) public void  (final String name1 final String name2) throws IOException { fastqToSam.getBaseName(name1 name2 freader1 freader2); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,readPairNameOk,"@Test(dataProvider=""okPairNames"") public void  (final String name1 final String name2) throws IOException { fastqToSam.getBaseName(name1 name2 freader1 freader2); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,testBadFile,"@Test(dataProvider=""badFormatFiles"" expectedExceptions=SAMException.class) public void  (final String filename) throws IOException { convertFile(filename null FastqQualityFormat.Standard); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,testFastqVersionBad,"@Test(dataProvider=""badVersionFiles"" expectedExceptions=SAMException.class) public void  (final String fastqVersionFilename final FastqQualityFormat version) throws IOException { convertFile(fastqVersionFilename version); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,testFastqVersionOk,"@Test(dataProvider=""okVersionFiles"") public void  (final String fastqVersionFilename final FastqQualityFormat version) throws IOException { convertFile(fastqVersionFilename version); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,testPairedBad,"@Test(dataProvider=""badPairedFiles"" expectedExceptions=PicardException.class) public void  (final String filename1 final String filename2) throws IOException { convertFile(filename1 filename2 FastqQualityFormat.Standard); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,testPairedOk,"@Test(dataProvider=""okPairedFiles"") public void  (final String filename1 final String filename2 final FastqQualityFormat version) throws IOException { convertFile(filename1 filename2 version); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,testPermissiveFail,"@Test(dataProvider=""permissiveFormatFiles"" expectedExceptions=SAMException.class) public void  (final String filename1 final String filename2 final FastqQualityFormat version) throws IOException { convertFile(filename1 filename2 version false); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,testPermissiveOk,"@Test(dataProvider=""permissiveFormatFiles"") public void  (final String filename1 final String filename2 final FastqQualityFormat version) throws IOException { convertFile(filename1 filename2 version true); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\FastqToSamTest.java,testSequentialFiles,"@Test public void  () throws IOException { final String singleEnd=""sequential-files/single_end_R1_001.fastq""; final String pairedEnd1=""sequential-files/paired_end_R1_001.fastq""; final String pairedEnd2=""sequential-files/paired_end_R2_001.fastq""; Assert.as"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\AsIsMarkDuplicatesTester.java,testSameUnclipped5PrimeOppositeStrand,"@Test(dataProvider="" Data"") public void testSameUnclipped5PrimeOppositeStrand(final File input){ final AbstractMarkDuplicatesCommandLineProgramTester tester=new BySumOfBaseQAndInOriginalOrderMDTester(); final SamReader reader=SamReaderFactory.makeDefault("
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\AsIsMarkDuplicatesTester.java,testSameUnclipped5PrimeOppositeStrandData,"@DataProvider public Object[][]  (){ final File TEST_DIR=new File(""testdata/picard/sam/MarkDuplicates""); return new Object[][]{new Object[]{new File(TEST_DIR ""sameUnclipped5primeEndv1.sam"")} new Object[]{new File(TEST_DIR ""sameUnclipped5primeEndv2.sam"")} "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\BySumOfBaseQAndInOriginalOrderMDTester.java,BySumOfBaseQAndInOriginalOrderMDTester,public  (){ super(DuplicateScoringStrategy.ScoringStrategy.SUM_OF_BASE_QUALITIES SAMFileHeader.SortOrder.unsorted false); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\BySumOfBaseQAndInOriginalOrderMDTester.java,getProgram,@Override protected CommandLineProgram  (){ return new MarkDuplicates(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\ElcHashBasedDuplicatesFinderTest.java,fillHistogramDataProvider,"@DataProvider(name="" "") public Object[][] fillHistogramDataProvider(){ return new Object[][]{{duplicatesFinder new Histogram<>() new Histogram<>() generatePairedReadSequence(false) generatePairedReadSequences(0 false) 1 0 0} {duplicatesFinder new Histogra"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\ElcHashBasedDuplicatesFinderTest.java,searchDuplicatesDataProvider,"@DataProvider(name="" "") public Object[][] searchDuplicatesDataProvider(){ return new Object[][]{{duplicatesFinder new Histogram<>() new Histogram<>() generatePairedReadSequences(1 false) 1 0 0} {duplicatesFinder new Histogram<>() new Histogram<>() generat"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\ElcHashBasedDuplicatesFinderTest.java,testFillHistogram,"@Test(dataProvider=""fillHistogramDataProvider"") public void  (ElcDuplicatesFinder duplicatesFinder Histogram<Integer> duplicationHisto Histogram<Integer> opticalHisto PairedReadSequence prs ArrayList<PairedReadSequence> dupes int dupHistoIndex int optHist"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\ElcHashBasedDuplicatesFinderTest.java,testSearchDuplicates,"@Test(dataProvider=""searchDuplicatesDataProvider"") public void  (ElcDuplicatesFinder duplicatesFinder Histogram<Integer> duplicationHisto Histogram<Integer> opticalHisto ArrayList<PairedReadSequence> dupes int dupHistoIndex int optHistoIndex int optHistoV"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\AbstractMarkDuplicatesCommandLineProgramTester.java,AbstractMarkDuplicatesCommandLineProgramTester,public  (){ this(SAMRecordSetBuilder.DEFAULT_DUPLICATE_SCORING_STRATEGY); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\AbstractMarkDuplicatesCommandLineProgramTester.java,getCommandLineProgramName,@Override public String  (){ return getProgram().getClass().getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTagRepresentativeReadIndexTester.java,MarkDuplicatesTagRepresentativeReadIndexTester,"public  (){ addArg(""TAGGING_POLICY=All""); addArg(""TAG_DUPLICATE_SET_MEMBERS=true""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTagRepresentativeReadIndexTester.java,getProgram,@Override protected CommandLineProgram  (){ return new MarkDuplicates(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTagRepresentativeReadIndexTester.java,test,@Override public void  (){ try { updateExpectedDuplicationMetrics(); int outputRecords=0; int indexInFile=0; final SamReader reader=SamReaderFactory.makeDefault().open(getOutput()); for ( final SAMRecord record : reader) { outputRecords++; final String ke
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\EstimateLibraryComplexityTest.java,createDataTestDefaultMinGroupCount,"@DataProvider(name=""testDefaultMinGroupCount"") public Object[][]  (){ return new Object[][]{{""dupes.sam"" 0 0} {""big_dupes.sam"" 8 497}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\EstimateLibraryComplexityTest.java,createDataTestMaxDiffRate,"@DataProvider(name=""testMaxDiffRate"") public Object[][]  (){ return new Object[][]{{""dupes.sam"" 0 2} {""big_dupes.sam"" 8 500}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\EstimateLibraryComplexityTest.java,createDataTestSimpleDuplicate,"@DataProvider(name=""testSimpleDuplicate"") public Object[][]  (){ return new Object[][]{{""dupes.sam"" 2 2} {""big_dupes.sam"" 12 500}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\EstimateLibraryComplexityTest.java,createDataTestSimpleDuplicateWithMaxReadLength,"@DataProvider(name=""testSimpleDuplicateWithMaxReadLength"") public Object[][]  (){ return new Object[][]{{""dupes.sam"" 2 2} {""big_dupes.sam"" 512 500}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\EstimateLibraryComplexityTest.java,createDataTestSimpleDuplicatesWithSecondaryAndSupplementaryRecords,"@DataProvider(name=""testSimpleDuplicatesWithSecondaryAndSupplementaryRecords"") public Object[][]  (){ return new Object[][]{{""dupes_with_sos.sam"" 2 2} {""big_dupes_with_sos.sam"" 12 500}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\EstimateLibraryComplexityTest.java,examineMetricsFile,private void  (final File output final int numDuplicates final int numReadPairsExamined){ final List<DuplicationMetrics> metricsList=MetricsFile.readBeans(output); Assert.assertEquals(metricsList.size() 1); final DuplicationMetrics metrics=metricsList.get(0); Assert.assertEquals(metrics.READ_PAIR_DUPLICATES * 2 + metrics.UNPAIRED_READ_DUPLICATES numDuplicates); Assert.assertEquals(metrics.READ_PAIRS_EXAMINED numReadPairsExamined); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\EstimateLibraryComplexityTest.java,getCommandLineProgramName,public String  (){ return EstimateLibraryComplexity.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\EstimateLibraryComplexityTest.java,testDefaultMinGroupCount,"@Test(dataProvider="" "") public void testDefaultMinGroupCount(final String testName final int numDuplicates final int numReadPairsExamined) throws IOException { final File input=new File(TEST_DATA_DIR testName); final File output=File.createTempFile(""estim"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\EstimateLibraryComplexityTest.java,testMaxDiffRate,"@Test(dataProvider="" "") public void testMaxDiffRate(final String testName final int numDuplicates final int numReadPairsExamined) throws IOException { final File input=new File(TEST_DATA_DIR testName); final File output=File.createTempFile(""estimateLibrar"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\EstimateLibraryComplexityTest.java,testSimpleDuplicate,"@Test(dataProvider="" "") public void testSimpleDuplicate(final String testName final int numDuplicates final int numReadPairsExamined) throws IOException { final File input=new File(TEST_DATA_DIR testName); final File output=File.createTempFile(""estimateLi"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\EstimateLibraryComplexityTest.java,testSimpleDuplicateWithMaxReadLength,"@Test(dataProvider="" "") public void testSimpleDuplicateWithMaxReadLength(final String testName final int numDuplicates final int numReadPairsExamined) throws IOException { final File input=new File(TEST_DATA_DIR testName); final File output=File.createTem"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\EstimateLibraryComplexityTest.java,testSimpleDuplicatesWithSecondaryAndSupplementaryRecords,"@Test(dataProvider="" "") public void testSimpleDuplicatesWithSecondaryAndSupplementaryRecords(final String testName final int numDuplicates final int numReadPairsExamined) throws IOException { final File input=new File(TEST_DATA_DIR testName); final File o"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTagRepresentativeReadIndexTest.java,getTester,protected MarkDuplicatesTagRepresentativeReadIndexTester  (){ return new MarkDuplicatesTagRepresentativeReadIndexTester(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTagRepresentativeReadIndexTest.java,testMultiRepresentativeReadTags,"@Test public void  (){ final MarkDuplicatesTagRepresentativeReadIndexTester tester=getTester(); tester.getSamRecordSetBuilder().setReadLength(45); tester.testRepresentativeReads=true; tester.setExpectedOpticalDuplicate(3); String representativeReadName1="""
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTagRepresentativeReadIndexTest.java,testRepresentativeReadTag,"@Test public void  (){ final MarkDuplicatesTagRepresentativeReadIndexTester tester=getTester(); tester.getSamRecordSetBuilder().setReadLength(45); tester.testRepresentativeReads=true; tester.setExpectedOpticalDuplicate(1); String representativeReadName=""R"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarTest.java,getTester,protected AbstractMarkDuplicatesCommandLineProgramTester  (){ return new MarkDuplicatesWithMateCigarTester(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarTest.java,testScoringStrategyForMateReferenceLengthComparison,"@Test public void  (){ final AbstractMarkDuplicatesCommandLineProgramTester tester=getTester(); tester.addMatePair(""READY"" 1 1 105 false false true true ""50M"" ""5I45M"" false true false false false DEFAULT_BASE_QUALITY); tester.addMatePair(""READX"" 1 1 100 f"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarTest.java,testScoringStrategyForReadNameComparison,@Test public void  (){ final AbstractMarkDuplicatesCommandLineProgramTester tester=getTester(); tester.addMappedFragment(0 1 false DEFAULT_BASE_QUALITY); tester.addMappedFragment(0 1 true DEFAULT_BASE_QUALITY); tester.runTest(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarTest.java,testTwoFragmentsLargeSoftClip,"@Test(expectedExceptions=PicardException.class) public void  (){ final AbstractMarkDuplicatesCommandLineProgramTester tester=getTester(); tester.getSamRecordSetBuilder().setReadLength(100); tester.addMappedFragment(0 1000 false ""100M"" DEFAULT_BASE_QUALITY"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarTest.java,testTwoFragmentsLargeSoftClipWithMinimumDistanceFailure,"@Test(expectedExceptions=PicardException.class) public void  (){ final AbstractMarkDuplicatesCommandLineProgramTester tester=getTester(); tester.addArg(""MINIMUM_DISTANCE=989""); tester.getSamRecordSetBuilder().setReadLength(100); tester.addMappedFragment(0"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarTest.java,testTwoFragmentsLargeSoftClipWithMinimumDistanceOK,"@Test public void  (){ final AbstractMarkDuplicatesCommandLineProgramTester tester=getTester(); tester.addArg(""MINIMUM_DISTANCE=990""); tester.getSamRecordSetBuilder().setReadLength(100); tester.addMappedFragment(0 1000 false ""100M"" DEFAULT_BASE_QUALITY); "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarTest.java,testTwoMappedPairsWithSoftClippingFirstOfPairOnly,"@Test public void  (){ final AbstractMarkDuplicatesCommandLineProgramTester tester=getTester(); tester.getSamRecordSetBuilder().setReadLength(76); tester.addMappedPair(0 12 46 false false ""6S42M28S"" ""3S73M"" true 50); tester.addMappedPair(0 12 51 true true"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTest.java,ExpectedPnAndVn,private  (final String expectedPn final String expectedVn){ this.expectedPn=expectedPn; this.expectedVn=expectedVn; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTest.java,addMappedFragment,"public void  (final int referenceSequenceIndex final int alignmentStart final boolean isDuplicate final String cigar final int defaultQualityScore){ final AbstractMarkDuplicatesCommandLineProgramTester tester=getTester(); tester.addMatePair(""RUNID:1:1:15993:13361"" 2 41212324 41212310 false false false false ""33S35M"" ""19S49M"" true true false false false DEFAULT_BASE_QUALITY); tester.addMatePair(""RUNID:2:2:15993:13362"" 2 41212324 41212310 false false true true ""33S35M"" ""19S49M"" true true false false false DEFAULT_BASE_QUALITY); final String barcodeTag=""BC""; for ( final SAMRecord record : new IterableAdapter<SAMRecord>(tester.getRecordIterator())) { record.setAttribute(barcodeTag ""Barcode1""); } tester.addArg(""BARCODE_TAG="" + barcodeTag); tester.runTest(); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTest.java,getTester,protected AbstractMarkDuplicatesCommandLineProgramTester  (){ return new MarkDuplicatesTester(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTest.java,pgRecordChainingTest,"@Test(dataProvider="" "") public void pgRecordChainingTest(final boolean suppressPg final Map<String List<ExpectedPnAndVn>> expectedPnVnByReadName){ final File outputDir=IOUtil.createTempDir(TEST_BASE_NAME + ""."" "".tmp""); outputDir.deleteOnExit(); try { fina"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTest.java,pgRecordChainingTestDataProvider,"@DataProvider(name=""pgRecordChainingTest"") public Object[][]  (){ final Map<String List<ExpectedPnAndVn>> withPgMap=new HashMap<String List<ExpectedPnAndVn>>(); withPgMap.put(""1AAXX.1.1"" Arrays.asList(new ExpectedPnAndVn(TEST_BASE_NAME null) new ExpectedP"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTest.java,setUp,"@BeforeClass public void  (){ TEST_BASE_NAME=""MarkDuplicates""; TEST_DATA_DIR=new File(""testdata/picard/sam/MarkDuplicates""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTest.java,testOpticalDuplicateDetection,"@Test(dataProvider="" DataProvider"") public void testOpticalDuplicateDetection(final File sam final long expectedNumOpticalDuplicates){ final File outputDir=IOUtil.createTempDir(TEST_BASE_NAME + ""."" "".tmp""); outputDir.deleteOnExit(); final File outputSam=n"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTest.java,testOpticalDuplicateDetectionDataProvider,"@DataProvider(name="" "") public Object[][] testOpticalDuplicateDetectionDataProvider(){ return new Object[][]{{new File(TEST_DATA_DIR ""optical_dupes.sam"") 1L} {new File(TEST_DATA_DIR ""optical_dupes_casava.sam"") 1L}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTest.java,testTwoMappedPairsWithSoftClippingFirstOfPairOnly,"@Test public void  (){ final AbstractMarkDuplicatesCommandLineProgramTester tester=getTester(); tester.getSamRecordSetBuilder().setReadLength(76); tester.addMappedPair(0 12 46 false false ""6S42M28S"" ""3S73M"" true 50); tester.addMappedPair(0 12 51 false fal"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTest.java,testWithBarcodeComplex,"@Test public void  (){ final AbstractMarkDuplicatesCommandLineProgramTester tester=getTester(); tester.getSamRecordSetBuilder().setReadLength(68); final String readNameOne=""RUNID:1:1:15993:13361""; final String readNameTwo=""RUNID:2:2:15993:13362""; final St"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTest.java,testWithBarcodeDuplicate,"@Test public void  (){ final AbstractMarkDuplicatesCommandLineProgramTester tester=getTester(); tester.getSamRecordSetBuilder().setReadLength(68); tester.addMatePair(""RUNID:1:1:15993:13361"" 2 41212324 41212310 false false false false ""33S35M"" ""19S49M"" tru"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTest.java,testWithBarcodeFragmentDuplicate,"@Test public void  (){ final AbstractMarkDuplicatesCommandLineProgramTester tester=getTester(); tester.addMappedFragment(2 41212324 false ""50M"" DEFAULT_BASE_QUALITY); tester.addMappedFragment(2 41212324 true ""50M"" DEFAULT_BASE_QUALITY); final String barco"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTest.java,testWithIndividualReadBarcodes,"@Test public void  (){ final AbstractMarkDuplicatesCommandLineProgramTester tester=getTester(); tester.getSamRecordSetBuilder().setReadLength(68); final String readNameOne=""RUNID:1:1:15993:13361""; final String readNameTwo=""RUNID:2:2:15993:13362""; final St"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTester.java,MarkDuplicatesTester,public  (){ super(DuplicateScoringStrategy.ScoringStrategy.TOTAL_MAPPED_REFERENCE_LENGTH); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesTester.java,getProgram,@Override protected CommandLineProgram  (){ return new MarkDuplicates(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarTester.java,MarkDuplicatesWithMateCigarTester,"public  (){ super(ScoringStrategy.TOTAL_MAPPED_REFERENCE_LENGTH); addArg(""MAX_RECORDS_IN_RAM=1000""); addArg(""BLOCK_SIZE=250""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicatesWithMateCigarTester.java,getProgram,@Override protected CommandLineProgram  (){ return new MarkDuplicatesWithMateCigar(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicateWithMissingReadOneBarcodeTest.java,getArgumentName,"@Override protected String  (){ return ""READ_TWO_BARCODE_TAG""; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicateWithMissingReadOneBarcodeTest.java,getTagValue,"@Override protected String  (){ return ""RX""; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicateWithMissingReadTwoBarcodeTest.java,getArgumentName,"@Override protected String  (){ return ""READ_TWO_BARCODE_TAG""; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicateWithMissingReadTwoBarcodeTest.java,getTagValue,"@Override protected String  (){ return ""RX""; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicateWithMissingSampleBarcodeTest.java,getArgumentName,"@Override protected String  (){ return ""BARCODE_TAG""; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\MarkDuplicateWithMissingSampleBarcodeTest.java,getTagValue,"@Override protected String  (){ return ""BC""; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\QuerySortedMarkDuplicatesTester.java,QuerySortedMarkDuplicatesTester,public  (){ super(DuplicateScoringStrategy.ScoringStrategy.TOTAL_MAPPED_REFERENCE_LENGTH SAMFileHeader.SortOrder.queryname); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\QuerySortedMarkDuplicatesTester.java,getProgram,@Override protected CommandLineProgram  (){ return new MarkDuplicates(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\SimpleMarkDuplicatesWithMateCigarTest.java,getTester,protected AbstractMarkDuplicatesCommandLineProgramTester  (){ return new SimpleMarkDuplicatesWithMateCigarTester(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\SimpleMarkDuplicatesWithMateCigarTest.java,testTwoMappedPairsWithSoftClippingFirstOfPairOnlyNoMateCigar,@Test(expectedExceptions=SAMException.class) @Override public void  (){ super.testTwoMappedPairsWithSoftClippingFirstOfPairOnlyNoMateCigar(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\SimpleMarkDuplicatesWithMateCigarTester.java,SimpleMarkDuplicatesWithMateCigarTester,"public  (){ super(DuplicateScoringStrategy.ScoringStrategy.TOTAL_MAPPED_REFERENCE_LENGTH); addArg(""MAX_RECORDS_IN_RAM=1000""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\SimpleMarkDuplicatesWithMateCigarTester.java,getProgram,@Override protected CommandLineProgram  (){ return new SimpleMarkDuplicatesWithMateCigar(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\ElcIdenticalBasesDuplicatesFinderTest.java,changeReadContent,private void  (byte[] read){ for (int i=MIN_IDENTICAL_BASES; i <= MIN_IDENTICAL_BASES + read.length * MAX_DIFF_RATE; i++) { read[i]+=1; } } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\ElcIdenticalBasesDuplicatesFinderTest.java,fillHistogramDataProvider,"@DataProvider(name="" "") public Object[][] fillHistogramDataProvider(){ return new Object[][]{{duplicatesFinder new Histogram<>() new Histogram<>() generatePairedReadSequence(false) generatePairedReadSequences(0 false) 1 0 0} {duplicatesFinder new Histogra"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\ElcIdenticalBasesDuplicatesFinderTest.java,generatePairedReadSequence,protected PairedReadSequence  (boolean isOpticalDuplicates){ PairedReadSequence prs=new PairedReadSequence(); prs.read1=new byte[100]; prs.read2=new byte[100]; if (isOpticalDuplicates) { short readGroup=1; short tile=Short.MAX_VALUE; prs.setReadGroup(readGroup); prs.setTile(tile); prs.setX(127); prs.setY(255); } return prs; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\ElcIdenticalBasesDuplicatesFinderTest.java,generatePairedReadSequences,protected ArrayList<PairedReadSequence>  (int seqsSize boolean isOpticalDuplicates){ ArrayList<PairedReadSequence> seq=new ArrayList<>(seqsSize); for (int i=0; i < seqsSize; i++) { seq.add(generatePairedReadSequence(isOpticalDuplicates)); } return seq; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\ElcIdenticalBasesDuplicatesFinderTest.java,generateSeqsWithNoDup,protected ArrayList<PairedReadSequence>  (int seqsSize boolean isOpticalDuplicates){ ArrayList<PairedReadSequence> seq=generatePairedReadSequences(seqsSize isOpticalDuplicates); PairedReadSequence prs=seq.get(seq.size() - 1); changeReadContent(prs.read1); changeReadContent(prs.read2); return seq; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\ElcIdenticalBasesDuplicatesFinderTest.java,searchDuplicatesDataProvider,"@DataProvider(name="" "") public Object[][] searchDuplicatesDataProvider(){ return new Object[][]{{duplicatesFinder new Histogram<>() new Histogram<>() generatePairedReadSequences(1 false) 1 0 0} {duplicatesFinder new Histogram<>() new Histogram<>() generat"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\ElcIdenticalBasesDuplicatesFinderTest.java,testFillHistogram,"@Test(dataProvider=""fillHistogramDataProvider"") public void  (ElcDuplicatesFinder duplicatesFinder Histogram<Integer> duplicationHisto Histogram<Integer> opticalHisto PairedReadSequence prs ArrayList<PairedReadSequence> dupes int dupHistoIndex int optHist"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\ElcIdenticalBasesDuplicatesFinderTest.java,testSearchDuplicates,"@Test(dataProvider=""searchDuplicatesDataProvider"") public void  (ElcDuplicatesFinder duplicatesFinder Histogram<Integer> duplicationHisto Histogram<Integer> opticalHisto ArrayList<PairedReadSequence> dupes int dupHistoIndex int optHistoIndex int optHistoV"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\util\OpticalDuplicateFinderTest.java,assertEquals,"void  (final boolean[] actual final boolean[] expected){ if (!Arrays.equals(actual expected)) { throw new AssertionError(""expected: "" + Arrays.toString(expected) + "" but was: ""+ Arrays.toString(actual)); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\util\OpticalDuplicateFinderTest.java,countTrue,int  (final boolean[] bs){ int count=0; for ( final boolean b : bs) if (b) ++count; return count; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\util\OpticalDuplicateFinderTest.java,getReadGroup,@Override public short  (){ return 1; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\util\OpticalDuplicateFinderTest.java,loc,private PhysicalLocation  (final int tile final int x final int y){ final PhysicalLocation l=new PhysicalLocationInt(){ @Override public short getReadGroup(){ return 1; } } ; l.setTile((short)tile); l.setX(x); l.setY(y); return l; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\util\OpticalDuplicateFinderTest.java,testDefaultRegex,"@Test public void  (){ final String readName1=""000000000-ZZZZZ:1:1105:17981:23325""; final String readName2=""000000000-ZZZZZ:1:1109:22981:17995""; final int[] tokens=new int[3]; Assert.assertEquals(ReadNameParser.getLastThreeFields(readName1 ':' tokens) 5);"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\util\OpticalDuplicateFinderTest.java,testKeeper,@Test public void  (){ final Log log=Log.getInstance(OpticalDuplicateFinderTest.class); final OpticalDuplicateFinder finder=new OpticalDuplicateFinder(OpticalDuplicateFinder.DEFAULT_READ_NAME_REGEX 100 log); List<PhysicalLocation> locs=Arrays.asList(loc(7
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\util\OpticalDuplicateFinderTest.java,testKeeperAtEndWithinCliqueOfAllOpticalDuplicates,@Test public void  (){ final Log log=Log.getInstance(OpticalDuplicateFinderTest.class); final OpticalDuplicateFinder finder=new OpticalDuplicateFinder(OpticalDuplicateFinder.DEFAULT_READ_NAME_REGEX 15 log); List<PhysicalLocation> locs=Arrays.asList(loc(1 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\util\OpticalDuplicateFinderTest.java,testKeeperNotInList,@Test public void  (){ final Log log=Log.getInstance(OpticalDuplicateFinderTest.class); final OpticalDuplicateFinder finder=new OpticalDuplicateFinder(OpticalDuplicateFinder.DEFAULT_READ_NAME_REGEX 100 log); List<PhysicalLocation> locs=Arrays.asList(loc(1
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\util\OpticalDuplicateFinderTest.java,testMaxSetSize,@Test public void  (){ final Log log=Log.getInstance(OpticalDuplicateFinderTest.class); List<PhysicalLocation> locs=Arrays.asList(loc(7 1500 1500) loc(7 1501 1501) loc(7 1490 1502)); final OpticalDuplicateFinder normalFinder=new OpticalDuplicateFinder(Opt
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\util\OpticalDuplicateFinderTest.java,testVeryLongReadNames,"@Test public void  (){ final String readName1=""M01234:123:000000000-ZZZZZ:1:1105:17981:23325""; final String readName2=""M01234:123:000000000-ZZZZZ:1:1109:22981:17995""; final int[] tokens=new int[3]; Assert.assertEquals(ReadNameParser.getLastThreeFields(rea"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigarTester.java,UmiAwareMarkDuplicatesWithMateCigarTester," (final boolean allowMissingUmis){ addArg(""UMI_METRICS_FILE="" + umiMetricsFile); if (allowMissingUmis) { addArg(""ALLOW_MISSING_UMIS="" + true); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigarTester.java,addMatePairWithUmi,"public void  (final String readName final int referenceSequenceIndex1 final int referenceSequenceIndex2 final int alignmentStart1 final int alignmentStart2 final boolean record1Unmapped final boolean record2Unmapped final boolean isDuplicate1 final boolean isDuplicate2 final String cigar1 final String cigar2 final boolean strand1 final boolean strand2 final boolean firstOnly final boolean record1NonPrimary final boolean record2NonPrimary final int defaultQuality final String umi final String assignedUMI){ final List<SAMRecord> samRecordList=samRecordSetBuilder.addPair(readName referenceSequenceIndex1 referenceSequenceIndex2 alignmentStart1 alignmentStart2 record1Unmapped record2Unmapped cigar1 cigar2 strand1 strand2 record1NonPrimary record2NonPrimary defaultQuality); final SAMRecord record1=samRecordList.get(0); final SAMRecord record2=samRecordList.get(1); if (this.noMateCigars) { record1.setAttribute(""MC"" null); record2.setAttribute(""MC"" null); } if (firstOnly) { samRecordSetBuilder.getRecords().remove(record2); } final String key1=samRecordToDuplicatesFlagsKey(record1); Assert.assertFalse(this.duplicateFlags.containsKey(key1)); this.duplicateFlags.put(key1 isDuplicate1); final String key2=samRecordToDuplicatesFlagsKey(record2); Assert.assertFalse(this.duplicateFlags.containsKey(key2)); this.duplicateFlags.put(key2 isDuplicate2); if (umi != null) { record1.setAttribute(""RX"" umi); record2.setAttribute(""RX"" umi); } if (assignedUMI != null) { record1.setAttribute(expectedUmiTag assignedUMI); record2.setAttribute(expectedUmiTag assignedUMI); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigarTester.java,getProgram,@Override protected CommandLineProgram  (){ UmiAwareMarkDuplicatesWithMateCigar uamdwmc=new UmiAwareMarkDuplicatesWithMateCigar(); return uamdwmc; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigarTester.java,setExpectedAssignedUmis,UmiAwareMarkDuplicatesWithMateCigarTester  (final List<String> expectedAssignedUmis){ this.expectedAssignedUmis=expectedAssignedUmis; return this; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigarTester.java,setExpectedMetrics,UmiAwareMarkDuplicatesWithMateCigarTester  (final UmiMetrics expectedMetrics){ this.expectedMetrics=expectedMetrics; return this; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigarTester.java,test,"@Override public void  (){ final SamReader reader=SamReaderFactory.makeDefault().open(getOutput()); for ( final SAMRecord record : reader) { if (expectedAssignedUmis != null) { Assert.assertEquals(record.getAttribute(""MI"") record.getAttribute(expectedUmiT"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigarTest.java,getTester,protected UmiAwareMarkDuplicatesWithMateCigarTester  (final boolean allowMissingUmis){ return new UmiAwareMarkDuplicatesWithMateCigarTester(allowMissingUmis); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigarTest.java,testBadUmiSetsDataProvider,"@DataProvider(name="" "") private Object[][] testBadUmiSetsDataProvider(){ return new Object[][]{{Arrays.asList(new String[]{""AAAA"" ""A""}) Arrays.asList(new String[]{""AAAA"" ""A""}) Arrays.asList(new Boolean[]{false false}) 4} {Arrays.asList(new String[]{""T"" ""G"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigarTest.java,testBadUmis,"@Test(dataProvider=""testBadUmiSetsDataProvider"" expectedExceptions={IllegalArgumentException.class PicardException.class}) public void  (List<String> umis List<String> assignedUmi final List<Boolean> isDuplicate final int editDistanceToJoin){ UmiAwareMark"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigarTest.java,testEmptyUmiDataProvider,"@DataProvider(name="" "") private Object[][] testEmptyUmiDataProvider(){ return new Object[][]{{Arrays.asList(new String[]{null null null}) Arrays.asList(new String[]{null null null}) Arrays.asList(new Boolean[]{false true true}) 4}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigarTest.java,testEmptyUmis,"@Test(dataProvider=""testEmptyUmiDataProvider"") public void  (List<String> umis List<String> assignedUmi final List<Boolean> isDuplicate final int editDistanceToJoin){ UmiAwareMarkDuplicatesWithMateCigarTester tester=getTester(true); tester.addArg(""MAX_EDI"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigarTest.java,testUmi,"@Test(dataProvider="" SetsDataProvider"") public void testUmi(List<String> umis List<String> assignedUmi final List<Boolean> isDuplicate final int editDistanceToJoin){ UmiAwareMarkDuplicatesWithMateCigarTester tester=getTester(false); tester.addArg(""MAX_EDI"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigarTest.java,testUmiMetrics,"@Test(dataProvider="" DataProvider"") public void testUmiMetrics(List<String> umis List<String> assignedUmi final List<Boolean> isDuplicate final int editDistanceToJoin final UmiMetrics expectedMetrics){ UmiAwareMarkDuplicatesWithMateCigarTester tester=getT"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigarTest.java,testUmiMetricsDataProvider,"@DataProvider(name="" "") private Object[][] testUmiMetricsDataProvider(){ double effectiveLength4_1=-(4. / 5.) * Math.log(4. / 5.) / Math.log(4.) - (1. / 5.) * Math.log(1. / 5.) / Math.log(4.); double effectiveLength3_1_1=-(3. / 5.) * Math.log(3. / 5.) / M"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigarTest.java,testUmiSetsDataProvider,"@DataProvider(name="" "") private Object[][] testUmiSetsDataProvider(){ return new Object[][]{{Arrays.asList(new String[]{""AAAA"" ""AAAA"" ""ATTA"" ""AAAA"" ""AAAT""}) Arrays.asList(new String[]{""AAAA"" ""AAAA"" ""ATTA"" ""AAAA"" ""AAAA""}) Arrays.asList(new Boolean[]{false "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigarTest.java,testUmiUtil,"@Test(dataProvider="" DataProvider"") public void testUmiUtil(List<String> observed List<String> expected){ for (int i=0; i < observed.size(); i++) { SAMRecord rec=new SAMRecord(new SAMFileHeader()); rec.setAttribute(""RX"" observed.get(i)); Assert.assertEqua"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\markduplicates\UmiAwareMarkDuplicatesWithMateCigarTest.java,testUmiUtilDataProvider,"@DataProvider(name="" "") private Object[][] testUmiUtilDataProvider(){ return new Object[][]{{Arrays.asList(new String[]{""AAAA"" ""AA-AA"" ""-A-T-A"" ""AAAAA--"" ""---A"" ""---"" """"}) Arrays.asList(new String[]{""AAAA"" ""AAAA"" ""ATA"" ""AAAAA"" ""A"" """" """"})}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\PipedDataTest.java,testSortSam,"@Test public void  (){ String[] command={""/bin/bash"" ""-c"" ""java -classpath "" + classPath + ""picard.cmdline.PicardCommandLine ""+ ""ViewSam ""+ ""I=testdata/picard/sam/test.bam ""+ ""ALIGNMENT_STATUS=All ""+ ""PF_STATUS=All ""+ ""| ""+ ""java -classpath ""+ classPath+ "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeSamFilesTest.java,getCommandLineProgramName,public String  (){ return MergeSamFiles.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeSamFilesTest.java,unsortedInputSortedOutputTest,"@Test public void  () throws Exception { final File unsortedInputTestDataDir=new File(TEST_DATA_DIR ""unsorted_input""); final File mergedOutput=File.createTempFile(""unsortedInputSortedOutputTest."" BamFileIoUtils.BAM_FILE_EXTENSION); mergedOutput.deleteOnEx"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\PositionBasedDownsampleSamTest.java,InvalidArgumentsTestProvider,"@DataProvider(name="" "") public Object[][] InvalidArgumentsTestProvider(){ return new Object[][]{{-1.0} {-.00001} {-5.0} {1.00001} {5.0} {50.0} {Double.MAX_VALUE} {Double.POSITIVE_INFINITY} {Double.NEGATIVE_INFINITY}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\PositionBasedDownsampleSamTest.java,TestBuilder,@Test public void  (){ final ValidateSamFile validateSamFile=new ValidateSamFile(); validateSamFile.INPUT=tempSamFile; Assert.assertEquals(validateSamFile.doWork() 0); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\PositionBasedDownsampleSamTest.java,TestInvalidArguments,"@Test(dataProvider=""InvalidArgumentsTestProvider"") public void  (final double fraction) throws IOException { final File samFile=tempSamFile; final File downsampled=File.createTempFile(""PositionalDownsampleSam"" "".bam"" tempDir); downsampled.deleteOnExit(); "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\PositionBasedDownsampleSamTest.java,TestInvalidTwice,"@Test(dataProvider=""allowTwiceData"") public void  (final boolean allowMultiple) throws IOException { final File samFile=tempSamFile; final File downsampled=File.createTempFile(""PositionalDownsampleSam"" "".bam"" tempDir); downsampled.deleteOnExit(); final do"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\PositionBasedDownsampleSamTest.java,ValidArgumentsTestProvider,"@DataProvider(name="" "") public Object[][] ValidArgumentsTestProvider(){ final List<Object[]> objects=new ArrayList<Object[]>(); for (double i=0.3; i <= 1; i+=.1) { final Object[] array={i}; objects.add(array); } return objects.toArray(new Object[1][]); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\PositionBasedDownsampleSamTest.java,allowTwiceData,"@DataProvider(name="" "") public Object[][] allowTwiceData(){ return new Object[][]{{true} {false}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\PositionBasedDownsampleSamTest.java,getCommandLineProgramName,@Override public String  (){ return PositionBasedDownsampleSam.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\PositionBasedDownsampleSamTest.java,setupBuilder,"@BeforeTest void  () throws IOException { final int numReads=10000; final String flowCellBarcode=""TESTBARCODE""; final int maxX=10000; final int maxY=20000; final int minX=1000; final int minY=2000; final String separator="":""; final int lane=1; final int t"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\PositionBasedDownsampleSamTest.java,tearDown,@AfterTest private void  (){ IOUtil.deleteDirectoryTree(tempDir); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\PositionBasedDownsampleSamTest.java,testDownsampleSingleTile,"@Test(dataProvider=""ValidArgumentsTestProvider"") public void  (final double fraction) throws IOException { testDownsampleWorker(tempSamFile fraction); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\PositionBasedDownsampleSamTest.java,testDownsampleWorker,"public void  (final File samFile final double fraction) throws IOException { final File downsampled=File.createTempFile(""PositionalDownsampleSam"" "".bam"" tempDir); final String[] args=new String[]{""INPUT="" + samFile.getAbsolutePath() ""OUTPUT="" + downsampled.getAbsolutePath() ""FRACTION="" + fraction ""CREATE_INDEX=true""}; Assert.assertEquals(runPicardCommandLine(args) 0); final ValidateSamFile validateSamFile=new ValidateSamFile(); validateSamFile.INPUT=downsampled; Assert.assertEquals(validateSamFile.doWork() 0); TestNGUtil.assertGreaterThan(SamTestUtil.countSamTotalRecord(downsampled) fraction * .8 * SamTestUtil.countSamTotalRecord(samFile)); TestNGUtil.assertLessThan(SamTestUtil.countSamTotalRecord(downsampled) fraction * 1.2 * SamTestUtil.countSamTotalRecord(samFile)); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,AlignmentAccumulator,private  (final boolean seenUnaligned final int numAlignments final String primaryAlignmentSequence){ this.seenUnaligned=seenUnaligned; this.numAlignments=numAlignments; this.primaryAlignmentSequence=primaryAlignmentSequence; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,HitSpec, (final boolean primary final boolean filtered final int mapq){ this.primary=primary; this.filtered=filtered; this.mapq=mapq; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,MostDistantStrategyAlignmentSpec,private  (final boolean expectedPrimary final String sequence final int alignmentStart){ this(expectedPrimary sequence alignmentStart 10); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,MultipleAlignmentSpec, (final String cigar final boolean reverseStrand final int mapQ final boolean oneOfTheBest){ this.cigar=cigar; this.reverseStrand=reverseStrand; this.mapQ=mapQ; this.oneOfTheBest=oneOfTheBest; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,UnmappedReadStrategiesProvider,"@DataProvider(name=""UnmappedReadStrategies"") public Object[][]  (){ return new Object[][]{{AbstractAlignmentMerger.UnmappingReadStrategy.DO_NOT_CHANGE ""contam.expected.NO_CHANGE.sam""} {null ""contam.expected.NO_CHANGE.sam""} {AbstractAlignmentMerger.Unmappi"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,addAlignmentForMostStrategy,"private void  (final SAMFileWriter writer final SAMRecord unmappedRecord final MostDistantStrategyAlignmentSpec spec final boolean reverse){ final SAMRecord alignedRecord=new SAMRecord(writer.getFileHeader()); alignedRecord.setReadName(unmappedRecord.getReadName()); alignedRecord.setReadBases(unmappedRecord.getReadBases()); alignedRecord.setBaseQualities(unmappedRecord.getBaseQualities()); alignedRecord.setReferenceName(spec.sequence); alignedRecord.setAlignmentStart(spec.alignmentStart); alignedRecord.setReadNegativeStrandFlag(reverse); alignedRecord.setCigarString(unmappedRecord.getReadBases().length + ""M""); alignedRecord.setMappingQuality(spec.mapQ); alignedRecord.setReadPairedFlag(unmappedRecord.getReadPairedFlag()); alignedRecord.setFirstOfPairFlag(unmappedRecord.getFirstOfPairFlag()); alignedRecord.setSecondOfPairFlag(unmappedRecord.getSecondOfPairFlag()); alignedRecord.setMateUnmappedFlag(true); writer.addAlignment(alignedRecord); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,addAlignmentsForBestFragmentMapqStrategy,"private void  (final SAMFileWriter writer final SAMRecord unmappedRecord final String sequence final int[] mapqs){ boolean reverse=false; int alignmentStart=1; for ( final int mapq : mapqs) { final SAMRecord alignedRecord=new SAMRecord(writer.getFileHeader()); alignedRecord.setReadName(unmappedRecord.getReadName()); alignedRecord.setReadBases(unmappedRecord.getReadBases()); alignedRecord.setBaseQualities(unmappedRecord.getBaseQualities()); alignedRecord.setReferenceName(sequence); alignedRecord.setAlignmentStart(alignmentStart); alignmentStart+=10; alignedRecord.setReadNegativeStrandFlag(reverse); reverse=!reverse; alignedRecord.setCigarString(unmappedRecord.getReadBases().length + ""M""); alignedRecord.setMappingQuality(mapq); alignedRecord.setReadPairedFlag(unmappedRecord.getReadPairedFlag()); alignedRecord.setFirstOfPairFlag(unmappedRecord.getFirstOfPairFlag()); alignedRecord.setSecondOfPairFlag(unmappedRecord.getSecondOfPairFlag()); alignedRecord.setMateUnmappedFlag(true); writer.addAlignment(alignedRecord); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,assertSamValid,private void  (final File sam){ new ValidateSamTester().assertSamValid(sam); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,brokenAlignedFiles,"@DataProvider(name="" "") Object[][] brokenAlignedFiles(){ return new Object[][]{new Object[]{""specialHeader.aligned.breaks.length.sam""} new Object[]{""specialHeader.aligned.breaks.md5.sam""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,createSamFilesToBeMerged,"private File[]  (final MultipleAlignmentSpec[] specs){ try { final File unmappedSam=File.createTempFile(""unmapped."" "".sam""); unmappedSam.deleteOnExit(); final SAMFileWriterFactory factory=new SAMFileWriterFactory(); final SAMFileHeader header=new SAMFileHeader(); header.setSortOrder(SAMFileHeader.SortOrder.queryname); final SAMRecord unmappedRecord=new SAMRecord(header); unmappedRecord.setReadName(""theRead""); unmappedRecord.setReadString(""ACGTACGTACGTACGT""); unmappedRecord.setBaseQualityString(""5555555555555555""); unmappedRecord.setReadUnmappedFlag(true); final SAMFileWriter unmappedWriter=factory.makeSAMWriter(header false unmappedSam); unmappedWriter.addAlignment(unmappedRecord); unmappedWriter.close(); final File alignedSam=File.createTempFile(""aligned."" "".sam""); alignedSam.deleteOnExit(); final String sequence=""chr1""; header.setSequenceDictionary(SAMSequenceDictionaryExtractor.extractDictionary(sequenceDict2.toPath())); final SAMFileWriter alignedWriter=factory.makeSAMWriter(header false alignedSam); for ( final MultipleAlignmentSpec spec : specs) { final SAMRecord alignedRecord=new SAMRecord(header); alignedRecord.setReadName(unmappedRecord.getReadName()); alignedRecord.setReadBases(unmappedRecord.getReadBases()); alignedRecord.setBaseQualities(unmappedRecord.getBaseQualities()); alignedRecord.setReferenceName(sequence); alignedRecord.setAlignmentStart(1); alignedRecord.setReadNegativeStrandFlag(spec.reverseStrand); alignedRecord.setCigarString(spec.cigar); alignedRecord.setMappingQuality(spec.mapQ); if (spec.oneOfTheBest) { alignedRecord.setAttribute(ONE_OF_THE_BEST_TAG 1); } alignedWriter.addAlignment(alignedRecord); } alignedWriter.close(); return new File[]{unmappedSam alignedSam}; } catch ( IOException e) { throw new PicardException(e.getMessage() e); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,doMergeAlignment,"private void  (final File unmappedBam final List<File> alignedBams final List<File> read1AlignedBams final List<File> read2AlignedBams final Integer read1Trim final Integer read2Trim final boolean alignReadsOnly final boolean clipAdapters final boolean isBisulfiteSequence final int maxInsOrDels final String progRecordId final String progGroupVersion final String progGroupCommandLine final String progGroupName final boolean pairedRun final File refSeq final File output final SamPairUtil.PairOrientation expectedOrientation final MergeBamAlignment.PrimaryAlignmentStrategy primaryAlignmentStrategy final String attributesToRetain final Boolean includeSecondary final Boolean unmapContaminantReads final SAMFileHeader.SortOrder sortOrder final AbstractAlignmentMerger.UnmappingReadStrategy unmappingReadStrategy){ final List<String> tagsToRc=new ArrayList<>(SAMRecord.TAGS_TO_REVERSE_COMPLEMENT); final List<String> tagsToRev=new ArrayList<>(SAMRecord.TAGS_TO_REVERSE); tagsToRc.add(""ab""); tagsToRev.addAll(Arrays.asList(""aa"" ""ac"" ""as"" ""ai"" ""af"")); final List<String> args=new ArrayList<>(Arrays.asList(""UNMAPPED_BAM="" + unmappedBam.getAbsolutePath() ""ALIGNED_READS_ONLY="" + alignReadsOnly ""CLIP_ADAPTERS="" + clipAdapters ""IS_BISULFITE_SEQUENCE="" + isBisulfiteSequence ""MAX_INSERTIONS_OR_DELETIONS="" + maxInsOrDels ""ADD_PG_TAG_TO_READS=true"")); if (alignedBams != null) { for ( final File alignedBam : alignedBams) { args.add(""ALIGNED_BAM="" + alignedBam.getAbsolutePath()); } } if (read1AlignedBams != null) { for ( final File alignedBam : read1AlignedBams) { args.add(""READ1_ALIGNED_BAM="" + alignedBam.getAbsolutePath()); } } if (read2AlignedBams != null) { for ( final File alignedBam : read2AlignedBams) { args.add(""READ2_ALIGNED_BAM="" + alignedBam.getAbsolutePath()); } } if (read1Trim != null) { args.add(""READ1_TRIM="" + read1Trim); } if (read2Trim != null) { args.add(""READ2_TRIM="" + read2Trim); } if (progRecordId != null) { args.add(""PROGRAM_RECORD_ID="" + progRecordId); } if (progGroupVersion != null) { args.add(""PROGRAM_GROUP_VERSION="" + progGroupVersion); } if (progGroupCommandLine != null) { args.add(""PROGRAM_GROUP_COMMAND_LINE="" + progGroupCommandLine); } if (progGroupName != null) { args.add(""PROGRAM_GROUP_NAME="" + progGroupName); } args.add(""PAIRED_RUN="" + pairedRun); args.add(""REFERENCE_SEQUENCE="" + refSeq.getAbsolutePath()); args.add(""OUTPUT="" + output.getAbsolutePath()); if (expectedOrientation != null) { args.add(""EXPECTED_ORIENTATIONS="" + expectedOrientation); } if (primaryAlignmentStrategy != null) { args.add(""PRIMARY_ALIGNMENT_STRATEGY="" + primaryAlignmentStrategy); } if (attributesToRetain != null) { args.add(""ATTRIBUTES_TO_RETAIN="" + attributesToRetain); } for ( final String t : tagsToRc) { args.add(""ATTRIBUTES_TO_REVERSE_COMPLEMENT="" + t); } for ( final String t : tagsToRev) { args.add(""ATTRIBUTES_TO_REVERSE="" + t); } if (includeSecondary != null) { args.add(""INCLUDE_SECONDARY_ALIGNMENTS="" + includeSecondary); } if (unmapContaminantReads != null) { args.add(""UNMAP_CONTAMINANT_READS="" + unmapContaminantReads); } if (unmappingReadStrategy != null) { args.add(""UNMAPPED_READ_STRATEGY="" + unmappingReadStrategy); } if (sortOrder != null) { args.add(""SORT_ORDER="" + sortOrder.name()); } Assert.assertEquals(runPicardCommandLine(args) 0 ""Merge did not succeed""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,equals,public boolean  (final Object o){ if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; final AlignmentAccumulator that=(AlignmentAccumulator)o; if (numAlignments != that.numAlignments) return false; if (seenUnaligned != that.seenUnaligned) return false; if (primaryAlignmentSequence != null ? !primaryAlignmentSequence.equals(that.primaryAlignmentSequence) : that.primaryAlignmentSequence != null) return false; return true; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,getCommandLineProgramName,public String  (){ return MergeBamAlignment.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,getDataForMergingTest,"@DataProvider(name=""separateTrimmed"") public Object[][]  (){ return new Object[][]{{mergingUnmappedBam Arrays.asList(firstReadAlignedBam) Arrays.asList(secondReadAlignedBam) 17 20 ""one file per read""} {mergingUnmappedBam Arrays.asList(firstReadAlignedBam_"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,getDataForSortingTest,"@DataProvider(name=""data"") public Object[][]  (){ return new Object[][]{{unmappedBam alignedQuerynameSortedBam true true ""Basic test with pre-sorted alignment""} {unmappedBam alignedBam false true ""Basic test with unsorted alignment""} {unmappedBam alignedQ"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,hashCode,@Override public int  (){ int result=(seenUnaligned ? 1 : 0); result=31 * result + numAlignments; result=31 * result + (primaryAlignmentSequence != null ? primaryAlignmentSequence.hashCode() : 0); return result; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,makeRead,private SAMRecord  (final SAMFileHeader alignedHeader final SAMRecord unmappedRec final HitSpec hitSpec final int hitIndex){ final SAMRecord rec=new SAMRecord(alignedHeader); rec.setReadName(unmappedRec.getReadName()); rec.setReadBases(unmappedRec.getReadBases()); rec.setBaseQualities(unmappedRec.getBaseQualities()); rec.setMappingQuality(hitSpec.mapq); if (!hitSpec.primary) rec.setNotPrimaryAlignmentFlag(true); final Cigar cigar=new Cigar(); final int readLength=rec.getReadLength(); if (hitSpec.filtered) { cigar.add(new CigarElement(readLength - 4 CigarOperator.M)); cigar.add(new CigarElement(1 CigarOperator.I)); cigar.add(new CigarElement(1 CigarOperator.M)); cigar.add(new CigarElement(1 CigarOperator.I)); cigar.add(new CigarElement(1 CigarOperator.M)); } else { cigar.add(new CigarElement(readLength CigarOperator.M)); } rec.setCigar(cigar); rec.setReferenceName(bigSequenceName); rec.setAttribute(SAMTag.HI.name() hitIndex); rec.setAlignmentStart(hitIndex + 1); return rec; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testBestFragmentMapqStrategy,"private void  (final String testName final int[] firstMapQs final int[] secondMapQs final boolean includeSecondary final int expectedFirstMapq final int expectedSecondMapq) throws Exception { final File unmappedSam=File.createTempFile(""unmapped."" "".sam""); unmappedSam.deleteOnExit(); final SAMFileWriterFactory factory=new SAMFileWriterFactory(); final SAMFileHeader header=new SAMFileHeader(); header.setSortOrder(SAMFileHeader.SortOrder.queryname); final String readName=""theRead""; final SAMRecord firstUnmappedRead=new SAMRecord(header); firstUnmappedRead.setReadName(readName); firstUnmappedRead.setReadString(""ACGTACGTACGTACGT""); firstUnmappedRead.setBaseQualityString(""5555555555555555""); firstUnmappedRead.setReadUnmappedFlag(true); firstUnmappedRead.setMateUnmappedFlag(true); firstUnmappedRead.setReadPairedFlag(true); firstUnmappedRead.setFirstOfPairFlag(true); final SAMRecord secondUnmappedRead=new SAMRecord(header); secondUnmappedRead.setReadName(readName); secondUnmappedRead.setReadString(""TCGAACGTTCGAACTG""); secondUnmappedRead.setBaseQualityString(""6666666666666666""); secondUnmappedRead.setReadUnmappedFlag(true); secondUnmappedRead.setMateUnmappedFlag(true); secondUnmappedRead.setReadPairedFlag(true); secondUnmappedRead.setSecondOfPairFlag(true); final SAMFileWriter unmappedWriter=factory.makeSAMWriter(header false unmappedSam); unmappedWriter.addAlignment(firstUnmappedRead); unmappedWriter.addAlignment(secondUnmappedRead); unmappedWriter.close(); final File alignedSam=File.createTempFile(""aligned."" "".sam""); alignedSam.deleteOnExit(); final String sequence=""chr1""; header.setSequenceDictionary(SAMSequenceDictionaryExtractor.extractDictionary(sequenceDict2.toPath())); final SAMFileWriter alignedWriter=factory.makeSAMWriter(header false alignedSam); addAlignmentsForBestFragmentMapqStrategy(alignedWriter firstUnmappedRead sequence firstMapQs); addAlignmentsForBestFragmentMapqStrategy(alignedWriter secondUnmappedRead sequence secondMapQs); alignedWriter.close(); final File output=File.createTempFile(""testBestFragmentMapqStrategy."" + testName "".sam""); output.deleteOnExit(); doMergeAlignment(unmappedSam Collections.singletonList(alignedSam) null null null null false true false 1 ""0"" ""1.0"" ""align!"" ""myAligner"" true fasta output SamPairUtil.PairOrientation.FR MergeBamAlignment.PrimaryAlignmentStrategy.BestEndMapq null includeSecondary null null); final SamReader reader=SamReaderFactory.makeDefault().open(output); int numFirstRecords=0; int numSecondRecords=0; int firstPrimaryMapq=-1; int secondPrimaryMapq=-1; for ( final SAMRecord rec : reader) { Assert.assertTrue(rec.getReadPairedFlag()); if (rec.getFirstOfPairFlag()) ++numFirstRecords; else if (rec.getSecondOfPairFlag()) ++numSecondRecords; else Assert.fail(""unpossible!""); if (!rec.getReadUnmappedFlag() && !rec.getNotPrimaryAlignmentFlag()) { if (rec.getFirstOfPairFlag()) { Assert.assertEquals(firstPrimaryMapq -1); firstPrimaryMapq=rec.getMappingQuality(); } else { Assert.assertEquals(secondPrimaryMapq -1); secondPrimaryMapq=rec.getMappingQuality(); } } else if (rec.getNotPrimaryAlignmentFlag()) { Assert.assertTrue(rec.getMateUnmappedFlag()); } } reader.close(); Assert.assertEquals(firstPrimaryMapq expectedFirstMapq); Assert.assertEquals(secondPrimaryMapq expectedSecondMapq); if (!includeSecondary) { Assert.assertEquals(numFirstRecords 1); Assert.assertEquals(numSecondRecords 1); } else { Assert.assertEquals(numFirstRecords Math.max(1 firstMapQs.length)); Assert.assertEquals(numSecondRecords Math.max(1 secondMapQs.length)); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testBestFragmentMapqStrategyDataProvider,"@DataProvider(name=""testBestFragmentMapqStrategy"") public Object[][]  (){ return new Object[][]{{""singleAlignmentFirstEnd"" new int[]{12} new int[0] 12 -1} {""singleAlignmentSecondEnd"" new int[0] new int[]{12} -1 12} {""singleAlignmentBothEnd"" new int[]{13} "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testContaminationDetection,"@Test(dataProvider=""UnmappedReadStrategies"") public void  (final AbstractAlignmentMerger.UnmappingReadStrategy strategy final String basename) throws IOException { final File unmappedSam=new File(TEST_DATA_DIR ""contam.unmapped.sam""); final File alignedSam"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testEarliestFragmentStrategy,"@Test(dataProvider="" DataProvider"") public void testEarliestFragmentStrategy(final String testName final MultipleAlignmentSpec[] specs) throws IOException { final File output=File.createTempFile(testName "".sam""); output.deleteOnExit(); final File[] sams=c"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testEarliestFragmentStrategyDataProvider,"@DataProvider(name="" "") public Object[][] testEarliestFragmentStrategyDataProvider(){ return new Object[][]{{""simpleForward"" new MultipleAlignmentSpec[]{new MultipleAlignmentSpec(""16M"" false 200 true)}} {""simpleReverse"" new MultipleAlignmentSpec[]{new Mul"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testEarliestFragmentStrategyPaired,"@Test(expectedExceptions=UnsupportedOperationException.class) public void  () throws Exception { final File output=File.createTempFile(""mergeTest"" "".sam""); output.deleteOnExit(); final File unmappedSam=File.createTempFile(""unmapped."" "".sam""); unmappedSam."
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testFragmentMultiHitWithFiltering,"@Test(dataProvider="" TestCases"") public void testFragmentMultiHitWithFiltering(final String description final List<HitSpec> hitSpecs final Integer expectedPrimaryHitIndex final int expectedNumReads final int expectedPrimaryMapq) throws Exception { final F"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testFragmentMultiHitWithFilteringTestCases,"@DataProvider(name="" "") public Object[][] testFragmentMultiHitWithFilteringTestCases(){ final ArrayList<Object[]> ret=new ArrayList<Object[]>(); List<HitSpec> hitSpecs; hitSpecs=new ArrayList<HitSpec>(); hitSpecs.add(new HitSpec(false true 10)); hitSpecs."
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testHeaderFromMappedBreaks,"@Test(dataProvider=""brokenAlignedFiles"" expectedExceptions=IllegalArgumentException.class) public void  (final String filename) throws IOException { final File unmappedSam=new File(TEST_DATA_DIR ""specialHeader.unmapped.sam""); final File alignedSam=new Fil"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testMappedToMultipleStrands,"@Test public void  () throws Exception { final File outputMappedToMultipleStands=File.createTempFile(""mappedToMultipleStrands"" "".sam""); outputMappedToMultipleStands.deleteOnExit(); doMergeAlignment(mergingUnmappedBam Collections.singletonList(multipleStra"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testMergeHeaderMappedAndReference,"@Test public void  () throws IOException { final File unmappedSam=new File(TEST_DATA_DIR ""specialHeader.unmapped.sam""); final File alignedSam=new File(TEST_DATA_DIR ""specialHeader.aligned.sam""); final File expectedSam=new File(TEST_DATA_DIR ""specialHeader"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testMergeHeaderMappedAndReferenceWithAlignedAsNamedStream,"@Test public void  () throws IOException  InterruptedException  NoSuchFieldException  IllegalAccessException { final File unmappedSam=new File(TEST_DATA_DIR ""specialHeader.unmapped.sam""); final File alignedSam=new File(TEST_DATA_DIR ""specialHeader.aligned"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testMergeHeaderMappedAndReferenceWithUnmappedAsNamedStream,"@Test public void  () throws IOException  InterruptedException  NoSuchFieldException  IllegalAccessException { final File unmappedSam=new File(TEST_DATA_DIR ""specialHeader.unmapped.sam""); final File alignedSam=new File(TEST_DATA_DIR ""specialHeader.aligned"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testMerger,"@Test public void  () throws Exception { final File output=File.createTempFile(""mergeTest"" "".sam""); output.deleteOnExit(); doMergeAlignment(unmappedBam Collections.singletonList(alignedBam) null null null null false true false 1 ""0"" ""1.0"" ""align!"" ""myAlig"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testMergerFromMultipleFiles,"@Test public void  () throws Exception { final File output=File.createTempFile(""mergeTest"" "".sam""); output.deleteOnExit(); doMergeAlignment(unmappedBam Arrays.asList(oneHalfAlignedBam otherHalfAlignedBam) null null null null false true false 1 ""0"" ""1.0"" """
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testMergerWithSupplemental,"@Test public void  () throws Exception { final File outputWithSupplemental=File.createTempFile(""mergeWithSupplementalTest"" "".sam""); outputWithSupplemental.deleteOnExit(); doMergeAlignment(unmappedBam Collections.singletonList(supplementalReadAlignedBam) n"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testMergingFromSeparatedReadTrimmedAlignments,"@Test(dataProvider=""separateTrimmed"") public void  (final File unmapped final List<File> r1Align final List<File> r2Align final int r1Trim final int r2Trim final String testName) throws Exception { final File output=File.createTempFile(""mergeMultipleAlign"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testMostDistantStrategy,"public void  (final String testName final boolean includeSecondary final MostDistantStrategyAlignmentSpec[] firstEndSpecs final MostDistantStrategyAlignmentSpec[] secondEndSpecs) throws Exception { final File unmappedSam=File.createTempFile(""unmapped."" "".sam""); unmappedSam.deleteOnExit(); final SAMFileWriterFactory factory=new SAMFileWriterFactory(); final SAMFileHeader header=new SAMFileHeader(); header.setSortOrder(SAMFileHeader.SortOrder.queryname); final String readName=""theRead""; final SAMRecord firstUnmappedRead=new SAMRecord(header); firstUnmappedRead.setReadName(readName); firstUnmappedRead.setReadString(""ACGT""); firstUnmappedRead.setBaseQualityString(""5555""); firstUnmappedRead.setReadUnmappedFlag(true); firstUnmappedRead.setMateUnmappedFlag(true); firstUnmappedRead.setReadPairedFlag(true); firstUnmappedRead.setFirstOfPairFlag(true); final SAMRecord secondUnmappedRead=new SAMRecord(header); secondUnmappedRead.setReadName(readName); secondUnmappedRead.setReadString(""TCGA""); secondUnmappedRead.setBaseQualityString(""6666""); secondUnmappedRead.setReadUnmappedFlag(true); secondUnmappedRead.setMateUnmappedFlag(true); secondUnmappedRead.setReadPairedFlag(true); secondUnmappedRead.setSecondOfPairFlag(true); final SAMFileWriter unmappedWriter=factory.makeSAMWriter(header false unmappedSam); unmappedWriter.addAlignment(firstUnmappedRead); unmappedWriter.addAlignment(secondUnmappedRead); unmappedWriter.close(); final File alignedSam=File.createTempFile(""aligned."" "".sam""); alignedSam.deleteOnExit(); header.setSequenceDictionary(SamReaderFactory.makeDefault().getFileHeader(sequenceDict).getSequenceDictionary()); final SAMFileWriter alignedWriter=factory.makeSAMWriter(header false alignedSam); String expectedFirstPrimarySequence=null; int expectedFirstPrimaryAlignmentStart=-1; String expectedSecondPrimarySequence=null; int expectedSecondPrimaryAlignmentStart=-1; boolean reverse=false; for ( final MostDistantStrategyAlignmentSpec spec : firstEndSpecs) { addAlignmentForMostStrategy(alignedWriter firstUnmappedRead spec reverse); reverse=!reverse; if (spec.expectedPrimary) { expectedFirstPrimarySequence=spec.sequence; expectedFirstPrimaryAlignmentStart=spec.alignmentStart; } } for ( final MostDistantStrategyAlignmentSpec spec : secondEndSpecs) { addAlignmentForMostStrategy(alignedWriter secondUnmappedRead spec reverse); reverse=!reverse; if (spec.expectedPrimary) { expectedSecondPrimarySequence=spec.sequence; expectedSecondPrimaryAlignmentStart=spec.alignmentStart; } } alignedWriter.close(); final File output=File.createTempFile(""testMostDistantStrategy."" + testName "".sam""); output.deleteOnExit(); doMergeAlignment(unmappedSam Collections.singletonList(alignedSam) null null null null false true false 1 ""0"" ""1.0"" ""align!"" ""myAligner"" true fasta output SamPairUtil.PairOrientation.FR MergeBamAlignment.PrimaryAlignmentStrategy.MostDistant null includeSecondary null null); final SamReader reader=SamReaderFactory.makeDefault().open(output); int numFirstRecords=0; int numSecondRecords=0; String firstPrimarySequence=null; int firstPrimaryAlignmentStart=-1; String secondPrimarySequence=null; int secondPrimaryAlignmentStart=-1; for ( final SAMRecord rec : reader) { Assert.assertTrue(rec.getReadPairedFlag()); if (rec.getFirstOfPairFlag()) ++numFirstRecords; else if (rec.getSecondOfPairFlag()) ++numSecondRecords; else Assert.fail(""unpossible!""); if (!rec.getReadUnmappedFlag() && !rec.getNotPrimaryAlignmentFlag()) { if (rec.getFirstOfPairFlag()) { Assert.assertEquals(firstPrimaryAlignmentStart -1); firstPrimarySequence=rec.getReferenceName(); firstPrimaryAlignmentStart=rec.getAlignmentStart(); } else { Assert.assertEquals(secondPrimaryAlignmentStart -1); secondPrimarySequence=rec.getReferenceName(); secondPrimaryAlignmentStart=rec.getAlignmentStart(); } } else if (rec.getNotPrimaryAlignmentFlag()) { Assert.assertTrue(rec.getMateUnmappedFlag()); } } CloserUtil.close(reader); Assert.assertEquals(firstPrimarySequence expectedFirstPrimarySequence); Assert.assertEquals(firstPrimaryAlignmentStart expectedFirstPrimaryAlignmentStart); Assert.assertEquals(secondPrimarySequence expectedSecondPrimarySequence); Assert.assertEquals(secondPrimaryAlignmentStart expectedSecondPrimaryAlignmentStart); if (!includeSecondary) { Assert.assertEquals(numFirstRecords 1); Assert.assertEquals(numSecondRecords 1); } else { Assert.assertEquals(numFirstRecords Math.max(1 firstEndSpecs.length)); Assert.assertEquals(numSecondRecords Math.max(1 secondEndSpecs.length)); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testMostDistantStrategyDataProvider,"@DataProvider(name=""testMostDistantStrategy"") public Object[][]  (){ return new Object[][]{{""multipleAlignmentsBothEnds"" new MostDistantStrategyAlignmentSpec[]{new MostDistantStrategyAlignmentSpec(false ""chr1"" 1 20) new MostDistantStrategyAlignmentSpec(fa"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testMultiHit,"@Test public void  () throws IOException { final File unmappedSam=new File(TEST_DATA_DIR ""multihit.unmapped.sam""); final File alignedSam=new File(TEST_DATA_DIR ""multihit.aligned.sam""); final File merged=File.createTempFile(""merged"" "".sam""); merged.deleteO"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testOldQuerynameSortFails,"@Test(expectedExceptions={IllegalStateException.class PicardException.class}) public void  () throws IOException { final File merged=File.createTempFile(""merged"" BamFileIoUtils.BAM_FILE_EXTENSION); merged.deleteOnExit(); doMergeAlignment(badorderUnmappedB"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testPairedMultiHitWithFiltering,"@Test(dataProvider="" TestCases"") public void testPairedMultiHitWithFiltering(final String description final List<HitSpec> firstOfPair final List<HitSpec> secondOfPair final Integer expectedPrimaryHitIndex final int expectedNumFirst final int expectedNumSe"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testPairedMultiHitWithFilteringTestCases,"@DataProvider(name="" "") public Object[][] testPairedMultiHitWithFilteringTestCases(){ final ArrayList<Object[]> ret=new ArrayList<Object[]>(); List<HitSpec> firstOfPair; List<HitSpec> secondOfPair; firstOfPair=new ArrayList<HitSpec>(); secondOfPair=Collec"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testRemoveNmMdAndUqOnOverlappingReads,"@Test public void  () throws IOException { final File output=File.createTempFile(""testRemoveNmMdAndUqOnOverlappingReads"" "".sam""); output.deleteOnExit(); doMergeAlignment(new File(TEST_DATA_DIR ""removetags.unmapped.sam"") Collections.singletonList(new File("
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testShortFragmentClipping,"@Test public void  () throws Exception { final File output=File.createTempFile(""testShortFragmentClipping"" "".sam""); output.deleteOnExit(); doMergeAlignment(new File(TEST_DATA_DIR ""cliptest.unmapped.sam"") Collections.singletonList(new File(TEST_DATA_DIR ""c"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,testSortingOnSamAlignmentMerger,"@Test(dataProvider=""data"") public void  (final File unmapped final File aligned final boolean sorted final boolean coordinateSorted final String testName) throws IOException { final File target=File.createTempFile(""target"" ""bam""); target.deleteOnExit(); f"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\MergeBamAlignmentTest.java,toString,"@Override public String  (){ return ""AlignmentAccumulator{"" + ""seenUnaligned="" + seenUnaligned + ""  numAlignments=""+ numAlignments+ ""  primaryAlignmentSequence='""+ primaryAlignmentSequence+ '\''+ '}'; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamFileConverterTest.java,convertFile,"private void  (final File inputFile final File fileToCompare final String extension){ final SamFormatConverter samFormatConverter=new SamFormatConverter(); final List<File> samFiles=new ArrayList<File>(); final ValidateSamFile validateSamFile=new ValidateSamFile(); final CompareSAMs compareSAMs=new CompareSAMs(); samFormatConverter.INPUT=inputFile; try { samFormatConverter.OUTPUT=File.createTempFile(""SamFileConverterTest."" + inputFile.getName() extension); samFormatConverter.OUTPUT.deleteOnExit(); } catch ( final IOException e) { e.printStackTrace(); } samFormatConverter.doWork(); validateSamFile.INPUT=samFormatConverter.OUTPUT; assertEquals(validateSamFile.doWork() 0); samFiles.add(samFormatConverter.OUTPUT); samFiles.add(fileToCompare); compareSAMs.samFiles=samFiles; compareSAMs.doWork(); assertTrue(compareSAMs.areEqual()); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamFileConverterTest.java,testBAMToCRAM,"@Test public void  (){ convertFile(unmappedBam unmappedCram "".cram""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamFileConverterTest.java,testBAMToSAM,"@Test public void  (){ convertFile(unmappedBam unmappedSam "".sam""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamFileConverterTest.java,testCRAMToBAM,"@Test public void  (){ convertFile(unmappedCram unmappedBam "".bam""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamFileConverterTest.java,testCRAMToSAM,"@Test public void  (){ convertFile(unmappedCram unmappedSam "".sam""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamFileConverterTest.java,testSAMToBAM,"@Test public void  (){ convertFile(unmappedSam unmappedBam "".bam""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamFileConverterTest.java,testSAMToCRAM,"@Test public void  (){ convertFile(unmappedSam unmappedCram "".cram""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,basicPositiveTests,"@Test(dataProvider=""positiveTestData"") public void  (final SAMFileHeader.SortOrder so final boolean removeDuplicates final boolean removeAlignmentInfo final boolean restoreOriginalQualities final boolean outputByReadGroup final String sample final String "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,getCommandLineProgramName,public String  (){ return RevertSam.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,getNegativeTestData,"@DataProvider(name=""overrideTestData"") public Object[][]  (){ return new Object[][]{{""NewSample"" null} {null ""NewLibrary""} {""NewSample"" ""NewLibrary""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,getPostitiveTestData,"@DataProvider(name=""positiveTestData"") public Object[][]  (){ return new Object[][]{{null true true true true null null Collections.EMPTY_LIST} {SAMFileHeader.SortOrder.queryname true true true false ""Hey Dad!"" null Arrays.asList(""XT"")} {null false true f"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testAssertAllReadGroupsMappedFailure,"@Test(expectedExceptions={PicardException.class}) public void  (){ final SAMReadGroupRecord rg1=new SAMReadGroupRecord(""rg1""); final SAMReadGroupRecord rg2=new SAMReadGroupRecord(""rg2""); final SAMReadGroupRecord rg3=new SAMReadGroupRecord(""rg3""); final Ma"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testAssertAllReadGroupsMappedSuccess,"@Test public void  (){ final SAMReadGroupRecord rg1=new SAMReadGroupRecord(""rg1""); final SAMReadGroupRecord rg2=new SAMReadGroupRecord(""rg2""); final Map<String File> outputMap=new HashMap<String File>(); outputMap.put(""rg1"" new File(""/foo/bar/rg1.bam"")); "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testCommandLineHelp,"@Test public void  () throws Exception { final File outputDir=Files.createTempDirectory(""picardRevertSamTest"").toFile(); outputDir.deleteOnExit(); final String args[]=new String[1]; args[0]=""--help""; final int returnCode=runPicardCommandLine(args); Assert"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testFilePathsWithMapFile,"@Test public void  (){ final Map<String File> outputMap=RevertSam.createOutputMap(validOutputMap null "".bam"" Collections.emptyList()); Assert.assertEquals(outputMap.get(""rg1"") new File(""/path/to/my_rg_1.ubam"")); Assert.assertEquals(outputMap.get(""rg2"") ne"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testFilePathsWithoutMapFile,"@Test public void  (){ final SAMReadGroupRecord rg1=new SAMReadGroupRecord(""rg1""); final SAMReadGroupRecord rg2=new SAMReadGroupRecord(""rg2""); final Map<String File> outputMap=RevertSam.createOutputMap(null new File(""/foo/bar"") "".bam"" Arrays.asList(rg1 rg"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testGetDefaultExtension,"@Test public void  (){ Assert.assertEquals(RevertSam.getDefaultExtension(""this.is.a.sam"") "".sam""); Assert.assertEquals(RevertSam.getDefaultExtension(""this.is.a.cram"") "".cram""); Assert.assertEquals(RevertSam.getDefaultExtension(""this.is.a.bam"") "".bam""); As"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testIsOutputMapHeaderValid,"@Test public void  (){ boolean isValid=RevertSam.ValidationUtil.isOutputMapHeaderValid(Arrays.asList(""READ_GROUP_ID"" ""OUTPUT"")); Assert.assertEquals(isValid true); isValid=RevertSam.ValidationUtil.isOutputMapHeaderValid(Arrays.asList(""OUTPUT"")); Assert.as"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testMutexOutputMapVsOutput,"@Test public void  () throws Exception { final File outputDir=Files.createTempDirectory(""picardRevertSamTest"").toFile(); outputDir.deleteOnExit(); final String args[]=new String[4]; int index=0; args[index++]=""INPUT="" + basicSamToRevert; args[index++]=""OU"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testNoInput,"@Test public void  () throws Exception { final File outputDir=Files.createTempDirectory(""picardRevertSamTest"").toFile(); outputDir.deleteOnExit(); final String args[]=new String[0]; try { final int returnCode=runPicardCommandLine(args); Assert.assertEqual"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testNoRgInfoOutputByRg,"@Test(expectedExceptions=PicardException.class) public void  (){ final String[] args=new String[]{""I=testdata/picard/sam/bam2fastq/paired/bad/missing-rg-info.sam"" ""OUTPUT_BY_READGROUP=true"" ""O=.""}; runPicardCommandLine(args); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testNoRgInfoSanitize,"@Test public void  () throws Exception { final File output=File.createTempFile(""no-rg-reverted"" "".sam""); output.deleteOnExit(); final String[] args=new String[]{""I=testdata/picard/sam/bam2fastq/paired/bad/missing-rg-info.sam"" ""SANITIZE=true"" ""O="" + output"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testOutputByReadGroupWithOutputMap,"@Test public void  () throws Exception { final File outputDir=Files.createTempDirectory(""tmpPicardTest"").toFile(); final File outputMapFile=Files.createTempFile(""picardRevertSamTestOutputMap"" "".txt"").toFile(); final PrintWriter mapWriter=new PrintWriter(o"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testSampleLibraryOverride,"@Test(dataProvider=""overrideTestData"" expectedExceptions={PicardException.class}) public void  (final String sample final String library) throws Exception { final File output=File.createTempFile(""bad"" "".sam""); output.deleteOnExit(); final String args[]=ne"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testSanitizeAndDeduplicateRecords,"@Test public void  () throws Exception { final File input=File.createTempFile(""test-input-santize-and-deduplicate-records"" "".sam""); final File output=File.createTempFile(""test-output-santize-and-deduplicate-records"" "".sam""); final SamReader reader=SamRead"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testSingleEnd,"@Test public void  () throws Exception { final File output=File.createTempFile(""single_end_reverted"" "".sam""); output.deleteOnExit(); final String args[]={""INPUT="" + singleEndSamToRevert ""OUTPUT="" + output.getAbsolutePath()}; runPicardCommandLine(args); fi"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testSingleEndSanitize,"@Test public void  () throws Exception { final File output=File.createTempFile(""single_end_reverted"" "".sam""); output.deleteOnExit(); final String args[]={""INPUT="" + singleEndSamToRevert ""OUTPUT="" + output.getAbsolutePath() ""SANITIZE=true""}; Assert.assertE"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testValidateOutputParamsByReadGroupBadHeaderMap,"@Test public void  (){ final List<String> errors=new ArrayList<String>(); RevertSam.ValidationUtil.validateOutputParamsByReadGroup(null badHeaderOutputMap errors); Assert.assertEquals(errors.size() 1); Assert.assertEquals(errors.get(0).contains(""Invalid h"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testValidateOutputParamsByReadGroupDirValid,@Test public void  (){ final List<String> errors=new ArrayList<String>(); RevertSam.ValidationUtil.validateOutputParamsByReadGroup(samTestData null errors); Assert.assertEquals(errors.size() 0); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testValidateOutputParamsByReadGroupMapValid,@Test public void  (){ final List<String> errors=new ArrayList<String>(); RevertSam.ValidationUtil.validateOutputParamsByReadGroup(null validOutputMap errors); Assert.assertEquals(errors.size() 0); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testValidateOutputParamsByReadGroupMissingMap,"@Test public void  (){ final List<String> errors=new ArrayList<String>(); RevertSam.ValidationUtil.validateOutputParamsByReadGroup(null nonExistentOutputMap errors); Assert.assertEquals(errors.size() 1); Assert.assertEquals(errors.get(0).contains(""Cannot "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testValidateOutputParamsByReadGroupNoMapOrDir,"@Test public void  (){ final List<String> errors=new ArrayList<String>(); RevertSam.ValidationUtil.validateOutputParamsByReadGroup(null null errors); Assert.assertEquals(errors.size() 1); Assert.assertEquals(errors.get(0).contains(""Must provide either"") t"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testValidateOutputParamsNotByReadGroupDir,"@Test public void  (){ final List<String> errors=new ArrayList<String>(); RevertSam.ValidationUtil.validateOutputParamsNotByReadGroup(samTestData null errors); Assert.assertEquals(errors.size() 1); Assert.assertEquals(errors.get(0).contains(""should not be"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testValidateOutputParamsNotByReadGroupMap,"@Test public void  (){ final List<String> errors=new ArrayList<String>(); RevertSam.ValidationUtil.validateOutputParamsNotByReadGroup(null validOutputMap errors); Assert.assertEquals(errors.size() 2); Assert.assertEquals(errors.get(0).contains(""Cannot pro"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testValidateOutputParamsNotByReadGroupNoOutput,"@Test public void  (){ final List<String> errors=new ArrayList<String>(); RevertSam.ValidationUtil.validateOutputParamsNotByReadGroup(null null errors); Assert.assertEquals(errors.size() 1); Assert.assertEquals(errors.get(0).contains(""OUTPUT is required"")"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,testValidateOutputParamsNotByReadGroupValid,@Test public void  (){ final List<String> errors=new ArrayList<String>(); RevertSam.ValidationUtil.validateOutputParamsNotByReadGroup(writablePath null errors); Assert.assertEquals(errors.size() 0); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\RevertSamTest.java,verifyPositiveResults,"private void  (final File outputFile final RevertSam reverter final boolean removeDuplicates final boolean removeAlignmentInfo final boolean restoreOriginalQualities final boolean outputByReadGroup final String readGroupId final int numReadsExpected final String sample final String library){ outputFile.deleteOnExit(); final SamReader reader=SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(outputFile); final SAMFileHeader header=reader.getFileHeader(); Assert.assertEquals(header.getSortOrder() SAMFileHeader.SortOrder.queryname); Assert.assertEquals(header.getProgramRecords().size() removeAlignmentInfo ? 0 : 1); final List<SAMReadGroupRecord> readGroups=header.getReadGroups(); if (outputByReadGroup) { Assert.assertEquals(readGroups.size() 1); Assert.assertEquals(readGroups.get(0).getId() readGroupId); } for ( final SAMReadGroupRecord rg : header.getReadGroups()) { if (sample != null) { Assert.assertEquals(rg.getSample() sample); } else { Assert.assertEquals(rg.getSample() ""Hi Mom!""); } if (library != null) { Assert.assertEquals(rg.getLibrary() library); } else { Assert.assertEquals(rg.getLibrary() ""my-library""); } } int numReads=0; for ( final SAMRecord rec : reader) { numReads++; if (removeDuplicates) { Assert.assertFalse(rec.getDuplicateReadFlag() ""Duplicates should have been removed: "" + rec.getReadName()); } if (removeAlignmentInfo) { Assert.assertTrue(rec.getReadUnmappedFlag() ""Alignment info should have been removed: "" + rec.getReadName()); } if (restoreOriginalQualities && !unmappedRead.equals(rec.getReadName() + ""/"" + (rec.getFirstOfPairFlag() ? ""1"" : ""2""))) { Assert.assertEquals(rec.getBaseQualityString() revertedQualities); } else { Assert.assertNotSame(rec.getBaseQualityString() revertedQualities); } for ( final SAMRecord.SAMTagAndValue attr : rec.getAttributes()) { if (removeAlignmentInfo || (!attr.tag.equals(""PG"") && !attr.tag.equals(""NM"") && !attr.tag.equals(SAMTag.MQ.toString()))) { Assert.assertFalse(reverter.ATTRIBUTE_TO_CLEAR.contains(attr.tag) attr.tag + "" should have been cleared.""); } } } Assert.assertEquals(numReads numReadsExpected); CloserUtil.close(reader); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,add,"void  (final SAMRecord record){ if (!record.getReadPairedFlag()) throw new PicardException(""Record "" + record.getReadName() + "" is not paired""); if (record.getFirstOfPairFlag()) { if (mate1 != null) throw new PicardException(""Mate 1 already set for record: "" + record.getReadName()); mate1=record; } else if (record.getSecondOfPairFlag()) { if (mate2 != null) throw new PicardException(""Mate 2 already set for record: "" + record.getReadName()); mate2=record; } else throw new PicardException(""Neither FirstOfPairFlag or SecondOfPairFlag is set for a paired record""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,badFiles,"@DataProvider(name="" "") public Object[][] badFiles(){ return new Object[][]{{""bad/unpaired-mate.sam""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,badGroupedFiles,"@DataProvider(name="" "") public Object[][] badGroupedFiles(){ return new Object[][]{{""bad/grouped-unpaired-mate.sam""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,clippingTests,"@DataProvider(name="" "") public Object[][] clippingTests(){ return new Object[][]{{null ""AAAAAAAAAA"" ""1111111111"" ""AAAAAAAAAA"" ""1111111111"" ""CCCCCCCCCC"" ""2222222222"" ""GGGGGGGGGG"" ""2222222222"" ""No clipping test""} {""X"" ""AAAAAAA"" ""1111111"" ""AAAAAA"" ""111111"" """
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,convertFile,private void  (final String[] args){ Assert.assertEquals(runPicardCommandLine(args) 0); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,createFastqReadHeaderSet,protected static Set<String>  (final File file){ final Set<String> set=new HashSet<String>(); final FastqReader freader=new FastqReader(file); while (freader.hasNext()) { final FastqRecord frec=freader.next(); set.add(frec.getReadName()); } return set; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,createPUPairsMap,protected static Map<String Map<String MatePair>>  (final File samFile) throws IOException { IOUtil.assertFileIsReadable(samFile); final SamReader reader=SamReaderFactory.makeDefault().open(samFile); final Map<String Map<String MatePair>> map=new LinkedHashMap<>(); Map<String MatePair> curFileMap; for ( final SAMRecord record : reader) { final String platformUnit=record.getReadGroup().getPlatformUnit(); curFileMap=map.get(platformUnit); if (curFileMap == null) { curFileMap=new LinkedHashMap<>(); map.put(platformUnit curFileMap); } MatePair mpair=curFileMap.get(record.getReadName()); if (mpair == null) { mpair=new MatePair(); curFileMap.put(record.getReadName() mpair); } mpair.add(record); } reader.close(); return map; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,createSamMatePairsMap,private Map<String MatePair>  (final File samFile) throws IOException { IOUtil.assertFileIsReadable(samFile); final SamReader reader=SamReaderFactory.makeDefault().open(samFile); final Map<String MatePair> map=new LinkedHashMap<String MatePair>(); for ( final SAMRecord record : reader) { MatePair mpair=map.get(record.getReadName()); if (mpair == null) { mpair=new MatePair(); map.put(record.getReadName() mpair); } mpair.add(record); } reader.close(); return map; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,getCommandLineProgramName,public String  (){ return SamToFastq.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,missingRgFiles,"@DataProvider(name="" "") public Object[][] missingRgFiles(){ return new Object[][]{{""bad/missing-rg-info.sam""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,newTempFastqFile,"private File  (final String filename) throws IOException { return newTempFastqFile(filename "".fastq""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,okFiles,"@DataProvider(name="" "") public Object[][] okFiles(){ return new Object[][]{{""ok/sorted-pair.sam""} {""ok/sorted-pair-no-rg.sam""} {""ok/last-pair-mates-flipped.sam""} {""ok/first-mate-bof-last-mate-eof.sam""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,okGroupedFiles,"@DataProvider(name="" "") public Object[][] okGroupedFiles(){ return new Object[][]{{""ok/grouped-last-pair-mates-flipped.sam"" new String[]{""rg1"" ""rg2""}}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,testBadFile,"@Test(dataProvider=""badFiles"" expectedExceptions=SAMFormatException.class) public void  (final String samFilename) throws IOException { final File samFile=new File(TEST_DATA_DIR samFilename); final File pair1=File.createTempFile(""tt-pair1."" "".fastq""); fin"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,testBadGroupedFile,"@Test(dataProvider=""badGroupedFiles"" expectedExceptions=SAMFormatException.class) public void  (final String samFilename) throws IOException { final File pair1File=newTempFastqFile(""pair1""); final File pair2File=newTempFastqFile(""pair2""); convertFile(new "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,testBadGroupedFileOutputPerRg,"@Test(dataProvider=""badGroupedFiles"" expectedExceptions=SAMException.class) public void  (final String samFilename) throws IOException { convertFile(new String[]{""INPUT="" + TEST_DATA_DIR + ""/""+ samFilename ""OUTPUT_DIR="" + IOUtil.getDefaultTmpDir().getAbso"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,testClipping,"@Test(dataProvider=""clippingTests"") public void  (final String clippingAction final String bases1_1 final String quals1_1 final String bases1_2 final String quals1_2 final String bases2_1 final String quals2_1 final String bases2_2 final String quals2_2 f"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,testFileCompression,"@Test(dataProvider=""okFiles"") public void  (final String samFilename) throws IOException { final File samFile=new File(TEST_DATA_DIR samFilename); final File pair1File=newTempFastqFile(""pair1"" "".fastq.gz""); final File pair2File=newTempFastqFile(""pair2"" ""."
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,testMissingRgFile,"@Test(dataProvider=""missingRgFiles"") public void  (final String samFilename) throws IOException { final File samFile=new File(TEST_DATA_DIR samFilename); final File pair1File=newTempFastqFile(""pair1""); final File pair2File=newTempFastqFile(""pair2""); pair1"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,testMissingRgFileOutputPerRg,"@Test(dataProvider=""missingRgFiles"" expectedExceptions=PicardException.class) public void  (final String samFilename) throws IOException { convertFile(new String[]{""INPUT="" + TEST_DATA_DIR + ""/""+ samFilename ""OUTPUT_DIR="" + IOUtil.getDefaultTmpDir().getAb"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,testOkFile,"@Test(dataProvider=""okFiles"") public void  (final String samFilename) throws IOException { final File samFile=new File(TEST_DATA_DIR samFilename); final File pair1File=newTempFastqFile(""pair1""); final File pair2File=newTempFastqFile(""pair2""); convertFile("
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,testOkGroupedFiles,"@Test(dataProvider=""okGroupedFiles"") public void  (final String samFilename final String[] groupFiles) throws IOException { final File samFile=new File(TEST_DATA_DIR samFilename); final Map<String Set<String>> outputSets=new HashMap<>(groupFiles.length); "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,testOkInterleavedFile,"@Test(dataProvider=""okFiles"") public void  (final String samFilename) throws IOException { final File samFile=new File(TEST_DATA_DIR samFilename); final File pairFile=newTempFastqFile(""pair""); convertFile(new String[]{""INPUT="" + samFile.getAbsolutePath() "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,testTrimming,"@Test(dataProvider=""trimmedData"") public void  (final String samFilename final int read1Trim final int read1MaxBases final int expectedRead1Length final int read2Trim final int read2MaxBases final int expectedRead2Length) throws IOException { final File s"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,trimmedData,"@DataProvider(name="" "") public Object[][] trimmedData(){ return new Object[][]{{""ok/sorted-pair.sam"" 6 7 7 5 8 8} {""ok/sorted-pair.sam"" 7 7 6 3 8 8}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,verifyFastq,"private void  (final File pair1File final File pair2File final File samFile) throws IOException { final Set<String> outputHeaderSet1=createFastqReadHeaderSet(pair1File); final Set<String> outputHeaderSet2=createFastqReadHeaderSet(pair2File); Assert.assertEquals(outputHeaderSet1.size() outputHeaderSet2.size()); final Map<String MatePair> map=createSamMatePairsMap(samFile); Assert.assertEquals(map.size() outputHeaderSet2.size()); for ( final Map.Entry<String MatePair> entry : map.entrySet()) { final MatePair mpair=entry.getValue(); Assert.assertNotNull(mpair.mate1); Assert.assertNotNull(mpair.mate2); Assert.assertEquals(mpair.mate1.getReadName() mpair.mate2.getReadName()); final String readName=mpair.mate1.getReadName(); Assert.assertTrue(outputHeaderSet1.contains(readName + ""/1"")); Assert.assertTrue(outputHeaderSet2.contains(readName + ""/2"")); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqTest.java,verifyFileIsGzCompressed,private void  (final File file) throws IOException { FileInputStream fis=new FileInputStream(file); final byte[] expectedMagicNumber={(byte)0x1f (byte)0x8b}; byte[] observedMagicNumber=new byte[2]; fis.read(observedMagicNumber 0 2); fis.close(); Assert.assertEquals(observedMagicNumber expectedMagicNumber); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SetNmMdAndUqTagsTest.java,fixFile,"private void  (final File input final File output final File reference) throws IOException { final String[] args={""INPUT="" + input ""OUTPUT="" + output ""REFERENCE_SEQUENCE="" + reference}; SetNmMdAndUqTags setNmMdAndUqTags=new SetNmMdAndUqTags(); Assert.assertEquals(setNmMdAndUqTags.instanceMain(args) 0 ""Fix did not succeed""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SetNmMdAndUqTagsTest.java,setUqOnly,"private void  (final File input final File output final File reference) throws IOException { final String[] args={""INPUT="" + input ""OUTPUT="" + output ""REFERENCE_SEQUENCE="" + reference ""SET_ONLY_UQ=true""}; SetNmMdAndUqTags setNmMdAndUqTags=new SetNmMdAndUqTags(); Assert.assertEquals(setNmMdAndUqTags.instanceMain(args) 0 ""Fix did not succeed""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SetNmMdAndUqTagsTest.java,sort,"private void  (final File input final File output){ final String[] args={""INPUT="" + input ""OUTPUT="" + output ""SORT_ORDER=coordinate""}; SortSam sortSam=new SortSam(); Assert.assertEquals(sortSam.instanceMain(args) 0 ""Sort did not succeed""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SetNmMdAndUqTagsTest.java,testValidSort,"@Test(dataProvider=""filesToFix"") public void  (final File input final File reference) throws IOException { final File sortOutput=File.createTempFile(""Sort"" "".bam""); sortOutput.deleteOnExit(); final File fixOutput=File.createTempFile(""Fix"" "".bam""); fixOutp"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SetNmMdAndUqTagsTest.java,testValidSortData,"@DataProvider(name=""filesToFix"") Object[][]  (){ return new Object[][]{new Object[]{new File(""testdata/picard/sam/aligned.sam"") fasta} new Object[]{new File(""testdata/picard/sam/aligned_queryname_sorted.sam"") fasta} new Object[]{new File(""testdata/picard/"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SetNmMdAndUqTagsTest.java,testValidUqSort,"@Test(dataProvider=""filesToFix"") public void  (final File input final File reference) throws IOException { final File sortOutput=File.createTempFile(""Sort"" "".bam""); sortOutput.deleteOnExit(); final File fixOutput=File.createTempFile(""Fix"" "".bam""); fixOutp"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SetNmMdAndUqTagsTest.java,validate,"private void  (final File input final File output final File reference){ final String[] args={""INPUT="" + input ""OUTPUT="" + output ""MODE=VERBOSE"" ""REFERENCE_SEQUENCE="" + reference}; ValidateSamFile validateSam=new ValidateSamFile(); Assert.assertEquals(validateSam.instanceMain(args) 0 ""validate did not succeed""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SetNmMdAndUqTagsTest.java,validateUq,"private void  (final File input final File reference){ final SamReader reader=SamReaderFactory.makeDefault().referenceSequence(reference).open(input); final SAMRecordIterator iterator=reader.iterator(); while (iterator.hasNext()) { SAMRecord rec=iterator.next(); if (!rec.getReadUnmappedFlag()) Assert.assertNotNull(rec.getAttribute(""UQ"")); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqWithTagsTest.java,argumentCombinations,"@Test(dataProvider="" data"") public void argumentCombinations(final String[] stgArguments final String[] qtgArguments final String[] sepArguments final int returnCode) throws IOException { final File temp_input=File.createTempFile(""input"" "".fastq""); temp_i"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqWithTagsTest.java,argumentCombinationsdata,"@DataProvider(name="" "") public Object[][] argumentCombinationsdata(){ return new Object[][]{{null null null 1} {STG_ARRAY null null 0} {STG_ARRAY new String[]{""UY""} null 1} {STG_ARRAY null new String[]{""AAAAA""} 1} {new String[]{""UR CR""} new String[]{""CY U"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqWithTagsTest.java,getCommandLineProgramName,public String  (){ return SamToFastqWithTags.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqWithTagsTest.java,okGroupedFiles,"@DataProvider(name="" "") public Object[][] okGroupedFiles(){ return new Object[][]{{""ok/grouped-last-pair-mates-flipped.sam"" new String[]{""rg1"" ""rg2""}}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqWithTagsTest.java,queryNonExistantTag,"@DataProvider(name="" "") public Object[][] queryNonExistantTag(){ return new Object[][]{{""ok/sorted-single.sam""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqWithTagsTest.java,testOkGroupedFiles,"@Test(dataProvider=""okGroupedFiles"") public void  (final String samFilename final String[] groupFiles) throws IOException { final File samFile=new File(TEST_DATA_DIR samFilename); final Map<String Set<String>> outputSets=new HashMap<>(groupFiles.length); "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqWithTagsTest.java,testQueryNonExistantTag,"@Test(dataProvider=""queryNonExistantTag"" expectedExceptions=PicardException.class) public void  (final String samFilename) throws IOException { final File temp_input=File.createTempFile(""input"" "".fastq""); temp_input.deleteOnExit(); runPicardCommandLine(ne"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqWithTagsTest.java,testTagGroupFastq,"@Test(dataProvider="" Data"") public void testTagGroupFastq(final String[] sequenceTags final String[] qualityTags final String[] sepArgs final String bases_1_1 final String quals_1_1 final String bases_1_2 final String quals_1_2 final String bases_2_1 fina"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SamToFastqWithTagsTest.java,testTagGroupFastqData,"@DataProvider(name="" "") public Object[][] testTagGroupFastqData(){ return new Object[][]{{new String[]{""CR""} new String[]{""CY""} null ""AAAAA"" ""11111"" ""CCCCC"" ""22222"" null null null null ""One Sequence Tag Group""} {new String[]{""CR UR""} new String[]{""CY UY""}"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SplitSamByLibraryTest.java,basicPositiveTest,"@Test public void  (){ SplitSamByLibrary splitter=new SplitSamByLibrary(); splitter.INPUT=new File(""testdata/picard/sam/split_test.sam""); Assert.assertEquals(splitter.doWork() 0 ""SAM file split should have succeeded but didn't.""); File f=new File(""unknown"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SplitSamByLibraryTest.java,countReads,private int  (File samFile){ SamReader reader=SamReaderFactory.makeDefault().open(samFile); int count=0; for (Iterator it=reader.iterator(); it.hasNext(); ) { it.next(); count++; } CloserUtil.close(reader); return count; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SplitSamByLibraryTest.java,testNoLibrarySpecified,"@Test public void  (){ SplitSamByLibrary splitter=new SplitSamByLibrary(); splitter.INPUT=new File(""testdata/picard/sam/invalid_coord_sort_order.sam""); Assert.assertEquals(splitter.doWork() SplitSamByLibrary.NO_LIBRARIES_SPECIFIED_IN_HEADER ""SAM file with"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SplitSamByLibraryTest.java,testNoUnknownFile,"@Test public void  (){ SplitSamByLibrary splitter=new SplitSamByLibrary(); splitter.INPUT=new File(""testdata/picard/sam/split_test2.sam""); Assert.assertEquals(splitter.doWork() 0 ""SAM file split should have succeeded but didn't.""); File f=new File(""unknow"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\CleanSamTester.java,CleanSamTester,public  (final String expectedCigar final int readLength final int defaultChromosomeLength){ super(readLength true defaultChromosomeLength); this.expectedCigar=expectedCigar; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\CleanSamTester.java,getCommandLineProgramName,@Override public String  (){ return CleanSam.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\CleanSamTester.java,test,"protected void  (){ try { final SamFileValidator validator=new SamFileValidator(new PrintWriter(System.out) 8000); validator.setIgnoreWarnings(true); validator.setVerbose(true 1000); validator.setErrorsToIgnore(Arrays.asList(SAMValidationError.Type.MISSING_READ_GROUP)); SamReaderFactory factory=SamReaderFactory.makeDefault().validationStringency(ValidationStringency.LENIENT); SamReader samReader=factory.open(getOutput()); final SAMRecordIterator iterator=samReader.iterator(); while (iterator.hasNext()) { final SAMRecord rec=iterator.next(); Assert.assertEquals(rec.getCigarString() expectedCigar); if (SAMUtils.hasMateCigar(rec)) { Assert.assertEquals(SAMUtils.getMateCigarString(rec) expectedCigar); } } CloserUtil.close(samReader); samReader=factory.open(getOutput()); final boolean validated=validator.validateSamFileVerbose(samReader null); CloserUtil.close(samReader); Assert.assertTrue(validated ""ValidateSamFile failed""); } finally { TestUtil.recursiveDelete(getOutputDir()); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SplitSamByNumberOfReadsTest.java,compareInputWithOutputs,private void  (final SamReader reader1 final SamReader reader2 final SAMRecordIterator inputIterator final int expectedFirstSize){ int count=0; for ( SAMRecord rec : reader1) { SAMRecord inputRec=inputIterator.next(); Assert.assertEquals(rec.getReadName() inputRec.getReadName()); count++; } Assert.assertEquals(count expectedFirstSize); for ( SAMRecord rec : reader2) { SAMRecord inputRec=inputIterator.next(); Assert.assertEquals(rec.getReadName() inputRec.getReadName()); } } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SplitSamByNumberOfReadsTest.java,getCommandLineProgramName,public String  (){ return SplitSamByNumberOfReads.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SplitSamByNumberOfReadsTest.java,testNFiles,"@Test public void  () throws IOException { final String tmpDir=IOUtil.getDefaultTmpDir().getAbsolutePath(); final String[] args=new String[]{""INPUT="" + PAIRED_FILE.getAbsolutePath() ""TOTAL_READS_IN_INPUT=10"" ""SPLIT_TO_N_FILES=2"" ""OUTPUT="" + tmpDir}; runPi"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SplitSamByNumberOfReadsTest.java,testNoTotalReads,"@Test public void  () throws IOException { final String tmpDir=IOUtil.getDefaultTmpDir().getAbsolutePath(); final String[] args=new String[]{""INPUT="" + PAIRED_FILE.getAbsolutePath() ""SPLIT_TO_N_READS=5"" ""OUTPUT="" + tmpDir}; runPicardCommandLine(args); fin"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SplitSamByNumberOfReadsTest.java,testOkFile,"@Test public void  () throws IOException { final String tmpDir=IOUtil.getDefaultTmpDir().getAbsolutePath(); final String[] args=new String[]{""INPUT="" + PAIRED_FILE.getAbsolutePath() ""TOTAL_READS_IN_INPUT=10"" ""SPLIT_TO_N_READS=5"" ""OUTPUT="" + tmpDir}; runPi"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SplitSamByNumberOfReadsTest.java,testOneOutput,"@Test public void  () throws IOException { final String tmpDir=IOUtil.getDefaultTmpDir().getAbsolutePath(); final String[] args=new String[]{""INPUT="" + PAIRED_FILE.getAbsolutePath() ""TOTAL_READS_IN_INPUT=10"" ""SPLIT_TO_N_READS=10"" ""OUTPUT="" + tmpDir}; runP"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SplitSamByNumberOfReadsTest.java,testStreamWithoutTotalReads,"@Test public void  () throws IOException { final String tmpDir=IOUtil.getDefaultTmpDir().getAbsolutePath(); final String[] args=new String[]{""INPUT=/dev/stdin"" ""SPLIT_TO_N_READS=5"" ""OUTPUT="" + tmpDir}; final int rc=runPicardCommandLine(args); Assert.asser"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SplitSamByNumberOfReadsTest.java,testThreeReadTemplate,"@Test public void  () throws IOException { final String tmpDir=IOUtil.getDefaultTmpDir().getAbsolutePath(); final String[] args=new String[]{""INPUT="" + THREE_READ_TEMPLATE.getAbsolutePath() ""TOTAL_READS_IN_INPUT=11"" ""SPLIT_TO_N_READS=2"" ""OUTPUT="" + tmpDir"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\SplitSamByNumberOfReadsTest.java,testWrongTotalReads,"@Test public void  () throws IOException { final String tmpDir=IOUtil.getDefaultTmpDir().getAbsolutePath(); final String[] args=new String[]{""INPUT="" + PAIRED_FILE.getAbsolutePath() ""TOTAL_READS_IN_INPUT=20"" ""SPLIT_TO_N_READS=5"" ""OUTPUT="" + tmpDir}; runPi"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\util\ReadNameParserTests.java,doTestGetRapidDefaultReadNameRegexSplit,"private void  (int numFields){ final int[] inputFields=new int[3]; final int[] expectedFields=new int[3]; String readName=""""; for (int i=0; i < numFields; i++) { if (0 < i) readName+="":""; readName+=Integer.toString(i); } inputFields[0]=inputFields[1]=inputFields[2]=-1; if (numFields < 3) { Assert.assertEquals(ReadNameParser.getLastThreeFields(readName ':' inputFields) -1); } else { Assert.assertEquals(ReadNameParser.getLastThreeFields(readName ':' inputFields) numFields); expectedFields[0]=expectedFields[1]=expectedFields[2]=-1; if (0 < numFields) expectedFields[0]=numFields - 3; if (1 < numFields) expectedFields[1]=numFields - 2; if (2 < numFields) expectedFields[2]=numFields - 1; for (int i=0; i < inputFields.length; i++) { Assert.assertEquals(inputFields[i] expectedFields[i]); } } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\util\ReadNameParserTests.java,testGetRapidDefaultReadNameRegexSplit,@Test public void  (){ for (int i=1; i < 10; i++) { doTestGetRapidDefaultReadNameRegexSplit(i); } } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\util\ReadNameParserTests.java,testParseReadNameDataProvider,"@DataProvider(name="" "") public Object[][] testParseReadNameDataProvider(){ return new Object[][]{{""RUNID:7:1203:2886:82292"" 1203 2886 82292} {""RUNID:7:1203:2884:16834"" 1203 2884 16834}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\util\ReadNameParserTests.java,testParseReadNameOK,"@Test(dataProvider=""testParseReadNameDataProvider"" enabled=true) public void  (final String readName final int tile final int x final int y){ ReadNameParser parser=new ReadNameParser(); PhysicalLocation loc=new PhysicalLocationInt(); Assert.assertTrue(par"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\util\ReadNameParserTests.java,testParseReadNameOverflow,"@Test(dataProvider=""testParseReadNameDataProvider"" enabled=true) public void  (final String readName final int tile final int x final int y){ ReadNameParser parser=new ReadNameParser(); PhysicalLocation loc=new PhysicalLocationShort(); Assert.assertTrue(p"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\util\ReadNameParserTests.java,testRapidParseInt,"@Test public void  (){ for (int i=-100; i < 100; i++) { Assert.assertEquals(ReadNameParser.rapidParseInt(Integer.toString(i)) i); Assert.assertEquals(ReadNameParser.rapidParseInt(Integer.toString(i) + ""A"") i); Assert.assertEquals(ReadNameParser.rapidParse"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\util\ReadNameParserTests.java,testRapidParseIntFails,"@Test public void  (){ List<String> values=CollectionUtil.makeList(""foo"" ""bar"" ""abc123"" ""-foo"" ""f00"" ""-f00""); for ( String s : values) { try { ReadNameParser.rapidParseInt(s); Assert.fail(""Should have failed to rapid-parse "" + s + "" as an int.""); } catch "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\util\ReadNameParserTests.java,testReadNameParsing,"@Test(dataProvider="" "") public void testReadNameParsing(final String readNameRegex final String readName final int tile final int x final int y final boolean addLocationInformationSucceeds){ final ReadNameParser parser=new ReadNameParser(readNameRegex); f"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\util\ReadNameParserTests.java,testReadNameParsingDataProvider,"@DataProvider(name=""testReadNameParsing"") public Object[][]  (){ final String lastThreeFieldsRegex=""(?:.*:)?([0-9]+)[^:]*:([0-9]+)[^:]*:([0-9]+)[^:]*$""; return new Object[][]{{lastThreeFieldsRegex ""RUNID:123:000000000-ZZZZZ:1:1105:17981:23325"" 1105 17981 "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,SamFileTester,public  (final int readLength final boolean deleteOnExit){ this(readLength deleteOnExit SAMRecordSetBuilder.DEFAULT_CHROMOSOME_LENGTH); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,addArg,public void  (final String arg){ args.add(arg); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,addFragment,private void  (final String readName final int referenceSequenceIndex final int alignmentStart final boolean recordUnmapped final boolean isDuplicate final String cigar final String qualityString final int defaultQualityScore final boolean isSecondary final boolean isSupplementary){ final SAMRecord record=samRecordSetBuilder.addFrag(readName referenceSequenceIndex alignmentStart false recordUnmapped cigar qualityString defaultQualityScore isSecondary isSupplementary); final String key=samRecordToDuplicatesFlagsKey(record); Assert.assertFalse(this.duplicateFlags.containsKey(key)); this.duplicateFlags.put(key isDuplicate); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,addMappedFragment,public void  (final String readName final int referenceSequenceIndex final int alignmentStart final boolean isDuplicate final String cigar final String qualityString final boolean isSecondary final boolean isSupplementary final int defaultQualityScore){ addFragment(readName referenceSequenceIndex alignmentStart false isDuplicate cigar qualityString defaultQualityScore isSecondary isSupplementary); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,addMappedPair,public void  (final int referenceSequenceIndex final int alignmentStart1 final int alignmentStart2 final boolean isDuplicate1 final boolean isDuplicate2 final String cigar1 final String cigar2 final boolean strand1 final boolean strand2 final boolean firstOnly final int defaultQualityScore){ addMatePair(referenceSequenceIndex alignmentStart1 alignmentStart2 false false isDuplicate1 isDuplicate2 cigar1 cigar2 strand1 strand2 firstOnly false false defaultQualityScore); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,addMatePair,public void  (final String readName final int referenceSequenceIndex final int alignmentStart1 final int alignmentStart2 final boolean record1Unmapped final boolean record2Unmapped final boolean isDuplicate1 final boolean isDuplicate2 final String cigar1 final String cigar2 final boolean strand1 final boolean strand2 final boolean firstOnly final boolean record1NonPrimary final boolean record2NonPrimary final int defaultQuality){ addMatePair(readName referenceSequenceIndex referenceSequenceIndex alignmentStart1 alignmentStart2 record1Unmapped record2Unmapped isDuplicate1 isDuplicate2 cigar1 cigar2 strand1 strand2 firstOnly record1NonPrimary record2NonPrimary defaultQuality); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,addRecord,public void  (final SAMRecord record){ final String key=samRecordToDuplicatesFlagsKey(record); Assert.assertFalse(this.duplicateFlags.containsKey(key)); this.duplicateFlags.put(key record.getDuplicateReadFlag()); this.samRecordSetBuilder.addRecord(record); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,addUnmappedFragment,public void  (final int referenceSequenceIndex final String qualityString){ addFragment(referenceSequenceIndex -1 true false null qualityString -1 false); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,addUnmappedPair,public void  (final int referenceSequenceIndex final int defaultQualityScore){ addMatePair(referenceSequenceIndex -1 -1 true true false false null null false false false false false defaultQualityScore); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,createInputFile,"private File  (){ final File input=new File(outputDir ""input.sam""); final SAMFileWriter writer=new SAMFileWriterFactory().makeSAMOrBAMWriter(samRecordSetBuilder.getHeader() true input); samRecordSetBuilder.getRecords().forEach(writer::addAlignment); writer.close(); return input; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,getArgs,public ArrayList<String>  (){ return args; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,getDeleteOnExit,public boolean  (){ return deleteOnExit; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,getInput,public SamReader  (){ return samRecordSetBuilder.getSamReader(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,getNumberOfRecords,public int  (){ return this.samRecordSetBuilder.size(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,getOutput,public File  (){ return output; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,getOutputDir,public File  (){ return outputDir; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,getRecordIterator,public CloseableIterator<SAMRecord>  (){ return this.samRecordSetBuilder.iterator(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,getSamRecordSetBuilder,public SAMRecordSetBuilder  (){ return samRecordSetBuilder; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,runTest,"public void  (){ final File input=createInputFile(); output=new File(outputDir ""output.sam""); args.add(""INPUT="" + input.getAbsoluteFile()); args.add(""OUTPUT="" + output.getAbsoluteFile()); Assert.assertEquals(runPicardCommandLine(args) 0); test(); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,samRecordToDuplicatesFlagsKey,"protected String  (final SAMRecord record){ final StringBuilder nameBuilder=new StringBuilder(); nameBuilder.append(record.getReadName()); nameBuilder.append(""-""); if (record.getReadUnmappedFlag()) { nameBuilder.append(""Unmapped""); } else { nameBuilder.append(record.getContig()).append(""-"").append(record.getAlignmentStart()); } nameBuilder.append(""-"").append(record.getReadPairedFlag()).append(""-"").append(record.getNotPrimaryAlignmentFlag()).append(""-""); if (record.getReadPairedFlag()) { nameBuilder.append(record.getFirstOfPairFlag()).append(""-"").append(record.getSecondOfPairFlag()); } else { nameBuilder.append(""false-false""); } return nameBuilder.toString(); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,setHeader,public void  (final SAMFileHeader header){ this.samRecordSetBuilder.setHeader(header); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,setNoMateCigars,public void  (final boolean value){ this.noMateCigars=value; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,setOutput,public void  (final File output){ this.output=output; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\SamFileTester.java,setOutputDir,"private void  (){ this.outputDir=IOUtil.createTempDir(this.getClass().getSimpleName() + ""."" "".tmp""); if (deleteOnExit) { outputDir.deleteOnExit(); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\ValidateSamTester.java,assertSamValid,"public void  (final File samFile){ final int validateExitStatus=runPicardCommandLine(new String[]{""I="" + samFile.getAbsolutePath()}); Assert.assertEquals(validateExitStatus 0); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\testers\ValidateSamTester.java,getCommandLineProgramName,public String  (){ return ValidateSamFile.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\ValidateSamFileTest.java,getCommandLineProgramName,@Override public String  (){ return ValidateSamFile.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\ValidateSamFileTest.java,samFiles,"@DataProvider public Object[][]  (){ return new Object[][]{{""nofile"" ValidateSamFile.ReturnTypes.FAILED.value()} {""good/sorted-pair.sam"" ValidateSamFile.ReturnTypes.SUCCESSFUL.value()} {""bad/unpaired-mate.sam"" ValidateSamFile.ReturnTypes.ERRORS.value()} {"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\ValidateSamFileTest.java,test,"@Test(dataProvider=""samFiles"") public void  (final String samFileName final int exitStatus){ final int validateExitStatus=runPicardCommandLine(new String[]{""I="" + new File(TEST_DATA_DIR + samFileName).getAbsolutePath()}); Assert.assertEquals(validateExitS"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\TestDataProviders.java,independentTestOfDataProviderTest,"@Test public void  () throws Exception { final Iterator<Object[]> data=TestNGUtil.getDataProviders(""picard""); Assert.assertTrue(data.hasNext() ""Found no data from testAllDataProvidersdata. Something is wrong.""); Assert.assertEquals(StreamSupport.stream(Sp"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\TestDataProviders.java,testAllDataProvidersData,"@DataProvider(name=""DataprovidersThatDontTestThemselves"") public Iterator<Object[]>  () throws Exception { return TestNGUtil.getDataProviders(""picard""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\TestDataProviders.java,testDataProviderswithDP,"@Test(dataProvider=""DataprovidersThatDontTestThemselves"") public void  (@NoInjection final Method method final Class clazz) throws IllegalAccessException  InstantiationException { Object instance=clazz.newInstance(); Set<Method> methodSet=new HashSet<>();"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\AlleleSubsettingUtilsTest.java,makeUpdatePLsAndADData,"@DataProvider(name=""updatePLsAndADData"") public Object[][]  (){ List<Object[]> tests=new ArrayList<>(); int i=0; final VariantContext vcBase=new VariantContextBuilder(""test"" ""20"" 10 10 AC).make(); final double[] homRefPL=new double[]{0 10 100}; final doub"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\AlleleSubsettingUtilsTest.java,swapAlleleData,"@DataProvider(name="" "") Iterator<Object[]> swapAlleleData(){ List<Object[]> tests=new ArrayList<>(); final VariantContext vcBase=new VariantContextBuilder(""test"" ""20"" 10 10 AC).make(); final Genotype base=new GenotypeBuilder(""NA12878"").DP(10).GQ(100).make"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\AlleleSubsettingUtilsTest.java,testSwapAlleles,"@Test(dataProvider=""swapAlleleData"") void  (final VariantContext ctx final Allele oldAllele final Allele newAllele final VariantContext result final boolean shouldSucceed){ try { final VariantContext newVc=AlleleSubsettingUtils.swapAlleles(ctx oldAllele n"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\AlleleSubsettingUtilsTest.java,testUpdatePLsAndADData,"@Test(dataProvider=""updatePLsAndADData"") public void  (final VariantContext originalVC final VariantContext selectedVC final List<Genotype> expectedGenotypes){ for ( final Genotype genotype : originalVC.getGenotypes()) { GenotypeLikelihoods.initializeAnyp"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\ViewSamTest.java,getCommandLineProgramName,@Override public String  (){ return ViewSam.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\ViewSamTest.java,testHeaderVersion,"@Test public void  () throws Exception { final String oldVersionHeader=""@HD\tVN:1.3\tSO:unsorted""; final File inputSam=File.createTempFile(""ViewSamTest.input."" "".sam""); inputSam.deleteOnExit(); final AsciiWriter writer=new AsciiWriter(new FileOutputStream"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\ViewSamTest.java,testIntervals,"@Test public void  () throws Exception { final File inputSam=new File(""testdata/picard/sam/viewsam_intervals_test.sam""); final File inputIntervalsFile=new File(""testdata/picard/sam/viewsam_intervals_test.interval_list""); final File viewSamOutputFile=File."
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\BedToIntervalListTest.java,doTest,"private void  (final String inputBed final String header) throws IOException  SAMException { final File outputFile=File.createTempFile(""bed_to_interval_list_test."" "".interval_list""); outputFile.deleteOnExit(); final BedToIntervalList program=new BedToIntervalList(); final File inputBedFile=new File(TEST_DATA_DIR inputBed); program.INPUT=inputBedFile; program.SEQUENCE_DICTIONARY=new File(TEST_DATA_DIR header); program.OUTPUT=outputFile; program.UNIQUE=true; program.doWork(); IOUtil.assertFilesEqual(new File(inputBedFile.getAbsolutePath() + "".interval_list"") outputFile); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\BedToIntervalListTest.java,testBedToIntervalList,"@Test(dataProvider="" DataProvider"") public void testBedToIntervalList(final String inputBed) throws IOException { doTest(inputBed ""header.sam""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\BedToIntervalListTest.java,testBedToIntervalListBadSequenceDictionary,"@Test(dataProvider=""testBedToIntervalListSequenceDictionaryBadDataProvider"" expectedExceptions={SAMException.class PicardException.class}) public void  (final String dictionary) throws IOException { doTest(""seq_dict_test.bed"" dictionary); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\BedToIntervalListTest.java,testBedToIntervalListDataProvider,"@DataProvider public Object[][]  (){ return new Object[][]{{""simple.bed""} {""overlapping.bed""} {""extended.bed""} {""one_base_interval.bed""} {""zero_base_interval.bed""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\BedToIntervalListTest.java,testBedToIntervalListOutOfBounds,"@Test(dataProvider="" DataProvider"" expectedExceptions=PicardException.class) public void testBedToIntervalListOutOfBounds(final String inputBed) throws IOException { doTest(inputBed ""header.sam""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\BedToIntervalListTest.java,testBedToIntervalListOutOfBoundsDataProvider,"@DataProvider public Object[][]  (){ return new Object[][]{{""end_after_chr.bed""} {""end_before_chr.bed""} {""missing_chr.bed""} {""start_after_chr.bed""} {""start_before_chr.bed""} {""off_by_one_interval.bed""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\BedToIntervalListTest.java,testBedToIntervalListSequenceDictionary,"@Test(dataProvider="" DataProvider"") public void testBedToIntervalListSequenceDictionary(final String dictionary) throws IOException { doTest(""seq_dict_test.bed"" dictionary); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\BedToIntervalListTest.java,testBedToIntervalListSequenceDictionaryBadDataProvider,"@DataProvider public Object[][]  (){ return new Object[][]{{""seq_dict_test.dictionary.bad""} {""seq_dict_test.dictionary.bad.vcf""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\BedToIntervalListTest.java,testBedToIntervalListSequenceDictionaryDataProvider,"@DataProvider public Object[][]  (){ return new Object[][]{{""seq_dict_test.dictionary.interval_list""} {""seq_dict_test.dictionary.fasta""} {""seq_dict_test.dictionary.dict""} {""seq_dict_test.dictionary.sam""} {""seq_dict_test.dictionary.vcf""}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\DelimitedTextFileWithHeaderIteratorTest.java,basicParsingTest,"@Test public void  () throws Exception { final String[][] data=new String[][]{new String[]{""FOO"" ""BAR"" ""SPLAT""} new String[]{""1"" ""2"" ""3""} new String[]{""a"" ""b"" ""c""} new String[]{""foo"" ""bar"" ""splat""}}; final File tmp=File.createTempFile(""tabbedTextTest."" ""."
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\DelimitedTextFileWithHeaderIteratorTest.java,parsingWithColumnHeadersTest,"@Test public void  () throws Exception { final String[] headers={""STRING"" ""STRING2"" ""NUMBER""}; final String[][] data=new String[][]{headers new String[]{""1"" ""2"" ""3""} new String[]{""a"" ""b"" ""2""} new String[]{""foo"" ""bar"" """"}}; final File tmp=File.createTempFi"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\FifoBufferTest.java,test,"public void  (final double megabytes) throws IOException { final File inputFile=File.createTempFile(""fifo_input."" "".foo""); inputFile.deleteOnExit(); final int nBytes=(int)(megabytes * 1024 * 1024); { final Random random=new Random(nBytes); final BufferedOutputStream out=new BufferedOutputStream(new FileOutputStream(inputFile)); final int bytesPerWrite=127; final byte[] bytes=new byte[bytesPerWrite]; for (int i=0; i < nBytes; i+=bytesPerWrite) { random.nextBytes(bytes); out.write(bytes); } out.close(); } final Md5CalculatingInputStream in=new Md5CalculatingInputStream(new FileInputStream(inputFile) (File)null); final Md5CalculatingOutputStream out=new Md5CalculatingOutputStream(new FileOutputStream(""/dev/null"") (File)null); final PrintStream outStream=new PrintStream(out); final FifoBuffer buffer=new FifoBuffer(in outStream); buffer.BUFFER_SIZE=128 * 1024 * 1024; buffer.doWork(); in.close(); out.close(); final String inputMd5=in.md5(); final String outputMd5=out.md5(); Assert.assertEquals(outputMd5 inputMd5 ""MD5s do not match between input and output.""); inputFile.delete(); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\FifoBufferTest.java,testFifoBuffer,@Test public void  () throws IOException { test(1); test(2); test(3); test(4); test(5); test(6); test(7); test(8); test(9); test(10); test(10.1345); test(150); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,SingleEndAdapter,private  (final String name final String threePrimeAdapter){ this.name=name; this.threePrimeAdapter=threePrimeAdapter; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,createSamRecordWithAdapterSequence,private SAMRecord  (final int readLength final IlluminaAdapterPair adapterPair final int adapterPosition){ final String adapterString=adapterPair.get3PrimeAdapterInReadOrder(); final int replacementLength=Math.min(adapterString.length() readLength - adapterPosition); final String adapterSubstring=adapterString.substring(0 replacementLength); final String readBases=replaceSubstring(makeBogusReadString(readLength) adapterSubstring adapterPosition adapterSubstring.length()); final SAMRecord rec=new SAMRecord(null); rec.setReadString(readBases); return rec; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,get3PrimeAdapter,@Override public String  (){ return threePrimeAdapter; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,get3PrimeAdapterBytes,@Override public byte[]  (){ return StringUtil.stringToBytes(threePrimeAdapter); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,get3PrimeAdapterBytesInReadOrder,@Override public byte[]  (){ return get3PrimeAdapterBytes(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,get3PrimeAdapterInReadOrder,@Override public String  (){ return threePrimeAdapter; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,get5PrimeAdapter,@Override public String  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,get5PrimeAdapterBytes,@Override public byte[]  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,get5PrimeAdapterBytesInReadOrder,@Override public byte[]  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,get5PrimeAdapterInReadOrder,@Override public String  (){ throw new UnsupportedOperationException(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,getClipPairedTestData,"@DataProvider(name=""clipPairedTestData"") public Object[][]  (){ return new Object[][]{{""Basic positive paired test matching"" ""CTACTGGCGCTGAAACTGAGCAGCCAAGCAGATCGG"" ""GCTTGGCTGCTCAGTTTCAGCGCCAGTAGAGATCGG"" IlluminaAdapterPair.INDEXED} {""Basic positive first "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,getClipTestData,"@DataProvider(name=""clipTestData"") public Object[][]  (){ final String FORWARD=IlluminaAdapterPair.PAIRED_END.get3PrimeAdapter(); final String SE_FORWARD=IlluminaAdapterPair.SINGLE_END.get3PrimeAdapter(); final String REVERSE=IlluminaAdapterPair.PAIRED_EN"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,getName,@Override public String  (){ return name; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,makeBogusReadString,private static String  (final int len){ final StringBuilder builder=new StringBuilder(len); final Map<Character Character> nextChar=new HashMap<Character Character>(); nextChar.put('A' 'C'); nextChar.put('C' 'G'); nextChar.put('G' 'T'); nextChar.put('T' 'A'); for (char curChar='A'; true; curChar=nextChar.get(curChar)) { for (int i=0; i < 6; ++i) { if (builder.length() == len) return builder.toString(); builder.append(curChar); } } } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,patchAdapterSubsequenceIntoRead,private static String  (final String read final String adapter final int length){ return replaceSubstring(read adapter.substring(0 length) read.length() - length read.length()); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,replaceSubstring,private static String  (final String s final String replacement final int position final int charsToReplace){ final StringBuilder sb=new StringBuilder(s); sb.replace(position position + charsToReplace replacement); return sb.toString(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,testAdapterInAllReadPositions,"@Test(dataProvider="" DataProvider"") public void testAdapterInAllReadPositions(final int readLength){ final int minAdapterLength=6; for ( final IlluminaAdapterPair adapterPair : IlluminaAdapterPair.values()) { final AdapterMarker marker=new AdapterMarker(a"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,testAdapterInAllReadPositionsDataProvider,"@DataProvider(name="" "") public Object[][] testAdapterInAllReadPositionsDataProvider(){ return new Object[][]{{100} {36}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,testAdapterListTruncation,"@Test(dataProvider="" DataProvider"") public void testAdapterListTruncation(final IlluminaAdapterPair adapterPair){ final int thresholdForTruncatingAdapterList=20; final int readLength=100; final AdapterMarker marker=new AdapterMarker(IlluminaUtil.IlluminaA"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,testAdapterListTruncationDataProvider,"@DataProvider(name="" "") public Object[][] testAdapterListTruncationDataProvider(){ Object[][] ret=new Object[IlluminaAdapterPair.values().length][]; for (int i=0; i < ret.length; ++i) { ret[i]=new Object[]{IlluminaAdapterPair.values()[i]}; } return ret; }"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,testAdapterTruncation,@Test public void  (){ final AdapterMarker marker=new AdapterMarker(30 IlluminaUtil.IlluminaAdapterPair.INDEXED IlluminaUtil.IlluminaAdapterPair.DUAL_INDEXED IlluminaUtil.IlluminaAdapterPair.NEXTERA_V2 IlluminaUtil.IlluminaAdapterPair.FLUIDIGM); Assert.as
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,testBasicClip,"@Test(dataProvider=""clipTestData"") public void  (final String testName final String read final String clip final int minMatch final double errRate final int expected){ final byte[] r=(read == null) ? null : StringUtil.stringToBytes(read); final byte[] c=("
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,testOneSidedMatchSupersededByTwoSidedMatch,@Test public void  (){ final int readLength=36; final int adapterLength=30; final String read1=patchAdapterSubsequenceIntoRead(makeBogusReadString(readLength) IlluminaAdapterPair.SINGLE_END.get3PrimeAdapterInReadOrder() adapterLength); final String read2=
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,testPairedEndClip,"@Test(dataProvider=""clipPairedTestData"") public void  (final String testName final String read1 final String read2 final AdapterPair expected){ final SAMRecord rec1=new SAMRecord(new SAMFileHeader()); rec1.setReadString(read1); rec1.setFirstOfPairFlag(tru"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ClippingUtilityTest.java,testSingleEndSamRecordClip,"@Test(dataProvider=""clipTestData"") public void  (final String testName final String read final String clip final int minMatch final double errRate final int expected){ if (read == null) return; final SingleEndAdapter adapter=new SingleEndAdapter(testName "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListScattererTest.java,Testcase,private  (final IntervalList source final int scatterWidth final IntervalListScatterer.Mode mode final List<IntervalList> expectedScatter){ this.source=source; this.expectedScatter=expectedScatter; this.scatterWidth=scatterWidth; this.mode=mode; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListScattererTest.java,composeIntervalList,"private static IntervalList  (final IntervalList source final String chromosome final int... segmentsByPair){ final IntervalList intervals=new IntervalList(source.getHeader()); for (int i=0; i < segmentsByPair.length; i+=2) { final Interval parentInterval=lookupIntervalContainingLocus(source chromosome segmentsByPair[i]); intervals.add(new Interval(""1"" segmentsByPair[i] segmentsByPair[i + 1] parentInterval.isNegativeStrand() parentInterval.getName())); } return intervals; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListScattererTest.java,lookupIntervalContainingLocus,private static Interval  (final IntervalList source final String chromosome final int startIndex){ for ( final Interval interval : source) { if (interval.getContig().equals(chromosome) && startIndex >= interval.getStart() && startIndex <= interval.getEnd()) { return interval; } } throw new NoSuchElementException(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListScattererTest.java,testScatter,"@Test(dataProvider="" Testcases"") public void testScatter(final Testcase tc){ final IntervalListScatterer scatterer=new IntervalListScatterer(tc.mode); final List<IntervalList> scatter=scatterer.scatter(tc.source tc.scatterWidth); Assert.assertEquals(scatt"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListScattererTest.java,testScatterTestcases,@DataProvider public static Object[][]  (){ final Object[][] objects=new Object[testcases.size()][]; for (int i=0; i < objects.length; i++) { objects[i]=new Object[]{testcases.get(i)}; } return objects; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListScattererTest.java,toString,"@Override public String  (){ return ""Testcase{"" + ""scatterWidth="" + scatterWidth + ""  mode=""+ mode+ '}'; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IlluminaUtilTest.java,byteBuffersSizeCopy,public byte[][]  (byte[][] bytes){ byte[][] outBytes=new byte[bytes.length][]; for (int i=0; i < bytes.length; i++) { outBytes[i]=new byte[bytes[i].length]; } return outBytes; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IlluminaUtilTest.java,iToB,public static final byte[]  (int[] intVals){ byte[] byteVals=new byte[intVals.length]; for (int i=0; i < byteVals.length; i++) { byteVals[i]=(byte)intVals[i]; } return byteVals; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IlluminaUtilTest.java,performanceTestGetTileFromReadName,"@Test public void  (){ final int ITERATIONS=5000000; final long startTime=System.currentTimeMillis(); for (int i=0; i < ITERATIONS; ++i) { final Integer tile=IlluminaUtil.getTileFromReadName(""300WFAAXX090909:1:1:1024:978#0/1""); if (tile == null || tile !="
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IlluminaUtilTest.java,readNames,"@DataProvider(name="" "") public Object[][] readNames(){ return new Object[][]{new Object[]{""300WFAAXX:1:119:1024:978#0/1"" 119} new Object[]{""300WFAAXX090909:1:1:1024:978#0/1"" 1} new Object[]{""FOO"" null} new Object[]{""FOO:BAR_splat"" null}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IlluminaUtilTest.java,solexaQualStrToPhredsToPhreds,"@DataProvider(name=""solexaQualStrToPhreds"") public Object[][]  (){ return new Object[][]{new Object[]{""x@Axy"" + ((char)156) + ((char)157)+ ((char)0)+ ((char)1)+ ""?"" new byte[][]{new byte[]{} iToB(new int[]{56}) iToB(new int[]{0 1 56 57 92 93}) iToB(new in"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IlluminaUtilTest.java,testFindTileInReadName,"@Test(dataProvider=""readNames"") public void  (final String readName final Integer tile){ final Integer otherTile=IlluminaUtil.getTileFromReadName(readName); Assert.assertEquals(otherTile tile ""Tile numbers do not match for read name: "" + readName); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListToBedTest.java,testConvertToBed,"@Test public void  () throws Exception { final IntervalListToBed program=new IntervalListToBed(); final File tmp=File.createTempFile(""interval_list_to_bed_test_output"" "".bed""); tmp.deleteOnExit(); final String[] args={""INPUT="" + INTERVAL_LIST.getAbsoluteP"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\sam\util\SamTestUtil.java,countSamTotalRecord,public static long  (final File samFile){ final SamReader reader=SamReaderFactory.make().open(samFile); assert reader.hasIndex(); long total=0; for (int i=0; i < reader.getFileHeader().getSequenceDictionary().size(); i++) { total+=reader.indexing().getIndex().getMetaData(i).getAlignedRecordCount(); total+=reader.indexing().getIndex().getMetaData(i).getUnalignedRecordCount(); } return total; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,dataTestHaplotypeProbabilitiesFromSequenceAddToProbs,"@DataProvider(name=""dataTestMissingContigInReference"") public Object[][]  (){ return new Object[][]{{false LiftoverVcf.EXIT_CODE_WHEN_CONTIG_NOT_IN_REFERENCE} {true 0}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,dataTestWriteOriginalPosition,"@DataProvider(name="" "") public Object[][] dataTestWriteOriginalPosition(){ return new Object[][]{{false} {true}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,getCommandLineProgramName,public String  (){ return LiftoverVcf.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,indelFlipData,"@DataProvider(name="" "") public Iterator<Object[]> indelFlipData(){ final Allele RefCAA=Allele.create(""CAA"" true); final Allele RefGTT=Allele.create(""GTT"" true); final Allele RefACGT=Allele.create(""ACGT"" true); final Allele RefAACG=Allele.create(""AACG"" tru"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,indelFlipDataWithOriginalAllele,"@DataProvider(name="" "") public Iterator<Object[]> indelFlipDataWithOriginalAllele(){ final List<Object[]> tests=new ArrayList<>(); indelFlipData().forEachRemaining(x -> { if (x[2] == null) { tests.add(x); } else { VariantContext source=(VariantContext)x[0"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListToolsTest.java,ActionsTest,@DataProvider public Iterator<Object[]>  (){ return Arrays.stream(IntervalListTools.Action.values()).map(a -> new Object[]{a}).iterator(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListToolsTest.java,actionAndTotalBasesData,@DataProvider public Object[][]  (){ return new Object[][]{{IntervalListTools.Action.CONCAT 341 4} {IntervalListTools.Action.UNION 201 2} {IntervalListTools.Action.INTERSECT 140 2} {IntervalListTools.Action.SUBTRACT 60 2} {IntervalListTools.Action.SYMDIFF
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListToolsTest.java,actionAndTotalBasesWithInvertData,@DataProvider public Object[][]  (){ final long totalBasesInDict=IntervalList.fromFile(secondInput).getHeader().getSequenceDictionary().getReferenceLength(); final int totalContigsInDict=IntervalList.fromFile(secondInput).getHeader().getSequenceDictionary
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListToolsTest.java,deleteTempDirs,@AfterTest void  (){ dirsToDelete.forEach(TestUtil::recursiveDelete); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListToolsTest.java,getCommandLineProgramName,@Override public String  (){ return IntervalListTools.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListToolsTest.java,testActions,"@Test(dataProvider=""actionAndTotalBasesData"") public void  (final IntervalListTools.Action action final long bases final int intervals) throws IOException { final IntervalList il=tester(action); Assert.assertEquals(il.getBaseCount() bases ""unexpected numb"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListToolsTest.java,testActionsWithInvert,"@Test(dataProvider=""actionAndTotalBasesWithInvertData"") public void  (final IntervalListTools.Action action final long bases final int intervals) throws IOException { final IntervalList il=tester(action true); Assert.assertEquals(il.getBaseCount() bases """
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListToolsTest.java,testAllActions,"@Test(dataProvider=""ActionsTest"") public void  (final IntervalListTools.Action action) throws IOException { final File ilOut=File.createTempFile(""IntervalListTools"" ""interval_list""); ilOut.deleteOnExit(); final List<String> args=new ArrayList<>(); args.ad"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListToolsTest.java,testScatter,"@Test(dataProvider="" Testcases"") public void testScatter(final IntervalListScattererTest.Testcase tc) throws IOException { final File ilOutDir=IOUtil.createTempDir(""IntervalListTools"" ""lists""); dirsToDelete.add(ilOutDir); final IntervalListScatterer scatt"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListToolsTest.java,testScatterTestcases,@DataProvider public static Object[][]  (){ final Object[][] objects=new Object[IntervalListScattererTest.testcases.size()][]; for (int i=0; i < objects.length; i++) { objects[i]=new Object[]{IntervalListScattererTest.testcases.get(i)}; } return objects; 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListToolsTest.java,testSecondInputValidation,@Test public void  (){ IntervalListTools intervalListTools=new IntervalListTools(); String[] errors=intervalListTools.customCommandLineValidation(); Assert.assertNull(errors); intervalListTools.SECOND_INPUT=new ArrayList<>(); errors=intervalListTools.cust
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\IntervalListToolsTest.java,tester,"private IntervalList  (IntervalListTools.Action action boolean invert) throws IOException { final File ilOut=File.createTempFile(""IntervalListTools"" ""interval_list""); ilOut.deleteOnExit(); final List<String> args=new ArrayList<>(); args.add(""ACTION="" + action.toString()); args.add(""INPUT="" + scatterable); if (action.takesSecondInput) { args.add(""SECOND_INPUT="" + secondInput); } else { args.add(""INPUT="" + secondInput); } if (invert) { args.add(""INVERT=true""); } args.add(""OUTPUT="" + ilOut); Assert.assertEquals(runPicardCommandLine(args) 0); return IntervalList.fromFile(ilOut); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,indelNoFlipData,"@DataProvider(name="" "") public Iterator<Object[]> indelNoFlipData(){ final VariantContextBuilder builder=new VariantContextBuilder().source(""test1"").chr(""chr1""); final VariantContextBuilder result_builder=new VariantContextBuilder().source(""test1"").chr(""c"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,leftAlignAllelesData,"@DataProvider(name="" "") public Iterator<Object[]> leftAlignAllelesData(){ final Allele RefG=Allele.create(""G"" true); final Allele A=Allele.create(""A"" false); final Allele RefA=Allele.create(""A"" true); final Allele RefC=Allele.create(""C"" true); final Allel"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,liftoverReverseStrand,"@DataProvider(name="" "") public Object[][] liftoverReverseStrand(){ return new Object[][]{{""testLiftoverBiallelicIndels.vcf"" 5 0} {""testLiftoverMultiallelicIndels.vcf"" 0 2} {""testLiftoverFailingVariants.vcf"" 3 0}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,noCallAndSymbolicData,"@DataProvider(name="" "") public Iterator<Object[]> noCallAndSymbolicData(){ final VariantContextBuilder builder=new VariantContextBuilder().source(""test1"").chr(""chr1""); final VariantContextBuilder result_builder=new VariantContextBuilder().source(""test1"")."
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,snpWithChangedRef,"@Test(dataProvider="" "") public void snpWithChangedRef(final VariantContext source final ReferenceSequence reference final VariantContext result){ final LiftOver liftOver=new LiftOver(POSITIVE_CHAIN_FILE); final Interval originalLocus=new Interval(source.g"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,teardown,@AfterClass public void  (){ IOUtil.deleteDirectoryTree(OUTPUT_DATA_PATH); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,testChangingInfoFields,"@Test public void  (){ final String filename=""testLiftoverFailingVariants.vcf""; final File liftOutputFile=new File(OUTPUT_DATA_PATH ""lift-delete-me.vcf""); final File rejectOutputFile=new File(OUTPUT_DATA_PATH ""reject-delete-me.vcf""); final File input=new "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,testChangingTagArguments,"@Test public void  (){ final String filename=""testLiftoverFailingVariants.vcf""; final File liftOutputFile=new File(OUTPUT_DATA_PATH ""lift-delete-me.vcf""); final File rejectOutputFile=new File(OUTPUT_DATA_PATH ""reject-delete-me.vcf""); final File input=new "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,testFlipIndel,"@Test(dataProvider=""indelFlipData"") public void  (final VariantContext source final ReferenceSequence reference final VariantContext result){ final LiftOver liftOver=new LiftOver(CHAIN_FILE); final Interval originalLocus=new Interval(source.getContig() so"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,testFlipIndelWithOriginalAlleles,"@Test(dataProvider=""indelFlipDataWithOriginalAllele"") public void  (final VariantContext source final ReferenceSequence reference final VariantContext result){ final LiftOver liftOver=new LiftOver(CHAIN_FILE); final Interval originalLocus=new Interval(sou"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,testLeftAlignVariants,"@Test(dataProvider=""leftAlignAllelesData"") public void  (final VariantContext source final ReferenceSequence reference final VariantContext result){ VariantContextBuilder vcb=new VariantContextBuilder(source); LiftoverUtils.leftAlignVariant(vcb source.get"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,testLiftOverNoCallAndSymbolic,"@Test(dataProvider=""noCallAndSymbolicData"") public void  (final LiftOver liftOver final VariantContext source final VariantContext result final boolean expectReversed){ final Interval target=liftOver.liftOver(new Interval(source.getContig() source.getStar"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,testLiftOverSimpleIndels,"@Test(dataProvider=""indelNoFlipData"") public void  (final LiftOver liftOver final ReferenceSequence reference final VariantContext source final VariantContext result){ final Interval target=liftOver.liftOver(new Interval(source.getContig() source.getStart"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,testMissingContigInReference,"@Test(dataProvider=""dataTestMissingContigInReference"") public void  (final boolean warnOnMissingContext final int expectedReturnCode){ final File liftOutputFile=new File(OUTPUT_DATA_PATH ""lift-delete-me.vcf""); final File rejectOutputFile=new File(OUTPUT_D"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,testReverseComplementFailureDoesNotErrorOut,"@Test public void  (){ final VariantContextBuilder builder=new VariantContextBuilder().source(""test"").loc(""chr1"" 1 4); final Allele originalRef=Allele.create(""CCCC"" true); final Allele originalAlt=Allele.create(""C"" false); builder.alleles(Arrays.asList(or"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,testReverseComplementedIndels,"@Test(dataProvider=""liftoverReverseStrand"") public void  (final String filename final int expectedPassing final int expectedFailing){ final File liftOutputFile=new File(OUTPUT_DATA_PATH ""lift-delete-me.vcf""); final File rejectOutputFile=new File(OUTPUT_DA"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,testWriteOriginalPosition,"@Test(dataProvider=""dataTestWriteOriginalPosition"") public void  (final boolean shouldWriteOriginalPosition){ final File liftOutputFile=new File(OUTPUT_DATA_PATH ""lift-delete-me.vcf""); final File rejectOutputFile=new File(OUTPUT_DATA_PATH ""reject-delete-m"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,testWriteVcfWithFlippedAlleles,"@Test public void  () throws IOException { final File liftOutputFile=new File(OUTPUT_DATA_PATH ""lift-delete-me.vcf""); final File rejectOutputFile=new File(OUTPUT_DATA_PATH ""reject-delete-me.vcf""); final File input=new File(TEST_DATA_PATH ""testLiftoverMism"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverVcfTest.java,testWriteVcfWithFlippedAllelesNegativeChain,"@Test public void  () throws IOException { final File liftOutputFile=new File(OUTPUT_DATA_PATH ""lift-delete-me.vcf""); final File rejectOutputFile=new File(OUTPUT_DATA_PATH ""reject-delete-me.vcf""); final File input=new File(TEST_DATA_PATH ""testLiftoverMism"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverUtilsTest.java,allelesToStringData,"@DataProvider public Iterator<Object[]>  (){ final List<Object[]> tests=new ArrayList<>(); tests.add(new Object[]{Arrays.asList(Allele.create(""A"" true) Allele.create(""G"")) Arrays.asList(""A"" ""G"")}); tests.add(new Object[]{Arrays.asList(Allele.create(""A"" fa"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverUtilsTest.java,swapRefAltData,"@DataProvider public Object[][]  (){ String testName=""test1""; final List<Object[]> tests=new ArrayList<>(); VariantContextBuilder builder=new VariantContextBuilder(testName ""chr1"" 2 2 Arrays.asList(RefA C)); VariantContextBuilder resultBuilder=new Variant"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverUtilsTest.java,testAllelesToString,"@Test(dataProvider=""allelesToStringData"") public void  (final List<Allele> input final List<String> output){ Assert.assertEquals(LiftoverUtils.allelesToStringList(input) output); List<Allele> restoredAlleles=output.stream().map(Allele::create).collect(Col"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\LiftoverUtilsTest.java,testSwapRefAlt,"@Test(dataProvider=""swapRefAltData"") public void  (final VariantContext swapMe final VariantContext expected){ VcfTestUtils.assertEquals(LiftoverUtils.swapRefAlt(swapMe annotationsToSwap annotationsToDrop) expected); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\MathUtilTest.java,assertEquals,"private void  (final double[] actual final double[] expected){ Assert.assertEquals(actual.length expected.length ""Arrays do not have equal lengths""); for (int i=0; i < actual.length; ++i) { Assert.assertEquals(actual[i] expected[i] ""Array differ at position "" + i); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\MathUtilTest.java,divideDoubleTestCases,@DataProvider public Object[][]  (){ return new Object[][]{new Object[]{15.0 3.0 5.0} new Object[]{15.0 0.0 0.0}}; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\MathUtilTest.java,divideMethodFailTestCases,@DataProvider public Object[][]  (){ return new Object[][]{new Object[]{new double[]{1 2 3 4} new double[]{2 3 4}} new Object[]{new double[]{100} new double[]{}}}; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\MathUtilTest.java,divideMethodTestCases,@DataProvider public Object[][]  (){ return new Object[][]{new Object[]{new double[]{1 2 3 4} new double[]{2 3 4 -5} new double[]{.5 2.0 / 3 3.0 / 4 -4.0 / 5}} new Object[]{new double[]{100} new double[]{200} new double[]{.5}} new Object[]{new double[]{0 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\MathUtilTest.java,logMathTest,@Test public void  (){ Assert.assertEquals(MathUtil.LOG_10_MATH.getLogValue(10) 1d 0.00001d); Assert.assertEquals(MathUtil.LOG_10_MATH.getNonLogValue(1) 10d 0.00001d); Assert.assertEquals(MathUtil.LOG_10_MATH.mean(5 5 5) 5d 0.00001d); Assert.assertEquals(
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\MathUtilTest.java,seqMethodTestCases,@DataProvider public Object[][]  (){ return new Object[][]{new Object[]{0d 5d 1d new double[]{0 1 2 3 4 5}} new Object[]{0d 0.5d 0.1d new double[]{0 0.1 0.2 0.3 0.4 0.5}} new Object[]{0d 0.5d 0.11d new double[]{0 0.11 0.22 0.33 0.44}} new Object[]{50d 55d
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\MathUtilTest.java,testDivide,"@Test(dataProvider=""divideMethodTestCases"") public void  (final double[] numerators final double[] denominators final double[] expected){ assertEquals(divide(numerators denominators) expected); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\MathUtilTest.java,testDivideDouble,"@Test(dataProvider=""divideDoubleTestCases"") public void  (final double numerator final double denominator final double expected){ Assert.assertEquals(MathUtil.divide(numerator denominator) expected); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\MathUtilTest.java,testDivideFail,"@Test(dataProvider=""divideMethodFailTestCases"" expectedExceptions=RuntimeException.class) public void  (final double[] lhs final double[] rhs){ divide(lhs rhs); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\MathUtilTest.java,testSeqGeneration,"@Test(dataProvider=""seqMethodTestCases"") public void  (final double from final double to final double by final double[] expected){ final double[] actual=MathUtil.seq(from to by); Assert.assertEquals(actual.length expected.length); for (int i=0; i < expect"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\GraphUtilsTest.java,secondTest,@Test public void  (){ GraphUtils.Graph<Integer> graph=new GraphUtils.Graph<>(); graph.addEdge(1 3); graph.addEdge(2 3); graph.addEdge(0 2); graph.addEdge(4 3); graph.addEdge(5 6); graph.addEdge(7 6); graph.addNode(8); Map<Integer Integer> clusters=graph.
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\GraphUtilsTest.java,simpleTest,@Test public void  (){ GraphUtils.Graph<Integer> graph=new GraphUtils.Graph<>(); graph.addEdge(5 6); graph.addEdge(5 8); graph.addEdge(7 9); graph.addEdge(7 8); graph.addEdge(4 2); graph.addEdge(1 2); graph.addEdge(3 1); Map<Integer Integer> clusters=grap
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ScatterIntervalsByNsTest.java,getSequence,@Override public ReferenceSequence  (final String contig){ if (contig.equals(record.getSequenceName())) { return new ReferenceSequence(record.getSequenceName() 0 referenceString.getBytes()); } else { return null; } } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ScatterIntervalsByNsTest.java,getSequenceDictionary,@Override public SAMSequenceDictionary  (){ return dictionary; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ScatterIntervalsByNsTest.java,getSubsequenceAt,@Override public ReferenceSequence  (final String contig final long start final long stop){ return null; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ScatterIntervalsByNsTest.java,isIndexed,@Override public boolean  (){ return false; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ScatterIntervalsByNsTest.java,nextSequence,@Override public ReferenceSequence  (){ if (!done) { done=true; return getSequence(record.getSequenceName()); } return null; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ScatterIntervalsByNsTest.java,reset,@Override public void  (){ done=false; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ScatterIntervalsByNsTest.java,testSegregate,"@DataProvider(name="" "") public Object[][] testSegregate(){ return new Object[][]{new Object[]{""NNNNNAAAAANNNNNN"" 1 CollectionUtil.makeList(new Interval(""fake1"" 1 5) new Interval(""fake1"" 6 10) new Interval(""fake1"" 11 16))} new Object[]{""NNNNNAAAAANNNNNN"" 5"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ScatterIntervalsByNsTest.java,testSegregateReference,"@Test(dataProvider=""testSegregate"") public void  (final String referenceString final int maxNmerToMerge final List<Interval> result) throws Exception { final SAMSequenceRecord record=new SAMSequenceRecord(""fake1"" referenceString.length()); final SAMSequen"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\ScatterIntervalsByNsTest.java,toString,@Override public String  (){ return null; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\MergingIteratorTest.java,QueueBackedIterator, (final Queue<T> queue){ this.backing=queue.iterator(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\MergingIteratorTest.java,compare,@Override public int  (Integer integer Integer integer2){ return integer - integer2; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\MergingIteratorTest.java,hasNext,@Override public boolean  (){ return backing.hasNext(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\MergingIteratorTest.java,next,@Override public T  (){ return backing.next(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\MergingIteratorTest.java,remove,@Override public void  (){ backing.remove(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\MergingIteratorTest.java,testIteratorsOfUnevenLength,@Test public void  (){ final Queue<Integer> queueOne=new LinkedList<Integer>(); queueOne.add(1); queueOne.add(3); queueOne.add(5); queueOne.add(7); queueOne.add(9); queueOne.add(11); queueOne.add(13); final Queue<Integer> queueTwo=new LinkedList<Integer>(
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\MergingIteratorTest.java,testOrderingAndCompleteness,@Test public void  (){ final Queue<Integer> queueOne=new LinkedList<Integer>(); queueOne.add(1); queueOne.add(3); queueOne.add(5); final Queue<Integer> queueTwo=new LinkedList<Integer>(); queueTwo.add(2); queueTwo.add(4); queueTwo.add(6); final Queue<Inte
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\MergingIteratorTest.java,testOutOfOrderIterators,@Test(expectedExceptions=IllegalStateException.class) public void  (){ final Queue<Integer> queueOne=new LinkedList<Integer>(); queueOne.add(1); queueOne.add(3); final Queue<Integer> queueTwo=new LinkedList<Integer>(); queueTwo.add(4); queueTwo.add(2); fi
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\QuerySortedReadPairIteratorUtilTest.java,testBasicHalfmappedReadPair,"@Test public void  (){ SAMRecordSetBuilder builder=new SAMRecordSetBuilder(false SAMFileHeader.SortOrder.queryname); builder.setReadLength(READ_LENGTH); builder.addPair(""halfmapped_paired"" 1 1 31 false true ""20M"" ""20M"" true false 20); PeekableIterator<SAM"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\QuerySortedReadPairIteratorUtilTest.java,testBasicPairedRead,"@Test public void  (){ SAMRecordSetBuilder builder=new SAMRecordSetBuilder(false SAMFileHeader.SortOrder.queryname); builder.setReadLength(READ_LENGTH); builder.addPair(""mapped_paired"" 1 1 31); PeekableIterator<SAMRecord> iterator=new PeekableIterator<SAM"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\QuerySortedReadPairIteratorUtilTest.java,testBasicUnmappedReadPair,"@Test public void  (){ SAMRecordSetBuilder builder=new SAMRecordSetBuilder(false SAMFileHeader.SortOrder.queryname); builder.setReadLength(READ_LENGTH); builder.addUnmappedPair(""unmapped_paired""); PeekableIterator<SAMRecord> iterator=new PeekableIterator<"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\QuerySortedReadPairIteratorUtilTest.java,testFragmentNoReadPair,"@Test public void  (){ SAMRecordSetBuilder builder=new SAMRecordSetBuilder(false SAMFileHeader.SortOrder.queryname); builder.setReadLength(READ_LENGTH); builder.addFrag(""mapped_frag_a"" 1 1 false); builder.addFrag(""mapped_frag_b"" 1 1 false); PeekableIterat"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\RExecutorTest.java,testFailingRScript,"@Test public void  (){ Assert.assertTrue(RExecutor.executeFromClasspath(""failing.R"") != 0); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\RExecutorTest.java,testPassingRScript,"@Test public void  (){ Assert.assertTrue(RExecutor.executeFromClasspath(""passing.R"") == 0); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\RExecutorTest.java,testRScriptNotFound,"@Test(expectedExceptions=IllegalArgumentException.class) public void  (){ RExecutor.executeFromClasspath(""asdlfjasl""); Assert.fail(); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TabbedTextFileWithHeaderParserTest.java,basicParsingTest,"@Test public void  () throws Exception { final String[][] data=new String[][]{new String[]{""FOO"" ""BAR"" ""SPLAT""} new String[]{""1"" ""2"" ""3""} new String[]{""a"" ""b"" ""c""} new String[]{""foo"" ""bar"" ""splat""}}; final File tmp=File.createTempFile(""tabbedTextTest."" ""."
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TabbedTextFileWithHeaderParserTest.java,parsingWithColumnHeadersTest,"@Test public void  () throws Exception { final String[][] data=new String[][]{new String[]{""1"" ""2"" ""3""} new String[]{""a"" ""b"" ""2""} new String[]{""foo"" ""bar"" """"}}; final String[] headers={""STRING"" ""STRING2"" ""NUMBER""}; final File tmp=File.createTempFile(""tabb"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TestNGUtil.java,assertEqualDoubleArrays,"public static void  (final double[] lhs final double[] rhs final double accuracy){ Assert.assertNotNull(lhs); Assert.assertNotNull(rhs); if (accuracy <= 0) throw new IllegalArgumentException(""Accuracy must be positive.""); Assert.assertEquals(lhs.length rhs.length ""Arrays not same length: "" + lhs.length + "" vs. ""+ rhs.length); for (int i=0; i < lhs.length; ++i) { Assert.assertTrue(compareDoubleWithAccuracy(lhs[i] rhs[i] accuracy) ""Arrays disagree at position "" + i + "": ""+ lhs[i]+ "" vs. ""+ rhs[i]+ "". ""); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TestNGUtil.java,assertGreaterThan,"static public void  (final double lhs final double rhs){ Assert.assertTrue(lhs > rhs String.format(""Expected inequality is not true: %g > %g"" lhs rhs)); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TestNGUtil.java,assertLessThan,"static public void  (final double lhs final double rhs){ Assert.assertTrue(lhs < rhs String.format(""Expected inequality is not true: %g < %g"" lhs rhs)); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TestNGUtil.java,compareDoubleWithAccuracy,"public static boolean  (final double lhs final double rhs final double accuracy){ if (accuracy <= 0) throw new IllegalArgumentException(""Accuracy must be positive.""); return abs(lhs - rhs) / (abs(lhs) + abs(rhs) + EPSILON) < accuracy; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TestNGUtil.java,doMetaTest,"@Test(dataProvider=""testcases"") public void  (final TestClazz testcase){ doTest(testcase); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\UnsignedTypeUtilTest.java,uByteData,"@DataProvider(name="" "") public Object[][] uByteData(){ return new Object[][]{{(byte)0xFF 255} {(byte)0xFE 254} {(byte)0x80 128} {(byte)0x7F 127} {(byte)0x70 112} {(byte)0x02 2} {(byte)0x01 1} {(byte)0x00 0}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\UnsignedTypeUtilTest.java,uByteToIntTest,"@Test(dataProvider=""uByteData"") public void  (final byte unsignedByte final int expectedInt){ Assert.assertEquals(UnsignedTypeUtil.uByteToInt(unsignedByte) expectedInt); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\UnsignedTypeUtilTest.java,uByteToShortTest,"@Test(dataProvider=""uByteData"") public void  (final byte unsignedByte final int expectedInt){ final short expectedShort=(short)expectedInt; Assert.assertEquals(UnsignedTypeUtil.uByteToShort(unsignedByte) expectedShort); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\UnsignedTypeUtilTest.java,uIntData,"@DataProvider(name="" "") public Object[][] uIntData(){ return new Object[][]{{0xFFFFFFFF 4294967295L} {0xFFFFFFFE 4294967294L} {0x81014000 2164342784L} {0x7FFFFFFF 2147483647L} {0x10502100 273686784L} {0x00000002 2L} {0x00000001 1L} {0x00000000 0L}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\UnsignedTypeUtilTest.java,uIntToLongTest,"@Test(dataProvider=""uIntData"") public void  (final int unsignedInt final long expectedLong){ Assert.assertEquals(UnsignedTypeUtil.uIntToLong(unsignedInt) expectedLong); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\UnsignedTypeUtilTest.java,uShortData,"@DataProvider(name="" "") public Object[][] uShortData(){ return new Object[][]{{(short)0xFFFF 65535} {(short)0xFFFE 65534} {(short)0x8021 32801} {(short)0x7FFF 32767} {(short)0x5545 21829} {(short)0x0002 2} {(short)0x0001 1} {(short)0x0000 0}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\UnsignedTypeUtilTest.java,uShortToIntTest,"@Test(dataProvider=""uShortData"") public void  (final short unsignedShort final int expectedInt){ Assert.assertEquals(UnsignedTypeUtil.uShortToInt(unsignedShort) expectedInt); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\AbstractVcfMergingClpTester.java,getContigPosition,"static String  (final VariantContext context){ return context.getContig() + ""-"" + Integer.toString(context.getStart()); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TextFileParsersTest.java,getBasicInputParserData,"@DataProvider(name=""basicInputParserData"") private Object[][]  (){ return new Object[][]{{new File(testFile1)} {IOUtil.openFileForReading(new File(testFile1))}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TextFileParsersTest.java,getFileName,public String  (){ return null; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TextFileParsersTest.java,getLeadingWhiteSpaceData,"@DataProvider(name=""leadingWhiteSpaceData"") private Object[][]  (){ return new Object[][]{{new File(testFile2)} {IOUtil.openFileForReading(new File(testFile2))}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TextFileParsersTest.java,getMultiFileParsingData,"@DataProvider(name=""multiFileParsingData"") private Object[][]  (){ return new Object[][]{{new File(testFile1) new File(testFile1)} {IOUtil.openFileForReading(new File(testFile1)) IOUtil.openFileForReading(new File(testFile1))}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TextFileParsersTest.java,getNoGroupingData,"@DataProvider(name=""noGroupingData"") private Object[][]  (){ return new Object[][]{{new File(testFile3)} {IOUtil.openFileForReading(new File(testFile3))}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TextFileParsersTest.java,getTabbedData,"@DataProvider(name=""tabbedData"") private Object[][]  (){ return new Object[][]{{new File(testFile4)} {IOUtil.openFileForReading(new File(testFile4))}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TextFileParsersTest.java,getTooManyWordsData,"@DataProvider(name=""tooManyWordsData"") private Object[][]  (){ return new Object[][]{{new File(testFile1)} {IOUtil.openFileForReading(new File(testFile1))}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TextFileParsersTest.java,getWordCountCalculationData,"@DataProvider(name=""data"") private Object[][]  (){ return new Object[][]{{""1\t2\t3"" false ""Tabs with all fields filled.""} {""1\t2\t"" false ""Tabs with no final field.""} {""\t2\t3"" false ""Tabs with no first field.""} {""\t2\t"" false ""Tabs with no first or final"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TextFileParsersTest.java,isDelimiter,protected boolean  (final byte b){ for (int i=0; i < delimiters.length; i++) { if (b == delimiters[i]) { return true; } } return false; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TextFileParsersTest.java,readNextLine,protected byte[]  (){ return new byte[0]; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TextFileParsersTest.java,setDelimiter,public void  (String delim){ delimiters=delim.toCharArray(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TextFileParsersTest.java,testMultiFileParsing,"@Test(dataProvider=""multiFileParsingData"") public void  (Object fileOrStream1 Object fileOrStream2) throws IOException { FormatUtil format=new FormatUtil(); List<String> expected=new ArrayList<String>(); if (fileOrStream1 instanceof File) { BufferedReader"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TextFileParsersTest.java,testTabbedFileParser,"@Test(dataProvider=""tabbedData"") public void  (Object fileOrStream){ TabbedInputParser parser=fileOrStream instanceof File ? new TabbedInputParser(false (File)fileOrStream) : new TabbedInputParser(false (InputStream)fileOrStream); while (parser.hasNext())"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TextFileParsersTest.java,testTextFileParser,"@Test(dataProvider=""basicInputParserData"") public void  (Object fileOrStream) throws IOException { FormatUtil format=new FormatUtil(); List<String> expected=new ArrayList<String>(); if (fileOrStream instanceof File) { BufferedReader reader=new BufferedRea"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TextFileParsersTest.java,testTextFileParserLeadingWhitespace,"@Test(dataProvider=""leadingWhiteSpaceData"") public void  (Object fileOrStream){ BasicInputParser parser=fileOrStream instanceof File ? new BasicInputParser(true (File)fileOrStream) : new BasicInputParser(true (InputStream)fileOrStream); while (parser.hasN"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TextFileParsersTest.java,testTextFileParserNoGrouping,"@Test(dataProvider=""noGroupingData"") public void  (Object fileOrStream){ BasicInputParser parser=fileOrStream instanceof File ? new BasicInputParser(true (File)fileOrStream) : new BasicInputParser(true (InputStream)fileOrStream); parser.setTreatGroupedDel"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TextFileParsersTest.java,testTooManyWords,"@Test(expectedExceptions=PicardException.class dataProvider=""tooManyWordsData"") public void  (Object fileOrStream){ BasicInputParser parser=fileOrStream instanceof File ? new BasicInputParser(true 3 (File)fileOrStream) : new BasicInputParser(true 3 (Input"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\util\TextFileParsersTest.java,testWordCountCalculation,"@Test(dataProvider=""data"") public void  (String line boolean groupDelimiters String name){ WordCountTestParser parser=new WordCountTestParser(); parser.setDelimiter(""\t ""); parser.setTreatGroupedDelimitersAsOne(groupDelimiters); parser.calculateWordCount("
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\CallingMetricAccumulatorTest.java,getSingletonSampleData,"@DataProvider(name="" "") public Object[][] getSingletonSampleData(){ final List<Object[]> retval=new ArrayList<>(10); final Allele ARef=Allele.create(""A"" true); final Allele G=Allele.create(""G"" false); final Allele C=Allele.create(""C"" false); final Genotyp"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\CallingMetricAccumulatorTest.java,testGetSingletonSample,"@Test(dataProvider=""getSingletonSampleData"") public void  (final VariantContext vc final String sample) throws Exception { Assert.assertEquals(CallingMetricAccumulator.getSingletonSample(vc) sample); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\AccumulateVariantCallingMetricsTest.java,checkResults,"private void  (final MetricsFile<CollectVariantCallingMetrics.VariantCallingDetailMetrics Comparable<?>> detail final MetricsFile<CollectVariantCallingMetrics.VariantCallingSummaryMetrics Comparable<?>> summary){ int parsedDetail=0; for ( final CollectVariantCallingMetrics.VariantCallingDetailMetrics metrics : detail.getMetrics()) { if (metrics.SAMPLE_ALIAS.equals(""FOO1"")) { Assert.assertEquals(metrics.HET_HOMVAR_RATIO 2.0); Assert.assertEquals(metrics.TOTAL_HET_DEPTH 30); Assert.assertEquals(metrics.TOTAL_SNPS 15); Assert.assertEquals(metrics.NUM_IN_DB_SNP 10); Assert.assertEquals(metrics.NOVEL_SNPS 5); Assert.assertEquals(metrics.FILTERED_SNPS 7); Assert.assertEquals(metrics.PCT_DBSNP 0.666667 0.01); Assert.assertEquals(metrics.DBSNP_TITV 2.333333 0.01); Assert.assertEquals(metrics.NOVEL_TITV 1.5 0.01); Assert.assertEquals(metrics.TOTAL_INDELS 9); Assert.assertEquals(metrics.NOVEL_INDELS 3); Assert.assertEquals(metrics.FILTERED_INDELS 12); Assert.assertEquals(metrics.NUM_IN_DB_SNP_INDELS 6); Assert.assertEquals(metrics.PCT_DBSNP_INDELS 0.666667 0.01); Assert.assertEquals(metrics.DBSNP_INS_DEL_RATIO 1.0 0.01); Assert.assertEquals(metrics.NOVEL_INS_DEL_RATIO 0.0 0.01); Assert.assertEquals(metrics.SNP_REFERENCE_BIAS 0.466667 0.01); Assert.assertEquals(metrics.NUM_SINGLETONS 10); } else if (metrics.SAMPLE_ALIAS.equals(""FOO2"")) { Assert.assertEquals(metrics.HET_HOMVAR_RATIO 1.571429); Assert.assertEquals(metrics.TOTAL_HET_DEPTH 33); Assert.assertEquals(metrics.TOTAL_SNPS 18); Assert.assertEquals(metrics.NUM_IN_DB_SNP 13); Assert.assertEquals(metrics.NOVEL_SNPS 5); Assert.assertEquals(metrics.FILTERED_SNPS 5); Assert.assertEquals(metrics.PCT_DBSNP 0.722222 0.01); Assert.assertEquals(metrics.DBSNP_TITV 2.25 0.01); Assert.assertEquals(metrics.NOVEL_TITV 0.666667 0.01); Assert.assertEquals(metrics.TOTAL_INDELS 6); Assert.assertEquals(metrics.NOVEL_INDELS 3); Assert.assertEquals(metrics.FILTERED_INDELS 6); Assert.assertEquals(metrics.NUM_IN_DB_SNP_INDELS 3); Assert.assertEquals(metrics.PCT_DBSNP_INDELS 0.5 0.01); Assert.assertEquals(metrics.DBSNP_INS_DEL_RATIO 0.5 0.01); Assert.assertEquals(metrics.NOVEL_INS_DEL_RATIO 0.5 0.01); Assert.assertEquals(metrics.SNP_REFERENCE_BIAS 0.696969 0.01); Assert.assertEquals(metrics.NUM_SINGLETONS 9); } else { Assert.assertTrue(false ""Unexpected sample name in detailed metrics: "" + metrics.SAMPLE_ALIAS); } parsedDetail++; } Assert.assertEquals(parsedDetail 2 ""Did not parse enough detail metrics.""); boolean parsedSummary=false; for ( final CollectVariantCallingMetrics.VariantCallingSummaryMetrics metrics : summary.getMetrics()) { Assert.assertEquals(metrics.TOTAL_SNPS 33); Assert.assertEquals(metrics.NOVEL_SNPS 10); Assert.assertEquals(metrics.NUM_IN_DB_SNP 23); Assert.assertEquals(metrics.FILTERED_SNPS 12); Assert.assertEquals(metrics.PCT_DBSNP 0.696969 0.01); Assert.assertEquals(metrics.DBSNP_TITV 2.285714 0.01); Assert.assertEquals(metrics.NOVEL_TITV 1.0 0.01); Assert.assertEquals(metrics.TOTAL_INDELS 15); Assert.assertEquals(metrics.NOVEL_INDELS 6); Assert.assertEquals(metrics.NUM_IN_DB_SNP_INDELS 9); Assert.assertEquals(metrics.FILTERED_INDELS 18); Assert.assertEquals(metrics.PCT_DBSNP_INDELS 0.6 0.01); Assert.assertEquals(metrics.DBSNP_INS_DEL_RATIO 0.8 0.01); Assert.assertEquals(metrics.NOVEL_INS_DEL_RATIO 0.2 0.01); Assert.assertEquals(metrics.SNP_REFERENCE_BIAS 0.587302 0.01); Assert.assertEquals(metrics.NUM_SINGLETONS 19); parsedSummary=true; } Assert.assertTrue(parsedSummary ""Did not parse summary metrics.""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\AccumulateVariantCallingMetricsTest.java,shardDataProvider,"@DataProvider(name="" "") public Object[][] shardDataProvider(){ final File filePrefix1=new File(TEST_DATA_DIR ""mergeTest.shard1""); final File filePrefix2=new File(TEST_DATA_DIR ""mergeTest.shard2""); final File filePrefix3=new File(TEST_DATA_DIR ""mergeTest.e"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\AccumulateVariantCallingMetricsTest.java,testMerge,"@Test(dataProvider=""shardDataProvider"") public void  (final List<File> inputs) throws IOException { final File mergedFilePrefix=new File(TEST_DATA_DIR + ""mergeTest""); final File mergedSummaryFile=new File(mergedFilePrefix.getAbsolutePath() + "".variant_cal"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\ByIntervalListVariantContextIteratorTest.java,ByIntervalListVariantContextIteratorTest,public  (){ this.header=getSAMFileHeader(); this.dict=header.getSequenceDictionary(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\ByIntervalListVariantContextIteratorTest.java,getReader,private VCFFileReader  (final File file){ return new VCFFileReader(file true); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\ByIntervalListVariantContextIteratorTest.java,getSAMFileHeader,private SAMFileHeader  (){ final VCFFileReader reader=getReader(CEU_TRIOS_SNPS_VCF); final SAMSequenceDictionary dict=reader.getFileHeader().getSequenceDictionary(); reader.close(); final SAMFileHeader header=new SAMFileHeader(); header.setSequenceDictionary(dict); return header; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\ByIntervalListVariantContextIteratorTest.java,testEmptyIntervalList,@Test public void  (){ final IntervalList intervalList=new IntervalList(header); final VCFFileReader reader=getReader(CEU_TRIOS_SNPS_VCF); final Iterator<VariantContext> iterator=new ByIntervalListVariantContextIterator(reader intervalList); Assert.assert
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\ByIntervalListVariantContextIteratorTest.java,testNoOverlapDifferentContig,"@Test public void  (){ final IntervalList intervalList=new IntervalList(header); intervalList.add(new Interval(""3"" 167166899 167166899)); final VCFFileReader reader=getReader(CEU_TRIOS_SNPS_VCF); final Iterator<VariantContext> iterator=new ByIntervalListV"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\ByIntervalListVariantContextIteratorTest.java,testNoVariants,@Test public void  (){ final IntervalList intervalList=new IntervalList(header); intervalList.add(new Interval(this.dict.getSequence(0).getSequenceName() 1 100)); final VCFFileReader reader=getReader(EMPTY_VCF); final Iterator<VariantContext> iterator=new
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\ByIntervalListVariantContextIteratorTest.java,testSimpleEnclosing,"@Test public void  (){ final IntervalList intervalList=new IntervalList(header); intervalList.add(new Interval(""12"" 68921962 68921962)); final VCFFileReader reader=getReader(CEU_TRIOS_INDELS_VCF); final Iterator<VariantContext> iterator=new ByIntervalList"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\ByIntervalListVariantContextIteratorTest.java,testSimpleOverlap,"@Test public void  (){ final IntervalList intervalList=new IntervalList(header); intervalList.add(new Interval(""2"" 167166899 167166899)); final VCFFileReader reader=getReader(CEU_TRIOS_SNPS_VCF); final Iterator<VariantContext> iterator=new ByIntervalListV"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\ByIntervalListVariantContextIteratorTest.java,testVariantOverlappingMultipleIntervalsIsReturnedOnlyOnce,"@Test public void  (){ final IntervalList intervalList=new IntervalList(header); intervalList.add(new Interval(""12"" 68921962 68921962)); intervalList.add(new Interval(""12"" 68921964 68921964)); final VCFFileReader reader=getReader(CEU_TRIOS_INDELS_VCF); fi"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\FixVcfHeaderTest.java,runFixVcfHeader,"private void  (final int checkFirstNRecords final File replacementHeader final boolean enforceSampleSamples) throws IOException { final FixVcfHeader program=new FixVcfHeader(); final File outputVcf=VcfTestUtils.createTemporaryIndexedFile(""output."" "".vcf""); program.INPUT=INPUT_VCF; program.OUTPUT=outputVcf; if (replacementHeader == null) { program.CHECK_FIRST_N_RECORDS=checkFirstNRecords; } else { program.HEADER=replacementHeader; program.ENFORCE_SAME_SAMPLES=enforceSampleSamples; } Assert.assertEquals(program.instanceMain(new String[0]) 0); IOUtil.assertFilesEqual(OUTPUT_VCF outputVcf); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\FixVcfHeaderTest.java,setup,"@BeforeTest void  () throws IOException { File OUTPUT_DATA_PATH=IOUtil.createTempDir(""FixVcfHeaderTest"" null); OUTPUT_DATA_PATH.deleteOnExit(); final File testDataPath=new File(""testdata/picard/vcf/FixVcfHeaderTest/""); INPUT_VCF=new File(testDataPath ""inp"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\FixVcfHeaderTest.java,testFixVcfHeader,"@Test(dataProvider="" DataProvider"") public void testFixVcfHeader(final int checkFirstNRecords final File replacementHeader final boolean enforceSampleSamples) throws IOException { runFixVcfHeader(checkFirstNRecords replacementHeader enforceSampleSamples);"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\FixVcfHeaderTest.java,testFixVcfHeaderDataProvider,"@DataProvider(name="" "") public Object[][] testFixVcfHeaderDataProvider(){ return new Object[][]{{-1 HEADER_VCF true} {-1 HEADER_VCF false} {-1 HEADER_VCF_WITH_EXTRA_SAMPLE false} {-1 null true} {1 null true} {Integer.MAX_VALUE null true}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\FixVcfHeaderTest.java,testReplaceHeaderWithDifferentSamplesError,@Test(expectedExceptions=PicardException.class) public void  () throws IOException { runFixVcfHeader(-1 HEADER_VCF_WITH_EXTRA_SAMPLE true); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\filter\TestFilterVcf.java,goodInputVcfs,"@DataProvider(name="" "") public Object[][] goodInputVcfs(){ return new Object[][]{{INPUT} {SITES_ONLY_INPUT}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\filter\TestFilterVcf.java,quickJavascriptFilter,"private File  (final String content) throws Exception { final File out=File.createTempFile(""jsfilter"" "".js""); out.deleteOnExit(); try (final PrintWriter pw=new PrintWriter(out)){ pw.println(content); } return out; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\filter\TestFilterVcf.java,slurpFilters,private ListMap<String String>  (final File vcf){ final ListMap<String String> map=new ListMap<>(); final VCFFileReader in=new VCFFileReader(vcf false); for ( final VariantContext ctx : in) { if (ctx.isNotFiltered()) continue; for ( final String filter : ctx.getFilters()) { map.add(ctx.getID() filter); } } in.close(); return map; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\filter\TestFilterVcf.java,sorted,<T extends Comparable>SortedSet<T>  (Set<T> in){ return new TreeSet<>(in); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\filter\TestFilterVcf.java,testAbFiltering,"@Test public void  () throws Exception { final Set<String> fails=CollectionUtil.makeSet(""tf2"" ""rs28566954"" ""rs28548431""); final File out=testFiltering(INPUT "".vcf.gz"" 0.4 0 0 Double.MAX_VALUE); final ListMap<String String> filters=slurpFilters(out); Asser"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\filter\TestFilterVcf.java,testCombinedFiltering,"@Test public void  () throws Exception { final TreeSet<String> fails=new TreeSet<String>(CollectionUtil.makeSet(""rs13302979"" ""rs13303033"" ""rs2710876"" ""rs2799066"" ""rs28548431"" ""rs28566954"" ""rs71509448"" ""rs71628926"" ""tf2"")); final File out=testFiltering(INP"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\filter\TestFilterVcf.java,testDpFiltering,"@Test public void  () throws Exception { final Set<String> fails=CollectionUtil.makeSet(""rs71509448"" ""rs71628926"" ""rs13302979"" ""rs2710876""); final File out=testFiltering(INPUT "".vcf.gz"" 0 18 0 Double.MAX_VALUE); final ListMap<String String> filters=slurpF"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\filter\TestFilterVcf.java,testDpFilteringToVcf,"@Test public void  () throws Exception { final Set<String> fails=CollectionUtil.makeSet(""rs71509448"" ""rs71628926"" ""rs13302979"" ""rs2710876""); final File out=testFiltering(INPUT "".vcf"" 0 18 0 Double.MAX_VALUE); final ListMap<String String> filters=slurpFilt"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\filter\TestFilterVcf.java,testFiltering,"private File  (final File vcf final String outputExtension final double minAb final int minDp final int minGq final double maxFs) throws Exception { final File out=VcfTestUtils.createTemporaryIndexedFile(""filterVcfTest."" outputExtension); final FilterVcf filterer=new FilterVcf(); filterer.CREATE_INDEX=true; filterer.INPUT=vcf; filterer.OUTPUT=out; filterer.MIN_AB=minAb; filterer.MIN_DP=minDp; filterer.MIN_GQ=minGq; filterer.MAX_FS=maxFs; final int retval=filterer.doWork(); if (retval != 0) { throw new PicardException(""Return value non-zero: "" + retval); } return out; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\filter\TestFilterVcf.java,testFilteringToVcfWithNoSequenceDictionary,"@Test(expectedExceptions=PicardException.class) public void  () throws Exception { final File out=File.createTempFile(""filterVcfTest."" "".vcf""); out.deleteOnExit(); final FilterVcf filterer=new FilterVcf(); filterer.CREATE_INDEX=true; filterer.INPUT=BAD_IN"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\filter\TestFilterVcf.java,testFsFiltering,"@Test(dataProvider=""goodInputVcfs"") public void  (final File input) throws Exception { final Set<String> fails=CollectionUtil.makeSet(""rs13303033"" ""rs28548431"" ""rs2799066""); final File out=testFiltering(input "".vcf.gz"" 0 0 0 5.0d); final ListMap<String St"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\filter\TestFilterVcf.java,testGqFiltering,"@Test public void  () throws Exception { final Set<String> fails=CollectionUtil.makeSet(""rs71509448""); { final File out=testFiltering(INPUT "".vcf.gz"" 0 0 20 Double.MAX_VALUE); final ListMap<String String> filters=slurpFilters(out); Assert.assertEquals(fil"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\filter\TestFilterVcf.java,testJavaScript,"@Test(dataProvider=""goodInputVcfs"") public void  (final File input) throws Exception { final File out=VcfTestUtils.createTemporaryIndexedFile(""filterVcfTestJS."" "".vcf""); final FilterVcf filterer=new FilterVcf(); filterer.INPUT=input; filterer.OUTPUT=out; "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\filter\TestFilterVcf.java,testNoFiltering,"@Test(dataProvider=""goodInputVcfs"") public void  (final File input) throws Exception { final File out=testFiltering(input "".vcf.gz"" 0 0 0 Double.MAX_VALUE); final VCFFileReader in=new VCFFileReader(out false); for ( final VariantContext ctx : in) { if (!c"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\CollectVariantCallingMetricsTest.java,testAllHomRefVCF,"@Test public void  () throws IOException { final File dbSnpFile=new File(TEST_DATA_DIR ""mini.dbsnp.vcf""); final File vcfFile=new File(TEST_DATA_DIR ""allHomRef.vcf""); final File indexedVcfFile=VcfTestUtils.createTemporaryIndexedVcfFromInput(vcfFile ""allHom"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\CollectVariantCallingMetricsTest.java,testMetricsTiny,"@Test public void  () throws IOException { final File dbSnpFile=new File(TEST_DATA_DIR ""mini.dbsnp.vcf""); final File vcfFile=new File(TEST_DATA_DIR ""mini.vcf""); final File outFile=new File(TEST_DATA_DIR ""vcmetrics_tiny""); final File summaryFile=new File(T"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\CollectVariantCallingMetricsTest.java,testMetricsTinyGVCF,"@Test public void  () throws IOException { final File dbSnpFile=new File(TEST_DATA_DIR ""mini.dbsnp.vcf""); final File vcfFile=new File(TEST_DATA_DIR ""mini_gvcf.vcf""); final File outFile=new File(TEST_DATA_DIR ""vcmetrics_tiny_gvcf""); final File summaryFile="
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceGA4GHSchemeTest.java,testGA4GHScheme,"@Test public void  () throws Exception { final GenotypeConcordanceCounts concordanceCounts=GenotypeConcordanceTest.getGenotypeConcordanceCounts(ceuTrioSnpsVcf ceuTrioSnpsVcf ""NA12878"" false null); concordanceCounts.validateCountsAgainstScheme(scheme); fin"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceGA4GHSchemeTest.java,testGA4GHSchemeDiffSamples,"@Test public void  () throws Exception { final GenotypeConcordanceCounts concordanceCounts=GenotypeConcordanceTest.getGenotypeConcordanceCounts(ceuTrioSnpsVcf ceuTrioSnpsVcf ""NA12891"" false null); concordanceCounts.validateCountsAgainstScheme(scheme); fin"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceGA4GHSchemeTest.java,testGA4GHSchemeDiffSamplesWithIntervals,"@Test public void  () throws Exception { final GenotypeConcordanceCounts concordanceCounts=GenotypeConcordanceTest.getGenotypeConcordanceCounts(ceuTrioSnpsVcf ceuTrioSnpsVcf ""NA12891"" false intervalList); concordanceCounts.validateCountsAgainstScheme(sche"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceGA4GHSchemeTest.java,testGA4GHSchemeWithIntervals,"@Test public void  () throws Exception { final GenotypeConcordanceCounts concordanceCounts=GenotypeConcordanceTest.getGenotypeConcordanceCounts(ceuTrioSnpsVcf ceuTrioSnpsVcf ""NA12878"" false intervalList); concordanceCounts.validateCountsAgainstScheme(sche"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceGA4GHSchemeWithMissingTest.java,testMissingHomRefSchemeWithIntervals,"@Test public void  (){ final GenotypeConcordanceCounts concordanceCounts=GenotypeConcordanceTest.getGenotypeConcordanceCounts(nistTruthVCF ceuTrioSNPSVCF ""NA12878"" true intervalList); concordanceCounts.validateCountsAgainstScheme(scheme); final Map<Genoty"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\MergeVcfsTest.java,getProgram,@Override protected CommandLineProgram  (){ return new MergeVcfs(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GatherVcfsTest.java,TestGatherFiles,"@Test(dataProvider=""vcfshards"") public void  (final List<File> inputFiles final File expectedOutput final int expectedRetVal) throws IOException { final List<String> args=new ArrayList<>(); final File output=VcfTestUtils.createTemporaryIndexedFile(""result"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GatherVcfsTest.java,getCommandLineProgramName,@Override public String  (){ return GatherVcfs.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GatherVcfsTest.java,setup,"@BeforeClass public void  () throws IOException { final File TEST_DIR=new File(""testdata/picard/vcf/GatherVcf""); vcf=VcfTestUtils.createTemporaryIndexedVcfFromInput(new File(TEST_DIR ""input.vcf"") ""whole.""); shard1=VcfTestUtils.createTemporaryIndexedVcfFro"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GatherVcfsTest.java,vcfshards,@DataProvider public Object[][]  (){ return new Object[][]{{Arrays.asList(shard1 shard2 shard3) vcf 0} {Arrays.asList(shard1 shard2_bad shard3) vcf 1} {Arrays.asList(shard1 shard3 shard2) vcf 1} {Arrays.asList(shard3 shard1 shard2) vcf 1} {Arrays.asList(s
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\processor\ByWholeContigTest.java,test,@Test public void  () throws Exception { final VcfFileSegmentGenerator.ByWholeContig segmenter=VcfFileSegmentGenerator.ByWholeContig.getInstance(); int chunkCount=0; for ( final VcfFileSegment variantContextCloseableIterator : segmenter.forVcf(TEST_VCF)) 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\processor\AccumulatorExecutorTest.java,accumulate,@Override public void  (final VariantContext vc){ observedVariantContextStrings.add(vc.toString()); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\processor\AccumulatorExecutorTest.java,build,@Override public VariantProcessor.Accumulator  (){ return new VariantProcessor.Accumulator(){ @Override public void accumulate( final VariantContext vc){ observedVariantContextStrings.add(vc.toString()); } @Override public Object result(){ return null; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\processor\AccumulatorExecutorTest.java,result,@Override public Object  (){ return null; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\processor\AccumulatorExecutorTest.java,test,@Test public void  () throws Exception { final Set<String> actualVariantContextStrings=Collections.synchronizedSet(new HashSet<String>()); for ( final File testVcf : TEST_VCFS) { for ( final VariantContext variantContext : new VCFFileReader(testVcf)) { ac
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\processor\ThreadsafeTest.java,ensureSameVariantsReadAsSimpleVcfFileIterator,@Test public void  (){ final VariantIteratorProducer.Threadsafe iteratorFactory=new VariantIteratorProducer.Threadsafe(VcfFileSegmentGenerator.byWholeContigSubdividingWithWidth(TEN_MILLION) Arrays.asList(VCF_WITH_MULTI_ALLELIC_VARIANT_AT_POSITION_10MILLIO
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\processor\ThreadsafeTest.java,ensureTestDataActuallyHasWideVariantAtTenMillion,"@Test public void  (){ final Joiner joiner=Joiner.on("":""); final VCFFileReader r=new VCFFileReader(VCF_WITH_MULTI_ALLELIC_VARIANT_AT_POSITION_10MILLION); Assert.assertEquals(joiner.join(r.query(""1"" TEN_MILLION TEN_MILLION)) joiner.join(r.query(""1"" TEN_MIL"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\processor\ThreadsafeTest.java,ensureUniqueVariantObservationsEspeciallyMultiAllelicOnesThatAppearAtChunkingBoundaries,@Test public void  (){ final VariantIteratorProducer.Threadsafe iteratorFactory=new VariantIteratorProducer.Threadsafe(VcfFileSegmentGenerator.byWholeContigSubdividingWithWidth(TEN_MILLION) Arrays.asList(VCF_WITH_MULTI_ALLELIC_VARIANT_AT_POSITION_10MILLIO
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceTest.java,assertMetricsFileEqual,private void  (final File actualMetricsFile final File expectedMetricsFile) throws FileNotFoundException { final MetricsFile<GenotypeConcordanceSummaryMetrics Comparable<?>> actual=new MetricsFile<GenotypeConcordanceSummaryMetrics Comparable<?>>(); actual.read(new FileReader(actualMetricsFile)); final MetricsFile<GenotypeConcordanceSummaryMetrics Comparable<?>> expected=new MetricsFile<GenotypeConcordanceSummaryMetrics Comparable<?>>(); expected.read(new FileReader(expectedMetricsFile)); Assert.assertTrue(expected.areMetricsEqual(actual)); Assert.assertTrue(expected.areHistogramsEqual(actual)); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceTest.java,assertNonZeroCountsAgree,public static void  (final GenotypeConcordanceCounts counter final Map<TruthAndCallStates Integer> expectedCountMap){ for ( final TruthState truthState : TruthState.values()) { for ( final CallState callState : CallState.values()) { Integer expectedCount=expectedCountMap.get(new TruthAndCallStates(truthState callState)); if (expectedCount == null) expectedCount=0; Assert.assertEquals(counter.getCount(truthState callState) expectedCount.intValue()); } } } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceTest.java,genotypeConcordanceDetermineStateDataProvider,"@DataProvider(name="" "") public Object[][] genotypeConcordanceDetermineStateDataProvider(){ final Object[][] originalUnitTestData=new Object[][]{{Aref Aref TruthState.HOM_REF Aref Aref CallState.HOM_REF} {Aref Aref TruthState.HOM_REF Aref C CallState.HET_R"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceTest.java,getGenotypeConcordanceCounts,"public static GenotypeConcordanceCounts  (final File truthVCF final File callVCF final String callSample final boolean missingSitesFlag List<File> intervalFiles){ final File outputBaseFileName=new File(OUTPUT_DATA_PATH ""actualGtConc""); final File outputSummaryFile=new File(outputBaseFileName.getAbsolutePath() + GenotypeConcordance.SUMMARY_METRICS_FILE_EXTENSION); final File outputDetailsFile=new File(outputBaseFileName.getAbsolutePath() + GenotypeConcordance.DETAILED_METRICS_FILE_EXTENSION); outputSummaryFile.deleteOnExit(); outputDetailsFile.deleteOnExit(); final GenotypeConcordance genotypeConcordance=new GenotypeConcordance(); genotypeConcordance.TRUTH_VCF=truthVCF; genotypeConcordance.TRUTH_SAMPLE=""NA12878""; genotypeConcordance.CALL_VCF=callVCF; genotypeConcordance.CALL_SAMPLE=callSample; genotypeConcordance.MISSING_SITES_HOM_REF=missingSitesFlag; genotypeConcordance.INTERVALS=intervalFiles; genotypeConcordance.OUTPUT=outputBaseFileName; Assert.assertEquals(genotypeConcordance.instanceMain(new String[0]) 0); return genotypeConcordance.getSnpCounter(); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceTest.java,getGenotypeConcordanceTestFileData,"@DataProvider(name=""genotypeConcordanceTestFileData"") public Object[][]  (){ return new Object[][]{{CEU_TRIOS_SNPS_VCF ""NA12878"" CEU_TRIOS_SNPS_VCF ""NA12878"" null null false false CEU_TRIOS_SNPS_VS_CEU_TRIOS_SNPS_GC} {CEU_TRIOS_INDELS_VCF ""NA12878"" CEU_TR"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceTest.java,makeUniqueListOfAlleles,private List<Allele>  (final Allele... alleles){ final Set<Allele> uniqueAlleles=new HashSet<Allele>(); for ( final Allele allele : alleles) { if (!allele.equals(Allele.NO_CALL)) { uniqueAlleles.add(allele); } } if (!uniqueAlleles.contains(Aref)) uniqueAlleles.add(Aref); return new ArrayList<Allele>(uniqueAlleles); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceTest.java,tearDown,@AfterClass public void  (){ IOUtil.deleteDirectoryTree(OUTPUT_DATA_PATH); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceTest.java,testGenotypeConcordance,"@Test(dataProvider=""genotypeConcordanceTestFileData"") public void  (final File vcf1 final String sample1 final File vcf2 final String sample2 final Integer minGq final Integer minDp final boolean outputAllRows final boolean missingSitesFlag final String e"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceTest.java,testGenotypeConcordanceDetermineState,private void  (final VariantContext truthVariantContext final TruthState expectedTruthState final VariantContext callVariantContext final CallState expectedCallState final int minGq final int minDp){ final TruthAndCallStates truthAndCallStates=GenotypeConcordance.determineState(truthVariantContext TRUTH_SAMPLE_NAME callVariantContext CALL_SAMPLE_NAME minGq minDp false); Assert.assertEquals(truthAndCallStates.truthState expectedTruthState); Assert.assertEquals(truthAndCallStates.callState expectedCallState); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceTest.java,testGenotypeConcordanceDetermineStateDp,"@Test public void  () throws Exception { final List<Allele> allelesNormal=makeUniqueListOfAlleles(Aref C); final Genotype gtNormal=GenotypeBuilder.create(TRUTH_SAMPLE_NAME Arrays.asList(Aref C)); final VariantContext vcNormal=new VariantContextBuilder(""te"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceTest.java,testGenotypeConcordanceDetermineStateFilter,"@Test public void  () throws Exception { final Set<String> filters=new HashSet<String>(Arrays.asList(""BAD!"")); final List<Allele> alleles1=makeUniqueListOfAlleles(Aref C); final Genotype gt1=GenotypeBuilder.create(TRUTH_SAMPLE_NAME Arrays.asList(Aref C));"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceTest.java,testGenotypeConcordanceDetermineStateGq,"@Test public void  () throws Exception { final List<Allele> allelesNormal=makeUniqueListOfAlleles(Aref C); final Genotype gtNormal=GenotypeBuilder.create(TRUTH_SAMPLE_NAME Arrays.asList(Aref C)); final VariantContext vcNormal=new VariantContextBuilder(""te"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceTest.java,testGenotypeConcordanceDetermineStateNull,"@Test public void  () throws Exception { final List<Allele> alleles=makeUniqueListOfAlleles(Aref C); final Genotype gt1=GenotypeBuilder.create(TRUTH_SAMPLE_NAME Arrays.asList(Aref C)); final VariantContext vc1=new VariantContextBuilder(""test"" snpLoc snpLo"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceTest.java,testIgnoreFilterStatus,"@Test public void  () throws Exception { final File truthVcfPath=new File(TEST_DATA_PATH.getAbsolutePath() ""NIST_subset_3sites.vcf""); final File callVcfPath=new File(TEST_DATA_PATH.getAbsolutePath() ""vcf_with_filtered_calls.vcf""); final File ignoreFilterS"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceTest.java,testNoCallVariants,"@Test public void  (){ final GenotypeConcordance genotypeConcordance=new GenotypeConcordance(); genotypeConcordance.TRUTH_VCF=new File(TEST_DATA_PATH ""mini.vcf""); genotypeConcordance.TRUTH_SAMPLE=""NA20801""; genotypeConcordance.CALL_VCF=new File(TEST_DATA_"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceTest.java,testNormalizeAllelesForIndels,@Test public void  (){ final Path truthVcfPath=Paths.get(TEST_DATA_PATH.getAbsolutePath() NORMALIZE_ALLELES_TRUTH); final Path callVcfPath=Paths.get(TEST_DATA_PATH.getAbsolutePath() NORMALIZE_ALLELES_CALL); final VCFFileReader truthReader=new VCFFileReade
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceTest.java,testNormalizeAllelesForWritingVCF,@Test public void  () throws FileNotFoundException { final File truthVcfPath=new File(TEST_DATA_PATH.getAbsolutePath() NORMALIZE_NO_CALLS_TRUTH); final File callVcfPath=new File(TEST_DATA_PATH.getAbsolutePath() NORMALIZE_NO_CALLS_CALL); final File outputB
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\GenotypeConcordanceTest.java,testSpanningDeletion,"@Test public void  () throws FileNotFoundException { final File truthVcfPath=new File(TEST_DATA_PATH.getAbsolutePath() ""spanningDeletionTruth.vcf""); final File callVcfPath=new File(TEST_DATA_PATH.getAbsolutePath() ""spanningDeletionCallset.vcf""); final Fil"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\processor\WidthLimitingDecoratorTest.java,Segment, (final int start final int stop){ this.start=start; this.stop=stop; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\processor\WidthLimitingDecoratorTest.java,contig,"@Override public String  (){ return ""A""; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\processor\WidthLimitingDecoratorTest.java,forVcf,@Override public Iterable<VcfFileSegment>  (final File vcf){ return Collections.singleton((VcfFileSegment)entireThing); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\processor\WidthLimitingDecoratorTest.java,start,@Override public int  (){ return start; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\processor\WidthLimitingDecoratorTest.java,stop,@Override public int  (){ return stop; } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\processor\WidthLimitingDecoratorTest.java,testForVcf,@Test public void  () throws Exception { final Segment entireThing=new Segment(1 9942); final ImmutableList<Segment> expectedSubThings=ImmutableList.of(new Segment(1 1000) new Segment(1001 2000) new Segment(2001 3000) new Segment(3001 4000) new Segment(40
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\processor\WidthLimitingDecoratorTest.java,toString,"@Override public String  (){ return ""Segment{"" + ""start="" + start + ""  stop=""+ stop+ ""  vcf=""+ vcf()+ ""  contig=""+ contig()+ '}'; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\processor\WidthLimitingDecoratorTest.java,vcf,"@Override public File  (){ return new File(""B""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\MendelianViolations\FindMendelianViolationsTest.java,grep,"private int  (final File file final String regex){ int results=0; final Pattern pattern=Pattern.compile("".*"" + regex + "".*""); try (final LineIteratorImpl li=new LineIteratorImpl(new AsciiLineReader(IOUtil.openFileForReading(file)))){ while (li.hasNext()) { final String line=li.next(); if (pattern.matcher(line).matches()) { results++; } } } catch ( final IOException e) { e.printStackTrace(); } return results; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\MendelianViolations\FindMendelianViolationsTest.java,grepMv,"private int  (final File file final String regex){ return grep(file ""[;\t]MV="" + regex + ""[;\t]""); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\MendelianViolations\FindMendelianViolationsTest.java,testFindMedelianViolations,"@Test public void  () throws IOException { final File vcfFile=new File(TEST_DATA_DIR ""CEUTrio_plus_FAKE.vcf""); final File vcfIndexFile=new File(TEST_DATA_DIR ""CEUTrio_plus_FAKE.vcf.idx""); if (vcfFile.lastModified() > vcfIndexFile.lastModified()) { if (vcf"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\SamTestUtils.java,createIndexedBam,"public static File  (final File samFile final File tempFilePrefix) throws IOException { final File output=File.createTempFile(tempFilePrefix.getAbsolutePath() "".bam""); output.deleteOnExit(); final File indexFile=new File(output.getAbsolutePath() + "".bai""); indexFile.deleteOnExit(); final SamReader in=SamReaderFactory.makeDefault().open(samFile); SAMFileWriter out=new SAMFileWriterFactory().setCreateIndex(true).makeBAMWriter(in.getFileHeader() true output); in.iterator().stream().forEach(out::addAlignment); out.close(); in.close(); return output; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\SplitVcfsTest.java,getCommandLineProgramName,public String  (){ return SplitVcfs.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\SplitVcfsTest.java,teardown,@AfterClass public void  (){ IOUtil.deleteDirectoryTree(OUTPUT_DATA_PATH); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\SplitVcfsTest.java,testSplit,"@Test public void  (){ final File indelOutputFile=new File(OUTPUT_DATA_PATH ""split-vcfs-test-indels-delete-me.vcf""); final File snpOutputFile=new File(OUTPUT_DATA_PATH ""split-vcfs-test-snps-delete-me.vcf""); final File input=new File(TEST_DATA_PATH ""CEUTri"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\SortVcfsTest.java,getProgram,@Override protected CommandLineProgram  (){ return new SortVcf(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\SortVcfsTest.java,testPresortedFile,"@Test public void  () throws IOException { final File snpInputFile=new File(TEST_DATA_PATH ""CEUTrio-snps.vcf""); final File output=File.createTempFile(""sort-presorted-test-output."" "".vcf""); final List<String> indexing=Arrays.asList(""CREATE_INDEX=false""); o"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\SortVcfsTest.java,testScrambledSnpsAndOrderedIndels,"@Test public void  () throws IOException { final File indelInputFile=new File(TEST_DATA_PATH ""CEUTrio-indels.vcf""); final File snpInputFile=new File(TEST_DATA_PATH ""CEUTrio-snps-scrambled.1.vcf""); final File output=File.createTempFile(""sort-scrambled-inde"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\SortVcfsTest.java,testScrambledSnpsAndScrambledIndels,"@Test public void  () throws IOException { final File indelInputFile=new File(TEST_DATA_PATH ""CEUTrio-indels-scrambled.1.vcf""); final File snpInputFile=new File(TEST_DATA_PATH ""CEUTrio-snps-scrambled.1.vcf""); final File output=File.createTempFile(""merge-i"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\SortVcfsTest.java,testSingleScrambledFile,"@Test public void  () throws IOException { final File snpInputFile=new File(TEST_DATA_PATH ""CEUTrio-snps-scrambled.1.vcf""); final File output=File.createTempFile(""sort-single-scrambled-test-output."" "".vcf""); final List<String> indexing=Arrays.asList(""CREA"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\SortVcfsTest.java,testTwoScrambledSnpFiles,"@Test public void  () throws IOException { final File inputFile1=new File(TEST_DATA_PATH ""CEUTrio-snps-scrambled.1.vcf""); final File inputFile2=new File(TEST_DATA_PATH ""vcfFormatTest.scrambled.vcf""); final File output=File.createTempFile(""sort-multiple-sc"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\SortVcfsTest.java,validateSortingResults,private void  (final File output final int expectedVariantContextCount){ final VCFFileReader outputReader=new VCFFileReader(output false); final VariantContextComparator outputComparator=outputReader.getFileHeader().getVCFRecordComparator(); VariantContext last=null; int variantContextCount=0; final CloseableIterator<VariantContext> iterator=outputReader.iterator(); while (iterator.hasNext()) { final VariantContext outputContext=iterator.next(); if (last != null) Assert.assertTrue(outputComparator.compare(last outputContext) <= 0); last=outputContext; variantContextCount++; } iterator.close(); Assert.assertEquals(variantContextCount expectedVariantContextCount); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VariantContextComparatorTest.java,buildVariantContext,"private static VariantContext  (final String source final String contig final long start){ final Collection<Allele> alleles=new ArrayList<Allele>(); alleles.add(Allele.create(""AAAA"" true)); alleles.add(Allele.create(""AAGG"" false)); return new VariantContextBuilder(source contig start start + 3 alleles).make(); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VariantContextComparatorTest.java,getOrderedContigList,private static List<String>  (final VariantContext... variantContexts){ final LinkedHashSet<String> contigs=new LinkedHashSet<String>(); for ( final VariantContext context : variantContexts) { contigs.add(context.getContig()); } return new ArrayList<String>(contigs); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VariantContextComparatorTest.java,testCombinationOne,"@Test public void  (){ final VariantContext contextOne=buildVariantContext(""source"" ""one"" 100); final VariantContext contextTwo=buildVariantContext(""source"" ""two"" 150); final List<String> contigs=getOrderedContigList(contextOne contextTwo); Assert.assertT"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VariantContextComparatorTest.java,testCombinationTwo,"@Test public void  (){ final VariantContext contextOne=buildVariantContext(""source"" ""one"" 150); final VariantContext contextTwo=buildVariantContext(""source"" ""two"" 100); final List<String> contigs=getOrderedContigList(contextOne contextTwo); Assert.assertT"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VariantContextComparatorTest.java,testContigs,"@Test public void  (){ final VariantContext contextOne=buildVariantContext(""source"" ""one"" 100); final VariantContext contextTwo=buildVariantContext(""source"" ""two"" 100); final List<String> contigs=getOrderedContigList(contextOne contextTwo); Assert.assertT"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VariantContextComparatorTest.java,testIdentical,"@Test public void  (){ final VariantContext contextOne=buildVariantContext(""source"" ""one"" 100); final List<String> contigs=getOrderedContigList(contextOne); Assert.assertEquals(0 new VariantContextComparator(contigs).compare(contextOne contextOne)); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VariantContextComparatorTest.java,testPositions,"@Test public void  (){ final VariantContext contextOne=buildVariantContext(""source"" ""one"" 100); final VariantContext contextTwo=buildVariantContext(""source"" ""one"" 150); final List<String> contigs=getOrderedContigList(contextOne contextTwo); Assert.assertT"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VariantContextComparatorTest.java,testThrowsOnDuplicateContig,"@Test(expectedExceptions=IllegalArgumentException.class) public void  (){ final List<String> contigs=new ArrayList<String>(3); contigs.add(""one""); contigs.add(""two""); contigs.add(""one""); new VariantContextComparator(contigs); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\UpdateVcfSequenceDictionaryTest.java,outputFies,"@DataProvider(name=""OutputFiles"") public static Object[][]  (){ return new Object[][]{{OUTPUT_DATA_PATH + ""updateVcfSequenceDictionaryTest-delete-me.vcf""} {STD_OUT_NAME}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\UpdateVcfSequenceDictionaryTest.java,teardown,@AfterClass public void  (){ IOUtil.deleteDirectoryTree(OUTPUT_DATA_PATH); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\UpdateVcfSequenceDictionaryTest.java,testUpdateVcfSequenceDictionary,"@Test(dataProvider=""OutputFiles"") public void  (final String outputFileName) throws IOException  NoSuchFieldException  IllegalAccessException { File input=new File(TEST_DATA_PATH ""vcfFormatTest.vcf""); final File samSequenceDictionaryVcf=new File(TEST_DATA"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VcfFormatConverterTest.java,compareFiles,private void  (final File file1 final File file2){ Assert.assertTrue(file1.exists()); Assert.assertTrue(file2.exists()); Assert.assertEquals(file1.length() file2.length()); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VcfFormatConverterTest.java,convertFile,"private File  (final File input final String prefix final String format){ final File outputFile; try { outputFile=File.createTempFile(prefix format); } catch ( final IOException ioe) { throw new PicardException(""Unable to create temp file!""); } outputFile.deleteOnExit(); new File(outputFile.getAbsolutePath() + Tribble.STANDARD_INDEX_EXTENSION).deleteOnExit(); final List<String> args=new ArrayList<String>(Arrays.asList(""INPUT="" + input.getAbsolutePath() ""OUTPUT="" + outputFile.getAbsolutePath())); if (VCF_GZ.equals(format)) { args.add(""CREATE_INDEX=false""); } if (input.getName().endsWith(VCF_GZ)) { args.add(""REQUIRE_INDEX=false""); } Assert.assertEquals(runPicardCommandLine(args) 0); return outputFile; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VcfFormatConverterTest.java,getCommandLineProgramName,public String  (){ return VcfFormatConverter.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VcfFormatConverterTest.java,runBackAndForthTest,"private void  (final File input final String format final String originalFormat){ final String tempPrefix=""backAndForth""; final File backAndForth=convertFile(input tempPrefix format); final File backAndForthSeries2=convertFile(backAndForth tempPrefix originalFormat); compareFiles(input backAndForthSeries2); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VcfFormatConverterTest.java,runLikeTest,"private void  (final File input final String format){ final File outputFile=convertFile(input ""likeTest"" format); compareFiles(input outputFile); } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VcfFormatConverterTest.java,testBcfToBcf,@Test public void  (){ runLikeTest(TEST_BCF BCF); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VcfFormatConverterTest.java,testBcfToVcf,@Test public void  (){ runBackAndForthTest(TEST_BCF VCF BCF); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VcfFormatConverterTest.java,testVcfToBcf,@Test public void  (){ runBackAndForthTest(TEST_VCF BCF VCF); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VcfFormatConverterTest.java,testVcfToVcf,@Test public void  (){ runLikeTest(TEST_VCF VCF); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VcfFormatConverterTest.java,testVcfToVcfGz,@Test public void  (){ runBackAndForthTest(TEST_VCF VCF_GZ VCF); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VcfTestUtils.java,assertEquals,"public static void  (final GenotypesContext actual final GenotypesContext expected){ if (expected == null) { Assert.assertNull(actual); return; } Assert.assertEquals(actual.getSampleNamesOrderedByName() expected.getSampleNamesOrderedByName() ""Sample names differ""); for ( final String name : expected.getSampleNamesOrderedByName()) { Assert.assertEquals(actual.get(name).getAlleles() expected.get(name).getAlleles() ""Alleles differ for sample "" + name); Assert.assertEquals(actual.get(name).getAD() expected.get(name).getAD()); Assert.assertEquals(actual.get(name).getPL() expected.get(name).getPL()); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VcfTestUtils.java,assertVcfFilesAreEqual,"public static void  (final File actual final File expected) throws IOException { final File indexedActual=createTemporaryIndexedVcfFromInput(actual ""assert""); final File indexedExpected=createTemporaryIndexedVcfFromInput(expected ""assert""); try (final VCFFileReader vcfReaderActual=new VCFFileReader(indexedActual);final VCFFileReader vcfReaderExpected=new VCFFileReader(indexedExpected)){ VcfTestUtils.assertEquals(vcfReaderActual vcfReaderExpected); } } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VcfTestUtils.java,createTemporaryIndexedFile,"public static File  (final String prefix final String suffix) throws IOException { final File out=File.createTempFile(prefix suffix); out.deleteOnExit(); String indexFileExtension=null; if (suffix.endsWith(""vcf.gz"")) { indexFileExtension="".tbi""; } else if (suffix.endsWith(""vcf"")) { indexFileExtension="".idx""; } else if (suffix.endsWith("".bam"")) { indexFileExtension="".bai""; } if (indexFileExtension != null) { final File indexOut=new File(out.getAbsolutePath() + indexFileExtension); indexOut.deleteOnExit(); } return out; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VcfTestUtils.java,createTemporaryIndexedVcfFromInput,"public static File  (final File vcfFile final String tempFilePrefix final String suffix) throws IOException { final String extension; if (suffix != null) { extension=suffix; } else if (vcfFile.getAbsolutePath().endsWith("".vcf"")) { extension="".vcf""; } else if (vcfFile.getAbsolutePath().endsWith("".vcf.gz"")) { extension="".vcf.gz""; } else { extension=""nope!""; } if (!extension.equals("".vcf"") && !extension.equals("".vcf.gz"")) throw new IllegalArgumentException(""couldn't find a .vcf or .vcf.gz ending for input file "" + vcfFile.getAbsolutePath()); File output=createTemporaryIndexedFile(tempFilePrefix extension); final VCFFileReader in=new VCFFileReader(vcfFile false); final VCFHeader header=in.getFileHeader(); final VariantContextWriter out=new VariantContextWriterBuilder().setReferenceDictionary(header.getSequenceDictionary()).setOptions(EnumSet.of(Options.INDEX_ON_THE_FLY)).setOutputFile(output).build(); out.writeHeader(header); for ( final VariantContext ctx : in) { out.add(ctx); } out.close(); in.close(); return output; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VcfToIntervalListTest.java,getCommandLineProgramName,public String  (){ return VcfToIntervalList.class.getSimpleName(); } 
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VcfToIntervalListTest.java,getVcfToIntervalListData,"@DataProvider(name=""VcfToIntervalListData"") public Object[][]  (){ return new Object[][]{{new File(TEST_RESOURCE_DIR ""small_m2_more_variants.vcf"") false 11 - 1 - 1} {new File(TEST_RESOURCE_DIR ""small_m2_more_variants.vcf"") true 11 - 1}}; } "
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\VcfToIntervalListTest.java,testExcludingFiltered,"@Test(dataProvider=""VcfToIntervalListData"") public void  (final File inputFile final boolean includeFiltered final int expectedIntervalsSize) throws IOException { final File outputFile=File.createTempFile(""vcftointervallist_"" "".interval_list""); outputFile"
C:\Users\User\Desktop\Thesis\picard\src\test\java\picard\vcf\processor\VcfFileSegmentGeneratorTest.java,ensureOverlapExclusionTest,"@Test public void  (){ final OverlapDetector<Interval> oneTinyIntervalDetector=new OverlapDetector<Interval>(0 0); final Interval theInterval=new Interval(""1"" 5 10); oneTinyIntervalDetector.addLhs(theInterval theInterval); final VcfFileSegmentGenerator no"
