ProjectName,methodName,methodBody
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\Arguments.java, arguments,private   (  arguments that )  {  argument factories . add all ( that . argument factories )  ;  untyped null argument = that . untyped null argument ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\Arguments.java,create copy,@ override public  arguments   (  )  {  return new  arguments ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\AbstractArgumentFactory.java, abstract argument factory,"protected   ( int sql type )  {  this . sql type = sql type ;   type argument type = find generic parameter ( get class (  )   abstract argument factory . class )  . or else throw (  (  )   -  >  new  illegal state exception ( get class (  )  . get simple name (  )   +  "" must extend  abstract argument factory with a concrete t parameter"" )  )  ;  if  ( argument type instanceof  class )   {   class <  ?  >  argument class =  (  class <  ?  >  ) argument type ;  this . is instance =  ( type value )   -  >  argument class . is assignable from ( get erased type ( type )  )  || argument class . is instance ( value )  ;   }  else  {  this . is instance =  ( type value )   -  >  argument type . equals ( type )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\Arguments.java,find for,public  optional <  argument >    (  type type  object value )  {  return argument factories . stream (  )  . flat map ( factory  -  >  to stream ( factory . build ( type value registry )  )  )  . find first (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\Arguments.java,get untyped null argument,public  argument   (  )  {  return untyped null argument ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\Arguments.java,register,public  arguments   (  argument factory factory )  {  argument factories . add ( 0 factory )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\Arguments.java,set registry,@ override public void   (  config registry registry )  {  this . registry = registry ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\Arguments.java,set untyped null argument,"public void   (  argument untyped null argument )  {  if  ( untyped null argument  =  =  null )   {  throw new  illegal argument exception ( ""the  argument itself may not be null"" )  ;   }  this . untyped null argument = untyped null argument ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\CharacterStreamArgument.java, character stream argument,public   (  reader reader int length )  {  this . value = reader ;  this . length = length ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\CharacterStreamArgument.java,apply,@ override public void   ( int position  prepared statement statement  statement context ctx )  throws sql exception  {  statement . set character stream ( position value length )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\InputStreamArgument.java, input stream argument,public   (  input stream stream int length boolean ascii )  {  this . value = stream ;  this . length = length ;  this . ascii = ascii ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\InputStreamArgument.java,apply,@ override public void   ( int position  prepared statement statement  statement context ctx )  throws sql exception  {  if  ( ascii )   {  if  ( value  !  =  null )   {  statement . set ascii stream ( position value length )  ;   }  else  {  statement . 
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\MapArguments.java, map arguments,public   (  map <  string  ?  >  args )  {  this . args = args ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\JavaTimeZoneIdArgumentFactory.java, java time zone id argument factory,public   (  )  {  super (  types . varchar )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\MapArguments.java,find,@ override public  optional <  argument >    (  string name  statement context ctx )  {  if  ( args . contains key ( name )  )   {  final  object argument = args . get ( name )  ;  final  class <  ?  >  argument class = argument  =  =  null  ?   object . 
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\MapArguments.java,to string,@ override public  string   (  )  {  return new  linked hash map <  >  ( args )  . to string (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\JavaTimeZoneIdArgumentFactory.java,build,@ override protected  argument   (  zone id value  config registry config )  {  return  ( i p ctx )   -  >  p . set string ( i value . get id (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\MethodReturnValueNamedArgumentFinder.java, method return value named argument finder,  (  string prefix  object object )  {  super ( prefix object )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\MethodReturnValueNamedArgumentFinder.java,invoke method," object   (  method method  statement context ctx )  {  try  {  return method . invoke ( object )  ;   }  catch  (   illegal access exception e )   {  throw new  unable to create statement exception (  string . format ( "" access exception invoking ""  +  ""method [%s] on [%s]"" method . get name (  )  object )  e ctx )  ;   }  catch  (   invocation target exception e )   {  throw new  unable to create statement exception (  string . format ( "" invocation target exception invoking ""  +  ""method [%s] on [%s]"" method . get name (  )  object )  e ctx )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\BeanPropertyArguments.java, bean property arguments,public   (  string prefix  object bean )  {  super ( prefix bean )  ;  this . property descriptors = class   property   descriptors . get ( bean . get class (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\BeanPropertyArguments.java,get getter,"private  method   (  string name  property descriptor descriptor  statement context ctx )  {   method getter = descriptor . get read method (  )  ;  if  ( getter  =  =  null )   {  throw new  unable to create statement exception (  string . format ( "" no getter method found for ""  +  ""bean property [%s] on [%s]"" name object )  ctx )  ;   }  return getter ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\BeanPropertyArguments.java,get nested argument finder,@ override  named argument finder   (  object obj )  {  return new  bean property arguments ( null obj )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\BeanPropertyArguments.java,get value,@ override  optional <  typed value >    (  string name  statement context ctx )  {   property descriptor descriptor = property descriptors . get ( name )  ;  if  ( descriptor  =  =  null )   {  return  optional . empty (  )  ;   }   method getter = get g
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\BeanPropertyArguments.java,to string,"@ override public  string   (  )  {  return "" { lazy bean property arguments \""""  +  object  +  ""\"""" ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\BuiltInArgumentFactory.java, built in argument,private   (  class < t >  klass int type  statement binder < t >  binder t value )  {  this . binder = binder ;  this . klass = klass ;  this . type = type ;  this . value = value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\BuiltInArgumentFactory.java,apply,@ override public void   ( int position  prepared statement statement  statement context ctx )  throws sql exception  {  if  ( value  =  =  null )   {  statement . set null ( position type )  ;  return ;   }  binder . bind ( statement position value )  ; 
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\ObjectFieldArguments.java, object field arguments,public   (  string prefix  object bean )  {  super ( prefix bean )  ;  this . fields = class   fields . get ( bean . get class (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\ObjectFieldArguments.java,get nested argument finder,@ override  named argument finder   (  object obj )  {  return new  object field arguments ( null obj )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\ObjectFieldArguments.java,get value,@ override  optional <  typed value >    (  string name  statement context ctx )  {   field field = fields . get ( name )  ;  if  ( field  =  =  null )   {  return  optional . empty (  )  ;   }  try  {   type type = field . get generic type (  )  ;   obje
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\ObjectFieldArguments.java,to string,"@ override public  string   (  )  {  return "" { lazy bean field arguments \""""  +  object  +  ""\"""" ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\ObjectArgumentFactory.java, object argument factory,private   (  class <  ?  >  type  integer sql type )  {  this . type = type ;  this . sql type = sql type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\ObjectArgumentFactory.java,build,@ override public  optional <  argument >    (  type expected type  object value  config registry config )  {  return  objects . equals ( type expected type )  || type . is instance ( value )   ?   optional . of ( new  object argument ( value sql type )  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\ObjectArgumentFactory.java,create,public static  argument factory   (  class <  ?  >  type  integer sql type )  {  return new  object argument factory ( type sql type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\ObjectArgument.java, object argument,"public   (  object value  integer sql type )  {  this . sql type = sql type ;  this . value = value ;  if  ( sql type  =  =  null && value  =  =  null )   {  throw new  illegal argument exception ( "" null value provided without a type"" )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\ObjectArgument.java,apply,@ override public void   ( final int position  prepared statement statement  statement context ctx )  throws sql exception  {  if  ( value  =  =  null )   {  statement . set null ( position sql type )  ;   }  else  {  if  ( sql type  !  =  null )   {  sta
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\ObjectArgument.java,to string,"@ override public  string   (  )  {  return  ( value  =  =  null  ?  ""null"" :  string . value of ( value )  )   +   ( sql type  =  =  null  ?  """" : ""  ( type ""  +  sql type  +  "" ) "" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\NullArgument.java, null argument,public   ( int sql type )  {  this . sql type = sql type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\NullArgument.java,apply,@ override public void   ( final int position  prepared statement statement  statement context ctx )  throws sql exception  {  statement . set null ( position sql type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\NullArgument.java,to string,"@ override public  string   (  )  {  return ""null"" ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\ObjectPropertyNamedArgumentFinder.java, object property named argument finder,"public   (  string prefix  object object )  {  this . prefix =  ( prefix  =  =  null || prefix . is empty (  )  )   ?  """" : prefix  +  "" . "" ;  this . object = object ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\ObjectPropertyNamedArgumentFinder.java, typed value,public   (  type type  object value )  {  this . type = type ;  this . value = value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\ObjectPropertyNamedArgumentFinder.java,find,@ override public final  optional <  argument >    (  string name  statement context ctx )  {  if  ( name . starts with ( prefix )  )   {  final  string actual name = name . substring ( prefix . length (  )  )  ;  int separator = actual name . index of ( 
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\CollectorColumnMapper.java, collector column mapper,  (  column mapper < t >  element mapper  collector < t a r >  collector )  {  this . element mapper = element mapper ;  this . collector = collector ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\CollectorColumnMapper.java,build from result set,private r   (  array array  statement context ctx )  throws sql exception  {  a result = collector . supplier (  )  . get (  )  ;   bi consumer < a t >  accumulator = collector . accumulator (  )  ;  try  (  result set rs = array . get result set (  )  )  {  while  ( rs . next (  )  )   {  accumulator . accept ( result element mapper . map ( rs 2 ctx )  )  ;   }   }  return collector . finisher (  )  . apply ( result )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\CollectorColumnMapper.java,map,@ override public r   (  result set r int column number  statement context ctx )  throws sql exception  {  java . sql .  array array = r . get array ( column number )  ;  if  ( array  =  =  null )   {  return null ;   }  try  {  return build from result s
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\ArrayColumnMapper.java, array column mapper,  (  column mapper <  ?  >  element mapper  class <  ?  >  component type )  {  this . element mapper = element mapper ;  this . component type = component type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\ArrayColumnMapper.java,build array,private  object   ( java . sql .  array array  statement context ctx )  throws sql exception  {  if  (  ! unsupported   types . contains ( array . get base type (  )  )  )   {  try  {   object ary = array . get array (  )  ;  if  ( component type . equals ( ary . get class (  )  . get component type (  )  )  )   {  return ary ;   }   }  catch  (  sql feature not supported exception swallowed )   {   }   }  unsupported   types . add ( array . get base type (  )  )  ;  return build from result set ( array ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\ArrayColumnMapper.java,build from result set,private  object   ( java . sql .  array array  statement context ctx )  throws sql exception  {   list <  object >  list = new  array list <  >  (  )  ;  try  (  result set rs = array . get result set (  )  )  {  while  ( rs . next (  )  )   {  list . add ( element mapper . map ( rs 2 ctx )  )  ;   }   }   object ary =  array . new instance ( component type list . size (  )  )  ;  if  ( component type . is primitive (  )  )   {  for  ( int i = 0 ;  i  <  list . size (  )  ;  i +  +  )   {   array . set ( ary i list . get ( i )  )  ;   }  return ary ;   }  return list . to array (  (  object[] ) ary )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\ArrayColumnMapper.java,map,@ override public  object   (  result set r int column number  statement context ctx )  throws sql exception  {  java . sql .  array array = r . get array ( column number )  ;  if  ( array  =  =  null )   {  return null ;   }  try  {  return build array (
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\ObjectMethodArguments.java, object method arguments,public   (  string prefix  object object )  {  super ( prefix object )  ;  this . methods = class   methods . get ( object . get class (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\ObjectMethodArguments.java,get nested argument finder,@ override  named argument finder   (  object obj )  {  return new  object method arguments ( null obj )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\ObjectMethodArguments.java,get value,@ override  optional <  typed value >    (  string name  statement context ctx )  {   method method = methods . get ( name )  ;  if  ( method  =  =  null )   {  return  optional . empty (  )  ;   }   type type = method . get generic return type (  )  ;   
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\argument\ObjectMethodArguments.java,to string,"@ override public  string   (  )  {  return "" { lazy object functions arguments \""""  +  object  +  ""\"""" ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\SqlArrayArgumentFactory.java,build,@ override public  optional <  argument >    (  type type  object value  config registry config )  {   class <  ?  >  erased type =  generic types . get erased type ( type )  ;  if  (  !  ( erased type . is array (  )  ||  collection . class . is assignab
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\InferredSqlArrayTypeFactory.java, inferred sql array type factory,"  (  sql array type <  ?  >  array type )  {  this . element type = find generic parameter ( array type . get class (  )   sql array type . class )  . or else throw (  (  )   -  >  new  unsupported operation exception ( "" must use a concretely typed  sql array type here"" )  )  ;  this . array type = array type ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\InferredSqlArrayTypeFactory.java,build,@ override public  optional <  sql array type <  ?  >  >    (  type element type  config registry config )  {  return this . element type . equals ( element type )   ?   optional . of ( array type )  :  optional . empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\SqlArrayMapperFactory.java,build,"@ override @ suppress warnings ( ""unchecked"" )  public  optional <  column mapper <  ?  >  >    (  type type  config registry config )  {  final  class <  ?  >  erased type =  generic types . get erased type ( type )  ;  if  ( erased type . is array (  ) "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\SqlArrayMapperFactory.java,element type mapper,private  optional <  column mapper <  ?  >  >    (  type element type  config registry config )  {   optional <  column mapper <  ?  >  >  mapper = config . get (  column mappers . class )  . find for ( element type )  ;  if  (  ! mapper . is present (  )  && element type  =  =   object . class )   {  return  optional . of (  ( rs num context )   -  >  rs . get object ( num )  )  ;   }  return mapper ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\SqlArrayArgument.java, sql array argument,  (  sql array type < t >  array type  collection < t >  list )  {  this . type name = array type . get type name (  )  ;  this . array = list . stream (  )  . map ( array type::convert array element )  . to array (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\SqlArrayArgument.java,apply,@ override public void   ( int position  prepared statement statement  statement context ctx )  throws sql exception  {   sql array argument strategy argument style = ctx . get sql array argument strategy (  )  ;  switch  ( argument style )   {  case sql 
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\VendorSupportedArrayType.java, vendor supported array type,  (  string type name )  {  this . type name = type name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\VendorSupportedArrayType.java,convert array element,@ override public  object   ( t element )  {  return element ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\VendorSupportedArrayType.java,factory,static  < t >  sql array type factory   (  class < t >  type  string sql type name )  {   sql array type < t >  array type = new  vendor supported array type <  >  ( sql type name )  ;  return  ( t ctx )   -  >  t . equals ( type )   ?   optional . of ( array type )  :  optional . empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\VendorSupportedArrayType.java,get type name,@ override public  string   (  )  {  return type name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\ArrayBuilder.java, array builder,  (  class <  ?  >  component type )  {  this . component type = component type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\ArrayBuilder.java,add,public void   (  object element )  {  list . add ( element )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\ArrayBuilder.java,build,public  object   (  )  {   object array =  array . new instance ( component type list . size (  )  )  ;  for  ( int i = 0 ;  i  <  list . size (  )  ;  i +  +  )   {   array . set ( array i list . get ( i )  )  ;   }  return array ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\SqlArrayTypes.java, sql array types,private   (  sql array types that )  {  factories . add all ( that . factories )  ;  argument strategy = that . argument strategy ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\SqlArrayTypes.java,create copy,@ override public  sql array types   (  )  {  return new  sql array types ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\SqlArrayTypes.java,find for,public  optional <  sql array type <  ?  >  >    (  type element type )  {  return factories . stream (  )  . flat map ( factory  -  >  to stream ( factory . build ( element type registry )  )  )  . find first (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\SqlArrayTypes.java,get argument strategy,public  sql array argument strategy   (  )  {  return argument strategy ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\SqlArrayTypes.java,register,public  sql array types   (  sql array type factory factory )  {  factories . add ( 0 factory )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\SqlArrayTypes.java,set argument strategy,public  sql array types   (  sql array argument strategy argument strategy )  {  this . argument strategy = argument strategy ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\array\SqlArrayTypes.java,set registry,@ override public void   (  config registry registry )  {  this . registry = registry ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\CloseException.java, close exception,public   (  string string  throwable throwable )  {  super ( string throwable )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\ElementTypeNotFoundException.java, element type not found exception,public   (  string message )  {  super ( message )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\ArrayCollectorFactory.java,accepts,@ override public boolean   (  type container type )  {  return get erased type ( container type )  . is array (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\ArrayCollectorFactory.java,build,@ override public  collector <  ?   ?   ?  >    (  type container type )  {   class <  ?  >  component type = get erased type ( container type )  . get component type (  )  ;  return  collector . of (  (  )   -  >  new  array builder ( component type )   
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\ArrayCollectorFactory.java,element type,@ override public  optional <  type >    (  type container type )  {  return  optional . of nullable ( get erased type ( container type )  . get component type (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\JdbiCollectors.java, jdbi collectors,private   (  jdbi collectors that )  {  factories . add all ( that . factories )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\JdbiCollectors.java,create copy,@ override public  jdbi collectors   (  )  {  return new  jdbi collectors ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\JdbiCollectors.java,find element type for,public  optional <  type >    (  type container type )  {  return find factory for ( container type )  . flat map ( f  -  >  f . element type ( container type )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\JdbiCollectors.java,find factory for,private  optional <  collector factory >    (  type container type )  {  return factories . stream (  )  . filter ( f  -  >  f . accepts ( container type )  )  . find first (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\JdbiCollectors.java,find for,public  optional <  collector <  ?   ?   ?  >  >    (  type container type )  {  return find factory for ( container type )  . map ( f  -  >  f . build ( container type )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\JdbiCollectors.java,register,public  jdbi collectors   (  collector factory factory )  {  factories . add ( 0 factory )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\NoSuchCollectorException.java, no such collector exception,public   (  string message )  {  super ( message )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\OptionalCollectors.java,to optional,public static  < t o >  collector < t  ?  o >    (  supplier < o >  empty  function < t o >  factory )  {  return  collector . of (  (  )   -  >  new  optional builder <  >  ( empty factory )   optional builder::set  optional builder::combine  optional builder::build )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\OptionalCollectors.java,to optional double,public static  collector <  double  ?   optional double >    (  )  {  return to optional (  optional double::empty  optional double::of )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\OptionalCollectors.java,to optional int,public static  collector <  integer  ?   optional int >    (  )  {  return to optional (  optional int::empty  optional int::of )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\OptionalCollectors.java,to optional long,public static  collector <  long  ?   optional long >    (  )  {  return to optional (  optional long::empty  optional long::of )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\OptionalBuilder.java, optional builder,  (  supplier < o >  empty  function < t o >  factory )  {  this . empty = empty ;  this . factory = factory ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\OptionalBuilder.java,build,o   (  )  {  return value  =  =  null  ?  empty . get (  )  : factory . apply ( value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\OptionalBuilder.java,combine,static  < t opt   t >  optional builder < t opt   t >    (  optional builder < t opt   t >  left  optional builder < t opt   t >  right )  {  if  ( left . set && right . set )   {  throw too many values ( left . value right . value )  ;   }  return left . set  ?  left : right ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\OptionalBuilder.java,set,void   ( t value )  {  if  ( set )   {  throw too many values ( this . value value )  ;   }  this . value = value ;  this . set = true ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\OptionalBuilder.java,stringify,"private static  string   (  object value )  {  return value  =  =  null  ?  null : ""'""  +  value  +  ""'"" ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\OptionalBuilder.java,too many values,"private static  < t >  illegal state exception   ( t first t second )  {  return new  illegal state exception (  string . format ( "" multiple values for optional: [%s  %s   .  .  . ]"" stringify ( first )  stringify ( second )  )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\BuiltInCollectorFactory.java, built in collector factory,public   (  )  {  collectors = new  hash map <  >  (  )  ;  collectors . put (  optional . class to optional (  )  )  ;  collectors . put (  collection . class to collection (  array list::new )  )  ;  collectors . put (  list . class to list (  )  )  ;  collectors . put (  array list . class to collection (  array list::new )  )  ;  collectors . put (  linked list . class to collection (  linked list::new )  )  ;  collectors . put (  copy on write array list . class to collection (  copy on write array list::new )  )  ;  collectors . put (  set . class to set (  )  )  ;  collectors . put (  hash set . class to collection (  hash set::new )  )  ;  collectors . put (  linked hash set . class to collection (  linked hash set::new )  )  ;  collectors . put (  sorted set . class to collection (  tree set::new )  )  ;  collectors . put (  tree set . class to collection (  tree set::new )  )  ;  collectors . put (  map . class to map (  linked hash map::new )  )  ;  collectors . put (  hash map . class to map (  hash map::new )  )  ;  collectors . put (  linked hash map . class to map (  linked hash map::new )  )  ;  collectors . put (  sorted map . class to map (  tree map::new )  )  ;  collectors . put (  tree map . class to map (  tree map::new )  )  ;  collectors . put (  concurrent map . class to map (  concurrent hash map::new )  )  ;  collectors . put (  concurrent hash map . class to map (  concurrent hash map::new )  )  ;  collectors . put (  weak hash map . class to map (  weak hash map::new )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\BuiltInCollectorFactory.java,accepts,@ override public boolean   (  type container type )  {   class <  ?  >  erased type = get erased type ( container type )  ;  return collectors . contains key ( erased type )  && container type instanceof  parameterized type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\BuiltInCollectorFactory.java,build,@ override public  collector <  ?   ?   ?  >    (  type container type )  {   class <  ?  >  erased type = get erased type ( container type )  ;  return collectors . get ( erased type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\BuiltInCollectorFactory.java,combine,private static  < k v m extends  map < k v >  > m   ( m a m b )  {  b . for each (  ( k v )   -  >  put entry ( a k v )  )  ;  return a ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\BuiltInCollectorFactory.java,element type,@ override public java . util .  optional <  type >    (  type container type )  {   class <  ?  >  erased type = get erased type ( container type )  ;  if  (  map . class . is assignable from ( erased type )  )   {  return  optional . of (  generic types
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\BuiltInCollectorFactory.java,put entry,"private static  < k v m extends  map < k v >  > void   ( m map k key v value )  {  v old value = map . put ( key value )  ;  if  ( old value  !  =  null )   {  throw new  illegal state exception (  string . format ( "" multiple values for  map key '%s': ['%s' '%s'  .  .  . ]"" key old value value )  )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\BuiltInCollectorFactory.java,to map,public static  < k v m extends  map < k v >  >  collector <  map .  entry < k v >   ?  m >    (  supplier < m >  map factory )  {  return  collector . of ( map factory  built in collector factory::put entry  built in collector factory::combine )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\BuiltInCollectorFactory.java,to optional,@ deprecated public static  < t >  collector < t  ?   optional < t >  >    (  )  {  return  optional collectors . to optional (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\config\ConfigRegistry.java, config registry,private   (  config registry that )  {  that . cache . for each (  ( type config )   -  >   {   jdbi config <  ?  >  copy = config . create copy (  )  ;  copy . set registry (  config registry . this )  ;  cache . put ( type copy )  ;   }   )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\config\ConfigRegistry.java,create copy,public  config registry   (  )  {  return new  config registry ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\config\ConfigRegistry.java,get,"public  < c extends  jdbi config < c >  > c   (  class < c >  config class )  {  return config class . cast ( cache . compute if absent ( config class type  -  >   {  try  {  c config = config class . get declared constructor (  )  . new instance (  )  ;  config . set registry (  config registry . this )  ;  return config ;   }  catch  (   reflective operation exception e )   {  throw new  illegal state exception ( "" unable to instantiate config class ""  +  config class  +  "" .   is there a public no - arg constructor ? "" e )  ;   }   }   )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\config\Configurable.java,configure,"@ suppress warnings ( ""unchecked"" )  default  < c extends  jdbi config < c >  >  this   (  class < c >  config class  consumer < c >  configurer )  {  configurer . accept ( get config ( config class )  )  ;  return  (  this ) this ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\config\Configurable.java,define,default  this   (  string key  object value )  {  return configure (  sql statements . class c  -  >  c . define ( key value )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\config\Configurable.java,get config,default  < c extends  jdbi config < c >  > c   (  class < c >  config class )  {  return get config (  )  . get ( config class )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\config\Configurable.java,register argument,default  this   (  argument factory factory )  {  return configure (  arguments . class c  -  >  c . register ( factory )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\config\Configurable.java,register array type,default  this   (  sql array type factory factory )  {  return configure (  sql array types . class c  -  >  c . register ( factory )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\config\Configurable.java,register collector,default  this   (  collector factory factory )  {  return configure (  jdbi collectors . class c  -  >  c . register ( factory )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\config\Configurable.java,register column mapper,default  this   (  column mapper factory factory )  {  return configure (  column mappers . class c  -  >  c . register ( factory )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\config\Configurable.java,register extension,default  this   (  extension factory factory )  {  return configure (  extensions . class c  -  >  c . register ( factory )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\config\Configurable.java,register row mapper,default  this   (  row mapper factory factory )  {  return configure (  row mappers . class c  -  >  c . register ( factory )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\config\Configurable.java,set map key column,default  this   (  string key column )  {  return configure (  map entry mappers . class c  -  >  c . set key column ( key column )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\config\Configurable.java,set map value column,default  this   (  string value column )  {  return configure (  map entry mappers . class c  -  >  c . set value column ( value column )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\config\Configurable.java,set sql array argument strategy,default  this   (  sql array argument strategy strategy )  {  return configure (  sql array types . class c  -  >  c . set argument strategy ( strategy )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\config\Configurable.java,set sql parser,default  this   (  sql parser parser )  {  return configure (  sql statements . class c  -  >  c . set sql parser ( parser )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\config\Configurable.java,set template engine,default  this   (  template engine template engine )  {  return configure (  sql statements . class c  -  >  c . set template engine ( template engine )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\config\Configurable.java,set timing collector,default  this   (  timing collector collector )  {  return configure (  sql statements . class c  -  >  c . set timing collector ( collector )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\ConstantHandleSupplier.java, constant handle supplier,  (  handle handle )  {  this . handle = handle ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\ConstantHandleSupplier.java,get config,@ override public  config registry   (  )  {  return handle . get config (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\ConstantHandleSupplier.java,get handle,@ override public  handle   (  )  {  return handle ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\ConstantHandleSupplier.java,invoke in context,@ override public  < v > v   (  extension method extension method  config registry config  callable < v >  task )  throws  exception  {   extension method old extension method = handle . get extension method (  )  ;  try  {  handle . set extension method 
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\ConstantHandleSupplier.java,of,static  handle supplier   (  handle handle )  {  return new  constant handle supplier ( handle )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\ConnectionException.java, connection exception,public   (  throwable cause )  {  super ( cause )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\OptionalPrimitiveCollectorFactory.java,accepts,@ override public boolean   (  type container type )  {  return collectors . contains key ( container type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\OptionalPrimitiveCollectorFactory.java,build,@ override public  collector <  ?   ?   ?  >    (  type container type )  {  return collectors . get ( container type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\collector\OptionalPrimitiveCollectorFactory.java,element type,@ override public  optional <  type >    (  type container type )  {  return  optional . of ( element types . get ( container type )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\extension\ExtensionMethod.java, extension method,public   (  class <  ?  >  type  method method )  {  this . type = require non null ( type )  ;  this . method = require non null ( method )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\extension\ExtensionMethod.java,get method,public  method   (  )  {  return method ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\extension\ExtensionMethod.java,get type,public  class <  ?  >    (  )  {  return type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\extension\NoSuchExtensionException.java, no such extension exception,public   (  string message )  {  super ( message )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\GenericTypes.java,find generic parameter,public static  optional <  type >    (  type type  class <  ?  >  parameterized supertype )  {   type parameter type = resolve type ( parameterized supertype . get type parameters (  ) [0] type )  ;  return parameter type instanceof  class || parameter type instanceof  parameterized type  ?   optional . of ( parameter type )  :  optional . empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\GenericTypes.java,get erased type,public static  class <  ?  >    (  type type )  {  return  type token . of ( type )  . get raw type (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Preconditions.java,check argument,public static void   ( boolean expression @ nullable  string error message template @ nullable  object .  .  .  error message args )  {  if  (  ! expression )   {  throw new  illegal argument exception ( format ( error message template error message args )  )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\GenericTypes.java,is array,public static boolean   (  type type )  {  return type instanceof  class <  ?  >  &&  (  (  class <  ?  >  ) type )  . is array (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Preconditions.java,check not null,public static  < t > t   ( t reference @ nullable  string error message template @ nullable  object .  .  .  error message args )  {  if  ( reference  =  =  null )   {  throw new  null pointer exception ( format ( error message template error message args )  )  ;   }  return reference ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\GenericTypes.java,resolve map entry type,private static  < k v >  type   (  type token < k >  key type  type token < v >  value type )  {  return new  type token <  map .  entry < k v >  >  (  )  {   }   . where ( new  type parameter < k >  (  )  {   }   key type )  . where ( new  type parameter < v >  (  )  {   }   value type )  . get type (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Preconditions.java,check state,public static void   ( boolean expression @ nullable  string error message template @ nullable  object .  .  .  error message args )  {  if  (  ! expression )   {  throw new  illegal state exception ( format ( error message template error message args )  )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Preconditions.java,format,static  string   (  string template @ nullable  object .  .  .  args )  {  return  string . format ( template args )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\GenericTypes.java,resolve type,public static  type   (  type type  type context type )  {  return  type token . of ( context type )  . resolve type ( type )  . get type (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\GenericType.java, generic type,"protected   (  )  {  this . type =  generic types . find generic parameter ( get class (  )   generic type . class )  . or else throw (  (  )   -  >  new  unsupported operation exception ( "" missing generic type parameter . "" )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\GenericType.java,get type,public final  type   (  )  {  return type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeCapture.java,capture,"final  type   (  )  {   type superclass = get class (  )  . get generic superclass (  )  ;  check argument ( superclass instanceof  parameterized type ""%s isn't parameterized"" superclass )  ;  return  (  (  parameterized type ) superclass )  . get actual type arguments (  ) [0] ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeParameter.java, type parameter,"protected   (  )  {   type type = capture (  )  ;  check argument ( type instanceof  type variable ""%s should be a type variable . "" type )  ;  this . type variable =  (  type variable <  ?  >  ) type ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeParameter.java,equals,@ override @ suppressfb warnings public final boolean   ( @ nullable  object o )  {  if  ( o instanceof  type parameter )   {   type parameter <  ?  >  that =  (  type parameter <  ?  >  ) o ;  return type variable . equals ( that . type variable )  ;   }
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeParameter.java,hash code,@ override public final int   (  )  {  return type variable . hash code (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeParameter.java,to string,@ override public  string   (  )  {  return type variable . to string (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java, type resolver,private   (  type table type table )  {  this . type table = type table ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java, type table,private   (  map <  type variable key  type >  map )  {  this . map = unmodifiable map ( new  linked hash map <  >  ( map )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java, type variable key,"  (  type variable <  ?  >  var )  {  this . var = check not null ( var ""var"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,according to,static  type resolver   (  type type )  {  return new  type resolver (  )  . where (  type mapping introspector . get type mappings ( type )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,capture,private  type[]   (  type[] types )  {   type[] result = new  type[types . length] ;  for  ( int i = 0 ;  i  <  types . length ;  i +  +  )   {  result[i] = capture ( types[i] )  ;   }  return result ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,capture nullable,private  type   ( @ nullable  type type )  {  if  ( type  =  =  null )   {  return null ;   }  return capture ( type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,equals,@ override public boolean   (  object obj )  {  if  ( obj instanceof  type variable key )   {   type variable key that =  (  type variable key ) obj ;  return equals type variable ( that . var )  ;   }  else  {  return false ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,equals type,boolean   (  type type )  {  if  ( type instanceof  type variable )   {  return equals type variable (  (  type variable <  ?  >  ) type )  ;   }  else  {  return false ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,equals type variable,private boolean   (  type variable <  ?  >  that )  {  return var . get generic declaration (  )  . equals ( that . get generic declaration (  )  )  && var . get name (  )  . equals ( that . get name (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,expect argument,"private static  < t > t   (  class < t >  type  object arg )  {  try  {  return type . cast ( arg )  ;   }  catch  (   class cast exception e )   {  throw new  illegal argument exception ( arg  +  "" is not a ""  +  type . get simple name (  )  )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,for lookup,static  type variable key   (  type t )  {  if  ( t instanceof  type variable )   {  return new  type variable key (  (  type variable <  ?  >  ) t )  ;   }  else  {  return null ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,get type mappings,static  map <  type variable key  type >    (  type context type )  {   type mapping introspector introspector = new  type mapping introspector (  )  ;  introspector . visit ( wildcard capturer . capture ( context type )  )  ;  return unmodifiable map ( new  linked hash map <  >  ( introspector . mappings )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,hash code,@ override public int   (  )  {  return  objects . hash ( var . get generic declaration (  )  var . get name (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,map,private void   ( final  type variable key var final  type arg )  {  if  ( mappings . contains key ( var )  )   {  return ;   }  for  (  type t = arg ;  t  !  =  null ;  t = mappings . get (  type variable key . for lookup ( t )  )  )   {  if  ( var . equals type ( t )  )   {  for  (  type x = arg ;  x  !  =  null ;  x = mappings . remove (  type variable key . for lookup ( x )  )  )   {   }  return ;   }   }  mappings . put ( var arg )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,populate type mappings,"private static void   ( final  map <  type variable key  type >  mappings  type from final  type to )  {  if  ( from . equals ( to )  )   {  return ;   }  new  type visitor (  )  {  @ override void visit type variable (   type variable <  ?  >  type variable )  {  mappings . put ( new  type variable key ( type variable )  to )  ;   }  @ override void visit wildcard type (   wildcard type from wildcard type )  {  if  (  !  ( to instanceof  wildcard type )  )   {  return ;   }   wildcard type to wildcard type =  (  wildcard type ) to ;   type[] from upper bounds = from wildcard type . get upper bounds (  )  ;   type[] to upper bounds = to wildcard type . get upper bounds (  )  ;   type[] from lower bounds = from wildcard type . get lower bounds (  )  ;   type[] to lower bounds = to wildcard type . get lower bounds (  )  ;  check argument ( from upper bounds . length  =  =  to upper bounds . length && from lower bounds . length  =  =  to lower bounds . length "" incompatible type: %s vs .  %s"" from wildcard type to )  ;  for  ( int i = 0 ;  i  <  from upper bounds . length ;  i +  +  )   {  populate type mappings ( mappings from upper bounds[i] to upper bounds[i] )  ;   }  for  ( int i = 0 ;  i  <  from lower bounds . length ;  i +  +  )   {  populate type mappings ( mappings from lower bounds[i] to lower bounds[i] )  ;   }   }  @ override void visit parameterized type (   parameterized type from parameterized type )  {  if  ( to instanceof  wildcard type )   {  return ;   }   parameterized type to parameterized type = expect argument (  parameterized type . class to )  ;  if  ( from parameterized type . get owner type (  )   !  =  null && to parameterized type . get owner type (  )   !  =  null )   {  populate type mappings ( mappings from parameterized type . get owner type (  )  to parameterized type . get owner type (  )  )  ;   }  check argument ( from parameterized type . get raw type (  )  . equals ( to parameterized type . get raw type (  )  )  "" inconsistent raw type: %s vs .  %s"" from parameterized type to )  ;   type[] from args = from parameterized type . get actual type arguments (  )  ;   type[] to args = to parameterized type . get actual type arguments (  )  ;  check argument ( from args . length  =  =  to args . length ""%s not compatible with %s"" from parameterized type to parameterized type )  ;  for  ( int i = 0 ;  i  <  from args . length ;  i +  +  )   {  populate type mappings ( mappings from args[i] to args[i] )  ;   }   }  @ override void visit generic array type (   generic array type from array type )  {  if  ( to instanceof  wildcard type )   {  return ;   }   type component type =  types . get component type ( to )  ;  check argument ( component type  !  =  null ""%s is not an array type . "" to )  ;  populate type mappings ( mappings from array type . get generic component type (  )  component type )  ;   }  @ override void visit class (   class <  ?  >  from class )  {  if  ( to instanceof  wildcard type )   {  return ;   }  throw new  illegal argument exception ( "" no type mapping from ""  +  from class  +  "" to "" +  to )  ;   }   }   . visit ( from )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,resolve,final  type   ( final  type variable <  ?  >  var )  {  final  type table unguarded = this ;   type table guarded = new  type table (  )  {  @ override public  type resolve internal (   type variable <  ?  >  intermediate var   type table for dependent )  {  if  ( intermediate var . get generic declaration (  )  . equals ( var . get generic declaration (  )  )  )   {  return intermediate var ;   }  return unguarded . resolve internal ( intermediate var for dependent )  ;   }   }   ;  return resolve internal ( var guarded )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,resolve generic array type,private  type   (  generic array type type )  {   type component type = type . get generic component type (  )  ;   type resolved component type = resolve type ( component type )  ;  return  types . new array type ( resolved component type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,resolve internal, type   (  type variable <  ?  >  var  type table for dependants )  {   type type = map . get ( new  type variable key ( var )  )  ;  if  ( type  =  =  null )   {   type[] bounds = var . get bounds (  )  ;  if  ( bounds . length  =  =  0 )   {  return var ;   }   type[] resolved bounds = new  type resolver ( for dependants )  . resolve types ( bounds )  ;  if  (  types .  native type variable equals . native   type   variable   only &&  arrays . equals ( bounds resolved bounds )  )   {  return var ;   }  return  types . new artificial type variable ( var . get generic declaration (  )  var . get name (  )  resolved bounds )  ;   }  return new  type resolver ( for dependants )  . resolve type ( type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,resolve parameterized type,private  parameterized type   (  parameterized type type )  {   type owner = type . get owner type (  )  ;   type resolved owner =  ( owner  =  =  null )   ?  null : resolve type ( owner )  ;   type resolved raw type = resolve type ( type . get raw type (  )  )  ;   type[] args = type . get actual type arguments (  )  ;   type[] resolved args = resolve types ( args )  ;  return  types . new parameterized type with owner ( resolved owner  (  class <  ?  >  ) resolved raw type resolved args )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,resolve type,"public  type   (  type type )  {  check not null ( type ""type"" )  ;  if  ( type instanceof  type variable )   {  return type table . resolve (  (  type variable <  ?  >  ) type )  ;   }  else if  ( type instanceof  parameterized type )   {  return resolve parameterized type (  (  parameterized type ) type )  ;   }  else if  ( type instanceof  generic array type )   {  return resolve generic array type (  (  generic array type ) type )  ;   }  else if  ( type instanceof  wildcard type )   {  return resolve wildcard type (  (  wildcard type ) type )  ;   }  else  {  return type ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,resolve types,private  type[]   (  type[] types )  {   type[] result = new  type[types . length] ;  for  ( int i = 0 ;  i  <  types . length ;  i +  +  )   {  result[i] = resolve type ( types[i] )  ;   }  return result ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,resolve wildcard type,private  wildcard type   (  wildcard type type )  {   type[] lower bounds = type . get lower bounds (  )  ;   type[] upper bounds = type . get upper bounds (  )  ;  return new  types .  wildcard type impl ( resolve types ( lower bounds )  resolve types ( upper bounds )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,to string,@ override public  string   (  )  {  return var . to string (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,visit class,@ override void   (  class <  ?  >  clazz )  {  visit ( clazz . get generic superclass (  )  )  ;  visit ( clazz . get generic interfaces (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,visit generic array type,"@ override void   (  generic array type from array type )  {  if  ( to instanceof  wildcard type )   {  return ;   }   type component type =  types . get component type ( to )  ;  check argument ( component type  !  =  null ""%s is not an array type . "" to"
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,visit parameterized type,@ override void   (  parameterized type parameterized type )  {   class <  ?  >  raw class =  (  class <  ?  >  ) parameterized type . get raw type (  )  ;   type variable <  ?  > [] vars = raw class . get type parameters (  )  ;   type[] type args = para
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,visit type variable,@ override void   (  type variable <  ?  >  t )  {  visit ( t . get bounds (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,visit wildcard type,@ override void   (  wildcard type t )  {  visit ( t . get upper bounds (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeResolver.java,where,"final  type table   (  map <  type variable key  ?  extends  type >  mappings )  {   map <  type variable key  type >  builder = new  linked hash map <  >  (  )  ;  builder . put all ( map )  ;  for  (   map .  entry <  type variable key  ?  extends  type >  mapping : mappings . entry set (  )  )   {   type variable key variable = mapping . get key (  )  ;   type type = mapping . get value (  )  ;  check argument (  ! variable . equals type ( type )  "" type variable %s bound to itself"" variable )  ;  builder . put ( variable type )  ;   }  return new  type table ( builder )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java, generic array type impl,  (  type component type )  {  this . component type =  java version . current . used in generic type ( component type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java, parameterized type impl,"  ( @ nullable  type owner type  class <  ?  >  raw type  type[] type arguments )  {  check not null ( raw type ""raw type"" )  ;  check argument ( type arguments . length  =  =  raw type . get type parameters (  )  . length "" expected %s type parameters but got %s"" raw type . get type parameters (  )  . length type arguments . length )  ;  disallow primitive type ( type arguments ""type parameter"" )  ;  this . owner type = owner type ;  this . raw type = raw type ;  this . arguments list =  java version . current . used in generic type ( type arguments )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java, type variable impl,"  ( d generic declaration  string name  type[] bounds )  {  disallow primitive type ( bounds ""bound for type variable"" )  ;  this . generic declaration = check not null ( generic declaration ""generic declaration"" )  ;  this . name = check not null ( name ""name"" )  ;  this . bounds = unmodifiable list ( new  array list <  >  (  arrays . as list ( bounds )  )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java, type variable invocation handler,  (  type variable impl <  ?  >  type variable impl )  {  this . type variable impl = type variable impl ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java, wildcard type impl,"  (  type[] lower bounds  type[] upper bounds )  {  disallow primitive type ( lower bounds ""lower bound for wildcard"" )  ;  disallow primitive type ( upper bounds ""upper bound for wildcard"" )  ;  this . lower bounds =  java version . current . used in generic type ( lower bounds )  ;  this . upper bounds =  java version . current . used in generic type ( upper bounds )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java,detect jvm behavior,@ suppressfb warnings private static  class ownership   (  )  {  class  local class < t >   {   }   class <  ?  >  subclass = new  local class <  string >  (  )  {   }   . get class (  )  ;   parameterized type parameterized type =  (  parameterized type 
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java,disallow primitive type,"private static void   (  type[] types  string used as )  {  for  (   type type : types )   {  if  ( type instanceof  class )   {   class <  ?  >  cls =  (  class <  ?  >  ) type ;  check argument (  ! cls . is primitive (  )  "" primitive type '%s' used as %s"" cls used as )  ;   }   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java,equals,@ override public boolean   (  object other )  {  if  (  !  ( other instanceof  parameterized type )  )   {  return false ;   }   parameterized type that =  (  parameterized type ) other ;  return get raw type (  )  . equals ( that . get raw type (  )  ) 
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java,filter upper bounds,private static  iterable <  type >    (  collection <  type >  bounds )  {   predicate <  type >  is object class =  object . class::equals ;  return bounds . stream (  )  . filter ( is object class . negate (  )  )  . collect ( to list (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java,get actual type arguments,@ override public  type[]   (  )  {  return to array ( arguments list )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java,get array class,static  class <  ?  >    (  class <  ?  >  component type )  {  return  array . new instance ( component type 0 )  . get class (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java,get bounds,public  type[]   (  )  {  return to array ( bounds )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java,get component type,"@ nullable static  type   (  type type )  {  check not null ( type ""type"" )  ;  final  atomic reference <  type >  result = new  atomic reference <  type >  (  )  ;  new  type visitor (  )  {  @ override void visit type variable (   type variable <  ?  > "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java,get generic component type,@ override public  type   (  )  {  return component type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java,get generic declaration,public d   (  )  {  return generic declaration ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java,get lower bounds,@ override public  type[]   (  )  {  return to array ( lower bounds )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java,get name,public  string   (  )  {  return name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java,get owner type,@ override public  type   (  )  {  return owner type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java,get raw type,@ override public  type   (  )  {  return raw type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java,get type name,public  string   (  )  {  return name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java,get upper bounds,@ override public  type[]   (  )  {  return to array ( upper bounds )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java,hash code,@ override public int   (  )  {  return  ( owner type  =  =  null  ?  0 : owner type . hash code (  )  )  ^ arguments list . hash code (  )  ^ raw type . hash code (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Types.java,invoke,@ override public  object   (  object proxy  method method  object[] args )  throws  throwable  {   string method name = method . get name (  )  ;   method type variable method = type variable methods . get ( method name )  ;  if  ( type variable method  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeVisitor.java,visit,"public final void   (  type .  .  .  types )  {  for  (   type type : types )   {  if  ( type  =  =  null ||  ! visited . add ( type )  )   {  continue ;   }  boolean succeeded = false ;  try  {  if  ( type instanceof  type variable )   {  visit type variable (  (  type variable <  ?  >  ) type )  ;   }  else if  ( type instanceof  wildcard type )   {  visit wildcard type (  (  wildcard type ) type )  ;   }  else if  ( type instanceof  parameterized type )   {  visit parameterized type (  (  parameterized type ) type )  ;   }  else if  ( type instanceof  class )   {  visit class (  (  class <  ?  >  ) type )  ;   }  else if  ( type instanceof  generic array type )   {  visit generic array type (  (  generic array type ) type )  ;   }  else  {  throw new  assertion error ( "" unknown type: ""  +  type )  ;   }  succeeded = true ;   }  finally  {  if  (  ! succeeded )   {  visited . remove ( type )  ;   }   }   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeToken.java, simple type token,  (  type type )  {  super ( type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeToken.java, type token,"private   (  type type )  {  this . runtime type = check not null ( type ""type"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeToken.java,get raw type,"public final  class <  ?  super t >    (  )  {   class <  ?  >  raw type = get raw types (  )  . iterator (  )  . next (  )  ;  @ suppress warnings ( ""unchecked"" )   class <  ?  super t >  result =  (  class <  ?  super t >  ) raw type ;  return result ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeToken.java,get raw types,"private  set <  class <  ?  super t >  >    (  )  {  final  set <  class <  ?  >  >  builder = new  linked hash set <  >  (  )  ;  new  type visitor (  )  {  @ override void visit type variable (   type variable <  ?  >  t )  {  visit ( t . get bounds (  )  )  ;   }  @ override void visit wildcard type (   wildcard type t )  {  visit ( t . get upper bounds (  )  )  ;   }  @ override void visit parameterized type (   parameterized type t )  {  builder . add (  (  class <  ?  >  ) t . get raw type (  )  )  ;   }  @ override void visit class (   class <  ?  >  t )  {  builder . add ( t )  ;   }  @ override void visit generic array type (   generic array type t )  {  builder . add (  types . get array class ( of ( t . get generic component type (  )  )  . get raw type (  )  )  )  ;   }   }   . visit ( runtime type )  ;  @ suppress warnings (  { ""unchecked"" ""rawtypes"" }  )   set <  class <  ?  super t >  >  result =  (  set )  collections . unmodifiable set ( builder )  ;  return result ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeToken.java,get type,public final  type   (  )  {  return runtime type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeToken.java,of,public static  type token <  ?  >    (  type type )  {  return new  simple type token <  >  ( type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeToken.java,resolve type,"public final  type token <  ?  >    (  type type )  {  check not null ( type ""type"" )  ;   type resolver resolver = type resolver ;  if  ( resolver  =  =  null )   {  resolver =  ( type resolver =  type resolver . according to ( runtime type )  )  ;   }  return of ( resolver . resolve type ( type )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeToken.java,visit class,@ override void   (  class <  ?  >  t )  {  builder . add ( t )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeToken.java,visit generic array type,@ override void   (  generic array type t )  {  builder . add (  types . get array class ( of ( t . get generic component type (  )  )  . get raw type (  )  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeToken.java,visit parameterized type,@ override void   (  parameterized type t )  {  builder . add (  (  class <  ?  >  ) t . get raw type (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeToken.java,visit type variable,@ override void   (  type variable <  ?  >  t )  {  visit ( t . get bounds (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeToken.java,visit wildcard type,@ override void   (  wildcard type t )  {  visit ( t . get upper bounds (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\TypeToken.java,where,public final  < x >  type token < t >    (  type parameter < x >  type param  type token < x >  type arg )  {   type resolver resolver = new  type resolver (  )  . where ( singleton map ( new  type resolver .  type variable key ( type param . type variable )  type arg . runtime type )  )  ;  return new  simple type token < t >  ( resolver . resolve type ( runtime type )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java, handle,  (  config registry config  transaction handler transactions  statement builder statement builder  connection connection )  {  this . transactions = transactions ;  this . connection = connection ;  this . config =  thread local . with initial (  (  )   -  >  config )  ;  this . extension method = new  thread local <  >  (  )  ;  this . statement builder = statement builder ;  this . force end transactions =  ! transactions . is in transaction ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java, transaction resetter,  (  transaction isolation level initial )  {  this . initial = initial ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,attach,"public  < t > t   (  class < t >  extension type )  {  return get config (  extensions . class )  . find for ( extension type  constant handle supplier . of ( this )  )  . or else throw (  (  )   -  >  new  no such extension exception ( "" extension not found: ""  +  extension type )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,begin,"public  handle   (  )  {  transactions . begin ( this )  ;  log . trace ( "" handle [ {  } ] begin transaction"" this )  ;  return this ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,close,@ override public void   (  )  {  set transaction isolation ( initial )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,commit,"public  handle   (  )  {  final long start =  system . nano time (  )  ;  transactions . commit ( this )  ;  log . trace ( "" handle [ {  } ] commit transaction in  {  } ms"" this  (  system . nano time (  )   -  start )   /  1000000l )  ;  return this ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,create batch,public  batch   (  )  {  return new  batch ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,create call,public  call   (  string sql )  {  return new  call ( this sql )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,create query,public  query   (  string sql )  {  return new  query ( this sql )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,create script,public  script   (  string sql )  {  return new  script ( this sql )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,create update,public  update   (  string sql )  {  return new  update ( this sql )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,execute,public int   (  string sql  object .  .  .  args )  {   update stmt = create update ( sql )  ;  int position = 0 ;  for  (   object arg : args )   {  stmt . bind ( position +  +  arg )  ;   }  return stmt . execute (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,get config,@ override public  config registry   (  )  {  return config . get (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,get connection,public  connection   (  )  {  return this . connection ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,get extension method,public  extension method   (  )  {  return extension method . get (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,get statement builder,public  statement builder   (  )  {  return statement builder ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,get transaction isolation level,"public  transaction isolation level   (  )  {  try  {  return  transaction isolation level . value of ( connection . get transaction isolation (  )  )  ;   }  catch  (  sql exception e )   {  throw new  unable to manipulate transaction isolation level exception ( ""unable to access current setting"" e )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,in transaction,public  < r x extends  exception > r   (  transaction isolation level level  handle callback < r x >  callback )  throws x  {  try  (  transaction resetter tr = new  transaction resetter ( get transaction isolation level (  )  )  )  {  set transaction isolation ( level )  ;  return transactions . in transaction ( this level callback )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,is closed,public boolean   (  )  {  return closed ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,is in transaction,public boolean   (  )  {  return transactions . is in transaction ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,is read only,"public boolean   (  )  {  try  {  return connection . is read only (  )  ;   }  catch  (  sql exception e )   {  throw new  unable to manipulate transaction isolation level exception ( "" could not get read only"" e )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,prepare batch,public  prepared batch   (  string sql )  {  return new  prepared batch ( this sql )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,release,"public  handle   (  string savepoint name )  {  transactions . release savepoint ( this savepoint name )  ;  log . trace ( "" handle [ {  } ] release savepoint \"" {  } \"""" this savepoint name )  ;  return this ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,rollback,"public  handle   (  )  {  final long start =  system . nano time (  )  ;  transactions . rollback ( this )  ;  log . trace ( "" handle [ {  } ] rollback transaction in  {  } ms"" this  (  (  system . nano time (  )   -  start )   /  1000000l )  )  ;  return this ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,rollback to savepoint,"public  handle   (  string savepoint name )  {  final long start =  system . nano time (  )  ;  transactions . rollback to savepoint ( this savepoint name )  ;  log . trace ( "" handle [ {  } ] rollback to savepoint \"" {  } \"" in  {  } ms"" this savepoint name  (  (  system . nano time (  )   -  start )   /  1000000l )  )  ;  return this ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,savepoint,"public  handle   (  string name )  {  transactions . savepoint ( this name )  ;  log . trace ( "" handle [ {  } ] savepoint \"" {  } \"""" this name )  ;  return this ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,select,public  query   (  string sql  object .  .  .  args )  {   query query = this . create query ( sql )  ;  int position = 0 ;  for  (   object arg : args )   {  query . bind ( position +  +  arg )  ;   }  return query ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,set config,void   (  config registry config )  {  this . config . set ( config )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,set config thread local,void   (  thread local <  config registry >  config )  {  this . config = config ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,set extension method,void   (  extension method extension method )  {  this . extension method . set ( extension method )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,set extension method thread local,void   (  thread local <  extension method >  extension method )  {  this . extension method = require non null ( extension method )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,set read only,"public  handle   ( boolean read only )  {  try  {  connection . set read only ( read only )  ;   }  catch  (  sql exception e )   {  throw new  unable to manipulate transaction isolation level exception ( "" could not set read only"" e )  ;   }  return this ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,set statement builder,public  handle   (  statement builder builder )  {  this . statement builder = builder ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,set transaction isolation,public void   ( int level )  {  try  {  if  ( connection . get transaction isolation (  )   =  =  level )   {  return ;   }  connection . set transaction isolation ( level )  ;   }  catch  (  sql exception e )   {  throw new  unable to manipulate transaction isolation level exception ( level e )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handle.java,use transaction,public  < x extends  exception > void   (  transaction isolation level level  handle consumer < x >  callback )  throws x  {  in transaction ( level handle  -  >   {  callback . use handle ( handle )  ;  return null ;   }   )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\extension\Extensions.java, extensions,private   (  extensions that )  {  factories . add all ( that . factories )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\extension\Extensions.java,create copy,@ override public  extensions   (  )  {  return new  extensions ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\extension\Extensions.java,find factory,public  < f extends  extension factory >  optional < f >    (  class < f >  factory type )  {  return factories . stream (  )  . filter ( factory type::is instance )  . map ( factory type::cast )  . find first (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\extension\Extensions.java,find factory for,private  optional <  extension factory >    (  class <  ?  >  extension type )  {  return factories . stream (  )  . filter ( factory  -  >  factory . accepts ( extension type )  )  . find first (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\extension\Extensions.java,find for,public  < e >  optional < e >    (  class < e >  extension type  handle supplier handle )  {  return find factory for ( extension type )  . map ( factory  -  >  factory . attach ( extension type handle )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\extension\Extensions.java,has extension for,public boolean   (  class <  ?  >  extension type )  {  return find factory for ( extension type )  . is present (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\extension\Extensions.java,register,public  extensions   (  extension factory factory )  {  factories . add ( 0 factory )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\h2\H2DatabasePlugin.java,customize jdbi,"@ override public void   (  jdbi db )  {  db . set sql array argument strategy (  sql array argument strategy . object   array )  ;  db . register array type ( uuid . class ""uuid"" )  ;  db . register array type ( int . class ""integer"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\internal\JdbiOptionals.java,find first present,@ safe varargs public static  < t >  optional < t >    (  supplier <  optional < t >  >  .  .  .  suppliers )  {  return  stream . of ( suppliers )  . flat map ( supplier  -  >  to stream ( supplier . get (  )  )  )  . find first (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handles.java, handles,private   (  handles that )  {  this . force end transactions = that . force end transactions ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handles.java,create copy,@ override public  handles   (  )  {  return new  handles ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handles.java,is force end transactions,public boolean   (  )  {  return force end transactions ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Handles.java,set force end transactions,public void   ( boolean force end transactions )  {  this . force end transactions = force end transactions ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\internal\IterableLike.java, primitive array iterator,  ( final  object obj )  {  size =  array . get length ( obj )  ;  arr = obj ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\internal\IterableLike.java,get type warning,"private static  string   ( final  class <  ?  >  type )  {  return ""argument must be one of the following:  iterable  or an array / varargs  ( primitive or complex type )  ;  was ""  +  type . get name (  )   +  "" instead"" ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\internal\IterableLike.java,has next,@ override public boolean   (  )  {  return index  <  size ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\internal\IterableLike.java,is empty,"public static boolean   ( final  object obj )  {  if  ( obj  =  =  null )   {  throw new  illegal argument exception ( ""cannot determine emptiness of null"" )  ;   }  if  ( obj instanceof  collection )   {  return  (  (  collection <  ?  >  ) obj )  . is empty (  )  ;   }  if  ( obj instanceof  iterable )   {  return  !  (  (  iterable <  ?  >  ) obj )  . iterator (  )  . has next (  )  ;   }  if  ( obj . get class (  )  . is array (  )  )   {  return  array . get length ( obj )   =  =  0 ;   }  throw new  illegal argument exception ( get type warning ( obj . get class (  )  )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\internal\IterableLike.java,is iterable,public static boolean   (  object maybe iterable )  {  return maybe iterable instanceof  iterator <  ?  >  || maybe iterable instanceof  iterable <  ?  >  || maybe iterable . get class (  )  . is array (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\internal\IterableLike.java,next,"@ override public  object   (  )  {  if  ( has next (  )  )   {  return  array . get ( arr index +  +  )  ;   }  else  {  throw new  no such element exception ( ""only ""  +  size  +  "" elements available"" )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\internal\IterableLike.java,of,"@ suppress warnings ( ""unchecked"" )  public static  iterator <  object >    (  object iterable )  {  if  ( iterable  =  =  null )   {  throw new  illegal argument exception ( ""can't iterate null"" )  ;   }  if  ( iterable instanceof  iterator <  ?  >  )   "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\internal\IterableLike.java,remove,@ override public void   (  )  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\internal\IterableLike.java,to list,public static  list <  object >    (  object iterable )  {   list <  object >  result = new  array list <  object >  (  )  ;  of ( iterable )  . for each remaining ( result::add )  ;  return result ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\internal\JdbiStreams.java,to stream,public static  < t >  stream < t >    (  optional < t >  optional )  {  return optional . is present (  )   ?   stream . of ( optional . get (  )  )  :  stream . empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\internal\JdbiThreadLocals.java,invoke in context,public static  < v l > v   (  thread local < l >  thread local l context  callable < v >  task )  throws  exception  {  l old context = thread local . get (  )  ;  try  {  thread local . set ( context )  ;  return task . call (  )  ;   }  finally  {  if  ( old context  =  =  null )   {  thread local . remove (  )  ;   }  else  {  thread local . set ( old context )  ;   }   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\internal\SqlScriptParser.java, sql script parser,public   (  token handler semicolon handler )  {  this . semicolon handler = semicolon handler ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\JdbiException.java, jdbi exception,public   (  string message )  {  super ( message )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Jdbi.java, jdbi,"private   (  connection factory connection factory )  {   objects . require non null ( connection factory ""null connection factory"" )  ;  this . connection factory = connection factory ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Jdbi.java,create,"public static  jdbi   ( final  string url final  string username final  string password )  {   objects . require non null ( url ""null url"" )  ;   objects . require non null ( username ""null username"" )  ;   objects . require non null ( password ""null password"" )  ;  return create (  (  )   -  >   driver manager . get connection ( url username password )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Jdbi.java,get config,@ override public  config registry   (  )  {  return config ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Jdbi.java,get statement builder factory,public  statement builder factory   (  )  {  return this . statement builder factory . get (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Jdbi.java,get transaction handler,public  transaction handler   (  )  {  return this . transactionhandler . get (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Jdbi.java,in transaction,public  < r x extends  exception > r   ( final  transaction isolation level level final  handle callback < r x >  callback )  throws x  {  return with handle ( handle  -  >  handle .  < r x > in transaction ( level callback )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Jdbi.java,install plugin,public  jdbi   (  jdbi plugin plugin )  {  plugin . customize jdbi ( this )  ;  plugins . add ( plugin )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Jdbi.java,install plugins,"public  jdbi   (  )  {   service loader . load (  jdbi plugin . class )  . for each ( this::install plugin )  ;  log . debug ( "" automatically installed plugins  {  } "" plugins )  ;  return this ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Jdbi.java,on demand,"public  < e > e   (  class < e >  extension type )  throws  no such extension exception  {  if  (  ! extension type . is interface (  )  )   {  throw new  illegal argument exception ( "" on - demand extensions are only supported for interfaces . "" )  ;   }  if  (  ! get config (  extensions . class )  . has extension for ( extension type )  )   {  throw new  no such extension exception ( "" extension not found: ""  +  extension type )  ;   }  return  on demand extensions . create ( this extension type )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Jdbi.java,open,"public  handle   (  )  {  try  {  final long start =  system . nano time (  )  ;   connection conn = connection factory . open connection (  )  ;  final long stop =  system . nano time (  )  ;  for  (   jdbi plugin p : plugins )   {  conn = p . customize connection ( conn )  ;   }   statement builder cache = statement builder factory . get (  )  . create statement builder ( conn )  ;   handle h = new  handle ( config . create copy (  )  transactionhandler . get (  )  cache conn )  ;  for  (   jdbi plugin p : plugins )   {  h = p . customize handle ( h )  ;   }  log . trace ( "" jdbi [ {  } ] obtain handle [ {  } ] in  {  } ms"" this h  ( stop  -  start )   /  1000000l )  ;  return h ;   }  catch  (  sql exception e )   {  throw new  connection exception ( e )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Jdbi.java,set statement builder factory,public  jdbi   (  statement builder factory factory )  {  this . statement builder factory . set ( factory )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Jdbi.java,set transaction handler,"public  jdbi   (  transaction handler handler )  {   objects . require non null ( handler ""null transaction handler"" )  ;  this . transactionhandler . set ( handler )  ;  return this ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Jdbi.java,use extension,public  < e x extends  exception > void   (  class < e >  extension type  extension consumer < e x >  callback )  throws  no such extension exception  x  {  with extension ( extension type extension  -  >   {  callback . use extension ( extension )  ;  return null ;   }   )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Jdbi.java,use handle,public  < x extends  exception > void   ( final  handle consumer < x >  callback )  throws x  {  with handle ( h  -  >   {  callback . use handle ( h )  ;  return null ;   }   )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Jdbi.java,use transaction,public  < x extends  exception > void   ( final  transaction isolation level level final  handle consumer < x >  callback )  throws x  {  use handle ( handle  -  >  handle . use transaction ( level callback )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Jdbi.java,with extension,"public  < r e x extends  exception > r   (  class < e >  extension type  extension callback < r e x >  callback )  throws  no such extension exception  x  {  try  (  lazy handle supplier handle = new  lazy handle supplier ( this config )  )  {  e extension = get config (  extensions . class )  . find for ( extension type handle )  . or else throw (  (  )   -  >  new  no such extension exception ( "" extension not found: ""  +  extension type )  )  ;  return callback . with extension ( extension )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\Jdbi.java,with handle,public  < r x extends  exception > r   (  handle callback < r x >  callback )  throws x  {  try  (  handle h = this . open (  )  )  {  return callback . with handle ( h )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\BuiltInMapperFactory.java,build,@ override public  optional <  column mapper <  ?  >  >    (  type type  config registry config )  {   class <  ?  >  raw type = get erased type ( type )  ;  if  ( raw type . is enum (  )  )   {  return  optional . of (  enum mapper . by name ( raw type .
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\generic\internal\Reflection.java,new proxy,"public static  < t > t   (  class < t >  interface type  invocation handler handler )  {  check not null ( handler ""handler"" )  ;  check argument ( interface type . is interface (  )  ""%s is not an interface"" interface type )  ;   object object =  proxy . new proxy instance ( interface type . get class loader (  )  new  class <  ?  > [] { interface type }  handler )  ;  return interface type . cast ( object )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\locator\ClasspathSqlLocator.java,find sql on classpath,public static  string   (  string name )  {   string path = resource path for ( name )  ;  return get resource on classpath ( select class loader (  )  path )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\locator\ClasspathSqlLocator.java,get resource on classpath,public static  string   (  class loader class loader  string path )  {  return cache . get ( new  abstract map .  simple entry <  >  ( class loader path )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\locator\ClasspathSqlLocator.java,open stream,"private static  input stream   (  class loader class loader  string path )  {   input stream is = class loader . get resource as stream ( path )  ;  if  ( is  =  =  null )   {  throw new  illegal argument exception ( "" cannot find classpath resource at ""  +  path )  ;   }  return is ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\locator\ClasspathSqlLocator.java,read resource,"private static  string   (  class loader class loader  string path )  {  try  (  input stream is = open stream ( class loader path )  )  {  return sql   script   parser . parse ( new antlr input stream ( is )  )  ;   }  catch  (  io exception e )   {  throw new  runtime exception ( "" unable to read classpath resource at ""  +  path e )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\locator\ClasspathSqlLocator.java,resource path for,private static  string   (  string fully qualified name )  {  return fully qualified name . replace ( package   delimiter path   delimiter )   +  sql   extension ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\locator\ClasspathSqlLocator.java,select class loader,private static  class loader   (  )  {  return  optional . of nullable (  thread . current thread (  )  . get context class loader (  )  )  . or else get (  classpath sql locator . class::get class loader )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\ColumnMapper.java,map,default t   (  result set r  string column label  statement context ctx )  throws sql exception  {  return map ( r r . find column ( column label )  ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\LazyHandleSupplier.java, lazy handle supplier,  (  jdbi db  config registry config )  {  this . db = db ;  this . config =  thread local . with initial (  (  )   -  >  config )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\LazyHandleSupplier.java,close,@ override public synchronized void   (  )  {  closed = true ;  if  ( handle  !  =  null )   {  handle . close (  )  ;   }  else  {  config . remove (  )  ;  extension method . remove (  )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\LazyHandleSupplier.java,get config,@ override public  config registry   (  )  {  return config . get (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\LazyHandleSupplier.java,get handle,@ override public  handle   (  )  {  if  ( handle  =  =  null )   {  init handle (  )  ;   }  return handle ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\LazyHandleSupplier.java,init handle,"private synchronized void   (  )  {  if  ( handle  =  =  null )   {  if  ( closed )   {  throw new  illegal state exception ( "" handle is closed"" )  ;   }   handle handle = db . open (  )  ;  handle . set extension method thread local ( extension method )  ;  handle . set config thread local ( config )  ;  this . handle = handle ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\LazyHandleSupplier.java,invoke in context,@ override public  < v > v   (  extension method extension method  config registry config  callable < v >  task )  throws  exception  {  return  jdbi thread locals . invoke in context ( this . extension method extension method  (  )   -  >   jdbi thread l
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\ColumnMappers.java, column mappers,private   (  column mappers that )  {  factories . add all ( that . factories )  ;  cache . put all ( that . cache )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\ColumnMappers.java,create copy,@ override public  column mappers   (  )  {  return new  column mappers ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\ColumnMappers.java,find for,public  optional <  column mapper <  ?  >  >    (  type type )  {   column mapper <  ?  >  cached = cache . get ( type )  ;  if  ( cached  !  =  null )   {  return  optional . of ( cached )  ;   }   optional <  column mapper <  ?  >  >  mapper = factories . stream (  )  . flat map ( factory  -  >  to stream ( factory . build ( type registry )  )  )  . find first (  )  ;  mapper . if present ( m  -  >  cache . put ( type m )  )  ;  return mapper ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\EnumByOrdinalMapperFactory.java,build,"@ suppress warnings (  { ""unchecked"" ""rawtypes"" }  )  @ override public  optional <  column mapper <  ?  >  >    (  type type  config registry config )  {   class <  ?  >  clazz = get erased type ( type )  ;  return clazz . is enum (  )   ?   optional . o"
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\ColumnMappers.java,register,public  column mappers   (  column mapper factory factory )  {  factories . add ( 0 factory )  ;  cache . clear (  )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\ColumnMappers.java,set registry,@ override public void   (  config registry registry )  {  this . registry = registry ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\EnumMapper.java, by name,private   (  class < e >  type )  {  this . type = type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\EnumMapper.java, by ordinal,private   (  class < e >  type )  {  this . constants = type . get enum constants (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\EnumMapper.java,by name,public static  < e extends  enum < e >  >  column mapper < e >    (  class < e >  type )  {  return new  by name <  >  ( type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\EnumMapper.java,by ordinal,public static  < e extends  enum < e >  >  column mapper < e >    (  class < e >  type )  {  return new  by ordinal <  >  ( type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\EnumMapper.java,map,@ override public e   (  result set r int column number  statement context ctx )  throws sql exception  {  int ordinal = r . get int ( column number )  ;  return r . was null (  )   ?  null : constants[ordinal] ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\EnumMapper.java,resolve,private e   (  string name )  {  final  illegal argument exception failure ;  try  {  return  enum . value of ( type name )  ;   }  catch  (   illegal argument exception e )   {  failure = e ;   }  for  (  e e : type . get enum constants (  )  )   {  if  ( e . name (  )  . equals ignore case ( name )  )   {  return e ;   }   }  throw failure ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\EnumByNameMapperFactory.java,build,"@ suppress warnings (  { ""unchecked"" ""rawtypes"" }  )  @ override public  optional <  column mapper <  ?  >  >    (  type type  config registry config )  {   class <  ?  >  clazz = get erased type ( type )  ;  return clazz . is enum (  )   ?   optional . o"
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\JoinRow.java, join row,  (  map <  type  object >  entries )  {  this . entries = entries ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\JoinRow.java,get,"public  object   (  type type )  {   object result = entries . get ( type )  ;  if  ( result  =  =  null &&  ! entries . contains key ( type )  )   {  throw new  illegal argument exception ( ""no result stored for ""  +  type )  ;   }  return result ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\JoinRowMapper.java, join row mapper,private   (  type[] types )  {  this . types = types ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\JoinRowMapper.java,for types,public static  join row mapper   (  type .  .  .  classes )  {  return new  join row mapper ( classes )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\JoinRowMapper.java,map,@ override public  join row   (  result set r  statement context ctx )  throws sql exception  {  return specialize ( r ctx )  . map ( r ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\JoinRowMapper.java,specialize,@ override public  row mapper <  join row >    (  result set r  statement context ctx )  throws sql exception  {   row mapper <  ?  > [] mappers = new  row mapper[types . length] ;  for  ( int i = 0 ;  i  <  types . length ;  i +  +  )   {   type type = t
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\InferredRowMapperFactory.java, inferred row mapper factory,"  (  row mapper <  ?  >  mapper )  {  this . maps = find generic parameter ( mapper . get class (  )   row mapper . class )  . or else throw (  (  )   -  >  new  unsupported operation exception ( "" must use a concretely typed  row mapper here"" )  )  ;  this . mapper = mapper ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\InferredRowMapperFactory.java,build,@ override public  optional <  row mapper <  ?  >  >    (  type type  config registry config )  {  return maps . equals ( type )   ?   optional . of ( mapper )  :  optional . empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\InferredColumnMapperFactory.java, inferred column mapper factory,"  (  column mapper <  ?  >  mapper )  {  this . maps = find generic parameter ( mapper . get class (  )   column mapper . class )  . or else throw (  (  )   -  >  new  unsupported operation exception ( "" must use a concretely typed  column mapper here"" )  )  ;  this . mapper = mapper ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\InferredColumnMapperFactory.java,build,@ override public  optional <  column mapper <  ?  >  >    (  type type  config registry config )  {  return maps . equals ( type )   ?   optional . of ( mapper )  :  optional . empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\MapEntryMappers.java, map entry mappers,private   (  map entry mappers that )  {  this . key column = that . key column ;  this . value column = that . value column ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\MapEntryMappers.java,create copy,@ override public  map entry mappers   (  )  {  return new  map entry mappers ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\MapEntryMappers.java,get key column,@ override public  string   (  )  {  return key column ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\MapEntryMappers.java,get value column,@ override public  string   (  )  {  return value column ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\MapEntryMapper.java, map entry mapper,private   (  row mapper < k >  key mapper  row mapper < v >  value mapper )  {  this . key mapper = key mapper ;  this . value mapper = value mapper ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\MapEntryMapper.java,factory,"@ suppress warnings ( ""unchecked"" )  static  row mapper factory   (  )  {  return  ( type config )   -  >   {  if  ( type instanceof  parameterized type && get erased type ( type )  . equals (  map .  entry . class )  )   {   type key type = resolve type "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\MapEntryMapper.java,get key mapper,"private static  row mapper <  ?  >    (  type key type  config registry config )  {   string column = config . get (  map entry mappers . class )  . get key column (  )  ;  if  ( column  =  =  null )   {  return config . get (  row mappers . class )  . find for ( key type )  . or else throw (  (  )   -  >  new  no such mapper exception ( "" no row mapper registered for map key ""  +  key type )  )  ;   }  else  {  return config . get (  column mappers . class )  . find for ( key type )  . map ( mapper  -  >  new  single column mapper <  >  ( mapper column )  )  . or else throw (  (  )   -  >  new  no such mapper exception ( "" no column mapper registered for map key ""  +  key type  +  "" in column "" +  column )  )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\MapEntryMapper.java,get value mapper,"private static  row mapper <  ?  >    (  type value type  config registry config )  {   string column = config . get (  map entry mappers . class )  . get value column (  )  ;  if  ( column  =  =  null )   {  return config . get (  row mappers . class )  . find for ( value type )  . or else throw (  (  )   -  >  new  no such mapper exception ( "" no row mapper registered for map value ""  +  value type )  )  ;   }  else  {  return config . get (  column mappers . class )  . find for ( value type )  . map ( mapper  -  >  new  single column mapper <  >  ( mapper column )  )  . or else throw (  (  )   -  >  new  no such mapper exception ( "" no column mapper registered for map value ""  +  value type  +  "" in column "" +  column )  )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\MapEntryMapper.java,map,@ override public  map .  entry < k v >    (  result set rs  statement context ctx )  throws sql exception  {  return new  abstract map .  simple immutable entry <  >  ( key mapper . map ( rs ctx )  value mapper . map ( rs ctx )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\MapEntryMapper.java,specialize,@ override public  row mapper <  map .  entry < k v >  >    (  result set rs  statement context ctx )  throws sql exception  {  return new  map entry mapper <  >  ( key mapper . specialize ( rs ctx )  value mapper . specialize ( rs ctx )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\MapEntryMappers.java,set key column,@ override public  map entry mappers   (  string key column )  {  this . key column = key column ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\MapEntryMappers.java,set value column,@ override public  map entry mappers   (  string value column )  {  this . value column = value column ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\MapMapper.java, map mapper,public   ( boolean fold case )  {  this . fold case = fold case ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\MapMapper.java,map,@ override public  map <  string  object >    (  result set rs  statement context ctx )  throws sql exception  {  return specialize ( rs ctx )  . map ( rs ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\MapMapper.java,specialize,@ override public  row mapper <  map <  string  object >  >    (  result set rs  statement context ctx )  throws sql exception  {   result set meta data m = rs . get meta data (  )  ;  int column count = m . get column count (  )  ;   string[] column name
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\MappingException.java, mapping exception,public   (  string message )  {  super ( message )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\Mappers.java,create copy,@ override public  mappers   (  )  {  return new  mappers (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\Mappers.java,find for,public  optional <  row mapper <  ?  >  >    (  type type )  {  return find first present (  (  )   -  >  row mappers . find for ( type )   (  )   -  >  column mappers . find for ( type )  . map (  single column mapper::new )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\Mappers.java,set registry,@ override public void   (  config registry registry )  {  this . row mappers = registry . get (  row mappers . class )  ;  this . column mappers = registry . get (  column mappers . class )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\NoSuchMapperException.java, no such mapper exception,public   (  string message )  {  super ( message )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\OptionalMapper.java, optional mapper,private   (  type type )  {  this . type = type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\OptionalMapper.java,map,"@ suppress warnings ( ""unchecked"" )  @ override public  optional < t >    (  result set r int column number  statement context ctx )  throws sql exception  {  final  column mapper <  ?  >  mapper = ctx . find column mapper for (  generic types . find gene"
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\OptionalMapper.java,of,public static  column mapper <  ?  >    (  type type )  {  return new  optional mapper <  >  ( type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\CaseInsensitiveColumnNameMatcher.java,column name matches,@ override public boolean   (  string column name  string java name )  {  return column name . equals ignore case ( java name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\CaseInsensitiveColumnNameMatcher.java,to string,@ override public  string   (  )  {  return get class (  )  . get simple name (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\BeanMapper.java, bean mapper,private   (  class < t >  type  string prefix )  {  this . type = type ;  this . prefix = prefix . to lower case (  )  ;  try  {  info =  introspector . get bean info ( type )  ;   }  catch  (   introspection exception e )   {  throw new  illegal argument exception ( e )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\BeanMapper.java,construct,"private t   (  )  {  try  {  return type . new instance (  )  ;   }  catch  (   exception e )   {  throw new  illegal argument exception (  string . format ( ""a bean  %s  was mapped ""  +  ""which was not instantiable"" type . get name (  )  )  e )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\BeanMapper.java,debug name,"private  string   (  property descriptor descriptor )  {  return  string . format ( ""%s . %s"" type . get simple name (  )  descriptor . get name (  )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\BeanMapper.java,factory,public static  row mapper factory   (  class <  ?  >  type  string prefix )  {  return  row mapper factory . of ( type  bean mapper . of ( type prefix )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\BeanMapper.java,map,@ override public t   (  result set rs  statement context ctx )  throws sql exception  {  return specialize ( rs ctx )  . map ( rs ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\BeanMapper.java,of,public static  < t >  row mapper < t >    (  class < t >  type  string prefix )  {  return new  bean mapper <  >  ( type prefix )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\BeanMapper.java,param name,private static  string   (  property descriptor descriptor )  {  return  stream . of ( descriptor . get read method (  )  descriptor . get write method (  )  )  . filter (  objects::non null )  . map ( method  -  >  method . get annotation (  column name . class )  )  . filter (  objects::non null )  . map (  column name::value )  . find first (  )  . or else get ( descriptor::get name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\BeanMapper.java,specialize,@ override public  row mapper < t >    (  result set rs  statement context ctx )  throws sql exception  {  final  list <  string >  column names = get column names ( rs )  ;  final  list <  column name matcher >  column name matchers = ctx . get config ( 
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\BeanMapper.java,specialize,"private  row mapper < t >    (  result set rs  statement context ctx  list <  string >  column names  list <  column name matcher >  column name matchers  list <  string >  unmatched columns )  throws sql exception  {  final  list <  row mapper <  ?  >  >  mappers = new  array list <  >  (  )  ;  final  list <  property descriptor >  properties = new  array list <  >  (  )  ;  for  (   property descriptor descriptor : info . get property descriptors (  )  )   {   nested anno =  stream . of ( descriptor . get read method (  )  descriptor . get write method (  )  )  . filter (  objects::non null )  . map ( m  -  >  m . get annotation (  nested . class )  )  . filter (  objects::non null )  . find first (  )  . or else ( null )  ;  if  ( anno  =  =  null )   {   string param name = prefix  +  param name ( descriptor )  ;  find column index ( param name column names column name matchers  (  )   -  >  debug name ( descriptor )  )  . if present ( index  -  >   {   type type = descriptor . get read method (  )  . get generic return type (  )  ;   column mapper <  ?  >  mapper = ctx . find column mapper for ( type )  . or else (  ( r n c )   -  >  r . get object ( n )  )  ;  mappers . add ( new  single column mapper <  >  ( mapper index  +  1 )  )  ;  properties . add ( descriptor )  ;  unmatched columns . remove ( column names . get ( index )  )  ;   }   )  ;   }  else  {   string nested prefix = prefix  +  anno . value (  )  ;   row mapper <  ?  >  nested mapper = nested mappers . compute if absent ( descriptor d  -  >  new  bean mapper <  >  ( d . get property type (  )  nested prefix )  )  . specialize0 ( rs ctx column names column name matchers unmatched columns )  ;  mappers . add ( nested mapper )  ;  properties . add ( descriptor )  ;   }   }  if  ( mappers . is empty (  )  && column names . size (  )   >  0 )   {  throw new  illegal argument exception (  string . format ( "" mapping bean type %s ""  +  ""didn't find any matching columns in result set"" type )  )  ;   }  return  ( r c )   -  >   {  t bean = construct (  )  ;  for  ( int i = 0 ;  i  <  mappers . size (  )  ;  i +  +  )   {   row mapper <  ?  >  mapper = mappers . get ( i )  ;   property descriptor property = properties . get ( i )  ;   object value = mapper . map ( r ctx )  ;  write property ( bean property value )  ;   }  return bean ;   }   ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\BeanMapper.java,write property,"private static void   (  object bean  property descriptor property  object value )  {  try  {  property . get write method (  )  . invoke ( bean value )  ;   }  catch  (   illegal access exception e )   {  throw new  illegal argument exception (  string . format ( "" unable to access setter for ""  +  ""property  %s"" property . get name (  )  )  e )  ;   }  catch  (   invocation target exception e )   {  throw new  illegal argument exception (  string . format ( "" invocation target exception trying to ""  +  ""invoker setter for the %s property"" property . get name (  )  )  e )  ;   }  catch  (   null pointer exception e )   {  throw new  illegal argument exception (  string . format ( "" no appropriate method to ""  +  ""write property %s"" property . get name (  )  )  e )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\FieldMapper.java, field mapper,private   (  class < t >  type  string prefix )  {  this . type = type ;  this . prefix = prefix . to lower case (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\FieldMapper.java,construct,"private t   (  )  {  try  {  return type . new instance (  )  ;   }  catch  (   exception e )   {   string message =  string . format ( ""a type  %s  was mapped which was not instantiable"" type . get name (  )  )  ;  throw new  illegal argument exception ( message e )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\FieldMapper.java,debug name,"private  string   (  field field )  {  return  string . format ( ""%s . %s"" type . get simple name (  )  field . get name (  )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\FieldMapper.java,factory,public static  row mapper factory   (  class <  ?  >  type  string prefix )  {  return  row mapper factory . of ( type  field mapper . of ( type prefix )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\FieldMapper.java,map,@ override public t   (  result set rs  statement context ctx )  throws sql exception  {  return specialize ( rs ctx )  . map ( rs ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\FieldMapper.java,of,public static  < t >  row mapper < t >    (  class < t >  type  string prefix )  {  return new  field mapper <  >  ( type prefix )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\FieldMapper.java,param name,private static  string   (  field field )  {  return  optional . of nullable ( field . get annotation (  column name . class )  )  . map (  column name::value )  . or else get ( field::get name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\FieldMapper.java,specialize,@ override public  row mapper < t >    (  result set rs  statement context ctx )  throws sql exception  {  final  list <  string >  column names = get column names ( rs )  ;  final  list <  column name matcher >  column name matchers = ctx . get config ( 
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\FieldMapper.java,specialize,"private  row mapper < t >    (  result set rs  statement context ctx  list <  string >  column names  list <  column name matcher >  column name matchers  list <  string >  unmatched columns )  throws sql exception  {  final  list <  row mapper <  ?  >  >  mappers = new  array list <  >  (  )  ;  final  list <  field >  fields = new  array list <  >  (  )  ;  for  (  class <  ?  >  a type = type ;  a type  !  =  null ;  a type = a type . get superclass (  )  )   {  for  (   field field : a type . get declared fields (  )  )   {   nested anno = field . get annotation (  nested . class )  ;  if  ( anno  =  =  null )   {   string param name = prefix  +  param name ( field )  ;  find column index ( param name column names column name matchers  (  )   -  >  debug name ( field )  )  . if present ( index  -  >   {   type type = field . get generic type (  )  ;   column mapper <  ?  >  mapper = ctx . find column mapper for ( type )  . or else (  ( r n c )   -  >  rs . get object ( n )  )  ;  mappers . add ( new  single column mapper ( mapper index  +  1 )  )  ;  fields . add ( field )  ;  unmatched columns . remove ( column names . get ( index )  )  ;   }   )  ;   }  else  {   string nested prefix = prefix  +  anno . value (  )  . to lower case (  )  ;   row mapper <  ?  >  mapper = nested mappers . compute if absent ( field f  -  >  new  field mapper <  >  ( field . get type (  )  nested prefix )  )  . specialize0 ( rs ctx column names column name matchers unmatched columns )  ;  mappers . add ( mapper )  ;  fields . add ( field )  ;   }   }   }  if  ( mappers . is empty (  )  && column names . size (  )   >  0 )   {  throw new  illegal argument exception (  string . format ( "" mapping fields for type %s ""  +  ""didn't find any matching columns in result set"" type )  )  ;   }  return  ( r c )   -  >   {  t obj = construct (  )  ;  for  ( int i = 0 ;  i  <  mappers . size (  )  ;  i +  +  )   {   row mapper <  ?  >  mapper = mappers . get ( i )  ;   field field = fields . get ( i )  ;   object value = mapper . map ( rs ctx )  ;  write field ( obj field value )  ;   }  return obj ;   }   ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\FieldMapper.java,write field,"private void   ( t obj  field field  object value )  {  try  {  field . set accessible ( true )  ;  field . set ( obj value )  ;   }  catch  (   illegal access exception e )   {  throw new  illegal argument exception (  string . format ( "" unable to access ""  +  ""property  %s"" field . get name (  )  )  e )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapper.java, constructor mapper,private   (  constructor < t >  constructor  string prefix )  {  this . constructor = constructor ;  this . prefix = prefix . to lower case (  )  ;  this . constructor properties = constructor . get annotation (  constructor properties . class )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapper.java,construct,private t   (  object[] params )  {  try  {  return constructor . new instance ( params )  ;   }  catch  (   instantiation exception| illegal access exception| invocation target exception e )   {  if  ( e . get cause (  )  instanceof  runtime exception )   {  throw  (  runtime exception ) e . get cause (  )  ;   }  if  ( e . get cause (  )  instanceof  error )   {  throw  (  error ) e . get cause (  )  ;   }  throw new  runtime exception ( e )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapper.java,debug name,"private  string   (  parameter parameter )  {  return  string . format ( ""%s constructor parameter %s"" constructor . get declaring class (  )  . get simple name (  )  parameter . get name (  )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapper.java,factory,public static  row mapper factory   (  constructor <  ?  >  constructor  string prefix )  {  return  row mapper factory . of ( constructor . get declaring class (  )   constructor mapper . of ( constructor prefix )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapper.java,map,@ override public t   (  result set rs  statement context ctx )  throws sql exception  {  return specialize ( rs ctx )  . map ( rs ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapper.java,of,public static  < t >  row mapper < t >    (  constructor < t >  constructor  string prefix )  {  return new  constructor mapper <  >  ( constructor prefix )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapper.java,param name,private static  string   (  parameter[] parameters int position  constructor properties parameter names )  {  final  parameter parameter = parameters[position] ;   column name db name = parameter . get annotation (  column name . class )  ;  if  ( db name  !  =  null )   {  return db name . value (  )  ;   }  if  ( parameter names  !  =  null )   {  return parameter names . value (  ) [position] ;   }  return parameter . get name (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapper.java,specialize,@ override public  row mapper < t >    (  result set rs  statement context ctx )  throws sql exception  {  final  list <  string >  column names = get column names ( rs )  ;  final  list <  column name matcher >  column name matchers = ctx . get config ( 
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapper.java,specialize,"private  row mapper < t >    (  result set rs  statement context ctx  list <  string >  column names  list <  column name matcher >  column name matchers  list <  string >  unmatched columns )  throws sql exception  {  final int count = constructor . get parameter count (  )  ;  final  parameter[] parameters = constructor . get parameters (  )  ;  final  row mapper <  ?  > [] mappers = new  row mapper <  ?  > [count] ;  for  ( int i = 0 ;  i  <  count ;  i +  +  )   {  final  parameter parameter = parameters[i] ;   nested anno = parameter . get annotation (  nested . class )  ;  if  ( anno  =  =  null )   {  final  string param name = prefix  +  param name ( parameters i constructor properties )  ;  final int column index = find column index ( param name column names column name matchers  (  )   -  >  debug name ( parameter )  )  . or else throw (  (  )   -  >  new  illegal argument exception (  string . format ( "" constructor '%s' parameter '%s' has no column in the result set .  ""  +  "" verify that the  java compiler is configured to emit parameter names  ""  +  ""that your result set has the columns expected  or annotate the "" +  ""parameter names explicitly with @ column name"" constructor param name )  )  )  ;  final  type type = parameter . get parameterized type (  )  ;  mappers[i] = ctx . find column mapper for ( type )  . map ( mapper  -  >  new  single column mapper ( mapper column index  +  1 )  )  . or else throw (  (  )   -  >  new  illegal argument exception (  string . format ( "" could not find column mapper for type '%s' of parameter '%s' for constructor '%s'"" type param name constructor )  )  )  ;  unmatched columns . remove ( column names . get ( column index )  )  ;   }  else  {   string nested prefix = prefix  +  anno . value (  )  ;  mappers[i] = nested mappers . compute if absent ( parameter p  -  >  new  constructor mapper <  >  ( find constructor for ( p . get type (  )  )  nested prefix )  )  . specialize0 ( rs ctx column names column name matchers unmatched columns )  ;   }   }  return  ( r c )   -  >   {  final  object[] params = new  object[count] ;  for  ( int i = 0 ;  i  <  count ;  i +  +  )   {  params[i] = mappers[i] . map ( r c )  ;   }  return construct ( params )  ;   }   ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\SnakeCaseColumnNameMatcher.java,column name matches,"@ override public boolean   (  string column name  string java name )  {  return column name . replace ( ""   "" """" )  . equals ignore case ( java name . replace ( ""   "" """" )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\ReflectionMappers.java, reflection mappers,private   (  reflection mappers that )  {  column name matchers = new  array list <  >  ( that . column name matchers )  ;  strict matching = that . strict matching ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\SnakeCaseColumnNameMatcher.java,to string,@ override public  string   (  )  {  return get class (  )  . get simple name (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\ReflectionMappers.java,create copy,@ override public  reflection mappers   (  )  {  return new  reflection mappers ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\ReflectionMappers.java,get column name matchers,public  list <  column name matcher >    (  )  {  return  collections . unmodifiable list ( column name matchers )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\ReflectionMappers.java,is strict matching,public boolean   (  )  {  return this . strict matching ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\ReflectionMappers.java,set column name matchers,public  reflection mappers   (  list <  column name matcher >  column name matchers )  {  this . column name matchers = new  array list <  >  ( column name matchers )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\ReflectionMappers.java,set strict matching,public  reflection mappers   ( boolean strict matching )  {  this . strict matching = strict matching ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\ReflectionMapperUtil.java,find column index,"public static  optional int   (  string param name  list <  string >  column names  list <  column name matcher >  column name matchers  supplier <  string >  debug name )  {   optional int result =  optional int . empty (  )  ;  for  ( int i = 0 ;  i  <  column names . size (  )  ;  i +  +  )   {   string column name = column names . get ( i )  ;  for  (   column name matcher strategy : column name matchers )   {  if  ( strategy . column name matches ( column name param name )  )   {  if  ( result . is present (  )  )   {  throw new  illegal argument exception (  string . format ( ""'%s'  ( %s )  matches multiple columns: '%s'  ( %d )  and '%s'  ( %d ) "" debug name . get (  )  param name column names . get ( result . get as int (  )  )  result . get as int (  )  column names . get ( i )  i )  )  ;   }  result =  optional int . of ( i )  ;  break ;   }   }   }  return result ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\ReflectionMapperUtil.java,get column names,public static  list <  string >    (  result set rs )  throws sql exception  {  final  result set meta data metadata = rs . get meta data (  )  ;  final int count = metadata . get column count (  )  ;  final  list <  string >  column names = new  array list <  >  ( count )  ;  for  ( int i = 0 ;  i  <  count ;   +  + i )   {  column names . add ( metadata . get column label ( i  +  1 )  . to lower case (  )  )  ;   }  return column names ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\reflect\JdbiConstructors.java,find constructor for,"public static  < t >  constructor < t >    (  class < t >  type )  {  @ suppress warnings ( ""unchecked"" )  final  constructor < t > [] constructors =  (  constructor < t > [] ) type . get declared constructors (  )  ;   list <  constructor < t >  >  annotated constructors =  stream . of ( constructors )  . filter ( c  -  >  c . is annotation present (  jdbi constructor . class )  )  . collect (  collectors . to list (  )  )  ;  if  ( annotated constructors . size (  )   >  1 )   {  throw new  illegal argument exception ( type  +  "" must have at most one constructor annotated @ jdbi constructor"" )  ;   }  else if  ( annotated constructors . size (  )   =  =  1 )   {  return annotated constructors . get ( 0 )  ;   }  annotated constructors =  stream . of ( constructors )  . filter ( c  -  >  c . is annotation present (  constructor properties . class )  )  . collect (  collectors . to list (  )  )  ;  if  ( annotated constructors . size (  )   >  1 )   {  throw new  illegal argument exception ( type  +  "" must have at most one constructor annotated @ constructor properties"" )  ;   }  else if  ( annotated constructors . size (  )   =  =  1 )   {  return annotated constructors . get ( 0 )  ;   }  if  ( constructors . length  !  =  1 )   {  throw new  illegal argument exception ( type  +  "" must have exactly one constructor  or specify it with @ jdbi constructor or @ constructor properties"" )  ;   }  return constructors[0] ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\RowMappers.java, row mappers,private   (  row mappers that )  {  factories . add all ( that . factories )  ;  cache . put all ( that . cache )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\RowMappers.java,create copy,@ override public  row mappers   (  )  {  return new  row mappers ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\RowMappers.java,find for,public  optional <  row mapper <  ?  >  >    (  type type )  {   row mapper <  ?  >  cached = cache . get ( type )  ;  if  ( cached  !  =  null )   {  return  optional . of ( cached )  ;   }   optional <  row mapper <  ?  >  >  mapper = factories . stream (  )  . flat map ( factory  -  >  to stream ( factory . build ( type registry )  )  )  . find first (  )  ;  mapper . if present ( m  -  >  cache . put ( type m )  )  ;  return mapper ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\RowMappers.java,register,public  row mappers   (  row mapper factory factory )  {  factories . add ( 0 factory )  ;  cache . clear (  )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\RowMappers.java,set registry,@ override public void   (  config registry registry )  {  this . registry = registry ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\OnDemandExtensions.java,create,"static  < e > e   (  jdbi db  class < e >  extension type )  {   thread local < e >  thread extension = new  thread local <  >  (  )  ;   invocation handler handler =  ( proxy method args )   -  >   {  if  ( equals   method . equals ( method )  )   {  return proxy  =  =  args[0] ;   }  if  ( hashcode   method . equals ( method )  )   {  return  system . identity hash code ( proxy )  ;   }  if  ( tostring   method . equals ( method )  )   {  return extension type  +  ""@""  +   integer . to hex string (  system . identity hash code ( proxy )  )  ;   }  if  ( thread extension . get (  )   !  =  null )   {  return invoke ( thread extension . get (  )  method args )  ;   }  return db . with extension ( extension type extension  -  >   jdbi thread locals . invoke in context ( thread extension extension  (  )   -  >  invoke ( extension method args )  )  )  ;   }   ;  return extension type . cast (  proxy . new proxy instance ( extension type . get class loader (  )  new  class[] { extension type }  handler )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\OnDemandExtensions.java,invoke,private static  object   (  object target  method method  object[] args )  {  try  {  if  (  proxy . is proxy class ( target . get class (  )  )  )   {  return  proxy . get invocation handler ( target )  . invoke ( target method args )  ;   }  return  method handles . lookup (  )  . unreflect ( method )  . bind to ( target )  . invoke with arguments ( args )  ;   }  catch  (   runtime exception| error e )   {  throw e ;   }  catch  (   throwable t )   {  throw new  runtime exception ( t )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\SingleColumnMapper.java, single column mapper,public   (  column mapper < t >  mapper  string column label )  {  this . delegate =  ( r ctx )   -  >  mapper . map ( r column label ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\mapper\SingleColumnMapper.java,map,@ override public t   (  result set r  statement context ctx )  throws sql exception  {  return delegate . map ( r ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\LinkedHashMapRowReducer.java,container,@ override default  map < k v >    (  )  {  return new  linked hash map <  >  (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\LinkedHashMapRowReducer.java,stream,@ override default  stream < v >    (  map < k v >  container )  {  return container . values (  )  . stream (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\NoResultsException.java, no results exception,public   (  string msg  statement context ctx )  {  super ( msg ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,absolute,@ override public boolean   ( int row )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,cancel row updates,@ override public void   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,clear warnings,@ override public void   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,delete row,@ override public void   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,find column,@ override public int   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,first,@ override public boolean   (  )  throws sql exception  {  return false ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get array,@ override public  array   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get ascii stream,@ override public  input stream   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get big decimal,@ override public  big decimal   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get binary stream,@ override public  input stream   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get blob,@ override public  blob   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get boolean,@ override public boolean   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get byte,@ override public byte   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get bytes,@ override public byte[]   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get character stream,@ override public  reader   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get clob,@ override public  clob   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get concurrency,@ override public int   (  )  throws sql exception  {  return concur   read   only ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get cursor name,@ override public  string   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get date,@ override public  date   (  string column label  calendar cal )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get double,@ override public double   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get fetch direction,@ override public int   (  )  throws sql exception  {  return fetch   forward ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get fetch size,@ override public int   (  )  throws sql exception  {  return 0 ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get float,@ override public float   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get holdability,@ override public int   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get int,@ override public int   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get long,@ override public long   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get meta data,@ override public  result set meta data   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,getn character stream,@ override public  reader   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,getn clob,@ override public n clob   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,getn string,@ override public  string   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get object,@ override public  < t > t   (  string column label  class < t >  type )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get ref,@ override public  ref   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get row,@ override public int   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get row id,@ override public  row id   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,getsqlxml,@ override public sqlxml   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get short,@ override public short   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get statement,@ override public  statement   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get string,@ override public  string   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get time,@ override public  time   (  string column label  calendar cal )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get timestamp,@ override public  timestamp   (  string column label  calendar cal )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get type,@ override public int   (  )  throws sql exception  {  return type   forward   only ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,geturl,@ override public url   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get unicode stream,@ override public  input stream   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,get warnings,@ override public sql warning   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,insert row,@ override public void   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,is after last,@ override public boolean   (  )  throws sql exception  {  return true ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,is before first,@ override public boolean   (  )  throws sql exception  {  return true ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,is closed,@ override public boolean   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,is first,@ override public boolean   (  )  throws sql exception  {  return false ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,is last,@ override public boolean   (  )  throws sql exception  {  return false ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,is wrapper for,@ override public boolean   (  class <  ?  >  iface )  throws sql exception  {  return false ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,last,@ override public boolean   (  )  throws sql exception  {  return false ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,move to current row,@ override public void   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,move to insert row,@ override public void   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,next,@ override public boolean   (  )  throws sql exception  {  return false ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,previous,@ override public boolean   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,refresh row,@ override public void   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,relative,@ override public boolean   ( int rows )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,row deleted,@ override public boolean   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,row inserted,@ override public boolean   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,row updated,@ override public boolean   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,unwrap,@ override public  < t > t   (  class < t >  iface )  throws sql exception  {  return iface . cast ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update array,@ override public void   (  string column label  array x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update ascii stream,@ override public void   (  string column label  input stream x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update big decimal,@ override public void   (  string column label  big decimal x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update binary stream,@ override public void   (  string column label  input stream x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update blob,@ override public void   (  string column label  input stream input stream )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update boolean,@ override public void   (  string column label boolean x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update byte,@ override public void   (  string column label byte x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update bytes,@ override public void   (  string column label byte[] x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update character stream,@ override public void   (  string column label  reader reader )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update clob,@ override public void   (  string column label  reader reader )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update date,@ override public void   (  string column label  date x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update double,@ override public void   (  string column label double x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update float,@ override public void   (  string column label float x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update int,@ override public void   (  string column label int x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update long,@ override public void   (  string column label long x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,updaten character stream,@ override public void   (  string column label  reader reader )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,updaten clob,@ override public void   (  string column label  reader reader )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,updaten string,@ override public void   (  string column label  string n string )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update null,@ override public void   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update object,@ override public void   (  string column label  object x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update ref,@ override public void   (  string column label  ref x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update row,@ override public void   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update row id,@ override public void   (  string column label  row id x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,updatesqlxml,@ override public void   (  string column label sqlxml xml object )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update short,@ override public void   (  string column label short x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update string,@ override public void   (  string column label  string x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update time,@ override public void   (  string column label  time x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,update timestamp,@ override public void   (  string column label  timestamp x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\EmptyResultSet.java,was null,@ override public boolean   (  )  throws sql exception  {  return false ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultIterable.java,collect,default  < r > r   (  collector < t  ?  r >  collector )  {  try  (  stream < t >  stream = stream (  )  )  {  return stream . collect ( collector )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultIterable.java,find first,default  optional < t >    (  )  {  try  (  result iterator < t >  iter = iterator (  )  )  {  return iter . has next (  )   ?   optional . of nullable ( iter . next (  )  )  :  optional . empty (  )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultIterable.java,find only,"default t   (  )  {  try  (  result iterator < t >  iter = iterator (  )  )  {  if  (  ! iter . has next (  )  )   {  throw new  illegal state exception ( "" no element found in 'only'"" )  ;   }  final t r = iter . next (  )  ;  if  ( iter . has next (  )  )   {  throw new  illegal state exception ( "" multiple elements found in 'only'"" )  ;   }  return r ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultIterable.java,for each,@ override default void   (  consumer <  ?  super t >  action )  {  try  (  result iterator < t >  iterator = iterator (  )  )  {  iterator . for each remaining ( action )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultProducers.java, result producers,private   ( boolean allow no results )  {  this . allow no results = allow no results ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultProducers.java,allow no results,public  result producers   ( boolean allow no results )  {  this . allow no results = allow no results ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultProducers.java,create copy,@ override public  result producers   (  )  {  return new  result producers ( allow no results )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultProducers.java,get generated keys,"private static  supplier <  result set >    (  supplier <  prepared statement >  supplier  statement context ctx )  {  return  (  )   -  >   {  try  {   result set rs = supplier . get (  )  . get generated keys (  )  ;  if  ( rs  =  =  null )   {  throw new  no results exception ( "" statement returned no generated keys"" ctx )  ;   }  ctx . add cleanable ( rs::close )  ;  return rs ;   }  catch  (  sql exception e )   {  throw new  result set exception ( "" could not get generated keys"" e ctx )  ;   }   }   ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultProducers.java,get result set,"private static  supplier <  result set >    (  supplier <  prepared statement >  supplier  statement context ctx )  {  return  (  )   -  >   {  try  {   result set rs = supplier . get (  )  . get result set (  )  ;  if  ( rs  =  =  null )   {  if  ( ctx . get config (  result producers . class )  . allow no results )   {  return new  empty result set (  )  ;   }  throw new  no results exception ( "" statement returned no results"" ctx )  ;   }  ctx . add cleanable ( rs::close )  ;  return rs ;   }  catch  (  sql exception e )   {  throw new  result set exception ( "" could not get result set"" e ctx )  ;   }   }   ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultProducers.java,returning generated keys,public static  result producer <  result bearing >    (  string .  .  .  generated key column names )  {  return  ( supplier ctx )   -  >   {  ctx . set returning generated keys ( true )  ;  if  ( generated key column names . length  >  0 )   {  ctx . set generated keys column names ( generated key column names )  ;   }  return  result bearing . of ( get generated keys ( supplier ctx )  ctx )  ;   }   ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultProducers.java,returning results,public static  result producer <  result bearing >    (  )  {  return  ( supplier ctx )   -  >   result bearing . of ( get result set ( supplier ctx )  ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultProducers.java,returning update count,public static  result producer <  integer >    (  )  {  return  ( statement supplier ctx )   -  >   {  try  {  return statement supplier . get (  )  . get update count (  )  ;   }  finally  {  ctx . close (  )  ;   }   }   ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultSetResultIterator.java, result set result iterator,  (  result set results  row mapper < t >  mapper  statement context context )  throws sql exception  {  this . results = require non null ( results )  ;  this . mapper = mapper . specialize ( results context )  ;  this . context = context ;  this . context . add cleanable ( results::close )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultSetResultIterator.java,close,@ override public void   (  )  {  closed = true ;  context . close (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultSetResultIterator.java,get context,@ override public  statement context   (  )  {  return context ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultSetResultIterator.java,has next,@ override public boolean   (  )  {  if  ( closed )   {  return false ;   }  if  ( already advanced )   {  return has next ;   }  has next = safe next (  )  ;  if  ( has next )   {  already advanced = true ;   }  else  {  close (  )  ;   }  return has nex
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultSetResultIterator.java,next,"@ override public t   (  )  {  if  ( closed )   {  throw new  illegal state exception ( ""iterator is closed"" )  ;   }  if  (  ! has next (  )  )   {  close (  )  ;  throw new  no such element exception ( "" no element to advance to"" )  ;   }  try  {  retur"
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultSetResultIterator.java,remove,"@ override public void   (  )  {  throw new  unsupported operation exception ( "" deleting from a result set iterator is not yet supported"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultSetResultIterator.java,safe next,"private boolean   (  )  {  try  {  return results . next (  )  ;   }  catch  (  sql exception e )   {  throw new  result set exception ( "" unable to advance result set"" e context )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\UnableToProduceResultException.java, unable to produce result exception,public   (  string string  throwable throwable  statement context ctx )  {  super ( string throwable ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\spi\JdbiPlugin.java,customize connection,default  connection   (  connection conn )  {  return conn ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\spi\JdbiPlugin.java,customize handle,default  handle   (  handle handle )  {  return handle ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ArgumentBinder.java,bind,static void   (  parsed parameters parameters  binding binding  prepared statement statement  statement context context )  {  if  ( parameters . is positional (  )  )   {  bind positional ( parameters . get parameter count (  )  binding statement context )  ;   }  else  {  bind named ( parameters . get parameter names (  )  binding statement context )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ArgumentBinder.java,bind named,"private static void   (  list <  string >  parameter names  binding binding  prepared statement statement  statement context context )  {  if  ( parameter names . is empty (  )  &&  ! binding . is empty (  )  )   {  throw new  unable to execute statement exception (  string . format ( "" unable to execute .   the query doesn't have named parameters  but provided binding '%s' . "" binding )  context )  ;   }  for  ( int i = 0 ;  i  <  parameter names . size (  )  ;  i +  +  )   {   string param = parameter names . get ( i )  ;  try  {  binding . find for name ( param context )  . or else throw (  (  )   -  >  new  unable to execute statement exception (  string . format ( "" unable to execute  no named parameter matches '%s' . "" param )  context )  )  . apply ( i  +  1 statement context )  ;   }  catch  (  sql exception e )   {  throw new  unable to create statement exception (  string . format ( "" exception while binding named parameter '%s'"" param )  e context )  ;   }   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ArgumentBinder.java,bind positional,"private static void   ( int size  binding binding  prepared statement statement  statement context context )  {  for  ( int i = 0 ;  i  <  size ;  i +  +  )   {  try  {   argument argument = binding . find for position ( i )  . or else ( null )  ;  if  ( argument  !  =  null )   {  argument . apply ( i  +  1 statement context )  ;   }   }  catch  (  sql exception e )   {  throw new  unable to execute statement exception ( "" exception while binding positional param at  ( 0 based )  position ""  +  i e context )  ;   }   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultSetException.java, result set exception,public   (  string msg  exception e  statement context ctx )  {  super ( msg e ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultBearing.java,collect into,"@ suppress warnings (  { ""unchecked"" ""rawtypes"" }  )  default  object   (  type container type )  {  return scan result set (  ( rs ctx )   -  >   {   collector collector = ctx . find collector for ( container type )  . or else throw (  (  )   -  >  new  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultBearing.java,collect rows,default  < a r > r   (  collector <  row view a r >  collector )  {  return scan result set (  ( supplier ctx )   -  >   {  try  (  result set rs = supplier . get (  )  )  {   row view rv = new  row view ( rs ctx )  ;  a acc = collector . supplier (  )  . get (  )  ;   bi consumer < a  row view >  consumer = collector . accumulator (  )  ;  while  ( rs . next (  )  )   {  consumer . accept ( acc rv )  ;   }  return collector . finisher (  )  . apply ( acc )  ;   }  catch  (  sql exception e )   {  throw new  unable to produce result exception ( e ctx )  ;   }  finally  {  ctx . close (  )  ;   }   }   )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultBearing.java,map,default  < t >  result iterable < t >    (  row mapper < t >  mapper )  {  return scan result set (  ( supplier ctx )   -  >   result iterable . of ( supplier mapper ctx )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultBearing.java,map to,"default  result iterable <  ?  >    (  type type )  {  return scan result set (  ( supplier ctx )   -  >   {   row mapper <  ?  >  mapper = ctx . find mapper for ( type )  . or else throw (  (  )   -  >  new  no such mapper exception ( "" no mapper registered for type ""  +  type )  )  ;  return  result iterable . of ( supplier mapper ctx )  ;   }   )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultBearing.java,map to bean,default  < t >  result iterable < t >    (  class < t >  type )  {  return map (  bean mapper . of ( type )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultBearing.java,map to map,default  result iterable <  map <  string  object >  >    (  )  {  return map ( new  map mapper (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultBearing.java,of,"static  result bearing   (  supplier <  result set >  result set supplier  statement context ctx )  {  return new  result bearing (  )  {  @ override public  < r > r scan result set (   result set scanner < r >  mapper )  {  try  {  return mapper . scan result set ( result set supplier ctx )  ;   }  catch  (  sql exception e )   {  throw new  result set exception ( "" error reading result set"" e ctx )  ;   }   }   }   ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultBearing.java,reduce result set,default  < u > u   ( u seed  result set accumulator < u >  accumulator )  {  return scan result set (  ( supplier ctx )   -  >   {  try  (  result set rs = supplier . get (  )  )  {  u result = seed ;  while  ( rs . next (  )  )   {  result = accumulator . apply ( result rs ctx )  ;   }  return result ;   }  catch  (  sql exception e )   {  throw new  unable to produce result exception ( e ctx )  ;   }  finally  {  ctx . close (  )  ;   }   }   )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\ResultBearing.java,reduce rows,default  < u > u   ( u seed  bi function < u  row view u >  accumulator )  {  return scan result set (  ( supplier ctx )   -  >   {  try  (  result set rs = supplier . get (  )  )  {   row view rv = new  row view ( rs ctx )  ;  u result = seed ;  while  ( rs . next (  )  )   {  result = accumulator . apply ( result rv )  ;   }  return result ;   }  catch  (  sql exception e )   {  throw new  unable to produce result exception ( e ctx )  ;   }  finally  {  ctx . close (  )  ;   }   }   )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\BaseStatement.java, base statement,  (  handle handle )  {  this . handle = handle ;  this . ctx = new  statement context ( handle . get config (  )  . create copy (  )  handle . get extension method (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\BaseStatement.java,add cleanable, this   (  cleanable cleanable )  {  get context (  )  . add cleanable ( cleanable )  ;  return typed this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\BaseStatement.java,add customizer,public final  this   ( final  statement customizer customizer )  {  this . customizers . add ( customizer )  ;  return typed this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\BaseStatement.java,add customizers,void   ( final  collection <  statement customizer >  customizers )  {  this . customizers . add all ( customizers )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\BaseStatement.java,after execution,"final void   ( final  prepared statement stmt )  {  for  (   statement customizer customizer : customizers )   {  try  {  customizer . after execution ( stmt ctx )  ;   }  catch  (  sql exception e )   {  throw new  unable to execute statement exception ( "" exception thrown in statement customization"" e ctx )  ;   }   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\BaseStatement.java,before binding,"final void   ( final  prepared statement stmt )  {  for  (   statement customizer customizer : customizers )   {  try  {  customizer . before binding ( stmt ctx )  ;   }  catch  (  sql exception e )   {  throw new  unable to execute statement exception ( "" exception thrown in statement customization"" e ctx )  ;   }   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\BaseStatement.java,before execution,"final void   ( final  prepared statement stmt )  {  for  (   statement customizer customizer : customizers )   {  try  {  customizer . before execution ( stmt ctx )  ;   }  catch  (  sql exception e )   {  throw new  unable to execute statement exception ( "" exception thrown in statement customization"" e ctx )  ;   }   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\BaseStatement.java,close,@ override public void   (  )  {  get context (  )  . close (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\BaseStatement.java,get config,@ override public  config registry   (  )  {  return ctx . get config (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\BaseStatement.java,get context,public final  statement context   (  )  {  return ctx ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\BaseStatement.java,get handle,public  handle   (  )  {  return handle ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Binding.java,add named,public void   (  string name  argument argument )  {  this . named . put ( name argument )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Binding.java,add named argument finder,public void   (  named argument finder args )  {  named argument finder . add ( args )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Binding.java,add positional,public void   ( int position  argument argument )  {  positionals . put ( position argument )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Binding.java,clear,public void   (  )  {  positionals . clear (  )  ;  named . clear (  )  ;  named argument finder . clear (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Binding.java,find for name,public  optional <  argument >    (  string name  statement context ctx )  {  if  ( named . contains key ( name )  )   {  return  optional . of ( named . get ( name )  )  ;   }  return named argument finder . stream (  )  . flat map ( arguments  -  >  to stream ( arguments . find ( name ctx )  )  )  . find first (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Binding.java,find for position,public  optional <  argument >    ( int position )  {  return  optional . of nullable ( positionals . get ( position )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Binding.java,is empty,public boolean   (  )  {  return positionals . is empty (  )  && named . is empty (  )  && named argument finder . is empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Binding.java,to string,"@ override public  string   (  )  {  boolean wrote = false ;   string builder b = new  string builder (  )  ;  b . append ( "" {  positional: { "" )  ;  for  (   map .  entry <  integer  argument >  entry : positionals . entry set (  )  )   {  wrote = true "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Batch.java, batch,public   (  handle handle )  {  super ( handle )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Batch.java,add,public  batch   (  string sql )  {  parts . add ( sql )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\RowView.java, row view,  (  result set rs  statement context ctx )  {  this . rs = rs ;  this . ctx = ctx ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Batch.java,execute,"public int[]   (  )  {  if  ( parts . size (  )   =  =  0 )   {  return new int[] {  }  ;   }   statement stmt ;  try  {  try  {  stmt = get handle (  )  . get statement builder (  )  . create ( get handle (  )  . get connection (  )  get context (  )  )  ;  add cleanable ( stmt::close )  ;   }  catch  (  sql exception e )   {  throw new  unable to create statement exception ( e get context (  )  )  ;   }  log . trace ( "" execute batch ["" )  ;  try  {  for  (   string part : parts )   {  final  string sql = get config (  sql statements . class )  . get template engine (  )  . render ( part get context (  )  )  ;  log . trace ( ""  {  } "" sql )  ;  stmt . add batch ( sql )  ;   }   }  catch  (  sql exception e )   {  throw new  unable to execute statement exception ( "" unable to configure jdbc statement"" e get context (  )  )  ;   }  try  {  final long start =  system . nano time (  )  ;  final int[] rs = stmt . execute batch (  )  ;  final long elapsed time =  system . nano time (  )   -  start ;  log . trace ( ""] executed in  {  } ms"" elapsed time  /  1000000l )  ;  get config (  sql statements . class )  . get timing collector (  )  . collect ( elapsed time get context (  )  )  ;  return rs ;   }  catch  (  sql exception e )   {  throw new  unable to execute statement exception ( munge batch exception ( e )  get context (  )  )  ;   }   }  finally  {  close (  )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\RowView.java,column mapper for,"private  column mapper <  ?  >    (  type type )  {  return column mappers . compute if absent ( type t  -  >  ctx . find column mapper for ( t )  . or else throw (  (  )   -  >  new  no such mapper exception ( "" no column mapper registered for ""  +  t )  )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Batch.java,munge batch exception,static sql exception   ( sql exception e )  {  for  ( sql exception next = e . get next exception (  )  ;  next  !  =  null ;  next = next . get next exception (  )  )   {  e . add suppressed ( next )  ;   }  return e ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\RowView.java,get column,public  object   ( int column  type type )  {  try  {  return column mapper for ( type )  . map ( rs column ctx )  ;   }  catch  (  sql exception e )   {  throw new  mapping exception ( e )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\RowView.java,get row,public  object   (  type type )  {  try  {  return row mapper for ( type )  . map ( rs ctx )  ;   }  catch  (  sql exception e )   {  throw new  mapping exception ( e )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\result\RowView.java,row mapper for,"private  row mapper <  ?  >    (  type type )  throws sql exception  {  if  ( row mappers . contains key ( type )  )   {  return row mappers . get ( type )  ;   }   row mapper <  ?  >  mapper = ctx . find row mapper for ( type )  . or else throw (  (  )   -  >  new  no such mapper exception ( "" no row mapper registered for ""  +  type )  )  . specialize ( rs ctx )  ;  row mappers . put ( type mapper )  ;  return mapper ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Call.java, call,public   (  handle handle  string sql )  {  super ( handle sql )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Call.java, out param argument,  ( int sql type  callable statement mapper mapper  string name )  {  this . sql type = sql type ;  this . mapper = mapper ;  this . name = name ;  params . add ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Call.java,apply,@ override public void   ( int position  prepared statement statement  statement context ctx )  throws sql exception  {   (  (  callable statement ) statement )  . register out parameter ( position sql type )  ;  this . position = position ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\DefaultStatementBuilder.java,create,@ override public  prepared statement   (  connection conn  string sql  statement context ctx )  throws sql exception  {  if  ( ctx . is returning generated keys (  )  )   {   string[] column names = ctx . get generated keys column names (  )  ;  if  ( co
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\DefaultStatementBuilder.java,create call,@ override public  callable statement   (  connection conn  string sql  statement context ctx )  throws sql exception  {  return conn . prepare call ( sql )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\DefinedAttributeTemplateEngine.java,render,@ override public  string   (  string template  statement context ctx )  {   string builder b = new  string builder (  )  ;   define statement lexer lexer = new  define statement lexer ( new antlr string stream ( template )  )  ;  try  {   token t = lexer
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Call.java,invoke,public  out parameters   (  )  {  try  {  final  prepared statement stmt = this . internal execute (  )  ;   out parameters out = new  out parameters (  )  ;  for  (   out param argument param : params )   {   object obj = param . map (  (  callable statement ) stmt )  ;  int index = param . position  -  1 ;  out . get map (  )  . put ( index obj )  ;  if  ( param . name  !  =  null )   {  out . get map (  )  . put ( param . name obj )  ;   }   }  return out ;   }  finally  {  close (  )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Call.java,map,"public  object   (  callable statement stmt )  {  try  {  if  ( mapper  !  =  null )   {  return mapper . map ( position stmt )  ;   }  switch  ( sql type )   {  case  types . clob: case  types . varchar: case  types . longnvarchar: case  types . longvarchar: case  types . nclob: case  types . nvarchar: return stmt . get string ( position )  ;  case  types . blob: case  types . varbinary: return stmt . get bytes ( position )  ;  case  types . smallint: return stmt . get short ( position )  ;  case  types . integer: return stmt . get int ( position )  ;  case  types . bigint: return stmt . get long ( position )  ;  case  types . timestamp: case  types . time: return stmt . get timestamp ( position )  ;  case  types . date: return stmt . get date ( position )  ;  case  types . float: return stmt . get float ( position )  ;  case  types . decimal: case  types . double: return stmt . get double ( position )  ;  default : return stmt . get object ( position )  ;   }   }  catch  ( sql exception e )   {  throw new  unable to execute statement exception ( "" could not get out parameter from statement"" e get context (  )  )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Call.java,register out parameter,public  call   (  string name int sql type  callable statement mapper mapper )  {  get binding (  )  . add named ( name new  out param argument ( sql type mapper name )  )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ColonPrefixSqlParser.java,internal parse,private  parsed sql   (  string sql )  throws  illegal argument exception  {   parsed sql .  builder parsed sql =  parsed sql . builder (  )  ;   colon statement lexer lexer = new  colon statement lexer ( new antlr string stream ( sql )  )  ;   token t = lexer . next token (  )  ;  while  ( t . get type (  )   !  =  eof )   {  switch  ( t . get type (  )  )   {  case comment: case literal: case quoted   text: case double   quoted   text: parsed sql . append ( t . get text (  )  )  ;  break ;  case named   param: parsed sql . append named parameter ( t . get text (  )  . substring ( 1 )  )  ;  break ;  case positional   param: parsed sql . append positional parameter (  )  ;  break ;  case escaped   text: parsed sql . append ( t . get text (  )  . substring ( 1 )  )  ;  break ;  default : break ;   }  t = lexer . next token (  )  ;   }  return parsed sql . build (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ColonPrefixSqlParser.java,name parameter,"@ override public  string   (  string raw name  statement context ctx )  {  return "":""  +  raw name ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ColonPrefixSqlParser.java,parse,"@ override public  parsed sql   (  string sql  statement context ctx )  {  try  {  return cache . compute if absent ( sql this::internal parse )  ;   }  catch  (   illegal argument exception e )   {  throw new  unable to create statement exception ( "" exc"
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\HashPrefixSqlParser.java,internal parse,private  parsed sql   ( final  string sql )  {   parsed sql .  builder parsed sql =  parsed sql . builder (  )  ;   hash statement lexer lexer = new  hash statement lexer ( new antlr string stream ( sql )  )  ;   token t = lexer . next token (  )  ;  while  ( t . get type (  )   !  =  eof )   {  switch  ( t . get type (  )  )   {  case comment: case literal: case quoted   text: case double   quoted   text: parsed sql . append ( t . get text (  )  )  ;  break ;  case named   param: parsed sql . append named parameter ( t . get text (  )  . substring ( 1 )  )  ;  break ;  case positional   param: parsed sql . append positional parameter (  )  ;  break ;  case escaped   text: parsed sql . append ( t . get text (  )  . substring ( 1 )  )  ;  break ;  default : break ;   }  t = lexer . next token (  )  ;   }  return parsed sql . build (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\HashPrefixSqlParser.java,name parameter,"@ override public  string   (  string raw name  statement context ctx )  {  return ""#""  +  raw name ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\HashPrefixSqlParser.java,parse,"@ override public  parsed sql   (  string sql  statement context ctx )  {  try  {  return cache . compute if absent ( sql this::internal parse )  ;   }  catch  (   illegal argument exception e )   {  throw new  unable to create statement exception ( "" exc"
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\MessageFormatTemplateEngine.java,render,@ override public  string   (  string template  statement context ctx )  {   message format msg format = new  message format ( template )  ;  validate keys ( ctx . get attributes (  )  . key set (  )  msg format . get formats (  )  . length )  ;   object[
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\MessageFormatTemplateEngine.java,validate keys,"private static void   (  set <  string >  key set int expected count )  {  if  ( key set . size (  )   !  =  expected count )   {  throw new  illegal argument exception ( ""expected ""  +  expected count  +  "" keys but got "" +  key set . size (  )  )  ;   }  if  ( key set . size (  )   =  =  0 )   {  return ;   }  final int[] keys = key set . stream (  )  . map to int (  integer::parse int )  . sorted (  )  . to array (  )  ;  if  ( keys[0]  !  =  0 )   {  throw new  illegal argument exception ( ""lowest key must be 0"" )  ;   }  for  ( int i = 1 ;  i  <  keys . length ;  i +  +  )   {  final int key = keys[i] ;  if  ( key  <  i )   {  throw new  illegal argument exception ( ""key ""  +  key  +  "" was given more than once"" )  ;   }  if  ( key  >  i )   {  throw new  illegal argument exception ( ""keys skip from ""  +   ( i  -  1 )   +  "" to "" +  key )  ;   }   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ParsedSql.java, parsed sql,private   (  string sql  parsed parameters parameters )  {  this . sql = sql ;  this . parameters = parameters ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ParsedSql.java,append,public  builder   (  string sql fragment )  {  sql . append ( sql fragment )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ParsedSql.java,append named parameter,"public  builder   (  string name )  {  named = true ;  parameter names . add ( name )  ;  return append ( "" ? "" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ParsedSql.java,append positional parameter,"public  builder   (  )  {  positional = true ;  parameter names . add ( positional   param )  ;  return append ( "" ? "" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ParsedSql.java,build,"public  parsed sql   (  )  {  if  ( positional && named )   {  throw new  unable to execute statement exception ( "" cannot mix named and positional parameters in a sql statement: ""  +  parameter names )  ;   }   parsed parameters parameters = new  parsed parameters ( positional parameter names )  ;  return new  parsed sql ( sql . to string (  )  parameters )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ParsedSql.java,builder,public static  builder   (  )  {  return new  builder (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ParsedSql.java,equals,@ override public boolean   (  object o )  {  if  ( this  =  =  o )   {  return true ;   }  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )   {  return false ;   }   parsed sql that =  (  parsed sql ) o ;  return  objects . equals ( sq
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ParsedSql.java,get parameters,public  parsed parameters   (  )  {  return parameters ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ParsedSql.java,get sql,public  string   (  )  {  return sql ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ParsedSql.java,hash code,@ override public int   (  )  {  return  objects . hash ( sql parameters )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ParsedSql.java,to string,"@ override public  string   (  )  {  return "" parsed sql { ""  +  ""sql = '""  +  sql  +  '\'' +  ""  parameters = "" +  parameters +  ' } ' ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Query.java, query,public   (  handle handle  string sql )  {  super ( handle sql )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Query.java,concurrent updatable,public  query   (  )  {  get context (  )  . set concurrent updatable ( true )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Query.java,execute,public  < r > r   (  result producer < r >  producer )  {  try  {  return producer . produce ( this::internal execute get context (  )  )  ;   }  catch  (  sql exception e )   {  try  {  close (  )  ;   }  catch  (   exception e1 )   {  e . add suppressed ( e1 )  ;   }  throw new  unable to produce result exception ( e get context (  )  )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Query.java,scan result set,@ override public  < r > r   (  result set scanner < r >  mapper )  {  return execute (  result producers . returning results (  )  )  . scan result set ( mapper )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Query.java,set fetch size,public  query   ( final int fetch size )  {  return add customizer (  statement customizers . fetch size ( fetch size )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Query.java,set max field size,public  query   ( final int max fields )  {  return add customizer (  statement customizers . max field size ( max fields )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Query.java,set max rows,public  query   ( final int max rows )  {  return add customizer (  statement customizers . max rows ( max rows )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\OutParameters.java,get bytes,"public byte[]   ( int pos )  {   object obj = map . get ( pos )  ;  if  ( obj  =  =  null )   {  if  (  ! map . contains key ( pos )  )   {  throw new  illegal argument exception (  string . format ( "" parameter at %d does not exist"" pos )  )  ;   }  return null ;   }  if  ( obj instanceof byte[] )   {  return  ( byte[] ) obj ;   }  else  {  throw new  illegal argument exception (  string . format ( "" parameter at %d is not byte[] but %s"" pos obj . get class (  )  )  )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\OutParameters.java,get date,public  date   ( int pos )  {   long epoch = get epoch ( pos )  ;  if  ( epoch  =  =  null )   {  return null ;   }  return new  date ( epoch )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\OutParameters.java,get double,public  double   ( int pos )  {  return get number ( pos )  . double value (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\OutParameters.java,get epoch,"private  long   ( int pos )  {   object obj = map . get ( pos )  ;  if  ( obj  =  =  null )   {  if  (  ! map . contains key ( pos )  )   {  throw new  illegal argument exception (  string . format ( "" parameter at %d does not exist"" pos )  )  ;   }  return null ;   }  if  ( obj instanceof java . util .  date )   {  return  (  ( java . util .  date ) obj )  . get time (  )  ;   }  else  {  throw new  illegal argument exception (  string . format ( "" parameter at %d is not  date but %s"" pos obj . get class (  )  )  )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\OutParameters.java,get float,public  float   ( int pos )  {  return get number ( pos )  . float value (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\OutParameters.java,get int,public  integer   ( int pos )  {  return get number ( pos )  . int value (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\OutParameters.java,get long,public  long   ( int pos )  {  return get number ( pos )  . long value (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\OutParameters.java,get map, map <  object  object >    (  )  {  return map ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\OutParameters.java,get number,"private  number   ( int pos )  {   object obj = map . get ( pos )  ;  if  ( obj  =  =  null )   {  if  (  ! map . contains key ( pos )  )   {  throw new  illegal argument exception (  string . format ( "" parameter at %d does not exist"" pos )  )  ;   }  return null ;   }  if  ( obj instanceof  number )   {  return  (  number ) obj ;   }  else  {  throw new  illegal argument exception (  string . format ( "" parameter at %d is not a number but %s"" pos obj . get class (  )  )  )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\OutParameters.java,get object,public  < t > t   ( int pos  class < t >  type )  {  return type . cast ( get object ( pos )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\OutParameters.java,get short,public  short   ( int pos )  {  return get number ( pos )  . short value (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\OutParameters.java,get string,"public  string   ( int pos )  {   object obj = map . get ( pos )  ;  if  ( obj  =  =  null )   {  if  (  ! map . contains key ( pos )  )   {  throw new  illegal argument exception (  string . format ( "" parameter at %d does not exist"" pos )  )  ;   }  return null ;   }  return obj . to string (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\OutParameters.java,get timestamp,public  timestamp   ( int pos )  {   long epoch = get epoch ( pos )  ;  if  ( epoch  =  =  null )   {  return null ;   }  return new  timestamp ( epoch )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\PreparedBatch.java, executed batch,  (  prepared statement stmt int[] update counts )  {  this . stmt = stmt ;  this . update counts = update counts ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\PreparedBatch.java, prepared batch,public   (  handle handle  string sql )  {  super ( handle sql )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\PreparedBatch.java,add,public  prepared batch   (  map <  string  ?  >  args )  {  bind map ( args )  ;  add (  )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\PreparedBatch.java,close,@ override public void   (  )  {  ctx . close (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\PreparedBatch.java,execute,"public  < r > r   (  result producer < r >  producer )  {  try  {  return producer . produce (  (  )   -  >  internal batch execute (  )  . stmt get context (  )  )  ;   }  catch  (  sql exception e )   {  try  {  close (  )  ;   }  catch  (   exception e1 )   {  e . add suppressed ( e1 )  ;   }  throw new  unable to produce result exception ( "" exception producing batch result"" e get context (  )  )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\PreparedBatch.java,execute and get mod count,public  result iterator <  integer >    (  )  {   statement context ctx = get context (  )  ;  final int[] mod count = execute (  )  ;  return new  result iterator <  integer >  (  )  {  int pos = 0 ;  @ override public boolean has next (  )  {  return pos  <  mod count . length ;   }  @ override public  integer next (  )  {  if  (  ! has next (  )  )   {  throw new  no such element exception (  )  ;   }  return mod count[pos +  + ] ;   }  @ override public  statement context get context (  )  {  return ctx ;   }  @ override public void close (  )  {  ctx . close (  )  ;   }   }   ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\PreparedBatch.java,execute and return generated keys,public  result bearing   (  string .  .  .  column names )  {  return execute ( returning generated keys ( column names )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\PreparedBatch.java,get context,@ override public  statement context   (  )  {  return ctx ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\PreparedBatch.java,has next,@ override public boolean   (  )  {  return pos  <  mod count . length ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\PreparedBatch.java,internal batch execute,"private  executed batch   (  )  {  if  (  ! get binding (  )  . is empty (  )  )   {  add (  )  ;   }  if  ( bindings . is empty (  )  )   {  throw new  illegal state exception ( "" no batch parts to execute"" )  ;   }   string rendered sql = get config (  sql statements . class )  . get template engine (  )  . render ( get sql (  )  get context (  )  )  ;  get context (  )  . set rendered sql ( rendered sql )  ;   parsed sql parsed sql = get config (  sql statements . class )  . get sql parser (  )  . parse ( rendered sql get context (  )  )  ;   string sql = parsed sql . get sql (  )  ;   parsed parameters parsed parameters = parsed sql . get parameters (  )  ;  get context (  )  . set parsed sql ( parsed sql )  ;  try  {  final  prepared statement stmt ;  try  {   statement builder statement builder = get handle (  )  . get statement builder (  )  ;   connection connection = get handle (  )  . get connection (  )  ;  stmt = statement builder . create ( connection sql get context (  )  )  ;  add cleanable (  (  )   -  >  statement builder . close ( connection sql stmt )  )  ;   }  catch  (  sql exception e )   {  throw new  unable to create statement exception ( e get context (  )  )  ;   }  before binding ( stmt )  ;  try  {  for  (   binding binding : bindings )   {  get context (  )  . set binding ( binding )  ;   argument binder . bind ( parsed parameters binding stmt get context (  )  )  ;  stmt . add batch (  )  ;   }   }  catch  (  sql exception e )   {  throw new  unable to execute statement exception ( "" exception while binding parameters"" e get context (  )  )  ;   }  before execution ( stmt )  ;  try  {  final long start =  system . nano time (  )  ;  final int[] rs = stmt . execute batch (  )  ;  final long elapsed time =  system . nano time (  )   -  start ;  log . trace ( "" prepared batch of  {  }  parts executed in  {  } ms"" bindings . size (  )  elapsed time  /  1000000l parsed sql )  ;  get config (  sql statements . class )  . get timing collector (  )  . collect ( elapsed time get context (  )  )  ;  after execution ( stmt )  ;  get context (  )  . set binding ( new  binding (  )  )  ;  return new  executed batch ( stmt rs )  ;   }  catch  (  sql exception e )   {  throw new  unable to execute statement exception (  batch . munge batch exception ( e )  get context (  )  )  ;   }   }  finally  {  bindings . clear (  )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\PreparedBatch.java,next,@ override public  integer   (  )  {  if  (  ! has next (  )  )   {  throw new  no such element exception (  )  ;   }  return mod count[pos +  + ] ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\PreparedBatch.java,scan result set,@ override public  < r > r   (  result set scanner < r >  mapper )  {  return execute (  result producers . returning results (  )  )  . scan result set ( mapper )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\PreparedBatch.java,size,public int   (  )  {  return bindings . size (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ParsedParameters.java, parsed parameters,  ( boolean positional  list <  string >  parameter names )  {  this . positional = positional ;  this . parameter names = unmodifiable list ( new  array list <  >  ( parameter names )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ParsedParameters.java,equals,@ override public boolean   (  object o )  {  if  ( this  =  =  o )   {  return true ;   }  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )   {  return false ;   }   parsed parameters that =  (  parsed parameters ) o ;  return position
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ParsedParameters.java,get parameter count,public int   (  )  {  return parameter names . size (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ParsedParameters.java,get parameter names,public  list <  string >    (  )  {  return parameter names ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ParsedParameters.java,hash code,@ override public int   (  )  {  return  objects . hash ( positional parameter names )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ParsedParameters.java,is positional,public boolean   (  )  {  return positional ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\ParsedParameters.java,to string,"@ override public  string   (  )  {  return "" parsed parameters { ""  +  ""positional = ""  +  positional  +  ""  parameter names = "" +  parameter names +  ' } ' ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Script.java, script,public   (  handle h  string sql )  {  super ( h sql )  ;  this . handle = h ;  this . sql = sql ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Script.java,add statement,private void   (  string statement  list <  string >  statements )  {   string trimmed statement = statement . trim (  )  ;  if  ( trimmed statement . is empty (  )  )   {  return ;   }  statements . add ( trimmed statement )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Script.java,execute,public int[]   (  )  {  final  list <  string >  statements = get statements (  )  ;   batch b = handle . create batch (  )  ;  statements . for each ( b::add )  ;  return b . execute (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Script.java,execute as separate statements,public void   (  )  {  for  (   string s : get statements (  )  )   {  handle . execute ( s )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Script.java,get statements,public  list <  string >    (  )  {  return split to statements ( get config (  sql statements . class )  . get template engine (  )  . render ( sql get context (  )  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Script.java,split to statements,private  list <  string >    (  string script )  {  final  list <  string >  statements = new  array list <  >  (  )  ;   string last statement = new  sql script parser (  ( t sb )   -  >   {  add statement ( sb . to string (  )  statements )  ;  sb . set length ( 0 )  ;   }   )  . parse ( new antlr string stream ( script )  )  ;  add statement ( last statement statements )  ;  return statements ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatements.java, sql statements,private   (  sql statements that )  {  this . attributes = new  concurrent hash map <  >  ( that . attributes )  ;  this . template engine = that . template engine ;  this . sql parser = that . sql parser ;  this . timing collector = that . timing collector ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatements.java,create copy,@ override public  sql statements   (  )  {  return new  sql statements ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatements.java,define,public  sql statements   (  string key  object value )  {  attributes . put ( key value )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatements.java,define map,public  sql statements   ( final  map <  string  ?  >  values )  {  if  ( values  !  =  null )   {  attributes . put all ( values )  ;   }  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatements.java,get attribute,public  object   (  string key )  {  return attributes . get ( key )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatements.java,get attributes,public  map <  string  object >    (  )  {  return attributes ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatements.java,get sql parser,public  sql parser   (  )  {  return sql parser ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatements.java,get template engine,public  template engine   (  )  {  return template engine ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatements.java,get timing collector,public  timing collector   (  )  {  return timing collector ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatements.java,set sql parser,public  sql statements   (  sql parser sql parser )  {  this . sql parser = sql parser ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatements.java,set template engine,public  sql statements   (  template engine template engine )  {  this . template engine = template engine ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatements.java,set timing collector,public  sql statements   (  timing collector timing collector )  {  this . timing collector = timing collector  =  =  null  ?   timing collector . nop   timing   collector : timing collector ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java, statement context,  (  config registry config  extension method extension method )  {  this . config = require non null ( config )  ;  this . extension method = extension method ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,add cleanable,public void   (  cleanable cleanable )  {  cleanables . add ( cleanable )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,close,@ override public void   (  )  {  sql exception exception = null ;  try  {   list <  cleanable >  cleanables = new  array list <  >  ( this . cleanables )  ;  this . cleanables . clear (  )  ;   collections . reverse ( cleanables )  ;  for  (   cleanable 
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,define,public void   (  string key  object value )  {  get config (  sql statements . class )  . define ( key value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,find argument for,public  optional <  argument >    (  type type  object value )  {  return get config (  arguments . class )  . find for ( type value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,find collector for,public  optional <  collector <  ?   ?   ?  >  >    (  type container type )  {  return get config (  jdbi collectors . class )  . find for ( container type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,find column mapper for,public  optional <  column mapper <  ?  >  >    (  type type )  {  return get config (  column mappers . class )  . find for ( type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,find element type for,public  optional <  type >    (  type container type )  {  return get config (  jdbi collectors . class )  . find element type for ( container type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,find mapper for,public  optional <  row mapper <  ?  >  >    (  type type )  {  return get config (  mappers . class )  . find for ( type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,find row mapper for,public  < t >  optional <  row mapper < t >  >    (  generic type < t >  type )  {  return get config (  row mappers . class )  . find for ( type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,find sql array type for,public  optional <  sql array type <  ?  >  >    (  type element type )  {  return get config (  sql array types . class )  . find for ( element type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,get attribute,public  object   (  string key )  {  return get config (  sql statements . class )  . get attribute ( key )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,get attributes,public  map <  string  object >    (  )  {  return get config (  sql statements . class )  . get attributes (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,get binding,public  binding   (  )  {  return binding ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,get config,public  config registry   (  )  {  return config ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,get connection,public  connection   (  )  {  return connection ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,get extension method,public  extension method   (  )  {  return extension method ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,get generated keys column names,public  string[]   (  )  {  return  arrays . copy of ( generated keys column names generated keys column names . length )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,get parsed sql,public  parsed sql   (  )  {  return parsed sql ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,get raw sql,public  string   (  )  {  return raw sql ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,get rendered sql,public  string   (  )  {  return rendered sql ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,get sql array argument strategy,public  sql array argument strategy   (  )  {  return get config (  sql array types . class )  . get argument strategy (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,get statement,public  prepared statement   (  )  {  return statement ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,is concurrent updatable,public boolean   (  )  {  return concurrent updatable ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,is returning generated keys,public boolean   (  )  {  return returning generated keys || generated keys column names . length  >  0 ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,set binding, statement context   (  binding b )  {  this . binding = b ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,set concurrent updatable,"public void   ( final boolean concurrent updatable )  {  if  ( concurrent updatable && is returning generated keys (  )  )   {  throw new  illegal argument exception ( "" cannot create a result set that is concurrent ""  +  ""updatable and is returning generated keys . "" )  ;   }  this . concurrent updatable = concurrent updatable ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,set connection, statement context   (  connection connection )  {  this . connection = connection ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,set generated keys column names,public void   (  string[] generated keys column names )  {  this . generated keys column names =  arrays . copy of ( generated keys column names generated keys column names . length )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,set parsed sql,void   (  parsed sql parsed sql )  {  this . parsed sql = parsed sql ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,set raw sql, statement context   (  string raw sql )  {  this . raw sql = raw sql ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,set rendered sql,void   (  string rendered sql )  {  this . rendered sql = rendered sql ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,set returning generated keys,"public void   ( boolean b )  {  if  ( is concurrent updatable (  )  && b )   {  throw new  illegal argument exception ( "" cannot create a result set that is concurrent ""  +  ""updatable and is returning generated keys . "" )  ;   }  this . returning generated keys = b ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementContext.java,set statement,void   (  prepared statement stmt )  {  statement = stmt ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementException.java, statement exception,public   (  string string )  {  super ( string )  ;  this . statement context = null ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementCustomizers.java,before execution,@ override public void   ( final  prepared statement stmt final  statement context ctx )  throws sql exception  {  stmt . set max field size ( max field size )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementCustomizers.java,fetch size,public static  statement customizer   ( final int fetch size )  {  return new  statement customizer (  )  {  @ override public void before execution (  final  prepared statement stmt  final  statement context ctx )  throws sql exception  {  stmt . set fetch size ( fetch size )  ;   }   }   ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementException.java,get message,"@ override public  string   (  )  {   string base = super . get message (  )  ;   statement context ctx = get statement context (  )  ;  if  ( ctx  =  =  null )   {  return base ;   }  else  {  return  string . format ( ""%s [statement:\""%s\""  rewritten:\"""
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementException.java,get statement context,public  statement context   (  )  {  return statement context ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementCustomizers.java,max field size,public static  statement customizer   ( final int max field size )  {  return new  statement customizer (  )  {  @ override public void before execution (  final  prepared statement stmt  final  statement context ctx )  throws sql exception  {  stmt . set max field size ( max field size )  ;   }   }   ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementCustomizers.java,max rows,public static  statement customizer   ( final int max rows )  {  return new  statement customizer (  )  {  @ override public void before execution (  final  prepared statement stmt  final  statement context ctx )  throws sql exception  {  stmt . set max rows ( max rows )  ;   }   }   ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\StatementCustomizers.java,statement timeout,public static  statement customizer   ( final int seconds )  {  return new  statement customizer (  )  {  @ override public void before execution (  final  prepared statement stmt  final  statement context ctx )  throws sql exception  {  stmt . set query timeout ( seconds )  ;   }   }   ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\UnableToCreateStatementException.java, unable to create statement exception,public   (  exception e  statement context ctx )  {  super ( e ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\UnableToExecuteStatementException.java, unable to execute statement exception,public   (  string message  throwable throwable  statement context ctx )  {  super ( message throwable ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\CMTTransactionHandler.java,in transaction,@ override public  < r x extends  exception > r   (  handle handle  transaction isolation level level  handle callback < r x >  callback )  throws x  {  return in transaction ( handle callback )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\CMTTransactionHandler.java,is in transaction,"@ override public boolean   (  handle handle )  {  try  {  return  ! handle . get connection (  )  . get auto commit (  )  ;   }  catch  (  sql exception e )   {  throw new  transaction exception ( "" failed to check status of transaction"" e )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\CMTTransactionHandler.java,release savepoint,"@ override public void   (  handle handle  string savepoint name )  {  throw new  unsupported operation exception ( "" savepoints not supported"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\CMTTransactionHandler.java,rollback,"@ override public void   (  handle handle )  {  throw new  transaction exception ( "" rollback called  this runtime exception thrown to halt the transaction"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\CMTTransactionHandler.java,rollback to savepoint,"@ override public void   (  handle handle  string name )  {  throw new  unsupported operation exception ( "" savepoints not supported"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\CMTTransactionHandler.java,savepoint,"@ override public void   (  handle handle  string name )  {  throw new  unsupported operation exception ( "" savepoints not supported"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\DelegatingTransactionHandler.java, delegating transaction handler,public   (  transaction handler delegate )  {  this . delegate = delegate ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\DelegatingTransactionHandler.java,begin,@ override public void   (  handle handle )  {  delegate . begin ( handle )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\DelegatingTransactionHandler.java,commit,@ override public void   (  handle handle )  {  delegate . commit ( handle )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\DelegatingTransactionHandler.java,get delegate,protected  transaction handler   (  )  {  return delegate ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\DelegatingTransactionHandler.java,in transaction,@ override public  < r x extends  exception > r   (  handle handle  transaction isolation level level  handle callback < r x >  callback )  throws x  {  return delegate . in transaction ( handle level callback )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\DelegatingTransactionHandler.java,is in transaction,@ override public boolean   (  handle handle )  {  return delegate . is in transaction ( handle )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\DelegatingTransactionHandler.java,release savepoint,@ override public void   (  handle handle  string name )  {  delegate . release savepoint ( handle name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\DelegatingTransactionHandler.java,rollback,@ override public void   (  handle handle )  {  delegate . rollback ( handle )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\DelegatingTransactionHandler.java,rollback to savepoint,@ override public void   (  handle handle  string name )  {  delegate . rollback to savepoint ( handle name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\DelegatingTransactionHandler.java,savepoint,@ override public void   (  handle handle  string name )  {  delegate . savepoint ( handle name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Update.java, update,public   (  handle handle  string sql )  {  super ( handle sql )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Update.java,execute,"public  < r > r   (  result producer < r >  producer )  {  try  {  return producer . produce ( this::internal execute get context (  )  )  ;   }  catch  (  sql exception e )   {  try  {  close (  )  ;   }  catch  (   exception e1 )   {  e . add suppressed ( e1 )  ;   }  throw new  unable to produce result exception ( "" could not produce statement result"" e get context (  )  )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\Update.java,execute and return generated keys,public  result bearing   (  string .  .  .  generated key column names )  {  return execute ( returning generated keys ( generated key column names )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\TransactionException.java, transaction exception,public   (  string msg )  {  super ( msg )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\LocalTransactionHandler.java, local stuff,  ( boolean initial )  {  this . initial autocommit = initial ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\LocalTransactionHandler.java,begin,@ override public void   (  handle handle )  {  try  {  if  (  ! local stuff . contains key ( handle )  )   {  boolean initial = handle . get connection (  )  . get auto commit (  )  ;  local stuff . put if absent ( handle new  local stuff ( initial )  ) 
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\LocalTransactionHandler.java,commit,"@ override public void   (  handle handle )  {  try  {  handle . get connection (  )  . commit (  )  ;   }  catch  (  sql exception e )   {  throw new  transaction exception ( "" failed to commit transaction"" e )  ;   }  finally  {  restore auto commit sta"
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\LocalTransactionHandler.java,get initial autocommit,boolean   (  )  {  return initial autocommit ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\LocalTransactionHandler.java,get savepoints, map <  string  savepoint >    (  )  {  return savepoints ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\LocalTransactionHandler.java,in transaction,@ override public  < r x extends  exception > r   (  handle handle  transaction isolation level level  handle callback < r x >  callback )  throws x  {  final  transaction isolation level initial = handle . get transaction isolation level (  )  ;  try  { 
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\LocalTransactionHandler.java,is in transaction,"@ override public boolean   (  handle handle )  {  try  {  return  ! handle . get connection (  )  . get auto commit (  )  ;   }  catch  (  sql exception e )   {  throw new  transaction exception ( "" failed to test for transaction status"" e )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\LocalTransactionHandler.java,release savepoint,@ override public void   (  handle handle  string name )  {  final  connection conn = handle . get connection (  )  ;  try  {  final  savepoint savepoint = local stuff . get ( handle )  . get savepoints (  )  . remove ( name )  ;  if  ( savepoint  =  =  n
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\LocalTransactionHandler.java,restore auto commit state,private void   ( final  handle handle )  {  try  {  final  local stuff stuff = local stuff . remove ( handle )  ;  if  ( stuff  !  =  null )   {  handle . get connection (  )  . set auto commit ( stuff . get initial autocommit (  )  )  ;  stuff . get savepoints (  )  . clear (  )  ;   }   }  catch  (  sql exception e )   {  throw new  unable to restore auto commit state exception ( e )  ;   }  finally  {  local stuff . remove ( handle )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\LocalTransactionHandler.java,rollback,"@ override public void   (  handle handle )  {  did txn rollback . set ( true )  ;  try  {  handle . get connection (  )  . rollback (  )  ;   }  catch  (  sql exception e )   {  throw new  transaction exception ( "" failed to rollback transaction"" e )  ; "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\LocalTransactionHandler.java,rollback to savepoint,@ override public void   (  handle handle  string name )  {  final  connection conn = handle . get connection (  )  ;  try  {  final  savepoint savepoint = local stuff . get ( handle )  . get savepoints (  )  . remove ( name )  ;  if  ( savepoint  =  =  n
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\LocalTransactionHandler.java,savepoint,@ override public void   (  handle handle  string name )  {  final  connection conn = handle . get connection (  )  ;  try  {  final  savepoint savepoint = conn . set savepoint ( name )  ;  local stuff . get ( handle )  . get savepoints (  )  . put ( name
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\SerializableTransactionRunner.java, serializable transaction runner,public   (  transaction handler delegate )  {  super ( delegate )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\SerializableTransactionRunner.java,create copy,@ override public  configuration   (  )  {  return new  configuration (  )  . set max retries ( max retries )  . set serialization failure sql state ( serialization failure sql state )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\SerializableTransactionRunner.java,in transaction,@ override public  < r x extends  exception > r   (  handle handle  transaction isolation level level  handle callback < r x >  callback )  throws x  {  final  transaction isolation level initial = handle . get transaction isolation level (  )  ;  try  { 
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\SerializableTransactionRunner.java,is sql state,protected boolean   (  string expected sql state  throwable throwable )  {  do  {  if  ( throwable instanceof sql exception )   {   string sql state =  (  ( sql exception ) throwable )  . getsql state (  )  ;  if  ( sql state  !  =  null && sql state . starts with ( expected sql state )  )   {  return true ;   }   }   }  while  (  ( throwable = throwable . get cause (  )  )   !  =  null )  ;  return false ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\SerializableTransactionRunner.java,set max retries,public  configuration   ( int max retries )  {  this . max retries = max retries ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\SerializableTransactionRunner.java,set serialization failure sql state,public  configuration   (  string serialization failure sql state )  {  this . serialization failure sql state = serialization failure sql state ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\TransactionIsolationLevel.java, transaction isolation level,  ( int value )  {  this . value = value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\TransactionIsolationLevel.java,int value,public int   (  )  {  return this . value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\TransactionIsolationLevel.java,value of,public static  transaction isolation level   ( int val )  {  switch  ( val )   {  case  connection . transaction   read   uncommitted: return read   uncommitted ;  case  connection . transaction   read   committed: return read   committed ;  case  connection . transaction   none: return none ;  case  connection . transaction   repeatable   read: return repeatable   read ;  case  connection . transaction   serializable: return serializable ;  default : return unknown ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\UnableToManipulateTransactionIsolationLevelException.java, unable to manipulate transaction isolation level exception,public   (  string msg sql exception e )  {  super ( msg e )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\transaction\UnableToRestoreAutoCommitStateException.java, unable to restore auto commit state exception,public   (  throwable throwable )  {  super ( throwable )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java, sql statement,  (  handle handle  string sql )  {  super ( handle )  ;  this . handle = handle ;  this . sql = sql ;  get context (  )  . set connection ( handle . get connection (  )  )  . set raw sql ( sql )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,bind,public final  this   (  string name url value )  {  return bind ( name to argument ( url . class value )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,bindascii stream,public final  this   (  string name  input stream value int length )  {  return bind ( name new  input stream argument ( value length true )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,bind bean,public  this   (  string prefix  object bean )  {  return bind named argument finder ( new  bean property arguments ( prefix bean )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,bind bean list,"public final  this   (  string key  list <  ?  >  values  list <  string >  property names )  throws  unable to create statement exception  {  if  ( values . is empty (  )  )   {  throw new  illegal argument exception ( get class (  )  . get simple name (  )   +  "" . bind bean list was called with no values . "" )  ;   }  if  ( property names . is empty (  )  )   {  throw new  illegal argument exception ( get class (  )  . get simple name (  )   +  "" . bind bean list was called with no properties . "" )  ;   }   string builder names = new  string builder (  )  ;   statement context ctx = get context (  )  ;  for  ( int value index = 0 ;  value index  <  values . size (  )  ;  value index +  +  )   {  if  ( value index  >  0 )   {  names . append ( ' ' )  ;   }   object bean = values . get ( value index )  ;   bean property arguments bean properties = new  bean property arguments ( null bean )  ;  names . append ( "" ( "" )  ;  for  ( int property index = 0 ;  property index  <  property names . size (  )  ;  property index +  +  )   {  if  ( property index  >  0 )   {  names . append ( "" "" )  ;   }   string property name = property names . get ( property index )  ;   string name = ""      ""  +  key  +  ""   "" +  value index +  ""   "" +  property name ;  names . append ( ':' )  . append ( name )  ;   argument argument = bean properties . find ( property name ctx )  . or else throw (  (  )   -  >  new  unable to create statement exception ( "" unable to get ""  +  property name  +  "" argument for "" +  bean ctx )  )  ;  bind ( name argument )  ;   }  names . append ( "" ) "" )  ;   }  return define ( key names . to string (  )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,bind binary stream,public final  this   (  string name  input stream value int length )  {  return bind ( name new  input stream argument ( value length false )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,bind by sql type,public final  this   ( int position  object value int sql type )  {  return bind ( position new  object argument ( value sql type )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,bind by type,public final  this   (  string name  object value  generic type <  ?  >  argument type )  {  return bind by type ( name value argument type . get type (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,bind fields,public  this   (  string prefix  object object )  {  return bind named argument finder ( new  object field arguments ( prefix object )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,bind list,"public final  this   (  string key  list <  ?  >  values )  {  if  ( values . is empty (  )  )   {  throw new  illegal argument exception ( get class (  )  . get simple name (  )   +  "" . bind list was called with an empty list . "" )  ;   }   string builder names = new  string builder (  )  ;  for  ( int i = 0 ;  i  <  values . size (  )  ;  i +  +  )   {   string name = ""      ""  +  key  +  ""   "" +  i ;  if  ( i  >  0 )   {  names . append ( ' ' )  ;   }   string param name = get config (  )  . get (  sql statements . class )  . get sql parser (  )  . name parameter ( name get context (  )  )  ;  names . append ( param name )  ;  bind ( name values . get ( i )  )  ;   }  return define ( key names . to string (  )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,bind map,public  this   (  map <  string  ?  >  map )  {  return map  =  =  null  ?  typed this : bind named argument finder ( new  map arguments ( map )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,bind methods,public  this   (  string prefix  object object )  {  return bind named argument finder ( new  object method arguments ( prefix object )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,bind named argument finder,public  this   ( final  named argument finder named argument finder )  {  if  ( named argument finder  !  =  null )   {  get binding (  )  . add named argument finder ( named argument finder )  ;   }  return typed this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,bind null,public final  this   ( int position int sql type )  {  return bind ( position new  null argument ( sql type )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,cleanup handle,private  this   (  consumer <  handle >  action )  {  add cleanable (  (  )   -  >   {  if  ( handle  !  =  null )   {  if  ( handle . is in transaction (  )  )   {  action . accept ( handle )  ;   }  handle . close (  )  ;   }   }   )  ;  return typed this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,cleanup handle commit,public  this   (  )  {  return cleanup handle (  handle::commit )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,cleanup handle rollback,public  this   (  )  {  return cleanup handle (  handle::rollback )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,define list,"public final  this   (  string key  list <  ?  >  values )  {  if  ( values . is empty (  )  )   {  throw new  illegal argument exception ( get class (  )  . get simple name (  )   +  "" . define list was called with an empty list . "" )  ;   }  if  ( values . contains ( null )  )   {  throw new  illegal argument exception ( get class (  )  . get simple name (  )   +  "" . define list was called with a list containing null values . "" )  ;   }   string value = values . stream (  )  . map (  object::to string )  . collect ( joining ( ""  "" )  )  ;  return define ( key value )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,factory not found,"private  unsupported operation exception   (  type type  object value )  {  if  ( type instanceof  class <  ?  >  )   {  final  type variable <  ?  > [] params =  (  (  class <  ?  >  ) type )  . get type parameters (  )  ;  if  ( params . length  >  0 )   {  return new  unsupported operation exception ( "" no type parameters found for erased type '""  +  type  +   arrays . to string ( params )  +  ""' .   to bind a generic type  prefer using bind by type . "" )  ;   }   }  return new  unsupported operation exception ( "" no argument factory registered for '""  +  value  +  ""' of type "" +  type )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,get binding,protected  binding   (  )  {  return get context (  )  . get binding (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,get sql,protected  string   (  )  {  return sql ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,internal execute," prepared statement   (  )  {   string rendered sql = get config (  sql statements . class )  . get template engine (  )  . render ( sql get context (  )  )  ;  get context (  )  . set rendered sql ( rendered sql )  ;   parsed sql parsed sql = get config (  sql statements . class )  . get sql parser (  )  . parse ( rendered sql get context (  )  )  ;   string sql = parsed sql . get sql (  )  ;   parsed parameters parsed parameters = parsed sql . get parameters (  )  ;  get context (  )  . set parsed sql ( parsed sql )  ;  try  {  if  ( get class (  )  . is assignable from (  call . class )  )   {  stmt = handle . get statement builder (  )  . create call ( handle . get connection (  )  sql get context (  )  )  ;   }  else  {  stmt = handle . get statement builder (  )  . create ( handle . get connection (  )  sql get context (  )  )  ;   }   }  catch  (  sql exception e )   {  throw new  unable to create statement exception ( e get context (  )  )  ;   }  add cleanable (  (  )   -  >  handle . get statement builder (  )  . close ( handle . get connection (  )  this . sql stmt )  )  ;  get context (  )  . set statement ( stmt )  ;  before binding ( stmt )  ;   argument binder . bind ( parsed parameters get binding (  )  stmt get context (  )  )  ;  before execution ( stmt )  ;  try  {  final long start =  system . nano time (  )  ;  stmt . execute (  )  ;  final long elapsed time =  system . nano time (  )   -  start ;  log . trace ( "" execute sql \"" {  } \"" in  {  } ms"" sql elapsed time  /  1000000l )  ;  get config (  sql statements . class )  . get timing collector (  )  . collect ( elapsed time get context (  )  )  ;   }  catch  (  sql exception e )   {  try  {  stmt . close (  )  ;   }  catch  (  sql exception e1 )   {  e . add suppressed ( e1 )  ;   }  throw new  unable to execute statement exception ( e get context (  )  )  ;   }  after execution ( stmt )  ;  return stmt ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,mapper for type," row mapper <  ?  >    (  type type )  {  return get config (  mappers . class )  . find for ( type )  . or else throw (  (  )   -  >  new  unsupported operation exception ( "" no mapper registered for ""  +  type )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,set query timeout,public  this   ( final int seconds )  {  return add customizer (  statement customizers . statement timeout ( seconds )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\main\java\org\jdbi\v3\core\statement\SqlStatement.java,to argument,private  argument   (  type type  object value )  {  return get config (  arguments . class )  . find for ( type value )  . or else throw (  (  )   -  >  factory not found ( type value )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestAbstractArgumentFactory.java, box,  ( t value )  {  this . value = value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestAbstractArgumentFactory.java, box of string argument factory,  (  )  {  super (  types . varchar )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestAbstractArgumentFactory.java, simple argument factory,  (  )  {  super (  types . varchar )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestAbstractArgumentFactory.java, simple type,  (  string value )  {  this . value = value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestAbstractArgumentFactory.java,build,@ override protected  argument   (  box <  string >  value  config registry config )  {  return  ( pos stmt ctx )   -  >  stmt . set string ( pos value . value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestAbstractArgumentFactory.java,test expected class,"@ test public void   (  )  throws sql exception  {   argument argument = new  simple argument factory (  )  . build (  simple type . class new  simple type ( ""foo"" )  config )  . or else ( null )  ;  assert that ( argument )  . is not null (  )  ;  argume"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestAbstractArgumentFactory.java,test expected generic type,"@ test public void   (  )  throws sql exception  {   argument argument = new  box of string argument factory (  )  . build ( box   of   string   type new  box <  >  ( ""foo"" )  config )  . or else ( null )  ;  assert that ( argument )  . is not null (  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestAbstractArgumentFactory.java,test expected generic type with different parameter,"@ test public void   (  )  {  assert that ( new  box of string argument factory (  )  . build ( box   of   object   type new  box <  object >  ( ""foo"" )  config )  )  . is empty (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestAbstractArgumentFactory.java,test null of different type,@ test public void   (  )  throws sql exception  {  assert that ( new  simple argument factory (  )  . build (  integer . class null config )  )  . is empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestAbstractArgumentFactory.java,test null of expected class,@ test public void   (  )  throws sql exception  {   argument argument = new  simple argument factory (  )  . build (  simple type . class null config )  . or else ( null )  ;  assert that ( argument )  . is not null (  )  ;  argument . apply ( 3 statemen
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestAbstractArgumentFactory.java,test null of expected generic type,@ test public void   (  )  throws sql exception  {   argument argument = new  box of string argument factory (  )  . build ( box   of   string   type null config )  . or else ( null )  ;  assert that ( argument )  . is not null (  )  ;  argument . apply (
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestAbstractArgumentFactory.java,test object class with instance of expected type,"@ test public void   (  )  throws sql exception  {   argument argument = new  simple argument factory (  )  . build (  object . class new  simple type ( ""bar"" )  config )  . or else ( null )  ;  assert that ( argument )  . is not null (  )  ;  argument . "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestAbstractArgumentFactory.java,test value of different type,@ test public void   (  )  throws sql exception  {  assert that ( new  simple argument factory (  )  . build ( int . class 1 config )  )  . is empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestArgumentsRegistry.java,build,@ override public  optional <  argument >    (  type expected type  object value  config registry config )  {  return value instanceof  weird  ?   optional . of ( new  weird argument (  )  )  :  optional . empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestArgumentsRegistry.java,test explicit waffle long,@ test public void   (  )  throws  exception  {  ctx . find argument for (  long . class 3l )  . get (  )  . apply ( 1 stmt null )  ;  verify ( stmt )  . set long ( 1 3 )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestArgumentsRegistry.java,test explicit waffle short,@ test public void   (  )  throws  exception  {  ctx . find argument for ( short . class  ( short ) 2000 )  . get (  )  . apply ( 2 stmt null )  ;  verify ( stmt )  . set short ( 2  ( short ) 2000 )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestArgumentsRegistry.java,test explicit waffle string,@ test public void   (  )  throws  exception  {  ctx . find argument for (  string . class i   am   a   string )  . get (  )  . apply ( 3 stmt null )  ;  verify ( stmt )  . set string ( 3 i   am   a   string )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestArgumentsRegistry.java,test pull weird class argument factory,@ test public void   (  )  throws  exception  {  handle . register argument ( new  weird class argument factory (  )  )  ;  assert that ( ctx . find argument for (  weird . class new  weird (  )  )  )  . has value satisfying ( a  -  >  assert that ( a )  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestArgumentsRegistry.java,test pull weird value argument factory,@ test public void   (  )  {  handle . register argument ( new  weird value argument factory (  )  )  ;  assert that ( ctx . find argument for (  weird . class new  weird (  )  )  )  . has value satisfying ( a  -  >  assert that ( a )  . is instance of ( 
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestArgumentsRegistry.java,test waffle long,@ test public void   (  )  throws  exception  {  ctx . find argument for (  object . class 3l )  . get (  )  . apply ( 1 stmt null )  ;  verify ( stmt )  . set long ( 1 3 )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestArgumentsRegistry.java,test waffle short,@ test public void   (  )  throws  exception  {  ctx . find argument for (  object . class  ( short ) 2000 )  . get (  )  . apply ( 2 stmt null )  ;  verify ( stmt )  . set short ( 2  ( short ) 2000 )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestArgumentsRegistry.java,test waffle string,@ test public void   (  )  throws  exception  {  ctx . find argument for (  object . class i   am   a   string )  . get (  )  . apply ( 3 stmt null )  ;  verify ( stmt )  . set string ( 3 i   am   a   string )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestArgumentFactory.java, name,public   (  string first  string last )  {  this . first = first ;  this . last = last ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestArgumentFactory.java,build,@ override public  optional <  argument >    (  type expected type  object value  config registry config )  {  if  ( expected type  =  =   name . class || value instanceof  name )   {   name name value =  (  name ) value ;  return config . get (  argument
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestArgumentFactory.java,get full name,"public  string   (  )  {  return first  +  "" ""  +  last ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestArgumentFactory.java,test on prepared batch,"@ test public void   (  )  throws  exception  {   handle h = db rule . get shared handle (  )  ;   prepared batch batch = h . prepare batch ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  ;  batch . register argument ( new  nameaf (  )"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestArgumentFactory.java,test register on handle,"@ test public void   (  )  throws  exception  {  try  (  handle h = db rule . open handle (  )  )  {  h . register argument ( new  nameaf (  )  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  . bind ( ""id"" 7 )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestArgumentFactory.java,test register on jdbi,"@ test public void   (  )  throws  exception  {  final  jdbi db = db rule . get jdbi (  )  ;  db . register argument ( new  nameaf (  )  )  ;  try  (  handle h = db . open (  )  )  {  h . create update ( ""insert into something  ( id  name )  values  ( :id"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestArgumentFactory.java,test register on statement,"@ test public void   (  )  throws  exception  {  db rule . get shared handle (  )  . create update ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  . register argument ( new  nameaf (  )  )  . bind ( ""id"" 1 )  . bind ( ""name"" new  name "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestArgumentFactory.java,to string,"@ override public  string   (  )  {  return "" <  name first = ""  +  first  +  "" last = "" +  last +  ""  > "" ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestBeanArguments.java,get bar,"@ suppress warnings ( ""unused"" )  protected  string   (  )  {  return ""baz"" ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestBeanArguments.java,get foo,"@ suppress warnings ( ""unused"" )  public  big decimal   (  )  {  return null ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestBeanArguments.java,test bind bare,"@ test public void   (  )  throws  exception  {   object bean = new  object (  )  {  @ suppress warnings ( ""unused"" )  public  big decimal get foo (  )  {  return  big decimal . one ;   }   }   ;  new  bean property arguments ( """" bean )  . find ( ""foo"" c"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestBeanArguments.java,test bind illegal access,"@ test public void   (  )  throws  exception  {   object bean = new  object (  )  {  @ suppress warnings ( ""unused"" )  public  string get bar (  )  throws  illegal access exception  {  throw new  illegal access exception (  )  ;   }   }   ;  exception . e"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestBeanArguments.java,test bind no getter,"@ test public void   (  )  throws  exception  {   object bean = new  object (  )  {  @ suppress warnings ( ""unused"" )  public void set bar (   string bar )  {   }   }   ;  exception . expect (  unable to create statement exception . class )  ;  new  bean "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestBeanArguments.java,test bind non public getter,"@ test public void   (  )  throws  exception  {   object bean = new  object (  )  {  @ suppress warnings ( ""unused"" )  protected  string get bar (  )  {  return ""baz"" ;   }  @ suppress warnings ( ""unused"" )  public void set bar (   string bar )  {   }   }"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestBeanArguments.java,test bind null,"@ test public void   (  )  throws  exception  {   object bean = new  object (  )  {  @ suppress warnings ( ""unused"" )  public  big decimal get foo (  )  {  return null ;   }   }   ;  new  bean property arguments ( """" bean )  . find ( ""foo"" ctx )  . get ( "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestBeanArguments.java,test bind prefix,"@ test public void   (  )  throws  exception  {   object bean = new  object (  )  {  @ suppress warnings ( ""unused"" )  public  string get bar (  )  {  return ""baz"" ;   }   }   ;  new  bean property arguments ( ""foo"" bean )  . find ( ""foo . bar"" ctx )  . g"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestCollectionArguments.java,test bind type erased,"@ test public void   (  )  throws  exception  {  try  ( final  handle h = db . open handle (  )  )  {  assert that thrown by (  (  )   -  >  h . execute ( ""select * from something where id  =  any ( :ids ) ""  collections . singleton ( 1 )  )  )  . is inst"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestInetAddressH2.java,get inet type,"protected  string   (  )  {  return ""varchar"" ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestInetAddressH2.java,test inet address,"@ test public void   (  )  throws  exception  {  db rule . get jdbi (  )  . use handle ( h  -  >   {  h . execute ( ""create table addrs  ( addr ""  +  get inet type (  )   +  "" primary key ) "" )  ;   string insert = ""insert into addrs values (  ?  ) "" ;   "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\array\TestVendorArrays.java,init,"private void   (  jdbi db )  {  db . register array type (  integer . class ""int"" )  ;  db . register array type (  string . class ""varchar"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestMapArguments.java,test null binding,"@ test public void   (  )  throws  exception  {   map <  string  object >  args =  collections . singleton map ( ""foo"" null )  ;  new  map arguments ( args )  . find ( ""foo"" ctx )  . get (  )  . apply ( 3 stmt null )  ;  verify ( stmt )  . set null ( 3  t"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\array\TestVendorArrays.java,test hsql db,"@ test public void   (  )  {   jdbi db =  jdbi . create ( ""jdbc:hsqldb:mem:""  +  uuid . randomuuid (  )  )  ;  init ( db )  ;  try  (  handle handle = db . open (  )  )  {  handle . execute ( ""create table player   stats  ( ""  +  ""name varchar ( 64 )  pri"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java, no arg functions,public   ( int i  string s )  {  this . i = i ;  this . s = s ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java, public fields,public   ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java,get name,"@ suppress warnings ( ""unused"" )  public  string   (  )  {  return "" keith"" ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java,get nested,"@ suppress warnings ( ""unused"" )  public  something   (  )  {  return thing ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java,id,public int   (  )  {  return i ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java,name,public  string   (  )  {  return s ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java,nested,"@ suppress warnings ( ""unused"" )  public  no arg functions   (  )  {  return new  no arg functions ( 0 "" keith"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java,test bean property binding,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   something original = new  something ( 0 "" keith"" )  ;  assert that ( h . create update ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  . bind "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java,test bean property nested binding,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   something thing = new  something ( 0 "" keith"" )  ;  assert that ( h . create update ( ""insert into something  ( id  name )  values  ( :my . nested . id  :my . nes"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java,test bean property prefix binding,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   something original = new  something ( 0 "" keith"" )  ;  assert that ( h . create update ( ""insert into something  ( id  name )  values  ( :my . id  :my . name ) "" "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java,test cascaded lazy args,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   update s = h . create update ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  ;   map <  string  object >  args = new  hash map <  >  (  )  ;  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java,test demo,"@ test public void   (  )  throws  exception  {   handle h = db rule . get shared handle (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  . bind ( ""id"" 1 )  . bind ( ""name"" "" brian"" )  . execute (  )  ;  h . e"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java,test fields binding,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  assert that ( h . create update ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  . bind fields ( new  public fields ( 0 "" keith"" )  )  . execute"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java,test fields nested binding,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  assert that ( h . create update ( ""insert into something  ( id  name )  values  ( :my . nested . id  :my . nested . name ) "" )  . bind fields ( ""my"" new  object ( "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java,test fields prefix binding,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  assert that ( h . create update ( ""insert into something  ( id  name )  values  ( :my . id  :my . name ) "" )  . bind fields ( ""my"" new  public fields ( 0 "" keith"" "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java,test functions binding,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  assert that ( h . create update ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  . bind methods ( new  no arg functions ( 0 "" keith"" )  )  . exe"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java,test functions nested binding,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  assert that ( h . create update ( ""insert into something  ( id  name )  values  ( :my . nested . id  :my . nested . name ) "" )  . bind methods ( ""my"" new  object ("
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java,test functions prefix binding,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  assert that ( h . create update ( ""insert into something  ( id  name )  values  ( :my . id  :my . name ) "" )  . bind methods ( ""my"" new  no arg functions ( 0 "" kei"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java,test insert,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   update insert = h . create update ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  ;  insert . bind ( ""id"" 1 )  ;  insert . bind ( ""name"" "" bri"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\argument\TestNamedParams.java,test map key binding,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   update s = h . create update ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  ;   map <  string  object >  args = new  hash map <  >  (  )  ;  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\collector\OptionalCollectorsTest.java,to optional,@ test public void   (  )  {   collector <  string  ?   optional <  string >  >  collector =  optional collectors . to optional (  )  ;  assert that (  stream .  <  string > empty (  )  . collect ( collector )  )  . is empty (  )  ;  assert that (  stream
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\collector\OptionalCollectorsTest.java,to optional double,@ test public void   (  )  {   collector <  double  ?   optional double >  collector =  optional collectors . to optional double (  )  ;  assert that (  stream .  <  double > empty (  )  . collect ( collector )  )  . is empty (  )  ;  assert that (  strea
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\collector\OptionalCollectorsTest.java,to optional int,@ test public void   (  )  {   collector <  integer  ?   optional int >  collector =  optional collectors . to optional int (  )  ;  assert that (  stream .  <  integer > empty (  )  . collect ( collector )  )  . is empty (  )  ;  assert that (  stream . 
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\collector\OptionalCollectorsTest.java,to optional long,@ test public void   (  )  {   collector <  long  ?   optional long >  collector =  optional collectors . to optional long (  )  ;  assert that (  stream .  <  long > empty (  )  . collect ( collector )  )  . is empty (  )  ;  assert that (  stream . of (
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\collector\BuiltInCollectorFactoryTest.java,collections,@ test public void   (  )  {  test collection type ( new  generic type <  collection <  string >  >  (  )  {   }   )  ;  test collection type ( new  generic type <  list <  string >  >  (  )  {   }   )  ;  test collection type ( new  generic type <  array
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\collector\BuiltInCollectorFactoryTest.java,maps,@ test public void   (  )  {  test map type ( new  generic type <  map <  long  string >  >  (  )  {   }   )  ;  test map type ( new  generic type <  hash map <  long  string >  >  (  )  {   }   )  ;  test map type ( new  generic type <  linked hash map <
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\collector\BuiltInCollectorFactoryTest.java,optional,@ test public void   (  )  {   type optional string = new  generic type <  optional <  string >  >  (  )  {   }   . get type (  )  ;  assert that ( factory . accepts ( optional string )  )  . is true (  )  ;  assert that ( factory . accepts (  optional . 
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\collector\BuiltInCollectorFactoryTest.java,test collection type,"private  < c extends  collection <  string >  > void   (  generic type < c >  generic type )  {   type container type = generic type . get type (  )  ;   class <  ?  >  erased type = get erased type ( container type )  ;  assert that ( factory . accepts ( container type )  )  . is true (  )  ;  assert that ( factory . accepts ( erased type )  )  . is false (  )  ;  assert that ( factory . element type ( container type )  )  . contains (  string . class )  ;   collector <  string  ?  c >  collector =  (  collector <  string  ?  c >  ) factory . build ( container type )  ;  assert that (  stream . of ( ""foo"" ""bar"" ""baz"" )  . collect ( collector )  )  . is instance of ( erased type )  . contains only ( ""foo"" ""bar"" ""baz"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\collector\BuiltInCollectorFactoryTest.java,test map type,"private  < m extends  map <  long  string >  > void   (  generic type < m >  generic type )  {   type container type = generic type . get type (  )  ;   class <  ?  >  erased type = get erased type ( container type )  ;  assert that ( factory . accepts ( container type )  )  . is true (  )  ;  assert that ( factory . accepts ( erased type )  )  . is false (  )  ;  assert that ( factory . element type ( container type )  )  . contains ( resolve map entry type (  long . class  string . class )  )  ;   collector <  map .  entry <  long  string >   ?  m >  collector =  (  collector <  map .  entry <  long  string >   ?  m >  ) factory . build ( container type )  ;  assert that (  stream . of ( entry ( 1l ""foo"" )  entry ( 2l ""bar"" )  entry ( 3l ""baz"" )  )  . collect ( collector )  )  . is instance of ( erased type )  . contains only ( entry ( 1l ""foo"" )  entry ( 2l ""bar"" )  entry ( 3l ""baz"" )  )  ;  assert that thrown by (  (  )   -  >   stream . of ( entry ( 1l ""foo"" )  entry ( 1l ""bar"" )  )  . collect ( collector )  )  . is instance of (  illegal state exception . class )  . has message containing ( "" multiple values"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\h2\TestH2SqlArrays.java,set up,"@ before public void   (  )  {  h = db rule . get shared handle (  )  ;  h . use transaction ( th  -  >   {  th . execute ( ""drop table if exists uuids"" )  ;  th . execute ( ""create table uuids  ( u array ) "" )  ;   }   )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\h2\TestH2SqlArrays.java,test uuid array,"@ test public void   (  )  throws  exception  {  assert that ( h . create update ( u   insert )  . bind ( ""u"" test uuids )  . execute (  )  )  . is equal to ( 1 )  ;  assert that ( h . create query ( u   select )  . map to ( uuid[] . class )  . find only "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\h2\TestH2SqlArrays.java,test uuid array list,"@ test public void   (  )  throws  exception  {  assert that ( h . create update ( u   insert )  . bind by type ( ""u"" new  array list <  >  (  arrays . as list ( test uuids )  )  uuid   list )  . execute (  )  )  . is equal to ( 1 )  ;  assert that ( h . "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\h2\TestH2SqlArrays.java,test uuid hash set,"@ test public void   (  )  throws  exception  {  assert that ( h . create update ( u   insert )  . bind by type ( ""u"" new  hash set <  >  (  arrays . as list ( test uuids )  )  uuid   set )  . execute (  )  )  . is equal to ( 1 )  ;  assert that ( h . cre"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\h2\TestH2SqlArrays.java,test uuid linked hash set,"@ test public void   (  )  throws  exception  {  assert that ( h . create update ( u   insert )  . bind by type ( ""u"" new  linked hash set <  >  (  arrays . as list ( test uuids )  )  uuid   set )  . execute (  )  )  . is equal to ( 1 )  ;  assert that ( "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\h2\TestH2SqlArrays.java,test uuid list,"@ test public void   (  )  throws  exception  {  assert that ( h . create update ( u   insert )  . bind by type ( ""u""  arrays . as list ( test uuids )  uuid   list )  . execute (  )  )  . is equal to ( 1 )  ;  assert that ( h . create query ( u   select )"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\HandleAccess.java,create handle,public static  handle   (  )  {   connection fake connection =  mockito . mock (  connection . class )  ;  return new  handle ( new  config registry (  )  new  local transaction handler (  )  new  default statement builder (  )  fake connection )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\generic\GenericTypeTest.java,generic,@ test public void   (  )  {  assert that ( new  generic type <  string >  (  )  {   }   . get type (  )  )  . is equal to (  string . class )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\generic\GenericTypeTest.java,raw,"@ suppress warnings ( "" types"" )  @ test ( expected =  unsupported operation exception . class )  public void raw (  )  {  new  generic type (  )  {   }   ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,iterator,"@ override public  iterator <  string >    (  )  {  final  list <  string >  tmp = new  array list <  string >  (  )  ;  tmp . add ( ""1"" )  ;  tmp . add ( ""2"" )  ;  return tmp . iterator (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test empty array,@ test public void   (  )  {  final  iterator <  object >  it =  iterable like . of ( new int[] {  }  )  ;  assert that ( it )  . is empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test empty array to iterator,@ test public void   (  )  {  final  object[] out = to array (  iterable like . of ( new int[] {  }  )  )  ;  assert that ( out )  . is empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test empty list to iterator,@ test public void   (  )  {  final  object[] out = to array (  iterable like . of ( new  array list <  integer >  (  )  )  )  ;  assert that ( out )  . is empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test int array,@ test public void   (  )  {  final  iterator <  object >  it =  iterable like . of ( new int[] { 1 2 3 }  )  ;  assert that ( it )  . contains exactly ( 1 2 3 )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test is empty empty list,@ test public void   (  )  {  assert that (  iterable like . is empty ( new  array list <  string >  (  )  )  )  . is true (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test is empty empty object array,@ test public void   (  )  {  assert that (  iterable like . is empty ( new  object[] {  }  )  )  . is true (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test is empty empty primitive array,@ test public void   (  )  {  assert that (  iterable like . is empty ( new int[] {  }  )  )  . is true (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test is empty list,"@ test public void   (  )  {  final  list <  string >  in = new  array list <  string >  (  )  ;  in . add ( ""1"" )  ;  in . add ( ""2"" )  ;  in . add ( ""3"" )  ;  assert that (  iterable like . is empty ( in )  )  . is false (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test is empty null,@ test ( expected =  illegal argument exception . class )  public void   (  )  {   iterable like . is empty ( null )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test is empty object,@ test ( expected =  illegal argument exception . class )  public void   (  )  {   iterable like . is empty ( new  object (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test is empty object array,"@ test public void   (  )  {  assert that (  iterable like . is empty ( new  object[] { ""1"" ""2"" ""3"" }  )  )  . is false (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test is empty primitive,@ test ( expected =  illegal argument exception . class )  public void   (  )  {   iterable like . is empty ( 5 )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test is empty primitive array,@ test public void   (  )  {  assert that (  iterable like . is empty ( new int[] { 1 2 3 }  )  )  . is false (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test iterable to iterator,"@ test public void   (  )  {  final  iterable <  string >  in = new  iterable <  string >  (  )  {  @ override public  iterator <  string >  iterator (  )  {  final  list <  string >  tmp = new  array list <  string >  (  )  ;  tmp . add ( ""1"" )  ;  tmp ."
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test list to iterator,"@ test public void   (  )  {  final  list <  string >  in = new  array list <  string >  ( 2 )  ;  in . add ( ""1"" )  ;  in . add ( ""2"" )  ;  final  object[] out = to array (  iterable like . of ( in )  )  ;  assert that ( out )  . contains exactly ( ""1"" """
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test null to iterator,@ test ( expected =  illegal argument exception . class )  public void   (  )  {   iterable like . of ( null )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test object to iterator,@ test ( expected =  illegal argument exception . class )  public void   (  )  {   iterable like . of ( new  object (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test other class to iterator,"@ test ( expected =  illegal argument exception . class )  public void   (  )  {   iterable like . of ( ""bla"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test overflow,@ test ( expected =  no such element exception . class )  public void   (  )  {  final  iterator <  ?  >  it =  iterable like . of ( new int[] { 1 }  )  ;  assert that ( it . has next (  )  )  . is true (  )  ;  assert that ( it . next (  )  )  . is equal
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test overflow on empty,@ test ( expected =  no such element exception . class )  public void   (  )  {  final  iterator <  ?  >  it =  iterable like . of ( new int[] {  }  )  ;  it . next (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test primitive array to iterator,@ test public void   (  )  {  final int[] in = new int[] { 1 2 }  ;  final  object[] out = to array (  iterable like . of ( in )  )  ;  assert that ( out )  . contains exactly ( 1 2 )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test primitive to iterator,@ test ( expected =  illegal argument exception . class )  public void   (  )  {   iterable like . of ( 1 )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test set to iterator,"@ test public void   (  )  {  final  set <  string >  in = new  hash set <  string >  ( 2 )  ;  in . add ( ""1"" )  ;  in . add ( ""2"" )  ;  final  object[] out = to array (  iterable like . of ( in )  )  ;  assert that ( out )  . contains exactly ( ""1"" ""2"" "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,test string array to iterator,"@ test public void   (  )  {  final  string[] in = new  string[] { ""1"" ""2"" }  ;  final  object[] out = to array (  iterable like . of ( in )  )  ;  assert that ( out )  . contains exactly ( ""1"" ""2"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\IterableLikeTest.java,to array,private static  object[]   ( final  iterator <  ?  >  iterator )  {  final  list <  object >  out = new  array list <  object >  (  )  ;  while  ( iterator . has next (  )  )   {  out . add ( iterator . next (  )  )  ;   }  return out . to array (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\lexer\TestColonGrammar.java,create lexer,@ override protected  lexer   (  string s )  {  return new  colon statement lexer ( new antlr string stream ( s )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\lexer\TestColonGrammar.java,name of,"@ override protected  string   ( int type )  {  switch  ( type )   {  case literal: return ""literal"" ;  case quoted   text: return ""quoted   text"" ;  case named   param: return ""named   param"" ;  case eof: return ""eof"" ;   }  return  string . value of ( t"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\lexer\TestColonGrammar.java,test empty quote,"@ test public void   (  )  throws  exception  {  expect ( ""select ''"" literal quoted   text eof )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\lexer\TestColonGrammar.java,test escaped colon,"@ test public void   (  )  throws  exception  {  expect ( ""insert into foo  ( val )  value  ( :bar\\:\\:type ) "" literal named   param escaped   text escaped   text literal eof )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\lexer\TestColonGrammar.java,test escaped empty quote,"@ test public void   (  )  throws  exception  {  expect ( ""select '\\''"" literal quoted   text eof )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\lexer\TestColonGrammar.java,test exclamation works,"@ test public void   (  )  throws  exception  {  expect ( ""select1  !  =  2 from dual"" literal eof )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\lexer\TestColonGrammar.java,test hash in column name works,"@ test public void   (  )  throws  exception  {  expect ( ""select col# from something where id  =  :id"" literal named   param eof )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\lexer\TestColonGrammar.java,test mixed,"@ test public void   (  )  throws  exception  {  expect ( ""select id from something where name like ':foo' and id  =   ?  and name like :name"" literal quoted   text literal positional   param literal named   param eof )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\lexer\TestColonGrammar.java,test named only,"@ test public void   (  )  throws  exception  {  expect ( ""select id from something where name like ':foo' and id  =  :id and name like :name"" literal quoted   text literal named   param literal named   param eof )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\lexer\TestColonGrammar.java,test this brokea test,"@ test public void   (  )  throws  exception  {  expect ( ""insert into something  ( id  name )  values  ( :id  :name ) "" literal named   param literal named   param literal eof )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\lexer\TestPrintfGrammar.java,create lexer,@ override protected  lexer   (  string s )  {  return new  formatter statement lexer ( new antlr string stream ( s )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\lexer\TestPrintfGrammar.java,name of,"@ override protected  string   ( int type )  {  switch  ( type )   {  case quoted   text: return ""quoted   text"" ;  case integer: return ""integer"" ;  case string: return ""string"" ;  case literal: return ""literal"" ;  case eof: return ""eof"" ;   }  return ""u"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\internal\lexer\TestPrintfGrammar.java,test foo,"@ test public void   (  )  throws  exception  {  expect ( ""select id from something where name like '%d' and id  =  %d and name like %s"" literal quoted   text literal integer literal string eof )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\locator\TestClasspathSqlLocator.java,get resource as stream,@ override public  input stream   (  string s )  {  load count . increment and get (  )  ;  return super . get resource as stream ( s )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\locator\TestClasspathSqlLocator.java,test caches result after first lookup,@ test public void   (  )  throws  exception  {   class loader class loader =  thread . current thread (  )  . get context class loader (  )  ;  final  atomic integer load count = new  atomic integer ( 0 )  ;   thread . current thread (  )  . set context 
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\locator\TestClasspathSqlLocator.java,test colon in comment,"@ test public void   (  )  throws  exception  {  find sql on classpath ( get class (  )  ""test - colon - in - comment"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\locator\TestClasspathSqlLocator.java,test comments in external sql,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  h . execute ( find sql on classpath ( ""insert - eric - with - comments"" )  )  ;  assert that ( h . select ( ""select name from something"" )  . map to (  string . cl"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\locator\TestClasspathSqlLocator.java,test locate by method name,"@ test public void   (  )  throws  exception  {  assert that ( find sql on classpath ( get class (  )  ""test locate by method name"" )  )  . contains ( ""select 1"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\locator\TestClasspathSqlLocator.java,test locate named,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  h . execute ( find sql on classpath ( ""insert - keith"" )  )  ;  assert that ( h . select ( ""select name from something"" )  . map to (  string . class )  . list (  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\locator\TestClasspathSqlLocator.java,test named params in external,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  h . create update ( find sql on classpath ( ""insert - id - name"" )  )  . bind ( ""id"" 1 )  . bind ( ""name"" "" tip"" )  . execute (  )  ;  assert that ( h . select ( """
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\locator\TestClasspathSqlLocator.java,test non existent resource,"@ test public void   (  )  throws  exception  {  exception . expect (  illegal argument exception . class )  ;  find sql on classpath ( ""this - does - not - exist"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\locator\TestClasspathSqlLocator.java,test positional params in prepared,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  h . execute ( find sql on classpath ( ""insert - id - name - positional"" )  3 "" tip"" )  ;  assert that ( h . select ( ""select name from something"" )  . map to (  st"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\locator\TestClasspathSqlLocator.java,test select by extension method name,"@ test public void   (  )  throws  exception  {  assert that ( find sql on classpath ( get class (  )  ""test - locate - by - custom - name"" )  )  . contains ( ""select 1"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\locator\TestClasspathSqlLocator.java,test useful exception for back tracing,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  exception . expect (  statement exception . class )  ;  exception . expect message ( ""insert into something ( id  name )  values  ( :id  :name ) "" )  ;  exception "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\MapEntryMapperTest.java, phone,public   ( int id  string phone )  {  this . id = id ;  this . phone = phone ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\MapEntryMapperTest.java, user,public   ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\MapEntryMapperTest.java,equals,@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   phone phone1 =  (  phone ) o ;  return id  =  =  phone1 . id &&  objects . equals ( p
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\MapEntryMapperTest.java,hash code,@ override public int   (  )  {  return  objects . hash ( id phone )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\MapEntryMapperTest.java,join row,"@ test public void   (  )  {  h . execute ( ""create table user  ( id int  name varchar ) "" )  ;  h . execute ( ""create table phone  ( id int  user   id int  phone varchar ) "" )  ;  h . prepare batch ( ""insert into user  ( id  name )  values  (  ?    ?  ) "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\MapEntryMapperTest.java,key value columns,"@ test public void   (  )  {  h . execute ( ""create table config  ( key varchar  value varchar ) "" )  ;  h . prepare batch ( ""insert into config  ( key  value )  values  (  ?    ?  ) "" )  . add ( ""foo"" ""123"" )  . add ( ""bar"" ""xyz"" )  . execute (  )  ;   m"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\MapEntryMapperTest.java,override key value column at jdbi level with null at statement,"@ test public void   (  )  {  h . execute ( ""create table user  ( id int  name varchar ) "" )  ;  h . execute ( ""create table phone  ( id int  user   id int  phone varchar ) "" )  ;  h . prepare batch ( ""insert into user  ( id  name )  values  (  ?    ?  ) "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\MapEntryMapperTest.java,set up,@ before public void   (  )  {  h = db rule . get shared handle (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\MapEntryMapperTest.java,to string,"@ override public  string   (  )  {  return "" phone { ""  +  ""id = ""  +  id  +  ""  phone = '"" +  phone +  '\'' +  ' } ' ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\MapEntryMapperTest.java,unique index,"@ test public void   (  )  {  h . execute ( ""create table user  ( id int  name varchar ) "" )  ;  h . prepare batch ( ""insert into user  ( id  name )  values  (  ?    ?  ) "" )  . add ( 1 ""alice"" )  . add ( 2 ""bob"" )  . add ( 3 ""cathy"" )  . add ( 4 ""dilbert"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\MapOptionalTest.java, optional bean,public   (  optional int int value  optional <  string >  name )  {  this . int value = int value ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\MapOptionalTest.java,test map optional,"@ test public void   (  )  throws  exception  {  final  handle h = db . get shared handle (  )  ;  h . execute ( ""insert into something ( int value  name )  values ( 1  ' duke' ) "" )  ;  h . execute ( ""insert into something ( int value  name )  values ( n"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\JoinRowMapperTest.java, article,public   ( int aid  string title )  {  this . aid = aid ;  this . title = title ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\JoinRowMapperTest.java, user,public   ( int uid  string name )  {  this . uid = uid ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\JoinRowMapperTest.java,a,"priv te static  article a ( int aid )  {  return new  article ( aid ""a""  +  aid )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\JoinRowMapperTest.java,equals,@ override public boolean   (  object obj )  {  if  ( obj instanceof  article )   {   article that =  (  article ) obj ;  return  objects . equals ( aid that . aid )  &&  objects . equals ( title that . title )  ;   }  return false ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\JoinRowMapperTest.java,get expected,public static  multimap <  user  article >    (  )  {   multimap <  user  article >  expected =  hash multimap . create (  )  ;  expected . put ( u ( 1 )  a ( 2 )  )  ;  expected . put ( u ( 3 )  a ( 1 )  )  ;  expected . put ( u ( 3 )  a ( 3 )  )  ;  return expected ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\JoinRowMapperTest.java,hash code,@ override public int   (  )  {  return  objects . hash ( aid title )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\JoinRowMapperTest.java,set up,"@ before public void   (  )  {  h = db rule . get shared handle (  )  ;  h . execute ( ""create table user  ( ""  +  ""uid integer not null ""  +  ""name varchar not null"" +  "" ) "" )  ;  h . execute ( ""create table article  ( ""  +  ""aid integer not null ""  +  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\JoinRowMapperTest.java,test cartesian product,"@ test public void   (  )  throws  exception  {   multimap <  user  article >  product =  hash multimap . create (  )  ;  h . create query ( ""select * from user  article"" )  . map (  join row mapper . for types (  user . class  article . class )  )  . for"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\JoinRowMapperTest.java,test join,"@ test public void   (  )  throws  exception  {   multimap <  user  article >  joined =  hash multimap . create (  )  ;  h . create query ( ""select * from user natural join author natural join article"" )  . map (  join row mapper . for types (  user . cla"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\JoinRowMapperTest.java,u,"private static  user   ( int uid )  {  return new  user ( uid ""u""  +  uid )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapperTest.java, constructor bean,@ jdbi constructor   (  string s int i )  {  this . s = s ;  this . i = i ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapperTest.java, constructor properties bean,"@ constructor properties (  { ""s"" ""i"" }  )    (  string x int y )  {  this . s = x ;  this . i = y ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapperTest.java, named parameter bean,"  ( @ column name ( ""xyz"" )  int i )  {  this . i = i ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapperTest.java, nested bean,  ( @ nested  constructor bean nested )  {  this . nested = nested ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapperTest.java, nested prefix bean,"  ( @ nested ( ""nested"" )   constructor bean nested )  {  this . nested = nested ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapperTest.java,execute,public  constructor bean   (  string query )  {  return db rule . get shared handle (  )  . create query ( query )  . map to (  constructor bean . class )  . find only (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapperTest.java,nested parameters,"@ test public void   (  )  {  assert that ( db rule . get shared handle (  )  . register row mapper (  constructor mapper . factory (  nested bean . class )  )  . select ( ""select s  i from bean"" )  . map to (  nested bean . class )  . find only (  )  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapperTest.java,nested parameters strict,@ test public void   (  )  {   handle handle = db rule . get shared handle (  )  ;  handle . get config (  reflection mappers . class )  . set strict matching ( true )  ;  handle . register row mapper (  constructor mapper . factory (  nested bean . class
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapperTest.java,nested prefix parameters,"@ test public void   (  )  {   nested prefix bean result = db rule . get shared handle (  )  . register row mapper (  constructor mapper . factory (  nested prefix bean . class )  )  . select ( ""select i nested   i  s nested   s from bean"" )  . map to (  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapperTest.java,nested prefix parameters strict,@ test public void   (  )  {   handle handle = db rule . get shared handle (  )  ;  handle . get config (  reflection mappers . class )  . set strict matching ( true )  ;  handle . register row mapper (  constructor mapper . factory (  nested prefix bean 
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapperTest.java,set up,@ before public void   (  )  throws  exception  {  db rule . get shared handle (  )  . register row mapper (  constructor mapper . factory (  constructor bean . class )  )  . register row mapper (  constructor mapper . factory (  named parameter bean . cl
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapperTest.java,test constructor properties,"@ test public void   (  )  throws  exception  {  final  constructor properties bean cpi = db rule . get shared handle (  )  . create query ( ""select * from bean"" )  . map to (  constructor properties bean . class )  . find only (  )  ;  assert that ( cpi "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapperTest.java,test duplicate,"@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  execute ( ""select i  s  s from bean"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapperTest.java,test extra,"@ test public void   (  )  throws  exception  {   constructor bean bean = execute ( ""select 1 as ignored  i  s from bean"" )  ;  assert that ( bean . s )  . is equal to ( ""3"" )  ;  assert that ( bean . i )  . is equal to ( 2 )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapperTest.java,test mismatch,"@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  execute ( ""select i  '7' from bean"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapperTest.java,test name,"@ test public void   (  )  throws  exception  {   named parameter bean nb = db rule . get shared handle (  )  . create query ( ""select 3 as xyz"" )  . map to (  named parameter bean . class )  . find only (  )  ;  assert that ( nb . i )  . is equal to ( 3 "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapperTest.java,test reversed,"@ test public void   (  )  throws  exception  {   constructor bean bean = execute ( ""select i  s from bean"" )  ;  assert that ( bean . s )  . is equal to ( ""3"" )  ;  assert that ( bean . i )  . is equal to ( 2 )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\ConstructorMapperTest.java,test simple,"@ test public void   (  )  throws  exception  {   constructor bean bean = execute ( ""select s  i from bean"" )  ;  assert that ( bean . s )  . is equal to ( ""3"" )  ;  assert that ( bean . i )  . is equal to ( 2 )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\SnakeCaseColumnNameMatcherTest.java,test bean numbers,"@ test public void   (  )  {  assert that ( snake . column name matches ( ""test   property   2"" ""test property2"" )  )  . is true (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\SnakeCaseColumnNameMatcherTest.java,test numbers dont match,"@ test public void   (  )  {  assert that ( snake . column name matches ( ""test   property   2"" ""test property3"" )  )  . is false (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\SnakeCaseColumnNameMatcherTest.java,test simple,"@ test public void   (  )  {  assert that ( snake . column name matches ( ""test   property   with   cheese"" ""test property with cheese"" )  )  . is true (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\SnakeCaseColumnNameMatcherTest.java,test without cheese,"@ test public void   (  )  {  assert that ( snake . column name matches ( ""test   property   with   cheese"" ""test property without cheese"" )  )  . is false (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,geti,"@ column name ( ""id"" )  public int   (  )  {  return i ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,get integer value,public  integer   (  )  {  return integer value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,get nested,public  something   (  )  {  return nested ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,gets,public  string   (  )  {  return s ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,mock all nulls result,private void   (  )  throws sql exception  {  when ( result set . was null (  )  )  . then return ( true )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,mock columns,private void   (  string .  .  .  columns )  throws sql exception  {  when ( result set meta data . get column count (  )  )  . then return ( columns . length )  ;  for  ( int i = 0 ;  i  <  columns . length ;  i +  +  )   {  when ( result set meta data . get column label ( i  +  1 )  )  . then return ( columns[i] )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,mock long result,private void   ( long a long )  throws sql exception  {  when ( result set . get long ( 1 )  )  . then return ( a long )  ;  when ( result set . was null (  )  )  . then return ( false )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,seti,public void   ( int i )  {  this . i = i ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,set integer value,public void   (  integer integer value )  {  this . integer value = integer value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,set nested,"@ nested ( ""nested"" )  public void   (  something nested )  {  this . nested = nested ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,sets,"@ column name ( ""name"" )  public void   (  string s )  {  this . s = s ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,set up mocks,@ before public void   (  )  throws sql exception  {  when ( result set . get meta data (  )  )  . then return ( result set meta data )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,should be case in sensitive of column and property names,"@ test public void   (  )  throws  exception  {  mock columns ( "" lo ngfield"" )  ;   long a long val = 100l ;  mock long result ( a long val )  ;   sample bean sample bean = mapper . map ( result set ctx )  ;  assert that ( sample bean . get long field ( "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,should be case in sensitive of column with underscores and property names,"@ test public void   (  )  throws  exception  {  mock columns ( "" lo ng    fi eld"" )  ;   long a long val = 100l ;  mock long result ( a long val )  ;   sample bean sample bean = mapper . map ( result set ctx )  ;  assert that ( sample bean . get long fie"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,should handle colum name with underscores,"@ test public void   (  )  throws  exception  {  mock columns ( ""long   field"" )  ;   long a long val = 100l ;  mock long result ( a long val )  ;   sample bean sample bean = mapper . map ( result set ctx )  ;  assert that ( sample bean . get long field ("
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\FieldMapperTest.java,mock columns,private void   (  string .  .  .  columns )  throws sql exception  {  when ( result set meta data . get column count (  )  )  . then return ( columns . length )  ;  for  ( int i = 0 ;  i  <  columns . length ;  i +  +  )   {  when ( result set meta data . get column label ( i  +  1 )  )  . then return ( columns[i] )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\FieldMapperTest.java,set up mocks,@ before public void   (  )  throws sql exception  {  when ( result set . get meta data (  )  )  . then return ( result set meta data )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\FieldMapperTest.java,should be case in sensitive of column and field names,"@ test public void   (  )  throws  exception  {  mock columns ( "" lo ngfield"" )  ;   long a long val = 100l ;  when ( result set . get long ( 1 )  )  . then return ( a long val )  ;  when ( result set . was null (  )  )  . then return ( false )  ;   sampl"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\FieldMapperTest.java,should handle empty result,@ test public void   (  )  throws  exception  {  mock columns (  )  ;   sample bean sample bean = mapper . map ( result set ctx )  ;  assert that ( sample bean )  . is not null (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\FieldMapperTest.java,should handle null value,"@ test public void   (  )  throws  exception  {  mock columns ( "" lo ngfield"" )  ;  when ( result set . get long ( 1 )  )  . then return ( 0l )  ;  when ( result set . was null (  )  )  . then return ( true )  ;   sample bean sample bean = mapper . map ( "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\FieldMapperTest.java,should not throw on mismatched columns,"@ test public void   (  )  throws  exception  {  mock columns ( ""long field"" ""extra column"" )  ;   long expected = 666l ;  when ( result set . get long ( 1 )  )  . then return ( expected )  ;  when ( result set . get string ( 2 )  )  . then return ( ""foo"""
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\FieldMapperTest.java,should set value on private field,"@ test public void   (  )  throws  exception  {  mock columns ( ""long field"" )  ;   long a long val = 100l ;  when ( result set . get long ( 1 )  )  . then return ( a long val )  ;  when ( result set . was null (  )  )  . then return ( false )  ;   sample"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\FieldMapperTest.java,should set values in super class fields,"@ test public void   (  )  throws  exception  {  mock columns ( ""long field"" ""blong field"" )  ;   long a long val = 100l ;   long b long val = 200l ;  when ( result set . get long ( 1 )  )  . then return ( a long val )  ;  when ( result set . get long ( 2"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\FieldMapperTest.java,should set values on all field access types,"@ test public void   (  )  throws  exception  {  mock columns ( ""long field"" ""protected string field"" ""package private int field"" ""private big decimal field"" )  ;   long a long val = 100l ;   string a string val = ""something"" ;  int a int val = 1 ;   big "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\FieldMapperTest.java,should throw on mismatched columns strict match,"@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  ctx . get config (  reflection mappers . class )  . set strict matching ( true )  ;  mock columns ( ""long field"" ""misspelled field"" )  ;  mapper . map ( r"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\FieldMapperTest.java,should throw on property type without registered mapper,"@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  mock columns ( ""long field"" ""value type field"" )  ;  when ( result set . get long ( 1 )  )  . then return ( 123l )  ;  when ( result set . get object ( 2 "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\FieldMapperTest.java,should throw on total mismatch,"@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  mock columns ( ""something else entirely"" )  ;  mapper . map ( result set ctx )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\FieldMapperTest.java,should use registered mapper for unknown property type,"@ test public void   (  )  throws  exception  {  handle . register column mapper ( new  value type mapper (  )  )  ;  mock columns ( ""long field"" ""value type field"" )  ;  when ( result set . get long ( 1 )  )  . then return ( 123l )  ;  when ( result set "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\FieldMapperTest.java,test column name annotation,"@ test public void   (  )  {   handle handle = db rule . get shared handle (  )  ;  handle . execute ( ""insert into something  ( id  name )  values  ( 1  'foo' ) "" )  ;   column name thing thing = handle . create query ( ""select * from something"" )  . map"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\FieldMapperTest.java,test nested,"@ test public void   (  )  {   handle handle = db rule . get shared handle (  )  ;  handle . execute ( ""insert into something  ( id  name )  values  ( 1  'foo' ) "" )  ;  assert that ( handle . register row mapper (  field mapper . factory (  nested thing "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\FieldMapperTest.java,test nested prefix,"@ test public void   (  )  {   handle handle = db rule . get shared handle (  )  ;  handle . execute ( ""insert into something  ( id  name )  values  ( 1  'foo' ) "" )  ;  assert that ( handle . register row mapper (  field mapper . factory (  nested prefix"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\FieldMapperTest.java,test nested prefix strict,@ test public void   (  )  {   handle handle = db rule . get shared handle (  )  ;  handle . get config (  reflection mappers . class )  . set strict matching ( true )  ;  handle . register row mapper (  field mapper . factory (  nested prefix thing . cla
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\FieldMapperTest.java,test nested strict,@ test public void   (  )  {   handle handle = db rule . get shared handle (  )  ;  handle . get config (  reflection mappers . class )  . set strict matching ( true )  ;  handle . register row mapper (  field mapper . factory (  nested thing . class )  )
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,should handle empty result,@ test public void   (  )  throws  exception  {  mock columns (  )  ;   sample bean sample bean = mapper . map ( result set ctx )  ;  assert that ( sample bean )  . is not null (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,should handle null value,"@ test public void   (  )  throws  exception  {  mock columns ( "" lo ngfield"" )  ;  mock all nulls result (  )  ;   sample bean sample bean = mapper . map ( result set ctx )  ;  assert that ( sample bean . get long field (  )  )  . is null (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,should not throw on mismatched columns,"@ test public void   (  )  throws  exception  {  mock columns ( ""long field"" ""extra column"" )  ;   long expected = 666l ;  when ( result set . get long ( 1 )  )  . then return ( expected )  ;  when ( result set . get string ( 2 )  )  . then return ( ""foo"""
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,should set value on public setter,"@ test public void   (  )  throws  exception  {  mock columns ( ""long field"" )  ;   long a long val = 100l ;  mock long result ( a long val )  ;   sample bean sample bean = mapper . map ( result set ctx )  ;  assert that ( sample bean . get long field (  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,should set values in super class properties,"@ test public void   (  )  throws  exception  {  mock columns ( ""long field"" ""blong field"" )  ;   long a long val = 100l ;   long b long val = 200l ;  when ( result set . get long ( 1 )  )  . then return ( a long val )  ;  when ( result set . get long ( 2"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,should set values on public setter,"@ test public void   (  )  throws  exception  {  mock columns ( ""long field"" )  ;   long expected = 1l ;  mock long result ( expected )  ;   sample bean sample bean = mapper . map ( result set ctx )  ;  assert that ( sample bean . get long field (  )  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,should throw on mismatched columns strict match,"@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  ctx . get config (  reflection mappers . class )  . set strict matching ( true )  ;  mock columns ( ""long field"" ""misspelled field"" )  ;  mapper . map ( r"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,should throw on package private setter,"@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  mock columns ( ""package private int field"" )  ;  when ( result set . get int ( 1 )  )  . then return ( 200 )  ;  when ( result set . was null (  )  )  . t"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,should throw on private setter,"@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  mock columns ( ""private big decimal field"" )  ;  when ( result set . get big decimal ( 1 )  )  . then return (  big decimal . one )  ;  when ( result set "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,should throw on property type without registered mapper,"@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  mock columns ( ""long field"" ""value type field"" )  ;  when ( result set . get long ( 1 )  )  . then return ( 123l )  ;  when ( result set . get object ( 2 "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,should throw on protected setter,"@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  mock columns ( ""protected string field"" )  ;   string expected = ""string"" ;  when ( result set . get string ( 1 )  )  . then return ( expected )  ;  when "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,should throw on total mismatch,"@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  mock columns ( ""something else entirely"" )  ;  mapper . map ( result set ctx )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,should use registered mapper for unknown property type,"@ test public void   (  )  throws  exception  {  handle . register column mapper ( new  value type mapper (  )  )  ;  mock columns ( ""long field"" ""value type field"" )  ;   long expected = 123l ;  when ( result set . get long ( 1 )  )  . then return ( expe"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,test column name annotation,"@ test public void   (  )  {   handle handle = db rule . get shared handle (  )  ;  handle . register row mapper (  bean mapper . factory (  column name bean . class )  )  ;  handle . execute ( ""insert into something  ( id  name )  values  ( 1  'foo' ) "" "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,test nested,"@ test public void   (  )  {   handle handle = db rule . get shared handle (  )  ;  handle . register row mapper (  bean mapper . factory (  nested bean . class )  )  ;  handle . execute ( ""insert into something  ( id  name )  values  ( 1  'foo' ) "" )  ; "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,test nested prefix,"@ test public void   (  )  {   handle handle = db rule . get shared handle (  )  ;  handle . register row mapper (  bean mapper . factory (  nested prefix bean . class )  )  ;  handle . execute ( ""insert into something  ( id  name )  values  ( 1  'foo' ) "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,test nested prefix strict,@ test public void   (  )  {   handle handle = db rule . get shared handle (  )  ;  handle . get config (  reflection mappers . class )  . set strict matching ( true )  ;  handle . register row mapper (  bean mapper . factory (  nested prefix bean . class
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\BeanMapperTest.java,test nested strict,@ test public void   (  )  {   handle handle = db rule . get shared handle (  )  ;  handle . get config (  reflection mappers . class )  . set strict matching ( true )  ;  handle . register row mapper (  bean mapper . factory (  nested bean . class )  )  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\SomethingMapper.java,map,"@ override public  something   (  result set r  statement context ctx )  throws sql exception  {  return new  something ( r . get int ( ""id"" )  r . get string ( ""name"" )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\TestRegisteredMappers.java,set up,@ before public void   (  )  throws  exception  {  db = db rule . get jdbi (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\TestRegisteredMappers.java,test register inferred on jdbi,"@ test public void   (  )  throws  exception  {  db . register row mapper ( new  something mapper (  )  )  ;   something sam = db . with handle ( handle1  -  >   {  handle1 . execute ( ""insert into something  ( id  name )  values  ( 18  ' sam' ) "" )  ;  r"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\DerivedBean.java,get blong field,public  long   (  )  {  return blong field ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\reflect\DerivedBean.java,set blong field,public void   (  long blong field )  {  this . blong field = blong field ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\ValueTypeMapper.java,build,@ override public  optional <  column mapper <  ?  >  >    (  type type  config registry config )  {  return  value type . class . is assignable from ( get erased type ( type )  )   ?   optional . of ( new  value type mapper (  )  )  :  optional . empty (
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\ValueTypeMapper.java,map,@ override public  value type   (  result set r int column number  statement context ctx )  throws sql exception  {  return  value type . value of ( r . get string ( column number )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\TestEnums.java,get id,public int   (  )  {  return id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\TestEnums.java,get name,public  name   (  )  {  return name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\TestEnums.java,set id,public void   ( int id )  {  this . id = id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\TestEnums.java,set name,public void   (  name name )  {  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\TestEnums.java,test enum case insensitive,"@ test public void   (  )  throws  exception  {  assert that ( db rule . get shared handle (  )  . create query ( ""select ' br ian'"" )  . map to (  something else .  name . class )  . find only (  )  )  . is equal to (  something else .  name . brian )  ;"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\TestEnums.java,test map enum values,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  h . create update ( ""insert into something  ( id  name )  v"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\TestEnums.java,test map invalid enum value,"@ test ( expected =  illegal argument exception . class )  public void   (  )  throws sql exception  {   handle h = db rule . open handle (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 1  'joe' ) "" )  . execute (  )  ;  h . c"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\mapper\TestEnums.java,test map to enum,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  h . create update ( ""insert into something  ( id  name )  v"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestReducing.java, something with locations,  (  something something )  {  this . something = something ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestReducing.java,at, something with loc ions at (  string where )  {  locations . add ( where )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestReducing.java,equals,@ override public boolean   (  object other )  {  if  (  !  ( other instanceof  something with locations )  )   {  return false ;   }   something with locations o =  (  something with locations ) other ;  return o . something . equals ( something )  && o 
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestReducing.java,hash code,@ override public int   (  )  {  return something . hash code (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestReducing.java,set up,"@ before public void   (  )  {   handle h = db rule . get shared handle (  )  ;  h . execute ( ""create table something   location  ( id int  location varchar ) "" )  ;  h . execute ( ""insert into something  ( id  name )  values  ( 1  'tree' ) "" )  ;  h . e"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestReducing.java,test collect rows,"@ test public void   (  )  {   iterable <  something with locations >  result = db rule . get shared handle (  )  . create query ( ""select something . id  name  location from something natural join something   location"" )  . collect rows (  collector .  <"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestReducing.java,test reduce result set,"@ test public void   (  )  {   map <  integer  something with locations >  result = db rule . get shared handle (  )  . create query ( ""select something . id  name  location from something natural join something   location"" )  . reduce result set ( new  h"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestIterator.java,do tear down,"@ after public void   (  )  throws  exception  {  assert that ( h . is closed (  )  )  . is true (  )  . with fail message ( "" handle was not closed correctly ! "" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestIterator.java,set up,@ before public void   (  )  throws  exception  {  h = db rule . open handle (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestReducing.java,test reduce rows,"@ test public void   (  )  {   list <  something with locations >  result = db rule . get shared handle (  )  . create query ( ""select something . id  name  location from something natural join something   location"" )  . reduce rows (  (   map <  integer "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestIterator.java,test empty explosion,"@ test ( expected =  no such element exception . class )  public void   (  )  throws  exception  {   result iterator <  map <  string  object >  >  it = h . create query ( ""select * from something order by id"" )  . cleanup handle rollback (  )  . map to m"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestIterator.java,test empty works too,"@ test public void   (  )  throws  exception  {   result iterator <  map <  string  object >  >  it = h . create query ( ""select * from something order by id"" )  . cleanup handle rollback (  )  . map to map (  )  . iterator (  )  ;  assert that ( it . has"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestReducing.java,test reduce rows with seed,"@ test public void   (  )  {   map <  integer  something with locations >  result = db rule . get shared handle (  )  . create query ( ""select something . id  name  location from something natural join something   location"" )  . reduce rows ( new  hash ma"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestReducing.java,to string,"@ override public  string   (  )  {  return  string . format ( "" something %s with locations %s"" something locations )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestIterator.java,test explode iterator,"@ test ( expected =  illegal state exception . class )  public void   (  )  throws  exception  {  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  h . create update ( ""insert into something  ( id  nam"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestIterator.java,test has next,"@ test public void   (  )  throws  exception  {  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  . execute (  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestIterator.java,test just next,"@ test public void   (  )  throws  exception  {  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  . execute (  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestIterator.java,test less leaking just next,"@ test public void   (  )  throws  exception  {  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  . execute (  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestIterator.java,test next,"@ test public void   (  )  throws  exception  {  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  . execute (  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestIterator.java,test non pathological just next,"@ test public void   (  )  throws  exception  {  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  final  map <  string  object >  result = h . create query ( ""select * from something order by id"" )  ."
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestIterator.java,test simple,"@ test public void   (  )  throws  exception  {  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  . execute (  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestIterator.java,test still leaking just next,"@ test public void   (  )  throws  exception  {  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  . execute (  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestIterator.java,test two one,"@ test public void   (  )  throws  exception  {  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  . execute (  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestIterator.java,test two two,"@ test public void   (  )  throws  exception  {  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  . execute (  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestResultBearing.java,add,public static  integer   (  integer u  integer v )  {  return u  +  v ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestResultBearing.java,set up,"@ before public void   (  )  throws  exception  {   handle h = db rule . get shared handle (  )  ;  h . execute ( ""create table reduce  ( u int ) "" )  ;  for  ( int u = 0 ;  u  <  5 ;  u +  +  )   {  h . execute ( ""insert into reduce values  (  ?  ) "" u )"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\result\TestResultBearing.java,test reduce bi function,"@ test public void   (  )  throws  exception  {  assert that ( db rule . get shared handle (  )  . create query ( ""select * from reduce"" )  . map to (  integer . class )  . reduce ( 0  test result bearing::add )  )  . is equal to ( 10 )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\rule\H2DatabaseRule.java,after,@ override protected void   (  )  {  try  {  con . close (  )  ;   }  catch  (  sql exception e )   {  throw new  assertion error ( e )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\rule\H2DatabaseRule.java,before,@ override protected void   (  )  throws  throwable  {  db =  jdbi . create ( uri )  ;  if  ( install plugins )   {  db . install plugins (  )  ;   }  plugins . for each ( db::install plugin )  ;  shared handle = db . open (  )  ;  con = shared handle . g
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\rule\H2DatabaseRule.java,get connection factory,public  connection factory   (  )  {  return  (  )   -  >   driver manager . get connection ( get connection string (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\rule\H2DatabaseRule.java,get connection string,public  string   (  )  {  return uri ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\rule\H2DatabaseRule.java,get jdbi,@ override public  jdbi   (  )  {  return db ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\rule\H2DatabaseRule.java,get shared handle,public  handle   (  )  {  return shared handle ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\rule\H2DatabaseRule.java,open handle,public  handle   (  )  {  return get jdbi (  )  . open (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\rule\H2DatabaseRule.java,with plugin,public h2 database rule   (  jdbi plugin plugin )  {  plugins . add ( plugin )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\rule\H2DatabaseRule.java,with plugins,public h2 database rule   (  )  {  install plugins = true ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\rule\PgDatabaseRule.java,after,@ override protected void   (  )  {  db = null ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\rule\PgDatabaseRule.java,apply,@ override public  statement   (  statement base  description description )  {  if  ( preparer  =  =  null )   {  preparer = new  jdbi preparer .  none (  )  ;   }  inner rule =  embedded postgres rules . prepared database ( preparer )  ;  return inner ru
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\rule\PgDatabaseRule.java,before,@ override protected void   (  )  throws  throwable  {  db =  jdbi . create ( inner rule . get test database (  )  )  ;  plugins . for each ( db::install plugin )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\rule\PgDatabaseRule.java,get jdbi,@ override public  jdbi   (  )  {  return db ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\rule\PgDatabaseRule.java,open handle,public  handle   (  )  {  return get jdbi (  )  . open (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\rule\PgDatabaseRule.java,with plugin,public  pg database rule   (  jdbi plugin plugin )  {  plugins . add ( plugin )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\rule\PgDatabaseRule.java,with preparer,public  pg database rule   (  jdbi preparer preparer )  {  this . preparer = preparer ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\HandyMapThing.java,add,public  handy map thing < k >    ( k k  object v )  {  this . put ( k v )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\StatementContextAccess.java,create context,public static  statement context   (  handle handle )  {  return new  statement context ( handle . get config (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\SampleBean.java,get long field,public  long   (  )  {  return long field ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\SampleBean.java,get package private int field,public int   (  )  {  return package private int field ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\SampleBean.java,get private big decimal field,public  big decimal   (  )  {  return private big decimal field ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\SampleBean.java,get protected string field,public  string   (  )  {  return protected string field ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\SampleBean.java,get value type field,public  value type   (  )  {  return value type field ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\SampleBean.java,set long field,public void   (  long long field )  {  this . long field = long field ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\SampleBean.java,set package private int field,void   ( int package private int field )  {  this . package private int field = package private int field ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\SampleBean.java,set private big decimal field,"@ suppress warnings ( ""unused"" )  private void   (  big decimal private big decimal field )  {  this . private big decimal field = private big decimal field ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\SampleBean.java,set protected string field,protected void   (  string protected string field )  {  this . protected string field = protected string field ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\SampleBean.java,set value type field,public void   (  value type value type field )  {  this . value type field = value type field ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\Something.java, something,public   ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\Something.java,equals,@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  (  !  ( o instanceof  something )  )  return false ;   something that =  (  something ) o ;  return this . id  =  =  that . id && this . int value  =  =  that . int va
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\Something.java,get id,public int   (  )  {  return id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\Something.java,get int value,public int   (  )  {  return int value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\Something.java,get integer value,public  integer   (  )  {  return integer value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\Something.java,get name,public  string   (  )  {  return name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\Something.java,hash code,@ override public int   (  )  {  return  objects . hash ( id name integer value int value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\Something.java,set id,public void   ( int id )  {  this . id = id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\Something.java,set int value,public void   ( int int value )  {  this . int value = int value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\Something.java,set integer value,public void   (  integer integer value )  {  this . integer value = integer value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\Something.java,set name,public void   (  string name )  {  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\Something.java,set without getter,public void   (  string bogus )  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\Something.java,to string,"@ override public  string   (  )  {  return "" something { ""  +  ""id = ""  +  id  +  ""  name = '"" +  name +  '\'' +  ""  integer value = "" +  integer value +  ""  int value = "" +  int value +  ' } ' ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBatch.java,test basics,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   batch b = h . create batch (  )  ;  b . add ( ""insert into something  ( id  name )  values  ( 0  ' keith' ) "" )  ;  b . add ( ""insert into something  ( id  name )"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBatch.java,test empty batch throws,"@ test ( expected =  illegal state exception . class )  public void   (  )  throws  exception  {  try  (  handle h = db rule . open handle (  )  )  {  final  prepared batch b = h . prepare batch ( ""insert into something  ( id  name )  values  (  ?    ?  )"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBatchExceptionRewrite.java,assert suppressions,"private void   (  throwable cause )  {   logger factory . get logger (  test batch exception rewrite . class )  . info ( ""exception"" cause )  ;  sql exception e =  ( sql exception ) cause ;  sql exception next exception = e . get next exception (  )  ;  assert that (  (  exception ) next exception )  . is equal to ( e . get suppressed (  ) [0] )  ;  assert that (  (  exception ) next exception . get next exception (  )  )  . is null (  )  ;  assert that ( e . get suppressed (  )  )  . has size ( 1 )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBatchExceptionRewrite.java,create table,"@ before public void   (  )  {  db rule . get jdbi (  )  . use handle ( h  -  >  h . execute ( ""create table something  (  id int primary key  name varchar ( 50 )   integer value integer  int value integer  ) "" )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBatchExceptionRewrite.java,test prepared batch,"@ test public void   (  )  throws  exception  {   prepared batch b = db rule . open handle (  )  . prepare batch ( ""insert into something  ( id  name )  values  (  ?   ?  ) "" )  ;  b . add ( 0 ""a"" )  ;  b . add ( 0 ""a"" )  ;  assert that exception of type "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBatchExceptionRewrite.java,test simple batch,"@ test public void   (  )  throws  exception  {   batch b = db rule . open handle (  )  . create batch (  )  ;  b . add ( ""insert into something  ( id  name )  values  ( 0  ' keith' ) "" )  ;  b . add ( ""insert into something  ( id  name )  values  ( 0  ' "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\StatementContextTest.java,map,@ override public  foo   (  result set r int column number  statement context ctx )  throws sql exception  {  return null ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\StatementContextTest.java,test mapper for delegates to registry,@ test public void   (  )  {   column mapper <  foo >  mapper = new  foo mapper (  )  ;   config registry config = new  config registry (  )  ;  config . get (  column mappers . class )  . register ( mapper )  ;  final  statement context context =  statem
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\StatementContextTest.java,test should not be able to combine concurrent updatable and generated keys,@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  final  statement context context =  statement context access . create context (  )  ;  context . set concurrent updatable ( true )  ;  context . set retur
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\StatementContextTest.java,test should not be able to combine generated keys and concurrent updatable,@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  final  statement context context =  statement context access . create context (  )  ;  context . set returning generated keys ( true )  ;  context . set c
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBindBeanList.java, thing key,public   (  string foo  string bar )  {  this . foo = foo ;  this . bar = bar ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBindBeanList.java,bind bean list with no properties,"@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {   thing key thing key = new  thing key ( ""a"" ""b"" )  ;  handle . create query ( ""select id  foo from thing where  ( foo  bar )  in  (  < keys >  ) "" )  . bi"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBindBeanList.java,bind bean list with no values,"@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  handle . create query ( ""select id  foo from thing where  ( foo  bar )  in  (  < keys >  ) "" )  . bind bean list ( ""keys""  collections . empty list (  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBindBeanList.java,get bar,public  string   (  )  {  return bar ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBindBeanList.java,get baz,public  string   (  )  {  return baz ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBindBeanList.java,get foo,public  string   (  )  {  return foo ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBindBeanList.java,get id,public int   (  )  {  return id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBindBeanList.java,happy path,"@ test public void   (  )  {   thing key thing1 key = new  thing key ( ""foo1"" ""bar1"" )  ;   thing key thing3 key = new  thing key ( ""foo3"" ""bar3"" )  ;   list <  thing >  list = handle . create query ( ""select id  foo from thing where  ( foo  bar )  in  ( "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBindBeanList.java,set up,"@ before public void   (  )  {  handle = db rule . get shared handle (  )  ;  handle . register row mapper (  field mapper . factory (  thing . class )  )  ;  handle . execute ( ""create table thing  ( id identity primary key  foo varchar ( 50 )   bar varc"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestCallable.java,set up,"@ before public void   (  )  throws  exception  {  h = db rule . get jdbi (  )  . open (  )  ;  h . execute ( ""create alias to   degrees for \""java . lang .  math . to degrees\"""" )  ;  h . execute ( ""create alias test   procedure for \""org . jdbi . v3 . c"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestCallable.java,test procedure,public static void   (  string in  string[] out )  {  out = new  string[1] ;  out[0] = in ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestCallable.java,test statement,"@ test public void   (  )  throws  exception  {   out parameters ret = h . create call ( "" ?   =  call to   degrees (  ?  ) "" )  . register out parameter ( 0  types . double )  . bind ( 1 100 . 0d )  . invoke (  )  ;   double expected =  math . to degrees"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestCallable.java,test statement with named param,"@ test public void   (  )  throws  exception  {   out parameters ret = h . create call ( "":x  =  call to   degrees ( :y ) "" )  . register out parameter ( ""x""  types . double )  . bind ( ""y"" 100 . 0d )  . invoke (  )  ;   double expected =  math . to degre"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestCallable.java,test with null return,"@ test @ ignore public void   (  )  throws  exception  {   out parameters ret = h . create call ( ""call test   procedure (  ?    ?  ) "" )  . bind ( 0  (  string ) null )  . register out parameter ( 1  types . varchar )  . invoke (  )  ;   string out = ret"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestCallable.java,test with null return with named param,"@ test @ ignore public void   (  )  throws  exception  {   out parameters ret = h . create call ( ""call test   procedure ( :x  :y ) "" )  . bind ( ""x""  (  string ) null )  . register out parameter ( ""y""  types . varchar )  . invoke (  )  ;   string out = r"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBindList.java,get bar,public  string   (  )  {  return bar ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBindList.java,get baz,public  string   (  )  {  return baz ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBindList.java,get foo,public  string   (  )  {  return foo ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBindList.java,get id,public int   (  )  {  return id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBindList.java,set up,"@ before public void   (  )  {  handle = db rule . get shared handle (  )  ;  handle . register row mapper (  field mapper . factory (  thing . class )  )  ;  handle . execute ( ""create table thing  ( id identity primary key  foo varchar ( 50 )   bar varc"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBindList.java,test bind list,"@ test public void   (  )  {  handle . create update ( ""insert into thing  (  < columns >  )  values  (  < values >  ) "" )  . define list ( ""columns"" ""id"" ""foo"" )  . bind list ( ""values"" 3 ""abc"" )  . execute (  )  ;   list <  thing >  list = handle . crea"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestBindList.java,test bind list with hash prefix parser,@ test public void   (  )  throws  exception  {   jdbi jdbi =  jdbi . create ( db rule . get connection factory (  )  )  ;  jdbi . set sql parser ( new  hash prefix sql parser (  )  )  ;  jdbi . use handle ( handle  -  >   {  handle . register row mapper 
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestDefineList.java,get bar,public  string   (  )  {  return bar ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestDefineList.java,get baz,public  string   (  )  {  return baz ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestDefineList.java,get foo,public  string   (  )  {  return foo ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestDefineList.java,get id,public int   (  )  {  return id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestDefineList.java,set up,"@ before public void   (  )  throws  exception  {  handle = db rule . get shared handle (  )  ;  handle . execute ( ""create table thing  ( id identity primary key  foo varchar ( 50 )   bar varchar ( 50 )   baz varchar ( 50 )  ) "" )  ;  handle . execute ( "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestDefineList.java,test define list select,"@ test public void   (  )  throws  exception  {  list = handle . create query ( ""select  < columns >  from thing order by id"" )  . define list ( ""columns""  arrays . as list ( ""id"" ""foo"" ""bar"" )  )  . map to (  thing . class )  . list (  )  ;  assert that "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestColonPrefixTemplateEngine.java,render,private  string   (  string sql  map <  string  object >  attributes )  {  attributes . for each (  ( key value )   -  >  when ( ctx . get attribute ( key )  )  . then return ( value )  )  ;  return template engine . render ( sql ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestColonPrefixTemplateEngine.java,set up,@ before public void   (  )  throws  exception  {  template engine = new  defined attribute template engine (  )  ;  parser = new  colon prefix sql parser (  )  ;  ctx = mock (  statement context . class )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestColonPrefixTemplateEngine.java,test backtick okay,"@ test public void   (  )  throws  exception  {   parsed sql parsed = parser . parse ( ""select * from `v$session"" ctx )  ;  assert that ( parsed . get sql (  )  )  . is equal to ( ""select * from `v$session"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestColonPrefixTemplateEngine.java,test bails out on invalid input,"@ test ( expected =  unable to create statement exception . class )  public void   (  )  throws  exception  {  render ( ""select * from something\n where id  =  :\u0087\u008e\u0092\u0097\u009c"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestColonPrefixTemplateEngine.java,test caches rewritten statements,"@ test public void   (  )  throws  exception  {  parser = spy ( parser )  ;   string sql = ""insert into something  ( id  name )  values  ( :id  :name ) "" ;   parsed sql parsed = parser . parse ( sql ctx )  ;  assert that ( parsed )  . is same as ( parser "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestColonPrefixTemplateEngine.java,test colon in comment,"@ test public void   (  )  throws  exception  {   string sql = "" / * comment with : colons :: inside it * /  select 1"" ;  assert that ( render ( sql )  )  . is equal to ( sql )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestColonPrefixTemplateEngine.java,test comment quote,"@ test public void   (  )  throws  exception  {   string sql = ""select 1  / * ' \""  < foo >  * / "" ;  assert that ( render ( sql )  )  . is equal to ( sql )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestColonPrefixTemplateEngine.java,test dollar sign okay,"@ test public void   (  )  throws  exception  {   parsed sql parsed = parser . parse ( ""select * from v$session"" ctx )  ;  assert that ( parsed . get sql (  )  )  . is equal to ( ""select * from v$session"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestColonPrefixTemplateEngine.java,test double colon,"@ test public void   (  )  throws  exception  {  final  string double colon = ""select 1::int"" ;   parsed sql parsed = parser . parse ( double colon ctx )  ;  assert that ( parsed . get sql (  )  )  . is equal to ( double colon )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestColonPrefixTemplateEngine.java,test hash in column name okay,"@ test public void   (  )  throws  exception  {   parsed sql parsed = parser . parse ( ""select column# from thetable where id  =  :id"" ctx )  ;  assert that ( parsed . get sql (  )  )  . is equal to ( ""select column# from thetable where id  =   ? "" )  ;  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestColonPrefixTemplateEngine.java,test ignore angle brackets not part of token,"@ test public void   (  )  throws  exception  {   string sql = ""select * from foo where end   date  <   ?  and start   date  >   ? "" ;  assert that ( render ( sql )  )  . is equal to ( sql )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestColonPrefixTemplateEngine.java,test leave enquoted tokens intact,"@ test public void   (  )  throws  exception  {   string sql = ""select ' < foo > ' foo  \"" < bar > \"" bar from something"" ;  assert that ( render ( sql  immutable map . of ( ""foo"" ""no"" ""bar"" ""stahp"" )  )  )  . is equal to ( sql )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestColonPrefixTemplateEngine.java,test newlines okay,"@ test public void   (  )  throws  exception  {   parsed sql parsed = parser . parse ( ""select * from something\n where id  =  :id"" ctx )  ;  assert that ( parsed . get sql (  )  )  . is equal to ( ""select * from something\n where id  =   ? "" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestColonPrefixTemplateEngine.java,test numbers,"@ test public void   (  )  throws  exception  {   parsed sql parsed = parser . parse ( "":bo0 ':nope'    %&^& *@ :id"" ctx )  ;  assert that ( parsed . get sql (  )  )  . is equal to ( "" ?  ':nope'    %&^& *@  ? "" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestColonPrefixTemplateEngine.java,test odd characters,"@ test public void   (  )  throws  exception  {   parsed sql parsed = parser . parse ( ""~* :boo ':nope'    %&^& *@ :id"" ctx )  ;  assert that ( parsed . get sql (  )  )  . is equal to ( ""~*  ?  ':nope'    %&^& *@  ? "" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestColonPrefixTemplateEngine.java,test substitutes defined attributes,"@ test public void   (  )  throws  exception  {   map <  string  object >  attributes =  immutable map . of ( ""column"" ""foo"" ""table"" ""bar"" )  ;   string rendered = render ( ""select  < column >  from  < table >  where  < column >   =  :some value"" attribut"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestColonPrefixTemplateEngine.java,test undefined attribute,"@ test ( expected =  unable to create statement exception . class )  public void   (  )  throws  exception  {  render ( ""select * from  < table > ""  collections . empty map (  )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestEscapedCharacters.java,parse string,private  string   ( final  string src )  {  return parser . parse ( src mock (  statement context . class )  )  . get sql (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestEscapedCharacters.java,test escaped sql,"@ test public void   (  )  {  assert that ( parse string ( ""insert into foo  ( xyz )  values  ( :bar\\:\\:some   strange   type ) "" )  )  . is equal to ( ""insert into foo  ( xyz )  values  (  ? ::some   strange   type ) "" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestEscapedCharacters.java,test simple sql,"@ test public void   (  )  {  assert that ( parse string ( ""insert into foo  ( xyz )  values  ( :bar ) "" )  )  . is equal to ( ""insert into foo  ( xyz )  values  (  ?  ) "" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestEscapedCharacters.java,test simple string,"@ test public void   (  )  {  assert that ( parse string ( ""hello  world"" )  )  . is equal to ( ""hello  world"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPositionalParameterBinding.java,set up,@ before public void   (  )  throws  exception  {  h = db rule . open handle (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPositionalParameterBinding.java,test behavior on bad binding,"@ test ( expected =  unable to execute statement exception . class )  public void   (  )  throws  exception  {  h . create query ( ""select * from something where id  =   ?  and name  =   ? "" )  . bind ( 0 1 )  . map to bean (  something . class )  . list "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPositionalParameterBinding.java,test behavior on bad binding,"@ test ( expected =  unable to execute statement exception . class )  public void   (  )  throws  exception  {  h . create query ( ""select * from something where id  =   ? "" )  . bind ( 1 1 )  . bind ( 2 "" hi"" )  . map to bean (  something . class )  . li"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPositionalParameterBinding.java,test insert param binding,"@ test public void   (  )  throws  exception  {  int count = h . create update ( ""insert into something  ( id  name )  values  (  ?   'eric' ) "" )  . bind ( 0 1 )  . execute (  )  ;  assert that ( count )  . is equal to ( 1 )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPositionalParameterBinding.java,test positional convenience insert,"@ test public void   (  )  throws  exception  {  int count = h . execute ( ""insert into something  ( id  name )  values  (  ?    ?  ) "" 1 ""eric"" )  ;  assert that ( count )  . is equal to ( 1 )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPositionalParameterBinding.java,test set positional integer,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  ;  h . execute ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  ;   something eric = h . create query ( ""sel"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPositionalParameterBinding.java,test set positional string,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  ;  h . execute ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  ;   something eric = h . create query ( ""sel"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestMessageFormatTemplateEngine.java,set up,@ before public void   (  )  {  template engine =  message format template engine . instance ;  attributes = new  hash map <  >  (  )  ;  ctx = mock (  statement context . class )  ;  when ( ctx . get attributes (  )  )  . then return ( attributes )  ;   
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestMessageFormatTemplateEngine.java,test blank key,"@ test public void   (  )  {  attributes . put ( "" "" ""hello"" )  ;  assert that thrown by (  (  )   -  >  template engine . render ( "" { 0 }  bar"" ctx )  )  . is instance of (  illegal argument exception . class )  . has message containing ( ""\"" \"""" )  ;  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestMessageFormatTemplateEngine.java,test duplicate key,"@ test public void   (  )  {  attributes . put ( ""0"" ""hello"" )  ;  attributes . put ( ""00"" ""world"" )  ;  assert that thrown by (  (  )   -  >  template engine . render ( "" { 0 }   { 1 } "" ctx )  )  . is instance of (  illegal argument exception . class ) "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestMessageFormatTemplateEngine.java,test many values,"@ test public void   (  )  {  attributes . put ( ""000"" ""a"" )  ;  attributes . put ( ""001"" ""b"" )  ;  attributes . put ( ""002"" ""c"" )  ;  attributes . put ( ""003"" ""d"" )  ;  attributes . put ( ""004"" ""e"" )  ;  attributes . put ( ""005"" ""f"" )  ;  attributes . pu"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestMessageFormatTemplateEngine.java,test negative key,"@ test public void   (  )  {  attributes . put ( "" - 1"" ""hello"" )  ;  assert that thrown by (  (  )   -  >  template engine . render ( "" { 0 }  bar"" ctx )  )  . is instance of (  illegal argument exception . class )  . has message containing ( ""must be 0"""
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestMessageFormatTemplateEngine.java,test no placeholders but with values,"@ test public void   (  )  {  attributes . put ( ""0"" ""hello"" )  ;  assert that thrown by (  (  )   -  >  template engine . render ( ""foo bar"" ctx )  )  . is instance of (  illegal argument exception . class )  . has message containing ( ""expected 0 keys b"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestMessageFormatTemplateEngine.java,test no placeholders no values,"@ test public void   (  )  {  attributes . clear (  )  ;  assert that ( template engine . render ( ""foo bar"" ctx )  )  . is equal to ( ""foo bar"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestMessageFormatTemplateEngine.java,test non numeric key,"@ test public void   (  )  {  attributes . put ( ""abc"" ""hello"" )  ;  assert that thrown by (  (  )   -  >  template engine . render ( "" { 0 }  bar"" ctx )  )  . is instance of (  illegal argument exception . class )  . has message containing ( ""\""abc\"""" ) "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestMessageFormatTemplateEngine.java,test skipped key,"@ test public void   (  )  {  attributes . put ( ""0"" ""hello"" )  ;  attributes . put ( ""2"" ""world"" )  ;  assert that thrown by (  (  )   -  >  template engine . render ( "" { 0 }   { 1 } "" ctx )  )  . is instance of (  illegal argument exception . class )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestMessageFormatTemplateEngine.java,test whitespace in key,"@ test public void   (  )  {  attributes . put ( "" 1 "" ""hello"" )  ;  assert that thrown by (  (  )   -  >  template engine . render ( "" { 0 }  bar"" ctx )  )  . is instance of (  illegal argument exception . class )  . has message containing ( ""\"" 1 \"""" ) "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestMessageFormatTemplateEngine.java,test with placeholders and values,"@ test public void   (  )  {  attributes . put ( ""02"" "" ! "" )  ;  attributes . put ( ""000"" ""hello"" )  ;  attributes . put ( ""01"" ""world"" )  ;  assert that ( template engine . render ( "" { 0 }   { 1 }  { 2 } "" ctx )  )  . is equal to ( ""hello world ! "" )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestMessageFormatTemplateEngine.java,test with placeholders but no values,"@ test public void   (  )  {  attributes . clear (  )  ;  assert that thrown by (  (  )   -  >  template engine . render ( "" { 0 }  bar"" ctx )  )  . is instance of (  illegal argument exception . class )  . has message containing ( ""expected 1 keys but go"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatch.java, public something,"@ constructor properties (  { ""id"" ""name"" }  )  public   (  integer id  string name )  {  this . id = id ;  this . name = name ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatch.java,close handle,@ after public void   (  )  {  h . close (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatch.java,open handle,@ before public void   (  )  {  h = db rule . open handle (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatch.java,test bigish batch,"@ test public void   (  )  throws  exception  {   prepared batch b = h . prepare batch ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  ;  int count = 100 ;  for  ( int i = 0 ;  i  <  count ;   +  + i )   {  b . bind ( ""id"" i )  . bind "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatch.java,test bind batch,"@ test public void   (  )  throws  exception  {   prepared batch b = h . prepare batch ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  ;  b . bind ( ""id"" 1 )  . bind ( ""name"" "" eric"" )  . add (  )  ;  b . bind ( ""id"" 2 )  . bind ( ""nam"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatch.java,test bind maps,"@ test public void   (  )  throws  exception  {   prepared batch b = h . prepare batch ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  ;  b . add (  immutable map . of ( ""id"" 0 ""name"" "" keith"" )  )  ;  b . add (  immutable map . of ( """
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatch.java,test bind properties,"@ test public void   (  )  throws  exception  {   prepared batch b = h . prepare batch ( ""insert into something  ( id  name )  values  (  ?    ?  ) "" )  ;  b . add ( 0 "" keith"" )  ;  b . add ( 1 "" eric"" )  ;  b . add ( 2 "" brian"" )  ;  b . execute (  )  ;"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatch.java,test context gets binding,"@ test public void   (  )  throws  exception  {  try  {  h . prepare batch ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  . bind ( ""id"" 0 )  . bind ( ""name"" ""alice"" )  . add (  )  . bind ( ""id"" 0 )  . bind ( ""name"" ""bob"" )  . add (  )"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatch.java,test forgot final add,"@ test public void   (  )  throws  exception  {   prepared batch b = h . prepare batch ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  ;  b . bind ( ""id"" 1 )  ;  b . bind ( ""name"" "" jeff"" )  ;  b . add (  )  ;  b . bind ( ""id"" 2 )  ;  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatch.java,test mixed mode batch,"@ test public void   (  )  throws  exception  {   prepared batch b = h . prepare batch ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  ;   map <  string  object >  one =  immutable map . of ( ""id"" 0 )  ;  b . bind ( ""name"" "" keith"" )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatch.java,test multiple execute bind,"@ test public void   (  )  {  final  prepared batch b = h . prepare batch ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  ;  b . bind ( ""id"" 1 )  . bind ( ""name"" "" eric"" )  . add (  )  ;  b . bind ( ""id"" 2 )  . bind ( ""name"" "" brian"" )"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatch.java,test multiple execute bind bean,"@ test public void   (  )  {  final  prepared batch b = h . prepare batch ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  ;  b . bind bean ( new  something ( 1 "" eric"" )  )  . add (  )  ;  b . bind bean ( new  something ( 2 "" brian"" ) "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatch.java,test multiple execute bind fields,"@ test public void   (  )  {  h . register row mapper (  constructor mapper . factory (  public something . class )  )  ;  final  prepared batch b = h . prepare batch ( ""insert into something  ( id  name )  values  ( :id  :name ) "" )  ;  b . bind fields ("
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatch.java,test positional binding,"@ test public void   (  )  throws  exception  {   prepared batch b = h . prepare batch ( ""insert into something  ( id  name )  values  (  ?    ?  ) "" )  ;  b . bind ( 0 0 )  . bind ( 1 "" keith"" )  . add (  )  . execute (  )  ;   list <  something >  r = h"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatchGenerateKeysPostgres.java, id create time,public   (  integer id  date create time )  {  this . id = id ;  this . create time = create time ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatchGenerateKeysPostgres.java,close,@ after public void   (  )  {  h . close (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatchGenerateKeysPostgres.java,get handle,@ before public void   (  )  {  h = db rule . get jdbi (  )  . open (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatchGenerateKeysPostgres.java,prepare,"@ override protected void   (  handle handle )  {  handle . execute ( ""create table something  ( id serial  name varchar ( 50 )   create   time timestamp default now (  )  ) "" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatchGenerateKeysPostgres.java,test batch insert with key generation and explicit column names,"@ test public void   (  )  {   prepared batch batch = h . prepare batch ( ""insert into something  ( name )  values  (  ?  )  "" )  ;  batch . add ( "" brian"" )  ;  batch . add ( "" thom"" )  ;   list <  integer >  ids = batch . execute and return generated ke"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatchGenerateKeysPostgres.java,test batch insert with key generation and explicit several column names,"@ test public void   (  )  {   prepared batch batch = h . prepare batch ( ""insert into something  ( name )  values  (  ?  )  "" )  ;  batch . add ( "" brian"" )  ;  batch . add ( "" thom"" )  ;   list <  id create time >  ids = batch . execute and return gener"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestPreparedBatchGenerateKeys.java,test batch insert with key generation,"@ test public void   (  )  throws  exception  {   jdbi db =  jdbi . create ( ""jdbc:hsqldb:mem:jdbi - batch - keys - test"" ""sa"" """" )  ;  try  (  handle h = db . open (  )  )  {  h . execute ( ""create table something  ( id integer not null generated by defa"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,do tear down,@ after public void   (  )  throws  exception  {  if  ( h  !  =  null )  h . close (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,set up,@ before public void   (  )  throws  exception  {  h = db rule . open handle (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test collect list,"@ test public void   (  )  throws  exception  {  h . prepare batch ( ""insert into something  ( id  name )  values  (  ?    ?  ) "" )  . add ( 1 "" brian"" )  . add ( 2 "" keith"" )  . execute (  )  ;   list <  string >  rs = h . create query ( ""select name fro"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test convenience method,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  ;  h . execute ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  ;   list <  map <  string  object >  >  r = "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test convenience method with param,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  ;  h . execute ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  ;   list <  map <  string  object >  >  r = "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test create query object,"@ test public void   (  )  throws  exception  {  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  . execute (  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test fetch size,"@ test public void   (  )  throws  exception  {  h . create script ( find sql on classpath ( ""default - data"" )  )  . execute (  )  ;   result iterable <  something >  ri = h . create query ( ""select id  name from something order by id"" )  . set fetch siz"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test first result,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  ;  h . execute ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  ;   something r = h . create query ( ""select"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test first with no result,"@ test public void   (  )  throws  exception  {   optional <  something >  s = h . create query ( ""select id  name from something"" )  . map to bean (  something . class )  . find first (  )  ;  assert that ( s . is present (  )  )  . is false (  )  ;   } "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test fold,"@ test public void   (  )  throws  exception  {  h . prepare batch ( ""insert into something  ( id  name )  values  (  ?    ?  ) "" )  . add ( 1 "" brian"" )  . add ( 2 "" keith"" )  . execute (  )  ;   map <  string  integer >  rs = h . create query ( ""select "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test helpful error on nothing set,"@ test ( expected =  unable to execute statement exception . class )  public void   (  )  throws  exception  {  h . create query ( ""select * from something where name  =  :name"" )  . map to map (  )  . list (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test iterated result,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  ;  h . execute ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  ;  try  (  result iterator <  something >  i"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test iterator behavior,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  ;  h . execute ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  ;  try  (  result iterator <  something >  i"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test iterator behavior,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  ;  h . execute ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  ;  try  (  result iterator <  something >  i"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test iterator behavior,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  ;  h . execute ( ""insert into something  ( id  name )  values  ( 2  'eric' ) "" )  ;  assert that ( h . create query ( ""select *"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test list with max rows,"@ test public void   (  )  throws  exception  {  h . prepare batch ( ""insert into something  ( id  name )  values  (  ?    ?  ) "" )  . add ( 1 "" brian"" )  . add ( 2 "" keith"" )  . add ( 3 "" eric"" )  . execute (  )  ;  assert that ( h . create query ( ""sele"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test map mapper ordering,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  (  ?    ?  ) "" 1 ""hello"" )  ;  h . execute ( ""insert into something  ( id  name )  values  (  ?    ?  ) "" 2 ""world"" )  ;   list <  map <  string  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test mapped query object,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  ;  h . execute ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  ;   result iterable <  something >  query = "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test mapped query object with null for primitive int field,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name  int value )  values  ( 1  'eric'  null ) "" )  ;   result iterable <  something >  query = h . create query ( ""select * from something order by id"" )  . map "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test mapped query object with nulls,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name  integer value )  values  ( 1  'eric'  null ) "" )  ;   result iterable <  something >  query = h . create query ( ""select * from something order by id"" )  . "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test mapper,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  ;  h . execute ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  ;   result iterable <  string >  query = h ."
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test mixed setting,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  ;  h . execute ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  ;  assert that thrown by (  (  )   -  >  h ."
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test null value in column,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  (  ?    ?  ) "" 1 null )  ;   optional <  string >  s = h . create query ( ""select name from something where id = 1"" )  . map to (  string . class "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test positional arg with named param,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  ;  h . execute ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  ;  assert that thrown by (  (  )   -  >  h ."
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test queries with null result sets,"@ test public void   (  )  throws  exception  {  expected exception . expect (  no results exception . class )  ;  h . select ( ""insert into something  ( id  name )  values  (  ?    ?  ) "" 1 ""hello"" )  . map to map (  )  . list (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test statement customizers persist after map,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  (  ?    ?  ) "" 1 ""hello"" )  ;  h . execute ( ""insert into something  ( id  name )  values  (  ?    ?  ) "" 2 ""world"" )  ;   list <  something >  rs"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestQueries.java,test useful argument output for debug,"@ test public void   (  )  throws  exception  {  expected exception . expect (  statement exception . class )  ;  expected exception . expect message ( ""arguments: {  positional: { 7:8 }   named: { name:brian }   finder:[ { one = two }   { lazy bean prope"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestStatementContext.java,test foo,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  final int inserted = h . create update ( ""insert into  < table >   ( id  name )  values  ( :id  :name ) "" )  . bind ( ""id"" 7 )  . bind ( ""name"" "" martin"" )  . defi"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestStatementExceptionContext.java,test foo,"@ test public void   (  )  throws  exception  {  assert that exception of type (  statement exception . class )  . is thrown by (  (  )   -  >  db rule . open handle (  )  . execute ( ""woof"" 7 "" tom"" )  )  . satisfies ( e  -  >  assert that ( e . get stat"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestScript.java,test fuzzy script,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   script script = h . create script ( get resource on classpath ( ""script / fuzzy - script . sql"" )  )  ;  script . execute as separate statements (  )  ;   list < "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestScript.java,test script as set of separate statements,@ test public void   (  )  throws  exception  {  assert that exception of type (  statement exception . class )  . is thrown by (  (  )   -  >   {   handle h = db rule . open handle (  )  ;   script script = h . create script ( get resource on classpath (
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestScript.java,test script stuff,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   script s = h . create script ( find sql on classpath ( ""default - data"" )  )  ;  s . execute (  )  ;  assert that ( h . select ( ""select * from something"" )  . ma"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestScript.java,test script with comments,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   script script = h . create script ( get resource on classpath ( ""script / insert - script - with - comments . sql"" )  )  ;  script . execute (  )  ;  assert that "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestScript.java,test script with string semicolon,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   script script = h . create script ( get resource on classpath ( ""script / insert - with - string - semicolons . sql"" )  )  ;  script . execute (  )  ;  assert tha"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestStatements.java,do tear down,@ after public void   (  )  throws  exception  {  if  ( h  !  =  null )  h . close (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestStatements.java,set up,@ before public void   (  )  throws  exception  {  h = db rule . open handle (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestStatements.java,test simple insert,"@ test public void   (  )  throws  exception  {  int c = h . execute ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  ;  assert that ( c )  . is equal to ( 1 )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestStatements.java,test simple update,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  ;  h . execute ( ""update something set name  =  'cire' where id  =  1"" )  ;   something eric = h . create query ( ""select * fro"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestStatements.java,test statement,"@ test public void   (  )  throws  exception  {  int rows = h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  assert that ( rows )  . is equal to ( 1 )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestStatements.java,test statement with optional results,"@ test public void   (  )  throws  exception  {  h . get config (  result producers . class )  . allow no results ( true )  ;  assert that ( h . create query ( ""commit"" )  . map to (  integer . class )  . find first (  )  )  . is empty (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestStatements.java,test statement with required results,"@ test ( expected =  no results exception . class )  public void   (  )  throws  exception  {  assert that ( h . create query ( ""commit"" )  . map to (  integer . class )  . find first (  )  )  . is empty (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestStatements.java,test update,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  ;  h . create update ( ""update something set name  =  'eric' where id  =  1"" )  . execute (  )  ;   something eric = h . create"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestUpdateGeneratedKeys.java,set up,"@ before public void   (  )  throws  exception  {  try  ( final  connection conn = db rule . get connection factory (  )  . open connection (  )  ; final  statement create = conn . create statement (  )  )  {  create . execute ( ""create table something   "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestUpdateGeneratedKeys.java,test delete,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   update insert = h . create update ( ""insert into something   else  ( name )  values  ( :name ) "" )  ;  insert . bind ( ""name"" "" brian"" )  ;   long id1 = insert . "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestUpdateGeneratedKeys.java,test insert,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   update insert1 = h . create update ( ""insert into something   else  ( name )  values  ( :name ) "" )  ;  insert1 . bind ( ""name"" "" brian"" )  ;   long id1 = insert1"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestUpdateGeneratedKeys.java,test update,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   update insert = h . create update ( ""insert into something   else  ( name )  values  ( :name ) "" )  ;  insert . bind ( ""name"" "" brian"" )  ;   long id1 = insert . "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestTimingCollector.java,collect,@ override public synchronized void   ( final long elapsed time final  statement context ctx )  {  raw statements . add ( ctx . get raw sql (  )  )  ;  rendered statements . add ( ctx . get rendered sql (  )  )  ;  parsed statements . add ( ctx . get pars
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestTimingCollector.java,do tear down,@ after public void   (  )  throws  exception  {  if  ( h  !  =  null )  h . close (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestTimingCollector.java,get parsed statements,public synchronized  list <  parsed sql >    (  )  {  return parsed statements ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestTimingCollector.java,get raw statements,public synchronized  list <  string >    (  )  {  return raw statements ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestTimingCollector.java,get rendered statements,public  list <  string >    (  )  {  return rendered statements ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestTimingCollector.java,open handle,protected  handle   (  )  throws sql exception  {  tc = new ttc (  )  ;  db rule . get jdbi (  )  . get config (  sql statements . class )  . set timing collector ( tc )  ;  return db rule . get jdbi (  )  . open (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestTimingCollector.java,set up,@ before public void   (  )  throws  exception  {  h = open handle (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestTimingCollector.java,test batch,"@ test public void   (  )  {   string insert = ""insert into something  ( id  name )  values  ( :id  :name ) "" ;  h . prepare batch ( insert )  . bind ( ""id"" 1 )  . bind ( ""name"" "" eric"" )  . add (  )  . bind ( ""id"" 2 )  . bind ( ""name"" "" brian"" )  . add ("
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestTimingCollector.java,test insert,"@ test public void   (  )  throws  exception  {   string statement = ""insert into something  ( id  name )  values  ( 1  'eric' ) "" ;  int c = h . execute ( statement )  ;  assert that ( c )  . is equal to ( 1 )  ;  assert that ( tc . get raw statements ( "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestTimingCollector.java,test update,"@ test public void   (  )  throws  exception  {   string stmt1 = ""insert into something  ( id  name )  values  ( 1  'eric' ) "" ;   string stmt2 = ""update something set name  =  :name where id  =  :id"" ;   string stmt3 = ""select * from something where id  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestClosingHandle.java,do tear down,@ after public void   (  )  throws  exception  {  if  ( h  !  =  null )  h . close (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestClosingHandle.java,set up,@ before public void   (  )  throws  exception  {  h = db rule . open handle (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestClosingHandle.java,test close with open container managed transaction,@ test public void   (  )  throws  exception  {  try  (  connection conn = db rule . get connection factory (  )  . open connection (  )  )  {  conn . set auto commit ( false )  ;   handle handle =  jdbi . open ( conn )  ;  handle . close (  )  ;   }   } 
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestClosingHandle.java,test close with open transaction,@ test public void   (  )  throws  exception  {  h . begin (  )  ;  assert that thrown by ( h::close )  . is instance of (  transaction exception . class )  ;  assert that ( h . is closed (  )  )  . is true (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestClosingHandle.java,test close with open transaction check disabled,@ test public void   (  )  throws  exception  {  h . get config (  handles . class )  . set force end transactions ( false )  ;  h . begin (  )  ;  h . close (  )  ;  assert that ( h . is closed (  )  )  . is true (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestClosingHandle.java,test closing,"@ test public void   (  )  throws  exception  {  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  . execute (  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestClosingHandle.java,test iterate all the way,"@ test public void   (  )  throws  exception  {  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  . execute (  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestClosingHandle.java,test iterate keep handle,"@ test public void   (  )  throws  exception  {  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  . execute (  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestClosingHandle.java,test iterator behaviour,"@ test public void   (  )  throws  exception  {  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  . execute (  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestClosingHandle.java,test iterator close,"@ test public void   (  )  throws  exception  {  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  . execute (  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestClosingHandle.java,test not closing,"@ test public void   (  )  throws  exception  {  h . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 2  'brian' ) "" )  . execute (  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestHandle.java,test in transaction,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   string value = h . in transaction ( handle  -  >   {  handle . execute ( ""insert into something  ( id  name )  values  ( 1  ' brian' ) "" )  ;  return handle . cre"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestHandle.java,test is closed,"@ suppress warnings ( ""resource"" )  @ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  assert that ( h . is closed (  )  )  . is false (  )  ;  h . close (  )  ;  assert that ( h . is closed (  )  )  . is true (  )"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestHandle.java,test mr winter,"@ test public void   (  )  {  final  handle h = db rule . get shared handle (  )  ;  h . execute ( ""create table \""\u2603\""  ( pk int primary key ) "" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestHandle.java,test silly number of callbacks,"@ test public void   (  )  throws  exception  {  try  (  handle h = db rule . open handle (  )  )  {  h . execute ( ""insert into something  ( id  name )  values  ( 1  ' keith' ) "" )  ;   }   string value = db rule . get jdbi (  )  . with handle ( handle  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestJdbi.java,test connection factory ctor,@ test public void   (  )  throws  exception  {   jdbi db =  jdbi . create (  (  )   -  >   {  try  {  return  driver manager . get connection ( this . db rule . get connection string (  )  )  ;   }  catch  (  sql exception e )   {  throw new  connection 
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestJdbi.java,test correct exception onsql exception,@ test ( expected =  connection exception . class )  public void   (  )  throws  exception  {   jdbi db =  jdbi . create (  (  )   -  >   {  throw new sql exception (  )  ;   }   )  ;  db . open (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestJdbi.java,test data source constructor,@ test public void   (  )  throws  exception  {   jdbi db =  jdbi . create ( this . db rule . get connection string (  )  )  ;  try  (  handle h = db . open (  )  )  {  assert that ( h )  . is not null (  )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestJdbi.java,test use handle,"@ test public void   (  )  throws  exception  {   jdbi db =  jdbi . create ( this . db rule . get connection string (  )  )  ;  db . use handle ( handle  -  >   {  handle . execute ( ""insert into something  ( id  name )  values  ( 1  ' brian' ) "" )  ;   s"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestJdbi.java,test with handle,"@ test public void   (  )  throws  exception  {   jdbi db =  jdbi . create ( this . db rule . get connection string (  )  )  ;   string value = db . with handle ( handle  -  >   {  handle . execute ( ""insert into something  ( id  name )  values  ( 1  ' br"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestJsr310.java,instant,"@ test public void   (  )  {   instant i =  instant . now (  )  ;  h . execute ( ""insert into stuff ( ts )  values  (  ?  ) "" i )  ;  assert that ( h . create query ( ""select ts from stuff"" )  . map to (  instant . class )  . find only (  )  )  . is equal"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestJsr310.java,local date,"@ test public void   (  )  {   local date d =  local date . now (  )  ;  h . execute ( ""insert into stuff ( d )  values  (  ?  ) "" d )  ;  assert that ( h . create query ( ""select d from stuff"" )  . map to (  local date . class )  . find only (  )  )  . i"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestJsr310.java,local date time,"@ test public void   (  )  {   local date time d =  local date time . now (  )  ;  h . execute ( ""insert into stuff ( ts )  values  (  ?  ) "" d )  ;  assert that ( h . create query ( ""select ts from stuff"" )  . map to (  local date time . class )  . find "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestJsr310.java,local time,"@ test public void   (  )  {  h . execute ( ""create table schedule  ( start time  end time ) "" )  ;   local time start =  local time . of ( 8 30 0 )  ;   local time end =  local time . of ( 10 30 0 )  ;  h . execute ( ""insert into schedule  ( start  end )"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestJsr310.java,offset date time,"@ test public void   (  )  {   offset date time dt =  offset date time . now (  )  ;  h . execute ( ""insert into stuff ( ts )  values  (  ?  ) "" dt )  ;  assert that ( h . create query ( ""select ts from stuff"" )  . map to (  offset date time . class )  . "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestJsr310.java,offset date time loses offset,"@ test public void   (  )  {   offset date time dt =  offset date time . now (  )  . with offset same instant (  zone offset . of hours (  - 7 )  )  ;  h . execute ( ""insert into stuff ( ts )  values  (  ?  ) "" dt )  ;  assert that ( h . create query ( ""s"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestJsr310.java,set up,"@ before public void   (  )  {  h = db rule . get shared handle (  )  ;  h . execute ( ""create table stuff  ( ts timestamp  d date ) "" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestJsr310.java,zoned date time,"@ test public void   (  )  {   zoned date time dt =  zoned date time . now (  )  ;  h . execute ( ""insert into stuff ( ts )  values  (  ?  ) "" dt )  ;  assert that ( h . create query ( ""select ts from stuff"" )  . map to (  zoned date time . class )  . fin"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestJsr310.java,zoned date time loses zone,"@ test public void   (  )  {   zoned date time dt =  zoned date time . now (  )  . with zone same instant (  zone id . of ( "" america /  denver"" )  )  ;  h . execute ( ""insert into stuff ( ts )  values  (  ?  ) "" dt )  ;  assert that ( h . create query ( "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestPlugins.java,customize connection,@ override public  connection   (  connection conn )  {  return c ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestPlugins.java,customize handle,@ override public  handle   (  handle handle )  {  return h ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestPlugins.java,test customize connection,@ test public void   (  )  throws  exception  {   connection c = mock (  connection . class )  ;  db rule . get jdbi (  )  . install plugin ( new  jdbi plugin (  )  {  @ override public  connection customize connection (   connection conn )  {  return c ;
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestPlugins.java,test customize handle,@ test public void   (  )  throws  exception  {   handle h = mock (  handle . class )  ;  db rule . get jdbi (  )  . install plugin ( new  jdbi plugin (  )  {  @ override public  handle customize handle (   handle handle )  {  return h ;   }   }   )  ;  a
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestHashPrefixSqlParser.java,render,private  string   (  string sql  map <  string  object >  attributes )  {   statement context ctx =  statement context access . create context (  )  ;  attributes . for each ( ctx::define )  ;  return template engine . render ( sql ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestHashPrefixSqlParser.java,set up,@ before public void   (  )  throws  exception  {  this . template engine = new  defined attribute template engine (  )  ;  this . parser = new  hash prefix sql parser (  )  ;  ctx = mock (  statement context . class )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestHashPrefixSqlParser.java,test backtick okay,"@ test public void   (  )  throws  exception  {   parsed sql parsed = parser . parse ( ""select * from `v$session"" ctx )  ;  assert that ( parsed . get sql (  )  )  . is equal to ( ""select * from `v$session"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestHashPrefixSqlParser.java,test bails out on invalid input,"@ test ( expected =  unable to create statement exception . class )  public void   (  )  throws  exception  {  parser . parse ( ""select * from something\n where id  =  #\u0087\u008e\u0092\u0097\u009c"" ctx )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestHashPrefixSqlParser.java,test colon is literal,"@ test public void   (  )  throws  exception  {   parsed sql parsed = parser . parse ( ""select * from foo where id  =  :id"" ctx )  ;  assert that ( parsed . get sql (  )  )  . is equal to ( ""select * from foo where id  =  :id"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestHashPrefixSqlParser.java,test comment quote,"@ test public void   (  )  throws  exception  {   string sql = ""select 1  / * ' \""  < foo >  * / "" ;  assert that ( parser . parse ( sql ctx )  . get sql (  )  )  . is equal to ( sql )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestHashPrefixSqlParser.java,test dollar sign okay,"@ test public void   (  )  throws  exception  {   parsed sql parsed = parser . parse ( ""select * from v$session"" ctx )  ;  assert that ( parsed . get sql (  )  )  . is equal to ( ""select * from v$session"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestHashPrefixSqlParser.java,test ignore angle brackets not part of token,"@ test public void   (  )  throws  exception  {   string sql = ""select * from foo where end   date  <   ?  and start   date  >   ? "" ;  assert that ( render ( sql )  )  . is equal to ( sql )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestHashPrefixSqlParser.java,test leave enquoted tokens intact,"@ test public void   (  )  throws  exception  {   string sql = ""select ' < foo > ' foo  \"" < bar > \"" bar from something"" ;  assert that ( render ( sql  immutable map . of ( ""foo"" ""no"" ""bar"" ""stahp"" )  )  )  . is equal to ( sql )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestHashPrefixSqlParser.java,test newlines okay,"@ test public void   (  )  throws  exception  {   parsed sql parsed = parser . parse ( ""select * from something\n where id  =  #id"" ctx )  ;  assert that ( parsed . get sql (  )  )  . is equal to ( ""select * from something\n where id  =   ? "" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestHashPrefixSqlParser.java,test numbers,"@ test public void   (  )  throws  exception  {   parsed sql parsed = parser . parse ( ""#bo0 '#nope'    %&^& *@ #id"" ctx )  ;  assert that ( parsed . get sql (  )  )  . is equal to ( "" ?  '#nope'    %&^& *@  ? "" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestHashPrefixSqlParser.java,test odd characters,"@ test public void   (  )  throws  exception  {   parsed sql parsed = parser . parse ( ""~* #boo '#nope'    %&^& *@ #id"" ctx )  ;  assert that ( parsed . get sql (  )  )  . is equal to ( ""~*  ?  '#nope'    %&^& *@  ? "" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestHashPrefixSqlParser.java,test substitutes defined attributes,"@ test public void   (  )  throws  exception  {   map <  string  object >  attributes =  immutable map . of ( ""column"" ""foo"" ""table"" ""bar"" )  ;   string rendered = render ( ""select  < column >  from  < table >  where  < column >   =  #some value"" attribut"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\statement\TestHashPrefixSqlParser.java,test undefined attribute,"@ test ( expected =  unable to create statement exception . class )  public void   (  )  throws  exception  {  render ( ""select * from  < table > ""  collections . empty map (  )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestUuid.java,setup dbi,"@ before public void   (  )  throws  exception  {  db = db rule . get jdbi (  )  ;  h = db . open (  )  ;  h . execute ( ""create table foo  ( bar uuid ) "" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestUuid.java,tear down,@ after public void   (  )  throws  exception  {  h . close (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestUuid.java,test uuid,"@ test public void   (  )  throws  exception  {  uuid u = uuid . randomuuid (  )  ;  h . create update ( ""insert into foo values  ( :uuid ) "" )  . bind ( ""uuid"" u )  . execute (  )  ;  assert that ( h . create query ( ""select * from foo"" )  . map to ( uui"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestTooManyCursors.java, connection invocation handler,public   (  connection connection int num successful statements )  {  this . connection = connection ;  this . num successful statements = num successful statements ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestTooManyCursors.java, error producing connection factory,  (  connection factory target int i )  {  this . target = target ;  conn count = i ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestTooManyCursors.java, statement invocation handler,public   (  statement stmt  connection invocation handler connection handler )  {  this . stmt = stmt ;  this . connection handler = connection handler ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestTooManyCursors.java,invoke,"@ override public  object   (  object proxy  method method  object[] args )  throws  throwable  {  if  ( ""close"" . equals ( method . get name (  )  )  )   {  connection handler . register close statement (  )  ;   }  try  {  return method . invoke ( stmt "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestTooManyCursors.java,new instance,public static  statement   (  statement stmt  connection invocation handler connection handler )  {   class <  ?  >  o = stmt . get class (  )  ;   list <  class <  ?  >  >  interfaces = new  array list <  >  (  )  ;  while  (  ! o . equals (  object . class )  )   {  interfaces . add all (  arrays . as list ( o . get interfaces (  )  )  )  ;  o = o . get superclass (  )  ;   }  return  (  statement )  proxy . new proxy instance ( stmt . get class (  )  . get class loader (  )  interfaces . to array ( new  class[interfaces . size (  ) ] )  new  statement invocation handler ( stmt connection handler )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestTooManyCursors.java,open connection,@ override public  connection   (  )  throws sql exception  {  return  connection invocation handler . new instance ( target . open connection (  )  conn count )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestTooManyCursors.java,register close statement,public void   (  )  {  num statements -  -  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestTooManyCursors.java,test foo,@ test public void   (  )  throws  exception  {   connection factory cf = db rule . get connection factory (  )  ;   connection factory error cf = new  error producing connection factory ( cf 99 )  ;   jdbi db =  jdbi . create ( error cf )  ;  db . use ha
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\transaction\TestLocalTransactionHandler.java,test rollback throw,"@ test public void   (  )  throws  exception  {   runtime exception outer = new  runtime exception ( "" transaction throws ! "" )  ;   runtime exception inner = new  runtime exception ( "" rollback throws ! "" )  ;   mockito . when ( c . get auto commit (  ) "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\transaction\TestSerializableTransactionRunner.java,set up,@ before public void   (  )  throws  exception  {  db =  jdbi . create ( db rule . get connection factory (  )  )  ;  db . set transaction handler ( new  serializable transaction runner (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\transaction\TestSerializableTransactionRunner.java,test eventually fails,@ test public void   (  )  throws  exception  {  final  atomic integer tries = new  atomic integer ( 5 )  ;   handle handle = db . open (  )  ;  assert that exception of type ( sql exception . class )  . is thrown by (  (  )   -  >  handle . in transactio
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\transaction\TestSerializableTransactionRunner.java,test eventually succeeds,@ test public void   (  )  throws  exception  {  final  atomic integer tries = new  atomic integer ( 3 )  ;   handle handle = db . open (  )  ;  handle . in transaction (  transaction isolation level . serializable conn  -  >   {  if  ( tries . decrement 
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\transaction\TestTransactions.java,begin,@ override public void   (  handle handle )  {  begin +  +  ;  super . begin ( handle )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\transaction\TestTransactions.java,close,@ after public void   (  )  {  h . close (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\transaction\TestTransactions.java,commit,@ override public void   (  handle handle )  {  commit +  +  ;  super . commit ( handle )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\transaction\TestTransactions.java,rollback,@ override public void   (  handle handle )  {  rollback +  +  ;  super . rollback ( handle )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\transaction\TestTransactions.java,set up,@ before public void   (  )  {  db rule . get jdbi (  )  . set transaction handler ( tx spy )  ;  h = db rule . open handle (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\transaction\TestTransactions.java,test callback,"@ test public void   (  )  throws  exception  {   string woot = h . in transaction ( x  -  >  "" woot ! "" )  ;  assert that ( woot )  . is equal to ( "" woot ! "" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\transaction\TestTransactions.java,test double open,@ test public void   (  )  throws  exception  {  assert that ( h . get connection (  )  . get auto commit (  )  )  . is true (  )  ;  h . begin (  )  ;  h . begin (  )  ;  assert that ( h . get connection (  )  . get auto commit (  )  )  . is false (  )  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\transaction\TestTransactions.java,test exception aborts transaction,"@ test public void   (  )  throws  exception  {  assert that thrown by (  (  )   -  >  h . in transaction ( handle  -  >   {  handle . execute ( ""insert into something  ( id  name )  values  (  ?    ?  ) "" 0 "" keith"" )  ;  throw new io exception (  )  ;  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\transaction\TestTransactions.java,test release savepoint,"@ test public void   (  )  throws  exception  {  h . begin (  )  ;  h . savepoint ( ""first"" )  ;  h . execute ( ""insert into something  ( id  name )  values  (  ?    ?  ) "" 1 "" martin"" )  ;  h . release ( ""first"" )  ;  assert that exception of type (  tra"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\transaction\TestTransactions.java,test rollback doesnt commit,@ test public void   (  )  throws  exception  {  assert that ( begin )  . is equal to ( 0 )  ;  h . use transaction ( th  -  >   {  assert that ( begin )  . is equal to ( 1 )  ;  assert that ( rollback )  . is equal to ( 0 )  ;  th . rollback (  )  ;   } 
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\transaction\TestTransactions.java,test rollback outside tx,"@ test public void   (  )  throws  exception  {  h . execute ( ""insert into something  ( id  name )  values  (  ?    ?  ) "" 7 "" tom"" )  ;  h . rollback (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\transaction\TestTransactions.java,test savepoint,"@ test public void   (  )  throws  exception  {  h . begin (  )  ;  h . execute ( ""insert into something  ( id  name )  values  (  ?    ?  ) "" 1 "" tom"" )  ;  h . savepoint ( ""first"" )  ;  h . execute ( ""insert into something  ( id  name )  values  (  ?   "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\transaction\TestTransactions.java,test throwing runtime exception percolates original,@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  h . in transaction ( handle  -  >   {  throw new  illegal argument exception (  )  ;   }   )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestUri.java,test uri,"@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  h . create update ( ""insert into something  ( id  name )  values  ( 1  :uri ) "" )  . bind ( ""uri"" test   uri )  . execute (  )  ;  assert that ( h . create query ("
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\ValueType.java, value type,private   (  string value )  {  this . value = value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\ValueType.java,equals,@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   value type that =  (  value type ) o ;  return this . value . equals ( that . value )
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\ValueType.java,get value,public  string   (  )  {  return value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\ValueType.java,hash code,@ override public int   (  )  {  return value . hash code (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\ValueType.java,to string,@ override public  string   (  )  {  return value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\ValueType.java,value of,public static  value type   (  string value )  {  return value  =  =  null  ?  null : new  value type ( value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\transaction\TestTransactionsAutoCommit.java,restore auto commit initial state on unexpected error,@ test public void   (  )  throws  exception  {  final  connection connection = mock (  connection . class )  ;  final  prepared statement statement = mock (  prepared statement . class )  ;   in order in order = in order ( connection statement )  ;   han
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\BatchTest.java, fruit,  ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestOptional.java, name,  (  string value )  {  this . value = value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestOptional.java,build,@ override public  optional <  argument >    (  type expected type  object value  config registry config )  {  if  ( expected type  =  =   name . class )   {   name name value =  (  name ) value ;  return  optional . of (  ( pos stmt c )   -  >  stmt . se
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestOptional.java,create test data,"@ before public void   (  )  {  handle = db rule . open handle (  )  ;  handle . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  handle . create update ( ""insert into something  ( id  name )  values  ( 2"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestOptional.java,equals,@ override public boolean   (  object obj )  {  if  (  !  ( obj instanceof  name )  )   {  return false ;   }   name that =  (  name ) obj ;  return this . value . equals ( that . value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestOptional.java,test bind optional empty,"@ test public void   (  )  throws  exception  {   list <  something >  result = handle . create query ( select   by   name )  . bind ( ""name""  optional . empty (  )  )  . map to bean (  something . class )  . list (  )  ;  assert that ( result )  . contai"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestOptional.java,test bind optional of custom type,"@ test public void   (  )  throws  exception  {  handle . register argument ( new  name argument factory (  )  )  ;   list <  something >  result = handle . create query ( select   by   name )  . bind ( ""name""  optional . of ( new  name ( ""eric"" )  )  )  "
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestOptional.java,test bind optional of unregistered custom type,"@ test public void   (  )  throws  exception  {  exception . expect (  unsupported operation exception . class )  ;  handle . create query ( select   by   name )  . bind ( ""name""  optional . of ( new  name ( ""eric"" )  )  )  . map to bean (  something . cl"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestOptional.java,test bind optional present,"@ test public void   (  )  throws  exception  {   something result = handle . create query ( select   by   name )  . bind ( ""name""  optional . of ( ""brian"" )  )  . map to bean (  something . class )  . find only (  )  ;  assert that ( result )  . is equal"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestOptional.java,test dynamic bind optional empty,"@ test public void   (  )  throws  exception  {   list <  something >  result = handle . create query ( select   by   name )  . bind by type ( ""name""  optional . empty (  )  new  generic type <  optional <  string >  >  (  )  {   }   )  . map to bean (  s"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestOptional.java,test dynamic bind optional of custom type,"@ test public void   (  )  throws  exception  {  handle . register argument ( new  name argument factory (  )  )  ;  handle . create query ( select   by   name )  . bind by type ( ""name""  optional . of ( new  name ( ""eric"" )  )  new  generic type <  optio"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestOptional.java,test dynamic bind optional of unregistered custom type,"@ test public void   (  )  throws  exception  {  exception . expect (  unsupported operation exception . class )  ;  handle . create query ( select   by   name )  . bind by type ( ""name""  optional . of ( new  name ( ""eric"" )  )  new  generic type <  optio"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestOptional.java,test dynamic bind optional present,"@ test public void   (  )  throws  exception  {   something result = handle . create query ( select   by   name )  . bind by type ( ""name""  optional . of ( ""eric"" )  new  generic type <  optional <  string >  >  (  )  {   }   )  . map to bean (  something"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestOptional.java,test map to optional,"@ test public void   (  )  throws  exception  {   generic type <  optional <  string >  >  optional string = new  generic type <  optional <  string >  >  (  )  {   }   ;  assert that ( handle . select ( ""select name from something where id  =  0"" )  . co"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestOptional.java,test map to optional double,"@ test public void   (  )  throws  exception  {  assert that ( handle . select ( ""select id from something where name  =  'slartibartfast'"" )  . collect into (  optional double . class )  )  . is empty (  )  ;  assert that ( handle . select ( ""select null"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestOptional.java,test map to optional int,"@ test public void   (  )  throws  exception  {  assert that ( handle . select ( ""select id from something where name  =  'arthur'"" )  . collect into (  optional int . class )  )  . is empty (  )  ;  assert that ( handle . select ( ""select null from somet"
C:\Users\User\Desktop\Thesis\jdbi\core\src\test\java\org\jdbi\v3\core\TestOptional.java,test map to optional long,"@ test public void   (  )  throws  exception  {  assert that ( handle . select ( ""select id from something where name  =  'ford'"" )  . collect into (  optional long . class )  )  . is empty (  )  ;  assert that ( handle . select ( ""select null from someth"
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\CallTest.java,test call,"@ test public void   (  )  {   handle handle = db . get handle (  )  ;  handle . execute ( find sql on classpath ( ""create   stored   proc   add"" )  )  ;   out parameters result = handle . create call ( "" { :sum  =  call add ( :a  :b )  } "" )  . bind ( ""a"
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ArgumentsTest.java,uuid argument,public   ( uuid uuid )  {  this . uuid = uuid ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ArgumentsTest.java,uuid argument factory,public   (  )  {  super (  types . varchar )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ArgumentsTest.java,apply,@ override public void   ( int position  prepared statement statement  statement context ctx )  throws sql exception  {  statement . set string ( position uuid . to string (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ArgumentsTest.java,bind int,"@ test public void   (  )  {  assert that ( handle . create query ( ""select :id"" )  . bind ( ""id"" 3 )  . map to (  integer . class )  . find only (  )  . int value (  )  )  . is equal to ( 3 )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ArgumentsTest.java,build,@ override protected  argument   ( uuid value  config registry config )  {  return  ( position statement ctx )   -  >  statement . set string ( position value . to string (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ArgumentsTest.java,get handle,@ before public void   (  )  {  handle = db rule . get shared handle (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ArgumentsTest.java,uuid argument,"@ test public void   (  )  {  uuid u = uuid . randomuuid (  )  ;  assert that ( handle . create query ( ""select cast ( :uuid as varchar ) "" )  . bind ( ""uuid"" new uuid argument ( u )  )  . map to (  string . class )  . find only (  )  )  . is equal to ( u"
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ArgumentsTest.java,uuid argument factory,"@ test public void   (  )  {  uuid u = uuid . randomuuid (  )  ;  handle . register argument ( new uuid argument factory (  )  )  ;  assert that ( handle . create query ( ""select cast ( :uuid as varchar ) "" )  . bind ( ""uuid"" u )  . map to (  string . cla"
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ContactBean.java, contact bean,public   ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ContactBean.java,equals,@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   contact bean that =  (  contact bean ) o ;  return id  =  =  that . id &&  objects . 
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ContactBean.java,get id,public int   (  )  {  return id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ContactBean.java,get name,public  string   (  )  {  return name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ContactBean.java,hash code,@ override public int   (  )  {  return  objects . hash ( id name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ContactBean.java,set id,public void   ( int id )  {  this . id = id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ContactBean.java,set name,public void   (  string name )  {  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ContactBean.java,to string,"@ override public  string   (  )  {  return "" contact bean { ""  +  ""id = ""  +  id  +  ""  name = '"" +  name +  '\'' +  ' } ' ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\GeneratedKeysTest.java, user,public   ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ExampleConfig.java, example config,private   (  example config other )  {  this . color = other . color ;  this . number = other . number ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ExampleConfig.java,create copy,@ override public  example config   (  )  {  return new  example config ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ExampleConfig.java,get color,public  string   (  )  {  return color ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ExampleConfig.java,get number,public int   (  )  {  return number ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ExampleConfig.java,set color,public  example config   (  string color )  {  this . color = color ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ExampleConfig.java,set number,public  example config   ( int number )  {  this . number = number ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\IntroductionTest.java, user,public   ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\IntroductionTest.java,core,"@ test public void   (  )  {   jdbi jdbi =  jdbi . create ( ""jdbc:h2:mem:test"" )  ;   list <  user >  users = jdbi . with handle ( handle  -  >   {  handle . execute ( ""create table user  ( id integer primary key  name varchar ) "" )  ;  handle . execute ("
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\PhoneBean.java, phone bean,public   ( int id  string name  string number )  {  this . id = id ;  this . name = name ;  this . number = number ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\PhoneBean.java,equals,@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   phone bean phone bean =  (  phone bean ) o ;  return id  =  =  phone bean . id &&  ob
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\PhoneBean.java,get id,public int   (  )  {  return id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\PhoneBean.java,get name,public  string   (  )  {  return name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\PhoneBean.java,get number,public  string   (  )  {  return number ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\PhoneBean.java,hash code,@ override public int   (  )  {  return  objects . hash ( id name number )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\PhoneBean.java,set id,public void   ( int id )  {  this . id = id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\PhoneBean.java,set name,public void   (  string name )  {  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\PhoneBean.java,set number,public void   (  string number )  {  this . number = number ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\PhoneBean.java,to string,"@ override public  string   (  )  {  return "" phone bean { ""  +  ""id = ""  +  id  +  ""  name = '"" +  name +  '\'' +  ""  number = '"" +  number +  '\'' +  ' } ' ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\FiveMinuteTourTest.java, contact,  ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\FiveMinuteTourTest.java,map,"@ override public  contact   (  result set r  statement context ctx )  throws sql exception  {  return new  contact ( r . get int ( ""id"" )  r . get string ( ""name"" )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\FiveMinuteTourTest.java,named parameters,"@ test public void   (  )  {  handle . register row mapper ( new  contact mapper (  )  )  ;  handle . create update ( ""insert into contacts  ( id  name )  values  ( :id  :name ) "" )  . bind ( ""id"" 3 )  . bind ( ""name"" "" chuck"" )  . execute (  )  ;   strin"
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\FiveMinuteTourTest.java,positional parameters,"@ test public void   (  )  {  handle . register row mapper ( new  contact mapper (  )  )  ;  handle . create update ( ""insert into contacts  ( id  name )  values  (  ?    ?  ) "" )  . bind ( 0 3 )  . bind ( 1 "" chuck"" )  . execute (  )  ;   string name = h"
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\FiveMinuteTourTest.java,register custom mapper,"@ test public void   (  )  {  handle . register row mapper ( new  contact mapper (  )  )  ;   list <  contact >  contacts = handle . create query ( ""select * from contacts"" )  . map to (  contact . class )  . list (  )  ;  assert that ( contacts )  . extr"
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\FiveMinuteTourTest.java,set up,"@ before public void   (  )  {   jdbi jdbi =  jdbi . create ( ""jdbc:h2:mem:test"" )  ;  this . jdbi = jdbi ;  this . handle = jdbi . open (  )  ;  jdbi . use handle ( handle  -  >   {  handle . execute ( ""create table contacts  ( id int primary key  name v"
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\FiveMinuteTourTest.java,tear down,@ after public void   (  )  {  handle . close (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\FiveMinuteTourTest.java,try with resources,"@ test public void   (  )  {  try  (  handle handle = jdbi . open (  )  )  {  handle . execute ( ""insert into contacts  ( id  name )  values  (  ?    ?  ) "" 3 "" chuck"" )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\FiveMinuteTourTest.java,use custom mapper,"@ test public void   (  )  {   list <  contact >  contacts = handle . create query ( ""select * from contacts"" )  . map ( new  contact mapper (  )  )  . list (  )  ;  assert that ( contacts )  . extracting ( ""id"" ""name"" )  . contains ( tuple ( 1 "" alice"" )"
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ResultsTest.java, named user,public   ( int id  user name name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ResultsTest.java, user,public   ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ResultsTest.java, user name,public   (  string name )  {  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ResultsTest.java,bean mapper,"@ test public void   (  )  {  handle . register row mapper (  bean mapper . factory (  user bean . class )  )  ;   list <  user bean >  users = handle . create query ( ""select id  name from user"" )  . map to (  user bean . class )  . list (  )  ;  assert "
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ResultsTest.java,bean mapper prefix,"@ test public void   (  )  {  handle . execute ( ""create table contacts  ( id int  name text ) "" )  ;  handle . execute ( ""create table phones  ( id int  contact   id int  name text  number text ) "" )  ;  handle . execute ( ""insert into contacts  ( id  na"
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ResultsTest.java,column mapper,"@ test public void   (  )  {  handle . register column mapper ( user name factory )  ;  handle . register row mapper (  constructor mapper . factory (  named user . class )  )  ;   named user bob = handle . create query ( ""select id  name from user where "
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ResultsTest.java,constructor mapper,"@ test public void   (  )  {  handle . register row mapper (  constructor mapper . factory (  user . class )  )  ;   set <  user >  user set = handle . create query ( ""select * from user order by id asc"" )  . map to (  user . class )  . collect (  collect"
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ResultsTest.java,find bob,"@ test public void   (  )  {   user u = find user by id ( 2 )  . or else throw (  (  )   -  >  new  assertion error ( "" no user found"" )  )  ;  assert that ( u . id )  . is equal to ( 2 )  ;  assert that ( u . name )  . is equal to ( "" bob"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ResultsTest.java,find user by id,"public  optional <  user >    ( long id )  {   row mapper <  user >  user mapper =  ( rs ctx )   -  >  new  user ( rs . get int ( ""id"" )  rs . get string ( ""name"" )  )  ;  return handle . create query ( ""select * from user where id = :id"" )  . bind ( ""id"" id )  . map ( user mapper )  . find first (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ResultsTest.java,get handle,@ before public void   (  )  {  handle = db rule . get shared handle (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ResultsTest.java,inline row mapper,"@ test public void   (  )  {   list <  user >  users = handle . create query ( ""select id  name from user order by id asc"" )  . map (  ( rs ctx )   -  >  new  user ( rs . get int ( ""id"" )  rs . get string ( ""name"" )  )  )  . list (  )  ;  assert that ( us"
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ResultsTest.java,map,"@ override public  user   (  result set rs  statement context ctx )  throws sql exception  {  return new  user ( rs . get int ( ""id"" )  rs . get string ( ""name"" )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ResultsTest.java,map to bean,"@ test public void   (  )  {   list <  user bean >  users = handle . create query ( ""select id  name from user"" )  . map to bean (  user bean . class )  . list (  )  ;  assert that ( users )  . extracting ( ""name"" )  . contains ( "" alice"" "" bob"" "" charlie"
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ResultsTest.java,row mapper,"@ test public void   (  )  {   list <  user >  users = handle . create query ( ""select id  name from user order by id asc"" )  . map ( new  user mapper (  )  )  . list (  )  ;  assert that ( users )  . has size ( 4 )  ;  assert that ( users . get ( 3 )  . "
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ResultsTest.java,row mapper factory,"@ test public void   (  )  {  handle . register row mapper (  user . class new  user mapper (  )  )  ;  handle . create query ( ""select id  name from user order by id asc"" )  . map to (  user . class )  . use stream ( stream  -  >   {   optional <  string"
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\ResultsTest.java,set up,"@ before public void   (  )  throws  exception  {  handle . execute ( ""create table user  ( id integer primary key auto   increment  name varchar ) "" )  ;  for  (   string name :  arrays . as list ( "" alice"" "" bob"" "" charlie"" "" data"" )  )   {  handle . ex"
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\StatementsTest.java,map,static  < k v >  map < k v >    ( k k1 v v1 k k2 v v2 )  {   hash map < k v >  h = new  hash map <  >  (  )  ;  h . put ( k1 v1 )  ;  h . put ( k2 v2 )  ;  return h ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\StatementsTest.java,set up,"@ before public void   (  )  {  handle = db rule . get shared handle (  )  ;  handle . execute ( ""create table user  ( id integer primary key  name varchar ) "" )  ;  handle . execute ( ""insert into user values  ( 1  ' alice' ) "" )  ;  handle . execute ( """
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\StatementsTest.java,test batch,"@ test public void   (  )  throws  exception  {   prepared batch batch = handle . prepare batch ( ""insert into user ( id  name )  values ( :id  :name ) "" )  ;  for  ( int i = 100 ;  i  <  5000 ;  i +  +  )   {  batch . bind ( ""id"" i )  . bind ( ""name"" "" u"
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\StatementsTest.java,test query,"@ suppress warnings ( ""unchecked"" )  @ test public void   (  )  throws  exception  {   list <  map <  string  object >  >  users = handle . create query ( ""select id  name from user order by id asc"" )  . map to map (  )  . list (  )  ;  assert that ( user"
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\StatementsTest.java,test script,"@ test public void   (  )  throws  exception  {  int[] results = handle . create script ( ""insert into user values ( 3  ' charlie' )  ; ""  +  ""update user set name = ' bobby  tables' where id = 2 ; "" )  . execute (  )  ;  assert that ( results )  . contai"
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\StatementsTest.java,test update,"@ test public void   (  )  throws  exception  {  int count = handle . create update ( ""insert into user ( id  name )  values ( :id  :name ) "" )  . bind ( ""id"" 3 )  . bind ( ""name"" "" charlie"" )  . execute (  )  ;  assert that ( count )  . is equal to ( 1 )"
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaArguments.java,build,@ override public  optional <  argument >    (  type expected type  object value  config registry config )  {  if  ( value instanceof com . google . common . base .  optional )   {   object nested value =  (  ( com . google . common . base .  optional <  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaArguments.java,factory,public static  argument factory   (  )  {  return new  factory (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaArguments.java,find optional type,private  type   (  type wrapper type  object nested value )  {  if  ( get erased type ( wrapper type )  . equals ( com . google . common . base .  optional . class )  )   {   optional <  type >  nested type = find generic parameter ( wrapper type com . google . common . base .  optional . class )  ;  if  ( nested type . is present (  )  )   {  return nested type . get (  )  ;   }   }  return nested value  =  =  null  ?   object . class : nested value . get class (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaCollectors.java, factory,public   (  )  {   type variable <  class <  multimap >  > [] multimap params =  multimap . class . get type parameters (  )  ;  multimap key = multimap params[0] ;  multimap value = multimap params[1] ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaCollectors.java,accepts,@ override public boolean   (  type container type )  {   class <  ?  >  erased type = get erased type ( container type )  ;  return collectors . contains key ( erased type )  && container type instanceof  parameterized type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaCollectors.java,build,@ override public  collector <  ?   ?   ?  >    (  type container type )  {  return collectors . get ( get erased type ( container type )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaCollectors.java,combine,private static  < k v mb extends  immutable multimap .  builder < k v >  > mb   ( mb a mb b )  {  a . put all ( b . build (  )  )  ;  return a ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaCollectors.java,element type,@ override public java . util .  optional <  type >    (  type container type )  {   class <  ?  >  erased type = get erased type ( container type )  ;  if  (  multimap . class . is assignable from ( erased type )  )   {   type key type = resolve type ( m
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaCollectors.java,factory,public static  collector factory   (  )  {  return new  factory (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaCollectors.java,put entry,private static  < k v m extends  multimap < k v >  > void   ( m map  map .  entry < k v >  entry )  {  map . put ( entry . get key (  )  entry . get value (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaCollectors.java,to array list multimap,public static  < k v >  collector <  map .  entry < k v >   ?   array list multimap < k v >  >    (  )  {  return to multimap (  array list multimap::create )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaCollectors.java,to hash bi map,public static  < k v >  collector <  map .  entry < k v >   ?   bi map < k v >  >    (  )  {  return to map (  hash bi map::create )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaCollectors.java,to hash multimap,public static  < k v >  collector <  map .  entry < k v >   ?   hash multimap < k v >  >    (  )  {  return to multimap (  hash multimap::create )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaCollectors.java,to immutable list multimap,public static  < k v >  collector <  map .  entry < k v >   ?   immutable list multimap < k v >  >    (  )  {  return  collector . of (  immutable list multimap:: < k v > builder  immutable list multimap .  builder::put  guava collectors::combine  immutable list multimap .  builder::build )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaCollectors.java,to immutable map,public static  < k v >  collector <  map .  entry < k v >   ?   immutable map < k v >  >    (  )  {  return  immutable map . to immutable map (  map .  entry::get key  map .  entry::get value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaCollectors.java,to immutable set multimap,public static  < k v >  collector <  map .  entry < k v >   ?   immutable set multimap < k v >  >    (  )  {  return  collector . of (  immutable set multimap:: < k v > builder  immutable set multimap .  builder::put  guava collectors::combine  immutable set multimap .  builder::build )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaCollectors.java,to linked list multimap,public static  < k v >  collector <  map .  entry < k v >   ?   linked list multimap < k v >  >    (  )  {  return to multimap (  linked list multimap::create )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaCollectors.java,to multimap,public static  < k v m extends  multimap < k v >  >  collector <  map .  entry < k v >   ?  m >    (  supplier < m >  multimap factory )  {  return  collector . of ( multimap factory  guava collectors::put entry  guava collectors::combine )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaCollectors.java,to optional,public static  < t >  collector < t  ?   optional < t >  >    (  )  {  return  optional collectors . to optional (  optional::absent  optional::of )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaCollectors.java,to tree multimap,public static  < k extends  comparable v extends  comparable >  collector <  map .  entry < k v >   ?   tree multimap < k v >  >    (  )  {  return to multimap (  tree multimap::create )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\main\java\org\jdbi\v3\guava\GuavaPlugin.java,customize jdbi,@ override public void   (  jdbi db )  {  db . register argument (  guava arguments . factory (  )  )  ;  db . register collector (  guava collectors . factory (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\UserBean.java,get id,public int   (  )  {  return id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\UserBean.java,get name,public  string   (  )  {  return name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\UserBean.java,set id,public void   ( int id )  {  this . id = id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\docs\src\test\java\jdbi\doc\UserBean.java,set name,public void   (  string name )  {  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaMappers.java,set up,"@ before public void   (  )  {  db rule . get jdbi (  )  . register array type (  integer . class ""integer"" )  . register array type ( uuid . class ""uuid"" )  ;  h = db rule . open handle (  )  ;  h . use transaction ( th  -  >   {  th . execute ( ""drop ta"
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaMappers.java,test integer immutable list,"@ test public void   (  )  throws  exception  {   integer[] test ints = new  integer[] { 5 4  - 6 1 9  integer . max   value  integer . min   value }  ;  h . execute ( ""insert into arrays  ( i )  values (  ?  ) ""  (  object ) test ints )  ;   immutable li"
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaMappers.java,test uuid immutable list,"@ test public void   (  )  throws  exception  {  uuid[] test uuids = new uuid[] { uuid . randomuuid (  )  uuid . randomuuid (  )  uuid . randomuuid (  )  uuid . randomuuid (  )  uuid . randomuuid (  )  }  ;  h . execute ( ""insert into arrays  ( u )  value"
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaCollectors.java,add data,"@ before public void   (  )  {   immutable list .  builder <  integer >  expected =  immutable list . builder (  )  ;  for  ( int i = 0 ;  i  <  10 ;  i +  +  )   {  db rule . get shared handle (  )  . execute ( ""insert into something ( name  int value ) "
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaCollectors.java,immutable list,"@ test public void   (  )  {   immutable list <  integer >  list = db rule . get shared handle (  )  . create query ( ""select int value from something"" )  . collect into ( new  generic type <  immutable list <  integer >  >  (  )  {   }   )  ;  assert tha"
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaCollectors.java,immutable set,"@ test public void   (  )  {   immutable set <  integer >  set = db rule . get shared handle (  )  . create query ( ""select int value from something"" )  . collect into ( new  generic type <  immutable set <  integer >  >  (  )  {   }   )  ;  assert that ("
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaCollectors.java,immutable sorted set,"@ test public void   (  )  {   immutable sorted set <  integer >  set = db rule . get shared handle (  )  . create query ( ""select int value from something"" )  . collect into ( new  generic type <  immutable sorted set <  integer >  >  (  )  {   }   )  ; "
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaCollectors.java,immutable sorted set with comparator,"@ test public void   (  )  {   comparator <  integer >  comparator =  comparator .  <  integer > natural order (  )  . reversed (  )  ;   immutable sorted set <  integer >  set = db rule . get shared handle (  )  . create query ( ""select int value from so"
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaCollectors.java,map collectors,@ test public void   (  )  {  test map collector (  immutable map . class new  generic type <  immutable map <  long  string >  >  (  )  {   }   )  ;  test map collector (  bi map . class new  generic type <  bi map <  long  string >  >  (  )  {   }   )  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaCollectors.java,multimap collectors,@ test public void   (  )  {  test multimap collector (  immutable multimap . class new  generic type <  immutable multimap <  long  string >  >  (  )  {   }   )  ;  test multimap collector (  immutable list multimap . class new  generic type <  immutable
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaCollectors.java,optional absent,"@ test public void   (  )  {   optional <  integer >  should be absent = db rule . get shared handle (  )  . create query ( ""select int value from something where int value  =  100"" )  . collect into ( new  generic type <  optional <  integer >  >  (  )  "
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaCollectors.java,optional multiple,"@ test ( expected =  illegal state exception . class )  public void   (  )  {  db rule . get shared handle (  )  . create query ( ""select int value from something"" )  . collect into ( new  generic type <  optional <  integer >  >  (  )  {   }   )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaCollectors.java,optional present,"@ test public void   (  )  {   optional <  integer >  should be present = db rule . get shared handle (  )  . create query ( ""select int value from something where int value  =  1"" )  . collect into ( new  generic type <  optional <  integer >  >  (  )  {"
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaCollectors.java,test map collector,"@ suppress warnings ( ""unchecked"" )  private  < m extends  map <  long  string >  > void   (  class <  ?  extends  map >  erased type  generic type < m >  generic type )  {   jdbi collectors registry = db rule . get jdbi (  )  . get config (  jdbi collect"
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaCollectors.java,test multimap collector,"@ suppress warnings ( ""unchecked"" )  private  < m extends  multimap <  long  string >  > void   (  class <  ?  extends  multimap >  erased type  generic type < m >  generic type )  {   jdbi collectors registry = db rule . get jdbi (  )  . get config (  jd"
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\MultimapEntryMapperTest.java, phone,public   ( int id  string phone )  {  this . id = id ;  this . phone = phone ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\MultimapEntryMapperTest.java, user,public   ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\MultimapEntryMapperTest.java,equals,@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   phone phone1 =  (  phone ) o ;  return id  =  =  phone1 . id &&  objects . equals ( p
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\MultimapEntryMapperTest.java,hash code,@ override public int   (  )  {  return  objects . hash ( id phone )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\MultimapEntryMapperTest.java,index,"@ test public void   (  )  {  h . execute ( ""create table user  ( id int  manager   id int  name varchar ) "" )  ;  h . prepare batch ( ""insert into user  ( id  manager   id  name )  values  (  ?    ?    ?  ) "" )  . add ( 1 0 ""alice"" )  . add ( 2 1 ""bob"" )"
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\MultimapEntryMapperTest.java,join row,"@ test public void   (  )  {  h . execute ( ""create table user  ( id int  name varchar ) "" )  ;  h . execute ( ""create table phone  ( id int  user   id int  phone varchar ) "" )  ;  h . prepare batch ( ""insert into user  ( id  name )  values  (  ?    ?  ) "
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\MultimapEntryMapperTest.java,key value columns,"@ test public void   (  )  {  h . execute ( ""create table config  ( key varchar  value varchar ) "" )  ;  h . prepare batch ( ""insert into config  ( key  value )  values  (  ?    ?  ) "" )  . add ( ""foo"" ""123"" )  . add ( ""foo"" ""456"" )  . add ( ""bar"" ""xyz"" )"
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\MultimapEntryMapperTest.java,set up,@ before public void   (  )  {  h = db rule . get shared handle (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\MultimapEntryMapperTest.java,to string,"@ override public  string   (  )  {  return "" phone { ""  +  ""id = ""  +  id  +  ""  phone = '"" +  phone +  '\'' +  ' } ' ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaOptional.java, name,  (  string value )  {  this . value = value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaOptional.java,build,@ override public java . util .  optional <  argument >    (  type expected type  object value  config registry config )  {  if  ( expected type  =  =   name . class )   {   name name value =  (  name ) value ;  return java . util .  optional . of (  ( po
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaOptional.java,create test data,"@ before public void   (  )  {  handle = db rule . open handle (  )  ;  handle . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  handle . create update ( ""insert into something  ( id  name )  values  ( 2"
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaOptional.java,equals,@ override public boolean   (  object obj )  {  if  (  !  ( obj instanceof  name )  )   {  return false ;   }   name that =  (  name ) obj ;  return this . value . equals ( that . value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaOptional.java,test bind optional empty,"@ test public void   (  )  throws  exception  {   list <  something >  result = handle . create query ( select   by   name )  . bind ( ""name""  optional . absent (  )  )  . map to bean (  something . class )  . list (  )  ;  assert that ( result )  . conta"
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaOptional.java,test bind optional of custom type,"@ test public void   (  )  throws  exception  {  handle . register argument ( new  name argument factory (  )  )  ;   list <  something >  result = handle . create query ( select   by   name )  . bind ( ""name""  optional . of ( new  name ( ""eric"" )  )  )  "
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaOptional.java,test bind optional of unregistered custom type,"@ test public void   (  )  throws  exception  {  exception . expect (  unsupported operation exception . class )  ;  handle . create query ( select   by   name )  . bind ( ""name""  optional . of ( new  name ( ""eric"" )  )  )  . map to bean (  something . cl"
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaOptional.java,test bind optional present,"@ test public void   (  )  throws  exception  {   something result = handle . create query ( select   by   name )  . bind ( ""name""  optional . of ( ""brian"" )  )  . map to bean (  something . class )  . find only (  )  ;  assert that ( result )  . is equal"
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaOptional.java,test dynamic bind optional empty,"@ test public void   (  )  throws  exception  {   list <  something >  result = handle . create query ( select   by   name )  . bind by type ( ""name""  optional . absent (  )  new  generic type <  optional <  string >  >  (  )  {   }   )  . map to bean (  "
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaOptional.java,test dynamic bind optional of custom type,"@ test public void   (  )  throws  exception  {  handle . register argument ( new  name argument factory (  )  )  ;  handle . create query ( select   by   name )  . bind by type ( ""name""  optional . of ( new  name ( ""eric"" )  )  new  generic type <  optio"
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaOptional.java,test dynamic bind optional of unregistered custom type,"@ test public void   (  )  throws  exception  {  exception . expect (  unsupported operation exception . class )  ;  handle . create query ( select   by   name )  . bind by type ( ""name""  optional . of ( new  name ( ""eric"" )  )  new  generic type <  optio"
C:\Users\User\Desktop\Thesis\jdbi\guava\src\test\java\org\jdbi\v3\guava\TestGuavaOptional.java,test dynamic bind optional present,"@ test public void   (  )  throws  exception  {   something result = handle . create query ( select   by   name )  . bind by type ( ""name""  optional . of ( ""eric"" )  new  generic type <  optional <  string >  >  (  )  {   }   )  . map to bean (  something"
C:\Users\User\Desktop\Thesis\jdbi\jodatime2\src\main\java\org\jdbi\v3\jodatime2\DateTimeMapper.java,map,@ override public  date time   (  result set r int column number  statement context ctx )  throws sql exception  {   timestamp ts = r . get timestamp ( column number )  ;  return ts  =  =  null  ?  null : new  date time ( ts . get time (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jodatime2\src\main\java\org\jdbi\v3\jodatime2\JodaTimePlugin.java,customize jdbi,@ override public void   (  jdbi db )  {  db . register argument ( new  date time argument factory (  )  )  ;  db . register column mapper ( new  date time mapper (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jodatime2\src\test\java\org\jdbi\v3\jodatime2\DateTimeTest.java,date time,"@ test public void   (  )  throws  exception  {   handle h = db rule . get shared handle (  )  ;  h . execute ( ""create table stuff ( ts timestamp ) "" )  ;   date time dt = new  date time (  )  ;  h . execute ( ""insert into stuff ( ts )  values  (  ?  ) """
C:\Users\User\Desktop\Thesis\jdbi\jodatime2\src\main\java\org\jdbi\v3\jodatime2\DateTimeArgumentFactory.java, date time argument factory,public   (  )  {  super (  types . timestamp )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jodatime2\src\main\java\org\jdbi\v3\jodatime2\DateTimeArgumentFactory.java,build,@ override protected  argument   (  date time value  config registry config )  {  return  ( pos stmt ctx )   -  >  stmt . set timestamp ( pos new  timestamp ( value . get millis (  )  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\main\java\org\jdbi\v3\jpa\internal\JpaClass.java, jpa class,"private   (  class < c >  clazz )  {  this . members = unmodifiable list ( new  array list <  >  ( inspect class ( clazz )  )  )  ;  logger . debug ( ""init  {  } :  {  }  members . "" clazz members . size (  )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\main\java\org\jdbi\v3\jpa\internal\JpaClass.java,get,"@ suppress warnings ( ""unchecked"" )  public static  < c >  jpa class < c >    (  class < c >  clazz )  {  return  (  jpa class < c >  ) cache . compute if absent ( clazz  jpa class::new )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\main\java\org\jdbi\v3\jpa\internal\JpaClass.java,inspect annotated properties,private static void   (  class <  ?  >  clazz  map <  string  jpa member >  members )  {  inspect properties ( clazz members true )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\main\java\org\jdbi\v3\jpa\internal\JpaClass.java,inspect class,private static  collection <  jpa member >    (  class <  ?  >  clazz )  {   map <  string  jpa member >  members = new  hash map <  >  (  )  ;  inspect fields ( clazz members )  ;  inspect annotated properties ( clazz members )  ;  inspect superclasses ( clazz members )  ;  inspect non annotated properties ( clazz members )  ;  return members . values (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\main\java\org\jdbi\v3\jpa\internal\JpaClass.java,inspect fields,private static void   (  class <  ?  >  clazz  map <  string  jpa member >  members )  {  for  (   field member : clazz . get declared fields (  )  )   {  if  ( members . contains key ( member . get name (  )  )  )   {  continue ;   }   column column = member . get annotation (  column . class )  ;  if  ( column  !  =  null )   {  members . put ( member . get name (  )  new  jpa member ( clazz column member )  )  ;   }   }   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\main\java\org\jdbi\v3\jpa\internal\JpaClass.java,inspect non annotated properties,private static void   (  class <  ?  >  clazz  map <  string  jpa member >  members )  {  inspect properties ( clazz members false )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\main\java\org\jdbi\v3\jpa\internal\JpaClass.java,inspect properties,"private static void   (  class <  ?  >  clazz  map <  string  jpa member >  members boolean has column annotation )  {  try  {   stream . of (  introspector . get bean info ( clazz )  . get property descriptors (  )  )  . filter ( property  -  >   ! members . contains key ( property . get name (  )  )  )  . filter ( property  -  >   !  ( property instanceof  indexed property descriptor )  )  . filter ( property  -  >   ! ""class"" . equals ( property . get name (  )  )  )  . for each ( property  -  >   {   method getter = property . get read method (  )  ;   method setter = property . get write method (  )  ;   column column =  stream . of ( getter setter )  . filter (  objects::non null )  . map ( method  -  >  method . get annotation (  column . class )  )  . filter (  objects::non null )  . find first (  )  . or else ( null )  ;  if  (  ( column  !  =  null )   =  =  has column annotation )   {  members . put ( property . get name (  )  new  jpa member ( clazz column property )  )  ;   }   }   )  ;   }  catch  (   introspection exception e )   {  logger . warn ( "" unable to introspect ""  +  clazz e )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\main\java\org\jdbi\v3\jpa\internal\JpaClass.java,inspect superclasses,private static void   (  class <  ?  >  clazz  map <  string  jpa member >  members )  {  while  (  ( clazz = clazz . get superclass (  )  )   !  =  null )   {  if  ( clazz . is annotation present (  mapped superclass . class )  )   {  inspect fields ( clazz members )  ;   }   }   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\main\java\org\jdbi\v3\jpa\internal\JpaClass.java,lookup member,public  jpa member   (  string column label )  {   string column = column label . to lower case (  locale . root )  ;  return members . stream (  )  . filter ( member  -  >  column . equals ( member . get column name (  )  . to lower case (  locale . root )  )  )  . find first (  )  . or else ( null )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\main\java\org\jdbi\v3\jpa\internal\JpaClass.java,members,public  list <  jpa member >    (  )  {  return members ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\main\java\org\jdbi\v3\jpa\internal\JpaMember.java, jpa member,  (  class <  ?  >  clazz  column column  property descriptor property )  {  this . clazz = require non null ( clazz )  ;  this . column name = name of ( column property . get name (  )  )  ;  this . type = property . get read method (  )  . get generic return type (  )  ;   method getter = property . get read method (  )  ;   method setter = property . get write method (  )  ;  getter . set accessible ( true )  ;  setter . set accessible ( true )  ;  this . accessor = getter::invoke ;  this . mutator = setter::invoke ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\main\java\org\jdbi\v3\jpa\internal\BindJpaFactory.java,create for parameter,@ override public  sql statement parameter customizer   (  annotation annotation  class <  ?  >  sql object type  method method  parameter param int index  type type )  {   bind jpa bind =  (  bind jpa ) annotation ;  final  string prefix ;  if  ( bind . 
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\main\java\org\jdbi\v3\jpa\internal\BindJpaFactory.java,read member,"private static  object   (  object entity  jpa member member )  {  try  {  return member . read ( entity )  ;   }  catch  (   illegal access exception e )   {   string message =  string . format ( "" unable to access property value for column %s"" member . get column name (  )  )  ;  throw new  entity member access exception ( message e )  ;   }  catch  (   invocation target exception e )   {   string message =  string . format ( "" exception thrown in accessor method for column %s"" member . get column name (  )  )  ;  throw new  entity member access exception ( message e )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\main\java\org\jdbi\v3\jpa\JpaPlugin.java,customize jdbi,@ override public void   (  jdbi db )  {  db . register row mapper ( new  jpa mapper factory (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\main\java\org\jdbi\v3\jpa\JpaMapper.java, jpa mapper,  (  class < c >  clazz )  {  this . clazz = clazz ;  this . jpa class =  jpa class . get ( clazz )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\main\java\org\jdbi\v3\jpa\JpaMapper.java,map,@ override public c   (  result set rs  statement context ctx )  throws sql exception  {  return specialize ( rs ctx )  . map ( rs ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\main\java\org\jdbi\v3\jpa\JpaMapperFactory.java,build,@ override public  optional <  row mapper <  ?  >  >    (  type type  config registry config )  {   class <  ?  >  clazz = get erased type ( type )  ;  return clazz . is annotation present (  entity . class )   ?   optional . of ( new  jpa mapper <  >  ( 
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\test\java\org\jdbi\v3\jpa\JpaTest.java, annotation priority thing,public   ( int id  string name )  {  set id ( id )  ;  set name ( name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\test\java\org\jdbi\v3\jpa\JpaTest.java, entity thing,public   ( int id  string name )  {  set id ( id )  ;  set name ( name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\test\java\org\jdbi\v3\jpa\JpaTest.java, extends mapped superclass thing,public   ( int id  string name )  {  set id ( id )  ;  set name ( name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\test\java\org\jdbi\v3\jpa\JpaTest.java, field thing,public   ( int id  string name )  {  set id ( id )  ;  set name ( name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\test\java\org\jdbi\v3\jpa\JpaTest.java, getter thing,public   ( int id  string name )  {  set id ( id )  ;  set name ( name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\test\java\org\jdbi\v3\jpa\JpaTest.java, named field thing,public   ( int id  string name )  {  set id ( id )  ;  set name ( name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\test\java\org\jdbi\v3\jpa\JpaTest.java, named getter thing,public   ( int id  string name )  {  set id ( id )  ;  set name ( name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\test\java\org\jdbi\v3\jpa\JpaTest.java, named setter thing,public   ( int id  string name )  {  set id ( id )  ;  set name ( name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\test\java\org\jdbi\v3\jpa\JpaTest.java, overriding subclass thing,public   ( int id  string name )  {  set id ( id )  ;  set name ( name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\test\java\org\jdbi\v3\jpa\JpaTest.java, setter thing,public   ( int id  string name )  {  set id ( id )  ;  set name ( name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\test\java\org\jdbi\v3\jpa\JpaTest.java,assert that thing,"private static  < t extends  thing >  abstract list assert <  ?   ?  extends  list <  ?  extends t >  t  ?  >    (  list < t >  rs )  {  return assert that ( rs )  . using element comparator (  (  comparator < t >  )  ( left right )   -  >   {  if  ( left . get id (  )   =  =  right . get id (  )  )   {  return  objects . to string ( left . get name (  )  """" )  . compare to (  objects . to string ( right . get name (  )  """" )  )  ;   }  return left . get id (  )   <  right . get id (  )   ?   - 1 : 1 ;   }   )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\test\java\org\jdbi\v3\jpa\JpaTest.java,get id,"@ override @ column ( name = ""meow"" )  public int   (  )  {  return super . get id (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\test\java\org\jdbi\v3\jpa\JpaTest.java,get name,public  string   (  )  {  return name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\test\java\org\jdbi\v3\jpa\PluginTest.java, thing,public   ( int id  string name )  {  set id ( id )  ;  set name ( name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\test\java\org\jdbi\v3\jpa\PluginTest.java,equals,@ override public boolean   (  object o )  {  if  ( o instanceof  thing )   {   thing thing =  (  thing ) o ;  return id  =  =  thing . id &&  objects . equals ( name thing . name )  ;   }  return false ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\test\java\org\jdbi\v3\jpa\PluginTest.java,get id,public int   (  )  {  return id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\test\java\org\jdbi\v3\jpa\PluginTest.java,get name,public  string   (  )  {  return name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\test\java\org\jdbi\v3\jpa\PluginTest.java,hash code,@ override public int   (  )  {  return  objects . hash ( id name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\noparameters\src\test\java\org\jdbi\v3\noparameters\TestSqlObjectNoParameterNames.java,bind list missing name,"@ test public void   (  )  throws  exception  {  assert that thrown by (  (  )   -  >  h . attach (  bind list without name dao . class )  . list by ids ( 1 )  )  . is instance of (  unsupported operation exception . class )  . has message containing ( ""p"
C:\Users\User\Desktop\Thesis\jdbi\noparameters\src\test\java\org\jdbi\v3\noparameters\TestSqlObjectNoParameterNames.java,bind list with name,"@ test public void   (  )  throws  exception  {  assert that ( h . attach (  bind list with name dao . class )  . list by ids ( 1 )  )  . contains ( new  something ( 1 "" elsie  hughes"" )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\noparameters\src\test\java\org\jdbi\v3\noparameters\TestSqlObjectNoParameterNames.java,define list with name,"@ test public void   (  )  throws  exception  {  assert that ( h . attach (  define list with name dao . class )  . list by ids ( ""1"" )  )  . contains exactly ( new  something ( 1 "" elsie  hughes"" )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\noparameters\src\test\java\org\jdbi\v3\noparameters\TestSqlObjectNoParameterNames.java,define list without name,"@ test public void   (  )  throws  exception  {  assert that thrown by (  (  )   -  >  h . attach (  define list without name dao . class )  . list by ids ( ""1"" )  )  . is instance of (  unsupported operation exception . class )  . has message containing "
C:\Users\User\Desktop\Thesis\jdbi\noparameters\src\test\java\org\jdbi\v3\noparameters\TestSqlObjectNoParameterNames.java,define missing name,"@ test public void   (  )  throws  exception  {  assert that thrown by (  (  )   -  >  h . attach (  define without name dao . class )  . get by id ( 1 )  )  . is instance of (  unsupported operation exception . class )  . has message containing ( ""parame"
C:\Users\User\Desktop\Thesis\jdbi\noparameters\src\test\java\org\jdbi\v3\noparameters\TestSqlObjectNoParameterNames.java,define with name,"@ test public void   (  )  throws  exception  {  assert that ( h . attach (  define with name dao . class )  . get by id ( 1 )  )  . is equal to ( new  something ( 1 "" elsie  hughes"" )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\noparameters\src\test\java\org\jdbi\v3\noparameters\TestSqlObjectNoParameterNames.java,explicit bind named,@ test public void   (  )  throws  exception  {  assert that thrown by (  (  )   -  >  h . attach (  bind dao . class )  . get by id explicit bind named ( 1 )  )  . is instance of (  unable to execute statement exception . class )  . has message containin
C:\Users\User\Desktop\Thesis\jdbi\noparameters\src\test\java\org\jdbi\v3\noparameters\TestSqlObjectNoParameterNames.java,explicit bind positional,"@ test public void   (  )  throws  exception  {  assert that ( h . attach (  bind dao . class )  . get by id explicit bind positional ( 1 )  )  . is equal to ( new  something ( 1 "" elsie  hughes"" )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\test\java\org\jdbi\v3\oracle12\OracleDatabaseRule.java,after,"@ override protected void   (  )  {  try  {  shared handle . execute ( ""drop table something"" )  ;  shared handle . execute ( ""drop sequence something   id   sequence"" )  ;  con . close (  )  ;   }  catch  (  sql exception e )   {  throw new  assertion er"
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\test\java\org\jdbi\v3\oracle12\OracleDatabaseRule.java,before,"@ override protected void   (  )  throws  throwable  {  db =  jdbi . create ( uri ""hr"" ""oracle"" )  ;  if  ( install plugins )   {  db . install plugins (  )  ;   }  plugins . for each ( db::install plugin )  ;  try  {  shared handle = db . open (  )  ;   "
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\test\java\org\jdbi\v3\oracle12\OracleDatabaseRule.java,get connection factory,public  connection factory   (  )  {  return  (  )   -  >   driver manager . get connection ( get connection string (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\test\java\org\jdbi\v3\oracle12\OracleDatabaseRule.java,get connection string,public  string   (  )  {  return uri ;   }  
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\test\java\org\jdbi\v3\oracle12\OracleDatabaseRule.java,get jdbi,@ override public  jdbi   (  )  {  return db ;   }  
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\test\java\org\jdbi\v3\oracle12\OracleDatabaseRule.java,get shared handle,public  handle   (  )  {  return shared handle ;   }  
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\test\java\org\jdbi\v3\oracle12\OracleDatabaseRule.java,open handle,public  handle   (  )  {  return get jdbi (  )  . open (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\test\java\org\jdbi\v3\oracle12\OracleDatabaseRule.java,with plugin,public  oracle database rule   (  jdbi plugin plugin )  {  plugins . add ( plugin )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\test\java\org\jdbi\v3\oracle12\OracleDatabaseRule.java,with plugins,public  oracle database rule   (  )  {  install plugins = true ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\main\java\org\jdbi\v3\oracle12\OracleReturning.java, return param,  ( int index int oracle type )  {  this . name = null ;  this . index = index ;  this . oracle type = oracle type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\main\java\org\jdbi\v3\oracle12\OracleReturning.java,apply,@ override public void   ( int position  prepared statement statement  statement context ctx )  throws sql exception  {  unwrap oracle statement ( statement )  . register return parameter ( position oracle type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\main\java\org\jdbi\v3\oracle12\OracleReturning.java,before binding,@ override public void   (  prepared statement stmt  statement context ctx )  throws sql exception  {  for  (   return param return param : return params )   {  return param . bind ( ctx . get binding (  )  )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\main\java\org\jdbi\v3\oracle12\OracleReturning.java,bind,void   (  binding binding )  {  if  ( name  =  =  null )   {  binding . add positional ( index this )  ;   }  else  {  binding . add named ( name this )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\main\java\org\jdbi\v3\oracle12\OracleReturning.java,get return result set,"private static  supplier <  result set >    (  supplier <  prepared statement >  supplier  statement context ctx )  {  return  (  )   -  >   {   prepared statement stmt = supplier . get (  )  ;  try  {  if  (  ! stmt . is wrapper for (  oracle prepared statement . class )  )   {  throw new  illegal state exception ( "" statement is not an instance of  nor a wrapper of   oracle prepared statement"" )  ;   }   oracle prepared statement statement = stmt . unwrap (  oracle prepared statement . class )  ;   result set rs = statement . get return result set (  )  ;  if  ( rs  !  =  null )   {  ctx . add cleanable ( rs::close )  ;   }  return rs ;   }  catch  (  sql exception e )   {  throw new  result set exception ( "" unable to retrieve return result set"" e ctx )  ;   }   }   ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\main\java\org\jdbi\v3\oracle12\OracleReturning.java,register,public  return parameters   (  string name int oracle type )  {  return params . add ( new  return param ( name oracle type )  )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\main\java\org\jdbi\v3\oracle12\OracleReturning.java,return parameters,public static  return parameters   (  )  {  return new  return parameters (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\main\java\org\jdbi\v3\oracle12\OracleReturning.java,returning dml,public static  result producer <  result bearing >    (  )  {  return  ( supplier ctx )   -  >   result bearing . of ( get return result set ( supplier ctx )  ctx )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\main\java\org\jdbi\v3\oracle12\OracleReturning.java,unwrap oracle statement,"private  oracle prepared statement   (  prepared statement stmt )  throws sql exception  {  if  (  ! stmt . is wrapper for (  oracle prepared statement . class )  )   {  throw new  illegal state exception ( "" statement is not an instance of  nor a wrapper of   oracle prepared statement"" )  ;   }  return stmt . unwrap (  oracle prepared statement . class )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\main\java\org\jdbi\v3\postgres\DurationArgumentFactory.java, duration argument factory,public   (  )  {  super (  types . other )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\main\java\org\jdbi\v3\postgres\DurationArgumentFactory.java,build,@ override public  argument   (  duration duration  config registry config )  {  final boolean is negative = duration . is negative (  )  ;  if  ( is negative )   {  duration = duration . negated (  )  ;   }  final long days = duration . to days (  )  ;  
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\main\java\org\jdbi\v3\postgres\DurationColumnMapperFactory.java,build,@ override public  optional <  column mapper <  ?  >  >    (  type type  config registry config )  {  if  ( type  !  =   duration . class )   {  return  optional . empty (  )  ;   }  return  optional . of (  ( r i c )   -  >   {  final  object obj = r . g
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\main\java\org\jdbi\v3\postgres\HStoreArgumentFactory.java,h store argument factory,public   (  )  {  super (  types . other )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\main\java\org\jdbi\v3\postgres\HStoreArgumentFactory.java,build,@ override protected  argument   (  map value  config registry config )  {  return  ( i p cx )   -  >  p . set object ( i value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\main\java\org\jdbi\v3\postgres\HStoreColumnMapper.java,map,"@ override @ suppress warnings ( ""unchecked"" )  public  map <  string  string >    (  result set r int column number  statement context ctx )  throws sql exception  {  return  (  map <  string  string >  ) r . get object ( column number )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\main\java\org\jdbi\v3\postgres\InetArgumentFactory.java, inet argument factory,public   (  )  {  super (  types . other )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\main\java\org\jdbi\v3\postgres\InetArgumentFactory.java,build,@ override protected  argument   (  inet address value  config registry config )  {  return  ( i p cx )   -  >  p . set object ( i value . get host address (  )   types . other )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\jpa\src\main\java\org\jdbi\v3\jpa\EntityMemberAccessException.java, entity member access exception,public   (  string message )  {  super ( message )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\main\java\org\jdbi\v3\postgres\JavaTimeMapperFactory.java,build,@ override public  optional <  column mapper <  ?  >  >    (  type type  config registry config )  {  if  ( type  =  =   local date . class || type  =  =   local time . class || type  =  =   local date time . class || type  =  =   offset date time . class
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\main\java\org\jdbi\v3\postgres\JavaTimeArgumentFactory.java,build,@ override public  optional <  argument >    (  type type  object value  config registry config )  {  if  ( type  =  =   local date . class )   {  return  optional . of ( new  object argument ( value  types . date )  )  ;   }  if  ( type  =  =   local tim
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\main\java\org\jdbi\v3\postgres\PeriodArgumentFactory.java, period argument factory,public   (  )  {  super (  types . other )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\main\java\org\jdbi\v3\postgres\PeriodArgumentFactory.java,build,@ override public  argument   (  period period  config registry config )  {  pg interval interval = new pg interval ( period . get years (  )  period . get months (  )  period . get days (  )  0 0 0 )  ;  return  ( i p cx )   -  >  p . set object ( i inte
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\main\java\org\jdbi\v3\postgres\PostgresPlugin.java,customize jdbi,@ override public void   (  jdbi db )  {  db . register argument ( new  typed enum argument factory (  )  )  ;  db . register argument ( new  java time argument factory (  )  )  ;  db . register argument ( new  duration argument factory (  )  )  ;  db . r
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\main\java\org\jdbi\v3\postgres\TypedEnumArgumentFactory.java, typed enum argument factory,public   (  )  {  super (  types . other )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\main\java\org\jdbi\v3\postgres\TypedEnumArgumentFactory.java,build,@ override protected  argument   (  enum value  config registry config )  {  return  ( p s c )   -  >  s . set object ( p value  types . other )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\main\java\org\jdbi\v3\postgres\UUIDArgumentFactory.java,uuid argument factory,public   (  )  {  super (  types . other )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\main\java\org\jdbi\v3\postgres\UUIDArgumentFactory.java,build,@ override protected  argument   ( uuid value  config registry config )  {  return  ( i stmt ctx )   -  >  stmt . set object ( i value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\test\java\org\jdbi\v3\oracle12\TestOracleReturning.java,test returning dml named params,"@ test public void   (  )  {   handle h = db rule . get shared handle (  )  ;   list <  integer >  ids = h . create update ( ""insert into something ( id  name )  values  ( :id  :name )  returning id into :result"" )  . bind bean ( new  something ( 17 "" bri"
C:\Users\User\Desktop\Thesis\jdbi\oracle12\src\test\java\org\jdbi\v3\oracle12\TestOracleReturning.java,test returning dml positional params,"@ test public void   (  )  {   handle h = db rule . get shared handle (  )  ;   list <  integer >  ids = h . create update ( ""insert into something ( id  name )  values  (  ?    ?  )  returning id into  ? "" )  . bind ( 0 17 )  . bind ( 1 "" brian"" )  . add"
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\main\java\org\jdbi\v3\postgres\PeriodColumnMapperFactory.java,build,@ override public  optional <  column mapper <  ?  >  >    (  type type  config registry config )  {  if  ( type  !  =   period . class )   {  return  optional . empty (  )  ;   }  return  optional . of (  ( r i c )   -  >   {  final  object obj = r . get
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\PostgresDbRule.java,rule,public static  jdbi rule   (  )  {  return  jdbi rule . embedded postgres (  )  . with plugin ( new  sql object plugin (  )  )  . with plugin ( new  postgres plugin (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestDuration.java,set up,"@ before public void   (  )  throws  exception  {  handle = postgres db rule . get handle (  )  ;  handle . use transaction ( h  -  >   {  h . execute ( ""drop table if exists intervals"" )  ;  h . execute ( ""create table intervals ( id int not null  foo in"
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestDuration.java,test duration too precise,"@ test ( expected =  illegal argument exception . class )  public void   (  )  {  handle . execute ( ""insert into intervals ( id  foo )  values (  ?    ?  ) "" 12  duration . of nanos ( 100 )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestDuration.java,test handles nulls,"@ test public void   (  )  {  handle . execute ( ""insert into intervals ( id  foo )  values (  ?    ?  ) "" 5 null )  ;  final  duration d = handle . create query ( ""select foo from intervals where id =  ? "" )  . bind ( 0 5 )  . map to (  duration . class "
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestDuration.java,test invalid duration,"@ test ( expected =  illegal argument exception . class )  public void   (  )  {  handle . create query ( ""select foo from intervals where id =  ? "" )  . bind ( 0 3 )  . map to (  duration . class )  . find only (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestDuration.java,test read negative duration,"@ test public void   (  )  {  handle . execute ( ""insert into intervals ( id  foo )  values (  ?   interval ' - 2 days  - 3 hours' ) "" 7 )  ;  final  duration d = handle . create query ( ""select foo from intervals where id =  ? "" )  . bind ( 0 7 )  . map "
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestDuration.java,test reads via fluentapi,"@ test public void   (  )  {   list <  duration >  periods = handle . create query ( ""select foo from intervals where id  =  1 or id  =  2 order by id"" )  . map to (  duration . class )  . list (  )  ;  assert that ( periods )  . is equal to (  immutable "
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestDuration.java,test tiny duration,"@ test public void   (  )  {  handle . execute ( ""insert into intervals ( id  foo )  values (  ?   interval '13us' ) "" 11 )  ;  final  duration d = handle . create query ( ""select foo from intervals where id =  ? "" )  . bind ( 0 11 )  . map to (  duration"
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestDuration.java,test trivial duration,"@ test public void   (  )  {  handle . execute ( ""insert into intervals ( id  foo )  values (  ?    ?  ) "" 4  duration . zero )  ;   duration d = handle . create query ( ""select foo from intervals where id =  ? "" )  . bind ( 0 4 )  . map to (  duration . "
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestDuration.java,test write duration too big,"@ test ( expected =  illegal argument exception . class )  public void   (  )  {  handle . execute ( ""insert into intervals ( id  foo )  values (  ?    ?  ) "" 9  duration . of days (  ( long )  integer . max   value  +  1 )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestDuration.java,test write duration too small,"@ test ( expected =  arithmetic exception . class )  public void   (  )  {  handle . execute ( ""insert into intervals ( id  foo )  values (  ?    ?  ) "" 10  duration . of seconds (  long . min   value )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestDuration.java,test write read negative duration,"@ test public void   (  )  {  handle . execute ( ""insert into intervals ( id  foo )  values (  ?    ?  ) "" 8  duration . of days (  - 3 )  . plus minutes ( 2 )  )  ;  final  duration d = handle . create query ( ""select foo from intervals where id =  ? "" )"
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestDuration.java,test writes via fluent api,"@ test public void   (  )  {  handle . execute ( ""insert into intervals ( id  foo )  values (  ?    ?  ) "" 6 test duration )  ;  final  duration d = handle . create query ( ""select foo from intervals where id =  ? "" )  . bind ( 0 6 )  . map to (  duration"
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestInetAddressPg.java,get inet type,"@ override protected  string   (  )  {  return ""inet"" ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestJavaTime.java,instant,"@ test public void   (  )  {  final  instant leap =  instant . of epoch milli (  - 14159025000l )  ;  h . execute ( ""insert into stuff values (  ?  ) "" leap )  ;  assert that ( h . create query ( ""select ts from stuff"" )  . map to (  instant . class )  . "
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestJavaTime.java,local date,"@ test public void   (  )  {   local date d =  local date . now (  )  ;  h . execute ( ""insert into stuff ( d )  values  (  ?  ) "" d )  ;  assert that ( h . create query ( ""select d from stuff"" )  . map to (  local date . class )  . find only (  )  )  . i"
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestJavaTime.java,local date time,"@ test public void   (  )  {   local date time d =  local date time . now (  )  ;  h . execute ( ""insert into stuff ( ts )  values  (  ?  ) "" d )  ;  assert that ( h . create query ( ""select ts from stuff"" )  . map to (  local date time . class )  . find "
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestJavaTime.java,local time,"@ test public void   (  )  {  h . execute ( ""create table schedule  ( start time  stop time ) "" )  ;   local time start =  local time . of ( 8 30 0 )  ;   local time stop =  local time . of ( 10 30 0 )  ;  h . execute ( ""insert into schedule  ( start  sto"
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestJavaTime.java,offset date time,"@ test public void   (  )  {   offset date time dt =  offset date time . now (  )  . with offset same instant (  zone offset . utc )  ;  h . execute ( ""insert into stuff ( ts )  values  (  ?  ) "" dt )  ;  assert that ( h . create query ( ""select ts from s"
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestJavaTime.java,offset date time loses offset,"@ test public void   (  )  {   offset date time dt =  offset date time . now (  )  . with offset same instant (  zone offset . of hours (  - 7 )  )  ;  h . execute ( ""insert into stuff ( ts )  values  (  ?  ) "" dt )  ;  assert that ( dt . is equal ( h . c"
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestJavaTime.java,set up,"@ before public void   (  )  {  h = db . get handle (  )  ;  h . use transaction ( th  -  >   {  th . execute ( ""drop table if exists stuff"" )  ;  th . execute ( ""create table stuff  ( ts timestamp  d date  z text ) "" )  ;   }   )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestJavaTime.java,zone id,"@ test public void   (  )  {  final  zone id zone =  zone id . system default (  )  ;  h . execute ( ""insert into stuff ( z )  values  (  ?  ) "" zone )  ;  assert that ( h . create query ( ""select z from stuff"" )  . map to (  zone id . class )  . find onl"
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestPeriod.java,set up,"@ before public void   (  )  throws  exception  {  handle = postgres db rule . get handle (  )  ;  handle . use transaction ( h  -  >   {  h . execute ( ""drop table if exists intervals"" )  ;  h . execute ( ""create table intervals ( id int not null  foo in"
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestPeriod.java,test handles nulls,"@ test public void   (  )  {  handle . execute ( ""insert into intervals ( id  foo )  values (  ?    ?  ) "" 5 null )  ;  final  period p = handle . create query ( ""select foo from intervals where id =  ? "" )  . bind ( 0 5 )  . map to (  period . class )  ."
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestPeriod.java,test invalid period,"@ test ( expected =  illegal argument exception . class )  public void   (  )  {  handle . create query ( ""select foo from intervals where id =  ? "" )  . bind ( 0 3 )  . map to (  period . class )  . find only (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestPeriod.java,test negative period,"@ test public void   (  )  {  handle . execute ( ""insert into intervals ( id  foo )  values (  ?   interval ' - 3 years  - 1 month 2 days' ) "" 7 )  ;  final  period p = handle . create query ( ""select foo from intervals where id =  ? "" )  . bind ( 0 7 )  "
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestPeriod.java,test reads via fluentapi,"@ test public void   (  )  {   list <  period >  periods = handle . create query ( ""select foo from intervals where id  =  1 or id  =  2 order by id"" )  . map to (  period . class )  . list (  )  ;  assert that ( periods )  . is equal to (  immutable list"
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestPeriod.java,test trivial period,"@ test public void   (  )  {  handle . execute ( ""insert into intervals ( id  foo )  values (  ?    ?  ) "" 4  period . of ( 0 0 0 )  )  ;   period p = handle . create query ( ""select foo from intervals where id =  ? "" )  . bind ( 0 4 )  . map to (  period"
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestPeriod.java,test writes via fluent api,"@ test public void   (  )  {  handle . execute ( ""insert into intervals ( id  foo )  values (  ?    ?  ) "" 6 test period )  ;  final  period p = handle . create query ( ""select foo from intervals where id =  ? "" )  . bind ( 0 6 )  . map to (  period . cla"
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestTypedEnum.java,setup dbi,"@ before public void   (  )  throws  exception  {  h = db . get handle (  )  ;  h . use transaction ( th  -  >   {  th . execute ( ""drop table if exists values"" )  ;  th . execute ( ""drop type if exists enum   t"" )  ;  th . execute ( ""create type enum   t"
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestTypedEnum.java,test bind,"@ test public void   (  )  throws  exception  {  h . create update ( ""insert into values values ( :value ) "" )  . bind ( ""value""  enumt . bar )  . execute (  )  ;  assert that ( h . create query ( ""select * from values"" )  . map to (  string . class )  . "
C:\Users\User\Desktop\Thesis\jdbi\postgres\src\test\java\org\jdbi\v3\postgres\TestTypedEnum.java,test map,"@ test public void   (  )  throws  exception  {  h . create update ( ""insert into values values ( 'baz' ) "" )  . execute (  )  ;  assert that ( h . create query ( ""select * from values"" )  . map to (  enumt . class )  . find only (  )  )  . is equal to ( "
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\main\java\org\jdbi\v3\spring4\JdbiFactoryBean.java, jdbi factory bean,public   (  data source data source )  {  this . data source = data source ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\main\java\org\jdbi\v3\spring4\JdbiFactoryBean.java,after properties set,"@ post construct private void   (  )  {  if  ( data source  =  =  null )   {  throw new  illegal state exception ( ""'data source' property must be set"" )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\main\java\org\jdbi\v3\spring4\JdbiFactoryBean.java,get object,@ override public  jdbi   (  )  throws  exception  {  final  jdbi jdbi =  jdbi . create (  (  )   -  >   data source utils . get connection ( data source )  )  ;  if  ( auto install plugins )   {  jdbi . install plugins (  )  ;   }  plugins . for each ( j
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\main\java\org\jdbi\v3\spring4\JdbiFactoryBean.java,get object type,@ override public  class <  jdbi >    (  )  {  return  jdbi . class ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\main\java\org\jdbi\v3\spring4\JdbiFactoryBean.java,is singleton,@ override public boolean   (  )  {  return true ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\main\java\org\jdbi\v3\spring4\JdbiFactoryBean.java,set auto install plugins,public  jdbi factory bean   ( boolean auto install plugins )  {  this . auto install plugins = auto install plugins ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\main\java\org\jdbi\v3\spring4\JdbiFactoryBean.java,set data source,public  jdbi factory bean   (  data source data source )  {  this . data source = data source ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\main\java\org\jdbi\v3\spring4\JdbiFactoryBean.java,set global defines,public void   (  map <  string  object >  defines )  {  global defines . put all ( defines )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\main\java\org\jdbi\v3\spring4\JdbiFactoryBean.java,set plugins,@ autowired ( required = false )  public  jdbi factory bean   (  collection <  jdbi plugin >  plugins )  {  this . plugins = new  array list <  >  ( plugins )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\main\java\org\jdbi\v3\spring4\JdbiUtil.java, adapter,  (  jdbi db  handle handle )  {  this . db = db ;  this . handle = handle ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\main\java\org\jdbi\v3\spring4\JdbiUtil.java,before completion,@ override public void   (  )  {  transactional   handles . remove ( handle )  ;   transaction synchronization manager . unbind resource ( db )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\main\java\org\jdbi\v3\spring4\JdbiUtil.java,close if needed,public static void   (  handle handle )  {  if  (  ! transactional   handles . contains ( handle )  )   {  handle . close (  )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\main\java\org\jdbi\v3\spring4\JdbiUtil.java,get handle,public static  handle   (  jdbi jdbi )  {   handle bound =  (  handle )  transaction synchronization manager . get resource ( jdbi )  ;  if  ( bound  =  =  null )   {  bound = jdbi . open (  )  ;  if  (  transaction synchronization manager . is synchronization active (  )  )   {   transaction synchronization manager . bind resource ( jdbi bound )  ;   transaction synchronization manager . register synchronization ( new  adapter ( jdbi bound )  )  ;  transactional   handles . add ( bound )  ;   }   }  return bound ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\main\java\org\jdbi\v3\spring4\JdbiUtil.java,resume,@ override public void   (  )  {   transaction synchronization manager . bind resource ( db handle )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\main\java\org\jdbi\v3\spring4\JdbiUtil.java,suspend,@ override public void   (  )  {   transaction synchronization manager . unbind resource ( db )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\AutoPlugin.java,customize jdbi,@ override public void   (  jdbi jdbi )  {  jdbi . define ( key value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\DummyService.java, dummy service,public   (  jdbi jdbi )  {  this . jdbi = jdbi ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\DummyService.java,in nested,@ override @ transactional ( propagation =  propagation . nested )  public void   (  callback c )  {  c . call ( jdbi )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\DummyService.java,in propagation required,@ override @ transactional ( propagation =  propagation . required )  public void   (  callback c )  {  c . call ( jdbi )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\DummyService.java,in requires new,@ override @ transactional ( propagation =  propagation . requires   new )  public void   (  callback c )  {  c . call ( jdbi )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\DummyService.java,in requires new read uncommitted,@ override @ transactional ( propagation =  propagation . requires   new isolation =  isolation . read   uncommitted )  public void   (  callback c )  {  c . call ( jdbi )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\ManualPlugin.java,customize jdbi,@ override public void   (  jdbi jdbi )  {  jdbi . define ( key value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\TestJdbiFactoryBean.java,set data source,@ autowired public void   (  data source ds )  {  this . ds = ds ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\TestJdbiFactoryBean.java,set jdbi,@ autowired public void   (  jdbi jdbi )  {  this . jdbi = jdbi ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\TestJdbiFactoryBean.java,set service,@ autowired public void   (  service service )  {  this . service = service ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\TestJdbiFactoryBean.java,test auto installed plugin,@ test public void   (  )  throws  exception  {  assert that ( jdbi . get config (  sql statements . class )  . get attribute (  auto plugin . key )  )  . is equal to (  auto plugin . value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\TestJdbiFactoryBean.java,test fails via exception,@ test public void   (  )  throws  exception  {  assert that exception of type (  force rollback . class )  . is thrown by (  (  )   -  >   {  service . in propagation required ( jdbi  -  >   {   handle h =  jdbi util . get handle ( jdbi )  ;  final int c
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\TestJdbiFactoryBean.java,test global defined attribute,"@ test public void   (  )  throws  exception  {  assert that ( jdbi . get config (  sql statements . class )  . get attribute ( ""foo"" )  )  . is equal to ( ""bar"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\TestJdbiFactoryBean.java,test manual installed plugin,@ test public void   (  )  throws  exception  {  assert that ( jdbi . get config (  sql statements . class )  . get attribute (  manual plugin . key )  )  . is equal to (  manual plugin . value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\TestJdbiFactoryBean.java,test nested,@ test public void   (  )  throws  exception  {  assert that exception of type (  force rollback . class )  . is thrown by (  (  )   -  >   {  service . in propagation required ( outer  -  >   {  final  handle h =  jdbi util . get handle ( outer )  ;  h .
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\TestJdbiFactoryBean.java,test requires new,"@ test public void   (  )  throws  exception  {  service . in propagation required ( outer  -  >   {  final  handle h =  jdbi util . get handle ( outer )  ;  h . execute ( ""insert into something  ( id  name )  values  ( 7  'ignored' ) "" )  ;  assert that "
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\TestJdbiFactoryBean.java,test service is actually set,@ test public void   (  )  throws  exception  {  assert that ( service )  . is not null (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlite\src\main\java\org\jdbi\v3\sqlite3\SQLitePlugin.java,customize jdbi,@ override public void   (  jdbi jdbi )  {  jdbi . register argument ( new url argument factory (  )  )  ;  jdbi . register column mapper ( new url column mapper (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\TestPluginInstall.java,customize jdbi,@ override public void   (  jdbi db )  {  pluginb called = true ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\TestPluginInstall.java,jdbi factory,@ bean public  jdbi factory bean   (  )  {  return new  jdbi factory bean (  )  . set data source ( new  driver manager data source (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\TestPluginInstall.java,plugina,@ bean public  jdbi plugin   (  )  {  return new  jdbi plugin (  )  {  @ override public void customize jdbi (   jdbi db )  {  plugina called = true ;   }   }   ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\TestPluginInstall.java,pluginb,@ bean public  jdbi plugin   (  )  {  return new  jdbi plugin (  )  {  @ override public void customize jdbi (   jdbi db )  {  pluginb called = true ;   }   }   ;   }  
C:\Users\User\Desktop\Thesis\jdbi\spring4\src\test\java\org\jdbi\v3\spring4\TestPluginInstall.java,test plugins installed,@ test public void   (  )  {  assert that ( db )  . is not null (  )  ;  assert that ( config . plugina called )  . is true (  )  ;  assert that ( config . pluginb called )  . is true (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\Configurer.java,configure for method,"default void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  throw new  unsupported operation exception ( "" not supported for method"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\Configurer.java,configure for type,"default void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {  throw new  unsupported operation exception ( "" not supported for type"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlite\src\main\java\org\jdbi\v3\sqlite3\URLColumnMapper.java,map,@ override public url   (  result set r int column number  statement context ctx )  throws sql exception  {  try  {  return new url ( r . get string ( column number )  )  ;   }  catch  (   malformedurl exception e )   {  throw new sql exception ( e )  ;  
C:\Users\User\Desktop\Thesis\jdbi\sqlite\src\main\java\org\jdbi\v3\sqlite3\URLArgumentFactory.java,url argument factory,public   (  )  {  super (  types . varchar )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlite\src\main\java\org\jdbi\v3\sqlite3\URLArgumentFactory.java,build,@ override protected  argument   ( url url  config registry config )  {  return  ( position statement ctx )   -  >  statement . set string ( position url . to string (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlite\src\test\java\org\jdbi\v3\sqlite3\TestUrls.java,set up,"@ before public void   (  )  throws  exception  {   jdbi jdbi =  jdbi . create ( ""jdbc:sqlite::memory:"" )  ;  jdbi . install plugin ( new sq lite plugin (  )  )  ;  handle = jdbi . open (  )  ;  handle . use transaction ( handle  -  >  handle . execute ( "
C:\Users\User\Desktop\Thesis\jdbi\sqlite\src\test\java\org\jdbi\v3\sqlite3\TestUrls.java,tear down,@ after public void   (  )  throws  exception  {  handle . close (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlite\src\test\java\org\jdbi\v3\sqlite3\TestUrls.java,test insert null url using bind by type,"@ test ( expected =  result set exception . class )  public void   (  )  {  handle . create update ( ""insert into foo values  ( :url ) "" )  . bind by type ( ""url"" null url . class )  . execute (  )  ;  handle . create query ( ""select url from foo"" )  . ma"
C:\Users\User\Desktop\Thesis\jdbi\sqlite\src\test\java\org\jdbi\v3\sqlite3\TestUrls.java,test insert url successful,"@ test public void   (  )  throws  malformedurl exception  {   string google string = ""http: /  / www . google . com"" ;  url google url = new url ( google string )  ;  handle . create update ( ""insert into foo values  ( :url ) "" )  . bind ( ""url"" google u"
C:\Users\User\Desktop\Thesis\jdbi\sqlite\src\test\java\org\jdbi\v3\sqlite3\TestUrls.java,test insert url using bind by type,"@ test public void   (  )  throws  malformedurl exception  {  url github url = new url ( ""http: /  / www . github . com"" )  ;  handle . create update ( ""insert into foo values  ( :url ) "" )  . bind by type ( ""url"" github url url . class )  . execute (  ) "
C:\Users\User\Desktop\Thesis\jdbi\sqlite\src\test\java\org\jdbi\v3\sqlite3\TestUrls.java,test map null url throws exception,"@ test ( expected =  result set exception . class )  public void   (  )  {  handle . create update ( ""insert into foo values  ( :url ) "" )  . bind ( ""url""  (  ( url ) null )  )  . execute (  )  ;  handle . create query ( ""select url from foo"" )  . map to "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterArgumentFactoriesImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterArgumentFactoriesImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   configurer delegate = new  register argument factory impl (  )  ;   register argument factories factories =  (  register argument factories 
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterArgumentFactoryImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterArgumentFactoryImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   register argument factory raf =  (  register argument factory ) annotation ;   arguments arguments = registry . get (  arguments . class )  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\KeyColumnImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {   key column key column =  (  key column ) annotation ;   string name = key column . value (  )  ;  registry . get (  map entry
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterBeanMapperImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterBeanMapperImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   register bean mapper register bean mapper =  (  register bean mapper ) annotation ;   class <  ?  >  bean class = register bean mapper . val
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterBeanMappersImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterBeanMappersImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   configurer delegate = new  register bean mapper impl (  )  ;   register bean mappers register bean mappers =  (  register bean mappers ) ann
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterCollectorFactoryImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterCollectorFactoryImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   register collector factory register collector factory =  (  register collector factory ) annotation ;   jdbi collectors collectors = registr
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterColumnMapperFactoriesImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterColumnMapperFactoriesImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   configurer delegate = new  register column mapper factory impl (  )  ;   register column mapper factories register column mapper factories =
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterColumnMapperImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterColumnMapperImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   register column mapper register column mapper =  (  register column mapper ) annotation ;   column mappers mappers = registry . get (  colum
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterColumnMapperFactoryImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterColumnMapperFactoryImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   register column mapper factory register column mapper factory =  (  register column mapper factory ) annotation ;  try  {   column mapper fa
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterConstructorMappersImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterConstructorMappersImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   configurer delegate = new  register constructor mapper impl (  )  ;   register constructor mappers register constructor mappers =  (  regist
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterConstructorMapperImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterConstructorMapperImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   register constructor mapper register constructor mapper =  (  register constructor mapper ) annotation ;   row mappers mappers = registry . 
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterColumnMappersImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterColumnMappersImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   configurer delegate = new  register column mapper impl (  )  ;   register column mappers register column mappers =  (  register column mappe
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterFieldMapperImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterFieldMapperImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   register field mapper register field mapper =  (  register field mapper ) annotation ;   class <  ?  >  type = register field mapper . value
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterFieldMappersImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterFieldMappersImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   configurer delegate = new  register field mapper impl (  )  ;   register field mappers register field mappers =  (  register field mappers )
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterObjectArgumentFactoriesImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterObjectArgumentFactoriesImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   configurer delegate = new  register object argument factory impl (  )  ;   register object argument factories register object argument facto
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterRowMapperFactoriesImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterRowMapperFactoriesImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   configurer delegate = new  register row mapper factory impl (  )  ;   register row mapper factories register row mapper factories =  (  regi
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterObjectArgumentFactoryImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterObjectArgumentFactoryImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   register object argument factory register object argument factory =  (  register object argument factory ) annotation ;   arguments argument
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterJoinRowMapperImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterJoinRowMapperImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   register join row mapper register join row mapper =  (  register join row mapper ) annotation ;  registry . get (  row mappers . class )  . 
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterRowMapperImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterRowMapperImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   register row mapper register row mapper =  (  register row mapper ) annotation ;  try  {  registry . get (  row mappers . class )  . registe
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterRowMappersImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterRowMappersImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   configurer delegate = new  register row mapper impl (  )  ;   register row mappers register row mappers =  (  register row mappers ) annotat
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterRowMapperFactoryImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\RegisterRowMapperFactoryImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   register row mapper factory register row mapper factory =  (  register row mapper factory ) annotation ;   row mappers mappers = registry . 
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\UseSqlParserImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {   use sql parser anno =  (  use sql parser ) annotation ;  try  {  final  sql parser parser = instantiate ( anno . value (  )  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\UseSqlParserImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   use sql parser anno =  (  use sql parser ) annotation ;  try  {  final  sql parser parser = instantiate ( anno . value (  )  sql object type
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\UseSqlParserImpl.java,instantiate,"private  sql parser   (  class <  ?  extends  sql parser >  value  class <  ?  >  sql object type  method m )  throws  exception  {  try  {   constructor <  ?  extends  sql parser >  no   arg = value . get constructor (  )  ;  return no   arg . new instance (  )  ;   }  catch  (   no such method exception e )   {  try  {   constructor <  ?  extends  sql parser >  class   arg = value . get constructor (  class . class )  ;  return class   arg . new instance ( sql object type )  ;   }  catch  (   no such method exception e1 )   {  if  ( m  !  =  null )   {   constructor <  ?  extends  sql parser >  c   m   arg = value . get constructor (  class . class  method . class )  ;  return c   m   arg . new instance ( sql object type m )  ;   }  throw new  illegal state exception ( "" unable to instantiate  no viable constructor ""  +  value . get name (  )  )  ;   }   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\ValueColumnImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {   value column value column =  (  value column ) annotation ;   string name = value column . value (  )  ;  registry . get (  m
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\UseTemplateEngineImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {   use template engine anno =  (  use template engine ) annotation ;  try  {  final  template engine template engine = instantia
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\UseTemplateEngineImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   use template engine anno =  (  use template engine ) annotation ;  try  {  final  template engine template engine = instantiate ( anno . val
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\config\internal\UseTemplateEngineImpl.java,instantiate,"private  template engine   (  class <  ?  extends  template engine >  value  class <  ?  >  sql object type  method m )  throws  exception  {  try  {   constructor <  ?  extends  template engine >  no   arg = value . get constructor (  )  ;  return no   arg . new instance (  )  ;   }  catch  (   no such method exception e )   {  try  {   constructor <  ?  extends  template engine >  class   arg = value . get constructor (  class . class )  ;  return class   arg . new instance ( sql object type )  ;   }  catch  (   no such method exception e1 )   {  if  ( m  !  =  null )   {   constructor <  ?  extends  template engine >  c   m   arg = value . get constructor (  class . class  method . class )  ;  return c   m   arg . new instance ( sql object type m )  ;   }  throw new  illegal state exception ( "" unable to instantiate  no viable constructor ""  +  value . get name (  )  )  ;   }   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\BindBeanListFactory.java,create for parameter,@ override public  sql statement parameter customizer   (  annotation annotation  class <  ?  >  sql object type  method method  parameter param int index  type type )  {  final  bind bean list bind bean list =  (  bind bean list ) annotation ;  final  st
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\BindFieldsFactory.java,create for parameter,@ override public  sql statement parameter customizer   (  annotation annotation  class <  ?  >  sql object type  method method  parameter param int index  type type )  {   bind fields bind =  (  bind fields ) annotation ;  return  ( stmt bean )   -  >   
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\BindBeanFactory.java,create for parameter,@ override public  sql statement parameter customizer   (  annotation annotation  class <  ?  >  sql object type  method method  parameter param int index  type type )  {   bind bean bind =  (  bind bean ) annotation ;  return  ( stmt bean )   -  >   {   
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\BindFactory.java,create for parameter,@ override public  sql statement parameter customizer   (  annotation annotation  class <  ?  >  sql object type  method method  parameter param int index  type type )  {   bind b =  (  bind ) annotation ;   string name from annotation = b  =  =  null  ? 
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\BindListFactory.java,create for parameter,@ override public  sql statement parameter customizer   (  annotation annotation  class <  ?  >  sql object type  method method  parameter param int index  type type )  {  final  bind list bind list =  (  bind list ) annotation ;  final  string name =  pa
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\BindMapFactory.java,create for parameter,@ override public  sql statement parameter customizer   (  annotation a  class <  ?  >  sql object type  method method  parameter param int index  type type )  {   bind map annotation =  (  bind map ) a ;   list <  string >  keys =  arrays . as list ( ann
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\BindMethodsFactory.java,create for parameter,@ override public  sql statement parameter customizer   (  annotation annotation  class <  ?  >  sql object type  method method  parameter param int index  type type )  {  return  ( stmt bean )   -  >   {  final  string prefix =  (  (  bind methods ) anno
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\DefineFactory.java,create for parameter,@ override public  sql statement parameter customizer   (  annotation annotation  class <  ?  >  sql object type  method method  parameter param int index  type type )  {   define define =  (  define ) annotation ;  final  string name =  parameter util . 
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\DefineListFactory.java,create for parameter,@ override public  sql statement parameter customizer   (  annotation annotation  class <  ?  >  sql object type  method method  parameter param int index  type type )  {  final  define list d =  (  define list ) annotation ;  final  string name =  parame
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\FetchSizeFactory.java,create for method,@ override public  sql statement customizer   (  annotation annotation  class <  ?  >  sql object type  method method )  {  return create for type ( annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\FetchSizeFactory.java,create for parameter,@ override public  sql statement parameter customizer   (  annotation annotation  class <  ?  >  sql object type  method method  parameter param int index  type type )  {  return  ( stmt fetch size )   -  >   (  (  query ) stmt )  . set fetch size (  (  i
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\FetchSizeFactory.java,create for type,@ override public  sql statement customizer   (  annotation annotation  class <  ?  >  sql object type )  {  int fetch size =  (  (  fetch size ) annotation )  . value (  )  ;  return stmt  -  >   (  (  query ) stmt )  . set fetch size ( fetch size )  ;  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\OutParameterListFactory.java,create for method,@ override public  sql statement customizer   (  annotation annotation  class <  ?  >  sql object type  method method )  {  final  out parameter list out params =  (  out parameter list ) annotation ;  return stmt  -  >   {   call call =  (  call ) stmt ;
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\MaxRowsFactory.java,create for method,@ override public  sql statement customizer   (  annotation annotation  class <  ?  >  sql object type  method method )  {  return create for type ( annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\MaxRowsFactory.java,create for parameter,@ override public  sql statement parameter customizer   (  annotation annotation  class <  ?  >  sql object type  method method  parameter param int index  type type )  {  return  ( stmt max rows )   -  >   (  (  query ) stmt )  . set max rows (  (  integ
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\MaxRowsFactory.java,create for type,@ override public  sql statement customizer   (  annotation annotation  class <  ?  >  sql object type )  {  final int max rows =  (  (  max rows ) annotation )  . value (  )  ;  return stmt  -  >   (  (  query ) stmt )  . set max rows ( max rows )  ;   }
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\QueryTimeOutFactory.java,create for method,@ override public  sql statement customizer   (  annotation annotation  class <  ?  >  sql object type  method method )  {  return create for type ( annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\QueryTimeOutFactory.java,create for parameter,@ override public  sql statement parameter customizer   (  annotation annotation  class <  ?  >  sql object type  method method  parameter param int index  type type )  {  return  ( stmt query timeout )   -  >  stmt . set query timeout (  (  integer ) que
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\QueryTimeOutFactory.java,create for type,@ override public  sql statement customizer   (  annotation annotation  class <  ?  >  sql object type )  {  int query timeout =  (  (  query time out ) annotation )  . value (  )  ;  return stmt  -  >  stmt . set query timeout ( query timeout )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\TimestampedFactory.java,create for method,@ override public  sql statement customizer   (  annotation annotation  class <  ?  >  sql object type  method method )  {  final  string parameter name =  (  (  timestamped ) annotation )  . value (  )  ;  return stmt  -  >  stmt . bind ( parameter name 
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\internal\OutParameterFactory.java,create for method,@ override public  sql statement customizer   (  annotation annotation  class <  ?  >  sql object type  method method )  {  final  out parameter out param =  (  out parameter ) annotation ;  return stmt  -  >   (  (  call ) stmt )  . register out paramete
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\SqlStatementCustomizerFactory.java,create for method,"default  sql statement customizer   (  annotation annotation  class <  ?  >  sql object type  method method )  {  throw new  unsupported operation exception ( "" not supported for method"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\SqlStatementCustomizerFactory.java,create for parameter,"default  sql statement parameter customizer   (  annotation annotation  class <  ?  >  sql object type  method method  parameter param int index  type param type )  {  throw new  unsupported operation exception ( "" not supported for parameter"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\customizer\SqlStatementCustomizerFactory.java,create for type,"default  sql statement customizer   (  annotation annotation  class <  ?  >  sql object type )  {  throw new  unsupported operation exception ( "" not supported for type"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\DefaultMethodHandler.java, default method handler,  (  method method )  {  try  {   class <  ?  >  declaring class = method . get declaring class (  )  ;  method handle = lookup for ( declaring class )  . unreflect special ( method declaring class )  ;   }  catch  (   reflective operation exception e )   {  throw new  runtime exception ( e )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\DefaultMethodHandler.java,invoke,@ override public  object   (  object target  object[] args  handle supplier handle )  {  try  {  return method handle . bind to ( target )  . invoke with arguments ( args )  ;   }  catch  (   runtime exception| error e )   {  throw e ;   }  catch  (   th
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\DefaultMethodHandler.java,lookup for,"private static  method handles .  lookup   (  class <  ?  >  clazz )  {  if  ( private   lookup   in  !  =  null )   {  try  {  return  (  method handles .  lookup ) private   lookup   in . invoke ( null clazz  method handles . lookup (  )  )  ;   }  catch  (   illegal access exception| invocation target exception e )   {   string message =  string . format ( "" error invoking  method handles . private lookup in ( %s . class   method handles . lookup (  )  )  in jdk 9 +  runtime"" clazz )  ;  throw new  runtime exception ( message e )  ;   }   }  return private lookups . compute if absent ( clazz type  -  >   {  try  {  final  constructor <  method handles .  lookup >  constructor =  method handles .  lookup . class . get declared constructor (  class . class int . class )  ;  if  (  ! constructor . is accessible (  )  )   {  constructor . set accessible ( true )  ;   }  return constructor . new instance ( type  method handles .  lookup . public |  method handles .  lookup . private |  method handles .  lookup . protected|  method handles .  lookup . package )  ;   }  catch  (   reflective operation exception e )   {  throw new  runtime exception ( e )  ;   }   }   )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\DefaultMethodHandler.java,private lookup in,"private static  method   (  )  {  try  {  return  method handles . class . get method ( ""private lookup in""  class . class  method handles .  lookup . class )  ;   }  catch  (   no such method exception e )   {  return null ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\HandlerDecorators.java, handler decorators,private   (  handler decorators that )  {  decorators . add all ( that . decorators )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\HandlerDecorators.java,apply decorators,public  handler   (  handler base  class <  ?  >  sql object type  method method )  {   handler handler = base ;  for  (   handler decorator decorator : decorators )   {  handler = decorator . decorate handler ( handler sql object type method )  ;   }  return handler ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\HandlerDecorators.java,create copy,@ override public  handler decorators   (  )  {  return new  handler decorators ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\HandlerDecorators.java,register,public  handler decorators   (  handler decorator decorator )  {  decorators . add ( decorator )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\internal\CreateSqlObjectHandler.java, create sql object handler,public   (  method method )  {  this . method = method ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\internal\CreateSqlObjectHandler.java,invoke,@ override public  object   (  object target  object[] args  handle supplier handle )  throws  exception  {  return handle . get config (  extensions . class )  . find factory (  sql object factory . class )  . or else throw (  (  )   -  >  new  illegal s
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\internal\ParameterUtil.java,find parameter name,public static  optional <  string >    (  string name from annotation  parameter parameter )  {  if  (  ! name from annotation . is empty (  )  )   {  return  optional . of ( name from annotation )  ;   }  return parameter . is name present (  )   ?   optional . of ( parameter . get name (  )  )  :  optional . empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\Handlers.java, handlers,private   (  handlers that )  {  factories . add all ( that . factories )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\Handlers.java,create copy,@ override public  handlers   (  )  {  return new  handlers ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\Handlers.java,find for,public  optional <  handler >    (  class <  ?  >  sql object type  method method )  {  return factories . stream (  )  . flat map ( factory  -  >  to stream ( factory . build handler ( sql object type method )  )  )  . find first (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\Handlers.java,register,public  handlers   (  handler factory factory )  {  factories . add ( 0 factory )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\internal\SqlAnnotations.java,find scripts,"private static  optional <  string >    (  method method  function <  string  string >  resolve sql )  {  final  sql scripts scripts = method . get annotation (  sql scripts . class )  ;  if  ( scripts  !  =  null )   {  return  optional . of (  arrays . stream ( scripts . value (  )  )  . map ( s  -  >  script value ( s method )  )  . map ( resolve sql )  . collect (  collectors . joining ( ""  ;  "" )  )  )  ;   }  final  sql script script = method . get annotation (  sql script . class )  ;  if  ( script  !  =  null )   {  return  optional . of ( resolve sql . apply ( script value ( script method )  )  )  ;   }  return  optional . empty (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\internal\SqlAnnotations.java,get annotation value,public static  optional <  string >    (  method method  function <  string  string >  resolve sql )  {   predicate <  string >  non empty = s  -  >   ! s . is empty (  )  ;  return  jdbi optionals . find first present (  (  )   -  >   optional . of nullable ( method . get annotation (  sql batch . class )  )  . map (  sql batch::value )  . map ( resolve sql )  . filter ( non empty )   (  )   -  >   optional . of nullable ( method . get annotation (  sql call . class )  )  . map (  sql call::value )  . map ( resolve sql )  . filter ( non empty )   (  )   -  >   optional . of nullable ( method . get annotation (  sql query . class )  )  . map (  sql query::value )  . map ( resolve sql )  . filter ( non empty )   (  )   -  >   optional . of nullable ( method . get annotation (  sql update . class )  )  . map (  sql update::value )  . map ( resolve sql )  . filter ( non empty )   (  )   -  >  find scripts ( method resolve sql )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\internal\SqlAnnotations.java,script value,private static  string   (  sql script script  method method )  {  return  ! script . value (  )  . is empty (  )   ?  script . value (  )  : method . get name (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\locator\AnnotationSqlLocator.java,locate,"@ override public  string   (  class <  ?  >  sql object type  method method  config registry config )  {  return  sql annotations . get annotation value ( method sql  -  >  sql )  . or else throw (  (  )   -  >  new  illegal state exception ( "" sql annot"
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\locator\internal\UseAnnotationSqlLocatorImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\locator\internal\UseAnnotationSqlLocatorImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {  registry . get (  sql objects . class )  . set sql locator ( new  annotation sql locator (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\locator\internal\UseClasspathSqlLocatorImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\locator\internal\UseClasspathSqlLocatorImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {  registry . get (  sql objects . class )  . set sql locator ( sql   locator )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\locator\internal\UseClasspathSqlLocatorImpl.java,default name,private static  string   (  string name  method method )  {  return  ! name . is empty (  )   ?  name : method . get name (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlMethodAnnotatedHandlerDecorator.java,build decorator,"private static  handler decorator   (  class <  ?  extends  handler decorator >  decorator class )  {  try  {  return decorator class . get constructor (  )  . new instance (  )  ;   }  catch  (   reflective operation exception e )   {  throw new  illegal state exception ( "" decorator class ""  +  decorator class  +  ""cannot be instantiated"" e )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlMethodAnnotatedHandlerDecorator.java,create decorator comparator,private  comparator <  class <  ?  extends  annotation >  >    (  decorator order order )  {   list <  class <  ?  extends  annotation >  >  ordering =  arrays . as list ( order . value (  )  )  ;  return  comparator . comparing int ( type  -  >   {  int index = ordering . index of ( type )  ;  return index  =  =   - 1  ?  ordering . size (  )  : index ;   }   )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlMethodAnnotatedHandlerDecorator.java,decorate handler,@ override public  handler   (  handler base  class <  ?  >  sql object type  method method )  {   handler handler = base ;   list <  class <  ?  extends  annotation >  >  annotation types =  stream . of ( method . get annotations (  )  )  . map (  annota
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlMethodHandlerFactory.java,build handler,"private  handler   (  class <  ?  extends  handler >  handler type  class <  ?  >  sql object type  method method )  {  try  {  return handler type . get constructor (  class . class  method . class )  . new instance ( sql object type method )  ;   }  catch  (   invocation target exception e )   {  throw to unchecked ( e . get cause (  )  )  ;   }  catch  (   reflective operation exception e )   {   }  try  {  return handler type . get constructor (  method . class )  . new instance ( method )  ;   }  catch  (   invocation target exception e )   {  throw to unchecked ( e . get cause (  )  )  ;   }  catch  (   reflective operation exception e )   {   }  try  {  return handler type . get constructor (  )  . new instance (  )  ;   }  catch  (   invocation target exception e )   {  throw to unchecked ( e . get cause (  )  )  ;   }  catch  (   reflective operation exception e )   {  throw new  illegal state exception ( "" handler class ""  +  handler type  +  "" cannot be instantiated .  "" +  "" expected a constructor with parameters  (  class   method )    (  method )   or  (  )  . "" e )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlMethodHandlerFactory.java,to unchecked,private  runtime exception   (  throwable t )  {  if  ( t instanceof  runtime exception )   {  return  (  runtime exception ) t ;   }  return new  runtime exception ( t )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlObjectPlugin.java,customize jdbi,@ override public void   (  jdbi db )  {  db . register extension ( new  sql object factory (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\DefaultMethodHandlerFactory.java,build handler,@ override public  optional <  handler >    (  class <  ?  >  sql object type  method method )  {  if  (  ! method . is default (  )  )   {  return  optional . empty (  )  ;   }   stream . of ( method . get annotations (  )  )  . map (  annotation::annota
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlObjects.java, sql objects,private   (  sql objects that )  {  sql locator = that . sql locator ;  default parameter customizer factory = that . default parameter customizer factory ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlObjects.java,create copy,@ override public  sql objects   (  )  {  return new  sql objects ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlObjects.java,get default parameter customizer factory,public  parameter customizer factory   (  )  {  return default parameter customizer factory ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlObjects.java,get sql locator,public  sql locator   (  )  {  return sql locator ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlObjects.java,set default parameter customizer factory,public  sql objects   (  parameter customizer factory default parameter customizer factory )  {  this . default parameter customizer factory = default parameter customizer factory ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlObjects.java,set sql locator,public  sql objects   (  sql locator sql locator )  {  this . sql locator =  objects . require non null ( sql locator )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\BindParameterCustomizerFactory.java,create for parameter,@ override public  sql statement parameter customizer   (  class <  ?  >  sql object type  method method  parameter param int index  type type )  {  return bind sql statement customizer factory . create for parameter ( null sql object type method param in
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlObjectFactory.java,accepts,"@ override public boolean   (  class <  ?  >  extension type )  {  if  ( looks like sql object ( extension type )  )   {  if  (  ! extension type . is interface (  )  )   {  throw new  illegal argument exception ( ""sql  objects are only supported for inte"
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlObjectFactory.java,attach,@ override public  < e > e   (  class < e >  extension type  handle supplier handle )  {   map <  method  handler >  handlers = method handlers for ( extension type handle . get config (  handlers . class )  handle . get config (  handler decorators . cla
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlObjectFactory.java,build method handler,"private  handler   (  class <  ?  >  sql object type  method method  handlers handlers  handler decorators decorators )  {   handler handler = handlers . find for ( sql object type method )  . or else throw (  (  )   -  >  new  illegal state exception (  string . format ( "" method %s . %s must be default or be annotated with a sql method annotation . "" sql object type . get simple name (  )  method . get name (  )  )  )  )  ;  return decorators . apply decorators ( handler sql object type method )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlObjectFactory.java,create invocation handler,private  invocation handler   (  class <  ?  >  sql object type  config registry instance config  map <  method  handler >  handlers  handle supplier handle )  {  return  ( proxy method args )   -  >   {   handler handler = handlers . get ( method )  ;   config registry method config = instance config . create copy (  )  ;  for each configurer ( method  ( configurer annotation )   -  >  configurer . configure for method ( method config annotation sql object type method )  )  ;  return handle . invoke in context ( new  extension method ( sql object type method )  method config  (  )   -  >  handler . invoke ( proxy args  =  =  null  ?  no   args : args handle )  )  ;   }   ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlObjectFactory.java,for each configurer,private void   (  annotated element element  bi consumer <  configurer  annotation >  consumer )  {   stream . of ( element . get annotations (  )  )  . filter ( a  -  >  a . annotation type (  )  . is annotation present (  configuring annotation . class )  )  . for each ( a  -  >   {   configuring annotation meta = a . annotation type (  )  . get annotation (  configuring annotation . class )  ;  consumer . accept ( get configurer ( meta . value (  )  )  a )  ;   }   )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlObjectFactory.java,get configurer,"private  configurer   (  class <  ?  extends  configurer >  factory class )  {  return configurers . compute if absent ( factory class c  -  >   {  try  {  return c . new instance (  )  ;   }  catch  (   instantiation exception| illegal access exception e )   {  throw new  illegal state exception ( "" unable to instantiate configurer factory class ""  +  factory class e )  ;   }   }   )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlObjectFactory.java,handler entry,"private static  map <  method  handler >    (  handler handler  class <  ?  >  klass  string method name  class <  ?  >  .  .  .  parameter types )  {  try  {  return  collections . singleton map ( klass . get method ( method name parameter types )  handler )  ;   }  catch  (   no such method exception| security exception e )   {  throw new  illegal state exception (  string . format ( ""can't find %s#%s%s"" klass . get name (  )  method name  arrays . as list ( parameter types )  )  e )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlObjectFactory.java,looks like sql object,private boolean   (  class <  ?  >  extension type )  {  if  (  sql object . class . is assignable from ( extension type )  )   {  return true ;   }  return  stream . of ( extension type . get methods (  )  )  . flat map ( m  -  >   stream . of ( m . get annotations (  )  )  )  . any match ( a  -  >  a . annotation type (  )  . is annotation present (  sql operation . class )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\SqlObjectFactory.java,method handlers for,"private  map <  method  handler >    (  class <  ?  >  sql object type  handlers registry  handler decorators decorators )  {  return handlers cache . compute if absent ( sql object type type  -  >   {  final  map <  method  handler >  handlers = new  hash map <  >  (  )  ;  handlers . put all ( handler entry (  ( t a h )   -  >  sql object type . get name (  )   +  '@'  +   integer . to hex string ( t . hash code (  )  )   object . class ""to string"" )  )  ;  handlers . put all ( handler entry (  ( t a h )   -  >  t  =  =  a[0]  object . class ""equals""  object . class )  )  ;  handlers . put all ( handler entry (  ( t a h )   -  >   system . identity hash code ( t )   object . class ""hash code"" )  )  ;  handlers . put all ( handler entry (  ( t a h )   -  >  h . get handle (  )   sql object . class ""get handle"" )  )  ;  try  {  handlers . put all ( handler entry (  ( t a h )   -  >  null sql object type ""finalize"" )  )  ;   }  catch  (   illegal state exception expected )   {   }  for  (   method method : sql object type . get methods (  )  )   {  handlers . compute if absent ( method m  -  >  build method handler ( sql object type m registry decorators )  )  ;   }  return handlers ;   }   )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\MapToFactory.java,create for parameter,@ override public  sql statement parameter customizer   (  annotation annotation  class <  ?  >  sql object type  method method  parameter param int index  type type )  {  return  ( stmt arg )   -  >   {  final  type type arg ;  if  ( arg instanceof  gene
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlCallHandler.java, sql call handler,"public   (  class <  ?  >  sql object type  method method )  {  super ( sql object type method )  ;   type return type =  generic types . resolve type ( method . get generic return type (  )  sql object type )  ;   class <  ?  >  return class =  generic types . get erased type ( return type )  ;  if  (  void . type . equals ( return class )  )   {  return out params = false ;   }  else if  (  out parameters . class . is assignable from ( return class )  )   {  return out params = true ;   }  else  {  throw new  illegal argument exception ( ""@ sql call methods may only return null or  out parameters at present"" )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlCallHandler.java,configure returner,@ override void   (  call c  sql object statement configuration cfg )  {  cfg . set returner (  (  )   -  >   {   out parameters ou = c . invoke (  )  ;  if  ( return out params )   {  return ou ;   }  else  {  return null ;   }   }   )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlCallHandler.java,create statement,@ override  call   (  handle handle  string located sql )  {  return handle . create call ( located sql )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\ResultReturner.java, collected result returner,  (  type return type )  {  this . return type = return type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\ResultReturner.java, consumer result returner,  (  method method int consumer index )  {  this . consumer index = consumer index ;  element type = method . get generic parameter types (  ) [consumer index] ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\ResultReturner.java, iterator returner,"  (  type return type )  {  this . element type =  generic types . find generic parameter ( return type  iterator . class )  . or else throw (  (  )   -  >  new  illegal state exception ( "" cannot reflect  iterator < t >  element type t in method return type ""  +  return type )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\ResultReturner.java, result iterable returner,"  (  type return type )  {  element type =  generic types . find generic parameter ( return type  result iterable . class )  . or else throw (  (  )   -  >  new  illegal state exception ( "" cannot reflect  result iterable < t >  element type t in method return type ""  +  return type )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\ResultReturner.java, result iterator returner,"  (  type return type )  {  this . element type =  generic types . find generic parameter ( return type  iterator . class )  . or else throw (  (  )   -  >  new  illegal state exception ( "" cannot reflect  result iterator < t >  element type t in method return type ""  +  return type )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\ResultReturner.java, single value returner,  (  type return type )  {  this . return type = return type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\ResultReturner.java, stream returner,"  (  type return type )  {  element type =  generic types . find generic parameter ( return type  stream . class )  . or else throw (  (  )   -  >  new  illegal state exception ( "" cannot reflect  stream < t >  element type t in method return type ""  +  return type )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\ResultReturner.java,check result,"private static  object   (  object result  type type )  {  if  ( result  =  =  null && get erased type ( type )  . is primitive (  )  )   {  throw new  illegal state exception ( ""sql method returns primitive ""  +  type  +  ""  but statement returned no results"" )  ;   }  return result ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\ResultReturner.java,element type,@ override protected  type   (  statement context ctx )  {  return element type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\ResultReturner.java,find consumer,static  optional <  result returner >    (  class <  ?  >  extension type  method method )  {  final  class <  ?  > [] param types = method . get parameter types (  )  ;  for  ( int i = 0 ;  i  <  param types . length ;  i +  +  )   {  if  ( param types[i]  =  =   consumer . class )   {  return  optional . of ( new  consumer result returner ( method i )  )  ;   }   }  return  optional . empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\ResultReturner.java,for method,"static  result returner   (  class <  ?  >  extension type  method method )  {   type return type =  generic types . resolve type ( method . get generic return type (  )  extension type )  ;   class <  ?  >  return class = get erased type ( return type )  ;  if  (  void . type . equals ( return class )  )   {  return find consumer ( extension type method )  . or else throw (  (  )   -  >  new  illegal state exception (  string . format ( "" method %s#%s is annotated as if it should return a value  but the method is void . "" method . get declaring class (  )  . get name (  )  method . get name (  )  )  )  )  ;   }  else if  (  result iterable . class . equals ( return class )  )   {  return new  result iterable returner ( return type )  ;   }  else if  (  stream . class . equals ( return class )  )   {  return new  stream returner ( return type )  ;   }  else if  (  result iterator . class . equals ( return class )  )   {  return new  result iterator returner ( return type )  ;   }  else if  (  iterator . class . equals ( return class )  )   {  return new  iterator returner ( return type )  ;   }  else if  ( method . is annotation present (  single value . class )  )   {  return new  single value returner ( return type )  ;   }  else  {  return new  collected result returner ( return type )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\ResultReturner.java,for optional return,static  result returner   (  class <  ?  >  extension type  method method )  {  if  ( method . get return type (  )   =  =  void . class )   {  return new  void returner (  )  ;   }  return for method ( extension type method )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\ResultReturner.java,mapped result,"@ override protected  void   (  result iterable <  ?  >  iterable  statement context ctx )  {  @ suppress warnings ( ""unchecked"" )   consumer <  object >  consumer =  (  consumer <  object >  ) ctx . get config (  sql object statement configuration . clas"
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\ResultReturner.java,reduced result,"@ override protected  void   (  stream <  ?  >  stream  statement context ctx )  {  @ suppress warnings ( ""unchecked"" )   consumer <  object >  consumer =  (  consumer <  object >  ) ctx . get config (  sql object statement configuration . class )  . get "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlObjectStatementConfiguration.java, sql object statement configuration,private   (  sql object statement configuration other )  {  this . returner = other . returner ;  this . args = other . args ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlObjectStatementConfiguration.java,create copy,@ override public  sql object statement configuration   (  )  {  return new  sql object statement configuration ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlObjectStatementConfiguration.java,get args, object[]   (  )  {  return args ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlObjectStatementConfiguration.java,get returner, supplier <  object >    (  )  {  return returner ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlObjectStatementConfiguration.java,set args,void   (  object[] args )  {  this . args = args ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlObjectStatementConfiguration.java,set returner,void   (  supplier <  object >  returner )  {  this . returner = returner ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlBatchHandler.java, constant chunk size function,  ( int value )  {  this . value = value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlBatchHandler.java, param based chunk size function,  ( int index )  {  this . index = index ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlBatchHandler.java, sql batch handler,"public   (  class <  ?  >  sql object type  method method )  {  super ( sql object type method )  ;  if  ( method . is annotation present (  use row reducer . class )  )   {  throw new  unsupported operation exception ( "" cannot declare @ use row reducer on a @ sql update method . "" )  ;   }  this . sql batch = method . get annotation (  sql batch . class )  ;  this . batch chunk size = determine batch chunk size ( sql object type method )  ;  final  get generated keys get generated keys = method . get annotation (  get generated keys . class )  ;  if  ( get generated keys  =  =  null )   {  if  (  ! return type is valid ( method . get return type (  )  )  )   {  throw new  unable to create sql object exception ( invalid return type message ( method )  )  ;   }   function <  prepared batch  result iterator <  ?  >  >  mod counts =  prepared batch::execute and get mod count ;  batch intermediate = method . get return type (  )  . equals ( boolean[] . class )   ?  map to boolean ( mod counts )  : mod counts ;  magic =  result returner . for optional return ( sql object type method )  ;   }  else  {   string[] column names = get generated keys . value (  )  ;  magic =  result returner . for method ( sql object type method )  ;  if  ( method . is annotation present (  use row mapper . class )  )   {   row mapper <  ?  >  mapper = row mapper for ( method . get annotation (  use row mapper . class )  )  ;  batch intermediate = batch  -  >  batch . execute and return generated keys ( column names )  . map ( mapper )  . iterator (  )  ;   }  else  {  batch intermediate = batch  -  >  batch . execute and return generated keys ( column names )  . map to ( magic . element type ( batch . get context (  )  )  )  . iterator (  )  ;   }   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlBatchHandler.java,call,@ override public int   (  object[] args )  {  return  (  integer ) args[index] ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlBatchHandler.java,create statement,@ override  prepared batch   (  handle handle  string located sql )  {  return handle . prepare batch ( located sql )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlBatchHandler.java,determine batch chunk size,"private  sql batch handler .  chunk size function   (  class <  ?  >  sql object type  method method )  {  int batch chunk size parameter index ;  if  (  ( batch chunk size parameter index = index of batch chunk size parameter ( method )  )   >  =  0 )   {  return new  param based chunk size function ( batch chunk size parameter index )  ;   }  else if  ( method . is annotation present (  batch chunk size . class )  )   {  final int size = method . get annotation (  batch chunk size . class )  . value (  )  ;  if  ( size  <  =  0 )   {  throw new  illegal argument exception ( "" batch chunk size must be  >  =  0"" )  ;   }  return new  constant chunk size function ( size )  ;   }  else if  ( sql object type . is annotation present (  batch chunk size . class )  )   {  final int size = sql object type . get annotation (  batch chunk size . class )  . value (  )  ;  return new  constant chunk size function ( size )  ;   }  else  {  return new  constant chunk size function (  integer . max   value )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlBatchHandler.java,execute batch,private  result iterator <  ?  >    ( final  handle handle final  prepared batch batch )  {  if  (  ! handle . is in transaction (  )  && sql batch . transactional (  )  )   {  return handle . in transaction ( c  -  >  batch intermediate . apply ( batch )  )  ;   }  else  {  return batch intermediate . apply ( batch )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlBatchHandler.java,get context,@ override public  statement context   (  )  {  return dummy . get context (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlBatchHandler.java,get parameter type,@ override  type   (  parameter parameter )  {   type type = super . get parameter type ( parameter )  ;  if  (  ! parameter . is annotation present (  single value . class )  )   {   class <  ?  >  erased type =  generic types . get erased type ( type ) 
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlBatchHandler.java,has next,@ override public boolean   (  )  {  for  (   iterator <  ?  >  extra : extras )   {  if  (  ! extra . has next (  )  )   {  return false ;   }   }  return true ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlBatchHandler.java,index of batch chunk size parameter,private int   (  method method )  {   annotation[][] parameter annotations = method . get parameter annotations (  )  ;  return  int stream . range ( 0 parameter annotations . length )  . filter ( i  -  >   stream . of ( parameter annotations[i] )  . any match (  batch chunk size . class::is instance )  )  . find first (  )  . or else (  - 1 )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlBatchHandler.java,invalid return type message,"private static  string   (  method method )  {  return method . get declaring class (  )   +  "" . ""  +  method . get name (  )  +  "" method is annotated with @ sql batch so should return void  int[]  or boolean[] but is returning: "" +  method . get return type (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlBatchHandler.java,invoke,@ override public  object   (  object target  object[] args  handle supplier h )  {  final  handle handle = h . get handle (  )  ;  final  string sql = locate sql ( handle )  ;  final int chunk size = batch chunk size . call ( args )  ;  final  iterator <
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlBatchHandler.java,map to boolean,private  function <  prepared batch  result iterator <  ?  >  >    (  function <  prepared batch  result iterator <  ?  >  >  mod counts )  {  return mod counts . and then ( iterator  -  >  new  result iterator <  boolean >  (  )  {  @ override public boolean has next (  )  {  return iterator . has next (  )  ;   }  @ override public  boolean next (  )  {  return  (  (  integer ) iterator . next (  )  )   >  0 ;   }  @ override public void close (  )  {  iterator . close (  )  ;   }  @ override public  statement context get context (  )  {  return iterator . get context (  )  ;   }   }   )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlBatchHandler.java,next,@ override public  object[]   (  )  {  for  ( int i = 0 ;  i  <  extras . size (  )  ;  i +  +  )   {  shared arg[i] = extras . get ( i )  . next (  )  ;   }  return shared arg ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlBatchHandler.java,return type is valid,private static boolean   (  class <  ?  >  type )  {  if  ( type . equals (  void . type )  )   {  return true ;   }  if  ( type . is array (  )  )   {   class <  ?  >  component type = type . get component type (  )  ;  return component type . equals (  integer . type )  || component type . equals (  boolean . type )  ;   }  return false ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlBatchHandler.java,zip args,"private  iterator <  object[] >    (  method method  object[] args )  {  boolean found iterator = false ;   list <  iterator <  ?  >  >  extras = new  array list <  >  (  )  ;  for  ( int param idx = 0 ;  param idx  <  method . get parameter count (  )  ;  param idx +  +  )   {  final boolean single value = method . get parameters (  ) [param idx] . is annotation present (  single value . class )  ;  final  object arg = args[param idx] ;  if  (  ! single value &&  iterable like . is iterable ( arg )  )   {  extras . add (  iterable like . of ( arg )  )  ;  found iterator = true ;   }  else  {  extras . add (  stream . generate (  (  )   -  >  arg )  . iterator (  )  )  ;   }   }  if  (  ! found iterator )   {  throw new  unable to create statement exception ( ""@ sql batch method has no  iterable or array parameters ""  +  "" did you mean @ sql query ? "" null null )  ;   }  final  object[] shared arg = new  object[args . length] ;  return new  iterator <  object[] >  (  )  {  @ override public boolean has next (  )  {  for  (   iterator <  ?  >  extra : extras )   {  if  (  ! extra . has next (  )  )   {  return false ;   }   }  return true ;   }  @ override public  object[] next (  )  {  for  ( int i = 0 ;  i  <  extras . size (  )  ;  i +  +  )   {  shared arg[i] = extras . get ( i )  . next (  )  ;   }  return shared arg ;   }   }   ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlQueryHandler.java, sql query handler,public   (  class <  ?  >  sql object type  method method )  {  super ( sql object type method )  ;  this . magic =  result returner . for method ( sql object type method )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlQueryHandler.java,configure returner,@ override void   (  query q  sql object statement configuration cfg )  {   use row mapper use row mapper = get method (  )  . get annotation (  use row mapper . class )  ;   use row reducer use row reducer = get method (  )  . get annotation (  use row r
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlQueryHandler.java,create statement,@ override  query   (  handle handle  string located sql )  {  return handle . create query ( located sql )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlScriptsHandler.java, sql scripts handler,public   (  class <  ?  >  sql object type  method method )  {  super ( sql object type method )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlScriptsHandler.java,configure returner,@ override void   (  script stmt  sql object statement configuration cfg )  {  cfg . set returner (  (  )   -  >  stmt . execute (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlScriptsHandler.java,create statement,@ override  script   (  handle handle  string located sql )  {  return new  script ( handle located sql )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\CustomizingStatementHandler.java, customizing statement handler,  (  class <  ?  >  type  method method )  {  this . sql object type = type ;  this . method = method ;  final  stream <  bound customizer >  type customizers = concat (  stream . of ( type . get interfaces (  )  )   stream . of ( type )  )  . flat map ( t  -  >  annotations for ( t )  )  . map ( a  -  >  instantiate factory ( a )  . create for type ( a type )  )  . map (  bound customizer::of )  ;  final  stream <  bound customizer >  method customizers = annotations for ( method )  . map ( a  -  >  instantiate factory ( a )  . create for method ( a type method )  )  . map (  bound customizer::of )  ;  final  stream <  bound customizer >  parameter customizers = parameter customizers ( type method )  ;  statement customizers =  stream . of ( type customizers method customizers parameter customizers )  . reduce (  stream . empty (  )   stream::concat )  . collect (  collectors . to list (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\CustomizingStatementHandler.java,annotations for,private static  stream <  annotation >    (  annotated element .  .  .  elements )  {  return  stream . of ( elements )  . map (  annotated element::get annotations )  . flat map (  stream::of )  . filter ( a  -  >  a . annotation type (  )  . is annotation present (  sql statement customizing annotation . class )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlUpdateHandler.java, sql update handler,"public   (  class <  ?  >  sql object type  method method )  {  super ( sql object type method )  ;  if  ( method . is annotation present (  use row reducer . class )  )   {  throw new  unsupported operation exception ( "" cannot declare @ use row reducer on a @ sql update method . "" )  ;   }  boolean is get generated keys = method . is annotation present (  get generated keys . class )  ;   type return type =  generic types . resolve type ( method . get generic return type (  )  sql object type )  ;  if  ( is get generated keys )   {   result returner magic =  result returner . for method ( sql object type method )  ;   string[] column names = method . get annotation (  get generated keys . class )  . value (  )  ;  this . returner = update  -  >   {   result bearing result bearing = update . execute and return generated keys ( column names )  ;   use row mapper use row mapper = method . get annotation (  use row mapper . class )  ;   result iterable <  ?  >  iterable = use row mapper  =  =  null  ?  result bearing . map to ( return type )  : result bearing . map ( row mapper for ( use row mapper )  )  ;  return magic . mapped result ( iterable update . get context (  )  )  ;   }   ;   }  else if  ( is numeric ( method . get return type (  )  )  )   {  this . returner = update  -  >  update . execute (  )  ;   }  else if  ( is boolean ( method . get return type (  )  )  )   {  this . returner = update  -  >  update . execute (  )   >  0 ;   }  else  {  throw new  unable to create sql object exception ( invalid return type message ( method return type )  )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlUpdateHandler.java,configure returner,@ override void   (  update u  sql object statement configuration cfg )  {  cfg . set returner (  (  )   -  >  returner . apply ( u )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlUpdateHandler.java,create statement,@ override  update   (  handle handle  string located sql )  {  return handle . create update ( located sql )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlUpdateHandler.java,invalid return type message,"private  string   (  method method  type return type )  {  return method . get declaring class (  )  . get simple name (  )   +  "" . ""  +  method . get name (  )  +  "" method is annotated with @ sql update so should return void  boolean  or  number but is returning: "" +  return type ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlUpdateHandler.java,is boolean,private boolean   (  class <  ?  >  type )  {  return type . equals ( boolean . class )  || type . equals (  boolean . class )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\statement\internal\SqlUpdateHandler.java,is numeric,private boolean   (  class <  ?  >  type )  {  return  number . class . is assignable from ( type )  || type . equals ( int . class )  || type . equals ( long . class ) || type . equals ( void . class )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\UnableToCreateSqlObjectException.java, unable to create sql object exception,public   (  string message )  {  super ( message )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\transaction\internal\TransactionDecorator.java,decorate handler,@ override public  handler   (  handler base  class <  ?  >  sql object type  method method )  {  final  transaction txn annotation = method . get annotation (  transaction . class )  ;  final  transaction isolation level isolation = txn annotation . valu
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Article.java, article,@ jdbi constructor public   ( long id  string title  string content )  {  set id ( id )  ;  set title ( title )  ;  set content ( content )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Article.java,equals,@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   article article =  (  article ) o ;  return id  =  =  article . id &&  objects . equa
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Article.java,get comments,public  list <  comment >    (  )  {  return comments ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Article.java,get content,public  string   (  )  {  return content ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Article.java,get id,public long   (  )  {  return id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Article.java,get title,public  string   (  )  {  return title ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Article.java,hash code,@ override public int   (  )  {  return  objects . hash ( id title content comments )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Article.java,new article,public static  article   ( long id  string title  string content  comment .  .  .  comments )  {   article article = new  article ( id title content )  ;  article . get comments (  )  . add all (  arrays . as list ( comments )  )  ;  return article ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Article.java,set comments,public void   (  list <  comment >  comments )  {  this . comments = comments ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Article.java,set content,public void   (  string content )  {  this . content = content ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Article.java,set id,public void   ( long id )  {  this . id = id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Article.java,set title,public void   (  string title )  {  this . title = title ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Article.java,to string,"@ override public  string   (  )  {  return "" article { ""  +  ""id = ""  +  id  +  ""  title = '"" +  title +  '\'' +  ""  content = '"" +  content +  '\'' +  ""  comments = "" +  comments +  ' } ' ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\transaction\Transactional.java,begin,default void   (  )  {  get handle (  )  . begin (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\transaction\Transactional.java,commit,default void   (  )  {  get handle (  )  . commit (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\transaction\Transactional.java,in transaction,"@ suppress warnings ( ""unchecked"" )  default  < r x extends  exception > r   (  transaction isolation level isolation  transactional callback < r  this x >  callback )  throws x  {  return get handle (  )  . in transaction ( isolation h  -  >  callback . "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\transaction\Transactional.java,release savepoint,default void   (  string savepoint name )  {  get handle (  )  . release ( savepoint name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\transaction\Transactional.java,rollback,default void   (  )  {  get handle (  )  . rollback (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\transaction\Transactional.java,rollback to savepoint,default void   (  string savepoint name )  {  get handle (  )  . rollback to savepoint ( savepoint name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\transaction\Transactional.java,savepoint,default void   (  string savepoint name )  {  get handle (  )  . savepoint ( savepoint name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\main\java\org\jdbi\v3\sqlobject\transaction\Transactional.java,use transaction,default  < x extends  exception > void   (  transaction isolation level isolation  transactional consumer <  this x >  callback )  throws x  {  in transaction ( isolation transactional  -  >   {  callback . use transaction ( transactional )  ;  return null ;   }   )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\BindSomething.java,create for parameter,@ override public  sql statement parameter customizer   (  annotation annotation  class <  ?  >  sql object type  method method  parameter param int index  type type )  {   bind something bind =  (  bind something ) annotation ;  return  ( stmt arg )   - 
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\LongValue.java, long value,private   ( long value )  {  this . value = value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Comment.java, comment,@ jdbi constructor public   ( long id  string content )  {  set id ( id )  ;  set content ( content )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\LongValue.java,equals,@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   long value long value =  (  long value ) o ;  return value  =  =  long value . value 
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Comment.java,equals,@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   comment comment =  (  comment ) o ;  return id  =  =  comment . id &&  objects . equa
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\LongValue.java,get value,public long   (  )  {  return value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Comment.java,get content,public  string   (  )  {  return content ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\LongValue.java,hash code,@ override public int   (  )  {  return  objects . hash ( value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Comment.java,get id,public long   (  )  {  return id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\LongValue.java,of,public static final  long value   ( long value )  {  return new  long value ( value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Comment.java,hash code,@ override public int   (  )  {  return  objects . hash ( id content )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Comment.java,new comment,static  comment   ( long id  string content )  {  return new  comment ( id content )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\LongValue.java,to string,"@ override public  string   (  )  {  return "" long value { ""  +  ""value = ""  +  value  +  ' } ' ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Comment.java,set content,public void   (  string content )  {  this . content = content ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Comment.java,set id,public void   ( long id )  {  this . id = id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\Comment.java,to string,"@ override public  string   (  )  {  return "" comment { ""  +  ""id = ""  +  id  +  ""  content = '"" +  content +  '\'' +  ' } ' ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\LongValueRowMapper.java,map,"@ override public  long value   (  result set rs  statement context ctx )  throws sql exception  {  long value = rs . get long ( ""long   value"" )  ;  return rs . was null (  )   ?  null :  long value . of ( value )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\LongValueColumnMapper.java,map,@ override public  long value   (  result set r int column number  statement context ctx )  throws sql exception  {  long value = r . get long ( column number )  ;  return r . was null (  )   ?  null :  long value . of ( value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\LongValueColumnMapperFactory.java,build,@ override public  optional <  column mapper <  ?  >  >    (  type type  config registry config )  {  return  long value . class . equals ( type )   ?   optional . of ( new  long value column mapper (  )  )  :  optional . empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\LongValueRowMapperFactory.java,build,@ override public  optional <  row mapper <  ?  >  >    (  type type  config registry config )  {  return  long value . class . equals ( type )   ?   optional . of ( new  long value row mapper (  )  )  :  optional . empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\StringValueColumnMapper.java,map,@ override public  string value   (  result set r int column number  statement context ctx )  throws sql exception  {  return  string value . of ( r . get string ( column number )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\StringValueColumnMapperFactory.java,build,@ override public  optional <  column mapper <  ?  >  >    (  type type  config registry config )  {  return  string value . class . equals ( type )   ?   optional . of ( new  string value column mapper (  )  )  :  optional . empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\StringValueRowMapper.java,map,"@ override public  string value   (  result set rs  statement context ctx )  throws sql exception  {  return  string value . of ( rs . get string ( ""string   value"" )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\StringValueRowMapperFactory.java,build,@ override public  optional <  row mapper <  ?  >  >    (  type type  config registry config )  {  return  string value . class . equals ( type )   ?   optional . of ( new  string value row mapper (  )  )  :  optional . empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\TestRegisterBeanMapper.java,get article with comments,"@ register bean mapper ( value =  article . class prefix = ""a"" )  @ register bean mapper ( value =  comment . class prefix = ""c"" )  default  optional <  article >    ( long id )  {  return get handle (  )  . select ( ""select ""  +  "" a . id a   id  ""  +  """
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\TestRegisterConstructorMapper.java,get article with comments,"@ register constructor mapper ( value =  article . class prefix = ""a"" )  @ register constructor mapper ( value =  comment . class prefix = ""c"" )  default  optional <  article >    ( long id )  {  return get handle (  )  . select ( ""select ""  +  "" a . id a"
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\TestRegisterFieldMapper.java,get article with comments,"@ register field mapper ( value =  article . class prefix = ""a"" )  @ register field mapper ( value =  comment . class prefix = ""c"" )  default  optional <  article >    ( long id )  {  return get handle (  )  . select ( ""select ""  +  "" a . id a   id  ""  + "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\TestRegisterRowMapper.java,list,"@ sql query ( ""select * from column   mappers"" )  @ register row mapper (  string value row mapper . class )  @ register row mapper (  long value row mapper . class )  @ register join row mapper (  {  string value . class  long value . class }  )   list <"
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\TestRegisterRowMapperFactory.java,list,"@ sql query ( ""select * from column   mappers"" )  @ register row mapper factory (  string value row mapper factory . class )  @ register row mapper factory (  long value row mapper factory . class )  @ register join row mapper (  {  string value . class  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\TestUseCustomHandlerFactory.java,build handler,@ override public  optional <  handler >    (  class <  ?  >  sql object type  method method )  {  return get implementation ( sql object type method )  . map ( m  -  >   (  handler )  ( target args handle )   -  >  m . invoke ( null  stream . concat (  s
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\ValueTypeEntity.java, value type entity,public   (  string value string value  long value long value )  {  this . string value = string value ;  this . long value = long value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\ValueTypeEntity.java,equals,@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   value type entity that =  (  value type entity ) o ;  return  objects . equals ( stri
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\ValueTypeEntity.java,hash code,@ override public int   (  )  {  return  objects . hash ( string value long value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\ValueTypeEntity.java,of,public static final  value type entity   (  string value string value  long value long value )  {  return new  value type entity ( string value long value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\ValueTypeEntity.java,to string,"@ override public  string   (  )  {  return "" value type entity { ""  +  ""string value = ""  +  string value  +  ""  long value = "" +  long value +  ' } ' ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\locator\TestSqlLocator.java, test config,private   (  test config that )  {  this . sql = that . sql ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\locator\TestSqlLocator.java,create copy,@ override public  test config   (  )  {  return new  test config ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\subpackage\PrivateImplementationFactory.java,create,public static  test bean binder .  public interface   (  )  {  return new  private implementation (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\subpackage\PrivateImplementationFactory.java,get value,"@ override public  string   (  )  {  return ""i should bind"" ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\MockClock.java,advance,public  instant   ( long amount to add  temporal unit unit )  {  return now = now . plus ( amount to add unit )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\MockClock.java,get zone,@ override public  zone id   (  )  {  return  zone id . system default (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\MockClock.java,instant,@ override public  instant   (  )  {  return now ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\MockClock.java,with zone,@ override public  clock   (  zone id zone )  {  throw new  unsupported operation exception (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestBatchingSingleValue.java, batching row,public   ( int id int[] values )  {  this . id = id ;  this . values = values ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestBatchingSingleValue.java,equals,@ override public boolean   (  object obj )  {  if  ( obj instanceof  batching row )   {   batching row other =  (  batching row ) obj ;  return id  =  =  other . id &&  arrays . equals ( values other . values )  ;   }  return false ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestBatchingSingleValue.java,hash code,@ override public int   (  )  {  return id ^  arrays . hash code ( values )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestBeanMapper.java, document,public   ( int id  string name  string contents )  {  this . id = id ;  this . name = name ;  this . contents = contents ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestBeanMapper.java, folder,public   ( int id  string name  document .  .  .  documents )  {  this . id = id ;  this . name = name ;  this . documents =  arrays . as list ( documents )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestBeanMapper.java,accumulate,"@ override public void   (  map <  integer  folder >  map  row view rv )  {   folder f = map . compute if absent ( rv . get column ( ""f   id""  integer . class )  id  -  >  rv . get row (  folder . class )  )  ;  if  ( rv . get column ( ""d   id""  integer ."
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestBeanMapper.java,create table,"@ before public void   (  )  throws  exception  {  h = db rule . open handle (  )  ;  h . create update ( ""create table test bean  ( value type varchar ( 50 )  ) "" )  . execute (  )  ;  dao = h . attach (  test dao . class )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestBeanMapper.java,equals,@ override public boolean   (  object obj )  {  if  (  !  ( obj instanceof  folder )  )   {  return false ;   }   folder that =  (  folder ) obj ;  return this . id  =  =  that . id &&  objects . equals ( this . name that . name )  &&  objects . equals ( 
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestBeanMapper.java,get contents,public  string   (  )  {  return contents ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestBeanMapper.java,get documents,public  list <  document >    (  )  {  return documents ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestBindFields.java, test object,public   ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestBindFields.java,get id,"public int   (  )  {  throw new  runtime exception ( "" should not be called . "" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestBindBean.java, bean,public   ( int id  value type value type )  {  this . id = id ;  this . value type = value type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestBindBean.java, value type argument factory,public   (  )  {  super (  types . varchar )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestBindBean.java,build,@ override protected  argument   (  value type value  config registry config )  {  return  ( pos stmt ctx )   -  >  stmt . set string ( pos value . get value (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestBindExpression.java,create for parameter,@ override public  sql statement parameter customizer   (  annotation annotation  class <  ?  >  sql object type  method method  parameter param int index  type type )  {  final  string root name =  (  (  bind root ) annotation )  . value (  )  ;  final  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestBindFunctions.java, fluent something,public   ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestBindMap.java, map key,  (  string value )  {  this . value = value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestConcurrentUpdatingQuery.java,set up,@ before public void   (  )  throws  exception  {  handle = db rule . get handle (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestConcurrentUpdatingQuery.java,test concurrent updateable result set,"@ test public void   (  )  throws  exception  {  handle . execute ( ""create table something  (  id identity primary key  name varchar ( 50 )   ) "" )  ;  handle . execute ( ""insert into something  ( id  name )  values  ( 7  ' tim' ) "" )  ;  handle . create"
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestColumnMappers.java,create table,"@ before public void   (  )  throws  exception  {  h = db rule . open handle (  )  ;  h . create update ( ""create table some bean  ( ""  +  "" primitive int integer  wrapper long bigint  ""  +  "" primitive char varchar ( 1 )   wrapped char varchar ( 1 )   "" "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestColumnMappers.java,drop table,"@ after public void   (  )  {  h . create update ( ""drop table some bean"" )  . execute (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestColumnMappers.java,get primitive char,public char   (  )  {  return primitive char ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestColumnMappers.java,get primitive int,public int   (  )  {  return primitive int ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestColumnMappers.java,get string,public  string   (  )  {  return string ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestColumnMappers.java,get uri,public uri   (  )  {  return uri ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestColumnMappers.java,get value type,public  value type   (  )  {  return value type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestColumnMappers.java,get wrapped char,public  character   (  )  {  return wrapped char ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestColumnMappers.java,get wrapper long,public  long   (  )  {  return wrapper long ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\StringValue.java, string value,private   (  string value )  {  this . value = value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\StringValue.java,equals,@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   string value that =  (  string value ) o ;  return  objects . equals ( value that . v
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\StringValue.java,get value,public  string   (  )  {  return value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\StringValue.java,hash code,@ override public int   (  )  {  return  objects . hash ( value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\StringValue.java,of,public static  string value   (  string value )  {  return value  =  =  null  ?  null : new  string value ( value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\config\StringValue.java,to string,"@ override public  string   (  )  {  return "" string value { ""  +  ""value = '""  +  value  +  '\'' +  ' } ' ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestFieldMapper.java,create table,"@ before public void   (  )  throws  exception  {  h = db rule . open handle (  )  ;  h . create update ( ""create table test bean  ( value type varchar ( 50 )  ) "" )  . execute (  )  ;  dao = h . attach (  test dao . class )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestFieldMapper.java,get value type,public  value type   (  )  {  return value type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestGetGeneratedKeysPostgres.java, id create time,public   ( long id  offset date time created on )  {  this . id = id ;  this . created on = created on ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestFoldToObjectGraph.java, person,public   (  string name  string role )  {  this . name = name ;  this . role = role ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestFoldToObjectGraph.java, team,public   (  string name  string mascot )  {  this . name = name ;  this . mascot = mascot ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestFoldToObjectGraph.java,equals,@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   person person =  (  person ) o ;  return name . equals ( person . name )  && role . e
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestFoldToObjectGraph.java,find all teams,default  map <  string  team >    (  )  {   iterator <  team person join row >  i = find all teams and people (  )  ;   map <  string  team >  acc = new  hash map <  >  (  )  ;  while  ( i . has next (  )  )   {   team person join row row = i . next (  )  ;  if  (  ! acc . contains key ( row . get team name (  )  )  )   {  acc . put ( row . get team name (  )  new  team ( row . get team name (  )  row . get mascot (  )  )  )  ;   }  acc . get ( row . get team name (  )  )  . get people (  )  . add ( new  person ( row . get person name (  )  row . get role (  )  )  )  ;   }  return acc ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestGuavaCollectors.java, user,public   ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestGuavaCollectors.java,equals,@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   user user =  (  user ) o ;  return id  =  =  user . id &&  objects . equals ( name us
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestInheritedAnnotations.java, character,@ jdbi constructor public   ( int id  string name  instant created  instant modified )  {  this . id = id ;  this . name = name ;  this . created = created ;  this . modified = modified ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestInheritedAnnotations.java,create copy,@ override public  config   (  )  {   config copy = new  config (  )  ;  copy . clock = this . clock ;  return copy ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestInheritedAnnotations.java,create for type,"@ override public  sql statement customizer   (  annotation annotation  class <  ?  >  sql object type )  {  return stmt  -  >  stmt . bind ( ""now""  offset date time . now ( stmt . get config (  config . class )  . clock )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestOutParameterAnnotation.java,call multiple out parameters,"@ sql call ( "" { call swap ( :a  :b  :c  :d )  } "" )  @ out parameter ( name = ""c"" sql type =  types . integer )  @ out parameter ( name = ""d"" sql type =  types . integer )   out parameters   ( int a int b )  ;  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestOutParameterAnnotation.java,call stored proc,"@ sql call ( "" { call set100 ( :outparam )  } "" )  @ out parameter ( name = ""outparam"" sql type =  types . integer )   out parameters   (  )  ;  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestOutParameterAnnotation.java,set up,"@ before public void   (  )  throws  exception  {  db = db rule . get jdbi (  )  ;  db . use handle ( h  -  >   {  h . execute ( ""create function set100 ( out outparam int )  as $$ begin outparam : =  100 ;  end ;  $$ language plpgsql"" )  ;  h . execute ("
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestOutParameterAnnotation.java,test multiple out parameters,"@ test public void   (  )  {   my dao my dao = db . on demand (  my dao . class )  ;   out parameters out parameters = my dao . call multiple out parameters ( 1 9 )  ;  assert that ( out parameters . get int ( ""c"" )  )  . is equal to ( 9 )  ;  assert that"
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestOutParameterAnnotation.java,test out parameter,"@ test public void   (  )  {   my dao my dao = db . on demand (  my dao . class )  ;   out parameters out parameters = my dao . call stored proc (  )  ;  assert that ( out parameters . get int ( ""outparam"" )  )  . is equal to ( 100 )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestPostgresBugs.java,failed,"@ transaction default  something   ( int id  string name )  throws io exception  {  insert ( id name )  ;  throw new io exception ( ""woof"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestReadOnly.java,read txn,@ transaction ( read only = true )  default void   (  runnable r )  {  r . run (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestReadOnly.java,test handle read only,@ test public void   (  )  throws  exception  {  try  (  handle h = db . open handle (  )  )  {  assert that ( h . is read only (  )  )  . is false (  )  ;  assert that ( h . get connection (  )  . is read only (  )  )  . is false (  )  ;  h . set read on
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestReadOnly.java,test read only inner,@ test public void   (  )  {  try  (  handle h = db . open handle (  )  )  {  ro dao dao = h . attach ( ro dao . class )  ;  dao . write txn (  (  )   -  >  dao . read txn (  (  )   -  >   {   }   )  )  ;   }   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestReadOnly.java,test read only outer,@ test ( expected =  transaction exception . class )  public void   (  )  {  try  (  handle h = db . open handle (  )  )  {  ro dao dao = h . attach ( ro dao . class )  ;  dao . read txn (  (  )   -  >  dao . write txn (  (  )   -  >   {   }   )  )  ;   }
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestReadOnly.java,test sql object read only,@ test public void   (  )  throws  exception  {  try  (  handle h = db . open handle (  )  )  {  ro dao dao = h . attach ( ro dao . class )  ;  assert that ( h . is read only (  )  )  . is false (  )  ;  assert that ( dao . verify read only (  )  )  . is 
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestReadOnly.java,verify read only,"@ transaction ( read only = true )  default boolean   (  )  throws sql exception  {  final  handle h = get handle (  )  ;  if  ( h . is read only (  )   !  =  h . get connection (  )  . is read only (  )  )   {  throw new  assertion error ( ""didn't set"" )"
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestReadOnly.java,write txn,@ transaction ( read only = false )  default void   (  runnable r )  {  r . run (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestRegisterArgumentFactory.java, name,public   (  string first  string last )  {  this . first = first ;  this . last = last ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestRegisterArgumentFactory.java,build,@ override public  optional <  argument >    (  type expected type  object value  config registry config )  {  if  ( expected type  =  =   name . class || value instanceof  name )   {   name name value =  (  name ) value ;  return  optional . of (  ( posi
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestRegisterRowMapperFactory.java, foo,  ( final int id final  string name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestRegisterRowMapperFactory.java,build,@ override public  optional <  row mapper <  ?  >  >    (  type type  config registry config )  {   class <  ?  >  erased type = get erased type ( type )  ;  try  {   map with map with = erased type . get annotation (  map with . class )  ;  return map wi
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestRegisterRowMapperFactory.java,get id,public int   (  )  {  return id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestRegisterRowMapperFactory.java,get name,public  string   (  )  {  return name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestRegisterJoinRowMapper.java,get authorship,"@ register join row mapper (  {  user . class  article . class }  )  @ sql query ( ""select * from user natural join author natural join article"" )   stream <  join row >    (  )  ;  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestRegisterJoinRowMapper.java,set up,@ before public void   (  )  {   join row mapper test t = new  join row mapper test (  )  ;  t . db rule = db rule ;  t . set up (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestRegisterJoinRowMapper.java,test sql object join row,@ test public void   (  )  {   handle handle = db rule . get shared handle (  )  ;   multimap <  user  article >  joined =  hash multimap . create (  )  ;  handle . attach (  user article dao . class )  . get authorship (  )  . for each ( jr  -  >  joined
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestReturningMap.java, phone,public   ( int id  string phone )  {  this . id = id ;  this . phone = phone ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestReturningMap.java, user,public   ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestSqlObjectFactory.java,accepts,"@ test public void   (  )  {  assert that ( factory . accepts (  nota sql object . class )  )  . is false (  )  ;  assert that thrown by (  (  )   -  >  factory . accepts (  sql object class . class )  )  . has message containing ( ""only supported for int"
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestSqlMethodDecorators.java,aborting decorator,@ foo @ abort @ bar @ custom sql operation @ decorator order (  {  foo . class  abort . class  bar . class }  )  void   (  )  ;  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestSqlMethodDecorators.java,decorate handler,"@ override public  handler   (  handler base  class <  ?  >  sql object type  method method )  {  return  ( obj args handle )   -  >   {  invoked ( ""abort"" )  ;  return null ;   }   ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestSqlMethodDecorators.java,invoke,"@ override public  object   (  object target  object[] args  handle supplier handle )  throws  exception  {  invoked ( ""method"" )  ;  return null ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestSqlMethodDecorators.java,invoked,static void   (  string value )  {  invocations . get (  )  . add ( value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestSqlMethodDecorators.java,ordered bar foo,@ foo @ bar @ custom sql operation @ decorator order (  {  bar . class  foo . class }  )  void   (  )  ;  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestSqlMethodDecorators.java,ordered bar foo on method,@ foo @ bar @ custom sql operation @ decorator order (  {  bar . class  foo . class }  )  void   (  )  ;  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestSqlMethodDecorators.java,ordered foo bar,@ foo @ bar @ custom sql operation @ decorator order (  {  foo . class  bar . class }  )  void   (  )  ;  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestSqlObject.java,broken,"default  string   ( @ bind int wat )  {  return ""foo"" ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestSqlObject.java,does transaction annotation work,@ transaction default boolean   (  )  {  return get handle (  )  . is in transaction (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestTimestamped.java, person,public   (  string first name  string last name )  {  this . first name = first name ;  this . last name = last name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestTimestamped.java,before,@ before public void   (  )  {  persondao = db rule . get jdbi (  )  . on demand (  persondao . class )  ;  persondao . create table (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestTimingCollector.java,collect,@ override public void   ( long elapsed time  statement context ctx )  {  statement names . add ( statement name strategy . get statement name ( ctx )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestTransactional.java, txn isolation checking invocation handler,public   (  connection real )  {  this . real = real ;   }  
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestTransactional.java,get connection,@ override public  connection   (  )  throws sql exception  {  final  connection real = super . get connection (  )  ;  return  (  connection )  proxy . new proxy instance ( real . get class (  )  . get class loader (  )  new  class <  ?  > [] {  connecti
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestTransactionAnnotation.java,failed,"@ transaction default  something   ( int id  string name )  throws io exception  {  insert ( id name )  ;  throw new io exception ( ""woof"" )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\sqlobject\src\test\java\org\jdbi\v3\sqlobject\TestRegisterConstructorMapper.java, sub something,public   ( int id  string name )  {  super ( id name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\main\java\org\jdbi\v3\stringtemplate4\internal\UseStringTemplateEngineImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\main\java\org\jdbi\v3\stringtemplate4\internal\UseStringTemplateEngineImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {  registry . get (  sql statements . class )  . set template engine ( new  string template engine (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\main\java\org\jdbi\v3\stringtemplate4\StringTemplateSqlLocator.java,find string template,public static st   (  class loader class loader  string path  string name )  {  st group group = find string template group ( class loader path )  ;  return find template in group ( path name group )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\main\java\org\jdbi\v3\stringtemplate4\StringTemplateSqlLocator.java,find string template group,public static st group   (  class loader class loader  string path )  {  return cache . compute if absent ( path p  -  >  read string template group ( class loader path )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\main\java\org\jdbi\v3\stringtemplate4\StringTemplateSqlLocator.java,find template in group,"private static st   (  string path  string name st group group )  {  if  (  ! group . is defined ( name )  )   {  throw new  illegal state exception ( "" no  string template group ""  +  name  +  "" for path "" +  path )  ;   }  return group . get instance of ( name )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\main\java\org\jdbi\v3\stringtemplate4\StringTemplateSqlLocator.java,open stream,"private static  input stream   (  class loader class loader  string path )  {   input stream is = class loader . get resource as stream ( path )  ;  if  ( is  =  =  null )   {  throw new  illegal state exception ( "" unable to find  string template group file at ""  +  path  +  "" on classpath"" )  ;   }  return is ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\main\java\org\jdbi\v3\stringtemplate4\StringTemplateSqlLocator.java,read string template group,"private static st group   (  class loader class loader  string path )  {  try  {  url resource = class loader . get resource ( path )  ;  st group file group = new st group file ( resource ""utf - 8"" ' < ' ' > ' )  ;  group . load (  )  ;  return group ;   }  catch  (   exception e )   {  throw new  runtime exception ( "" unable to read  string template group file at ""  +  path  +  "" on classpath"" e )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\main\java\org\jdbi\v3\stringtemplate4\StringTemplateSqlLocator.java,resource path for,private static  string   (  class <  ?  >  clazz )  {  return clazz . get name (  )  . replace ( ' . ' ' / ' )   +  template   group   extension ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\main\java\org\jdbi\v3\stringtemplate4\StringTemplateSqlLocator.java,to string,private static  string   (  input stream input stream )  throws io exception  {  char[] buffer = new char[1024] ;   string builder out = new  string builder (  )  ;   reader in = new  input stream reader ( input stream utf   8 )  ;  for  ( int rsz ;   ( rsz = in . read ( buffer 0 buffer . length )  )   >  =  0 ;   )   {  out . append ( buffer 0 rsz )  ;   }  return out . to string (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\main\java\org\jdbi\v3\stringtemplate4\internal\UseStringTemplateSqlLocatorImpl.java,configure for method,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\main\java\org\jdbi\v3\stringtemplate4\internal\UseStringTemplateSqlLocatorImpl.java,configure for type,@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   sql locator locator =  ( type method config )   -  >   {   string template name =  sql annotations . get annotation value ( method sql  -  >
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\main\java\org\jdbi\v3\stringtemplate4\StringTemplateEngine.java,render,@ override public  string   (  string sql  statement context ctx )  {  st template = new st ( new st group (  )  sql )  ;  ctx . get attributes (  )  . for each ( template::add )  ;  return template . render (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindListNullPostgresTest.java,exit,"@ after public void   (  )  {  handle . execute ( ""drop table something"" )  ;  handle . close (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindListTest.java,exit,@ after class public static void   (  )  {  handle . close (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindListNullTest.java, logging parser,public   (  list <  string >  log )  {  this . log = log ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindListNullTest.java,exit,@ after class public static void   (  )  {  handle . close (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\testing\src\main\java\org\jdbi\v3\testing\EmbeddedPostgresJdbiRule.java, embedded postgres jdbi rule,  (  )  {  embedded pg =  embedded postgres rules . single instance (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\testing\src\main\java\org\jdbi\v3\testing\EmbeddedPostgresJdbiRule.java,apply,@ override public  statement   (  statement base  description description )  {  return embedded pg . apply ( super . apply ( base description )  description )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\testing\src\main\java\org\jdbi\v3\testing\EmbeddedPostgresJdbiRule.java,create jdbi,@ override protected  jdbi   (  )  {  return  jdbi . create ( embedded pg . get embedded postgres (  )  . get postgres database (  )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\stringtemplate4\TestStringTemplateLoading.java,set up,@ before public void   (  )  throws  exception  {  handle = db rule . get shared handle (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\stringtemplate4\TestStringTemplateLoading.java,test baz,"public void   ( int id )  {   wombat wombat = handle . attach (  wombat . class )  ;  wombat . insert ( new  something ( id "" doo""  +  id )  )  ;   string name = handle . create query ( ""select name from something where id  =  ""  +  id )  . map to (  string . class )  . find only (  )  ;  assert that ( name )  . is equal to ( "" doo""  +  id )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\stringtemplate4\TestStringTemplateLoading.java,test concurrent loading,@ test public void   (  )  throws  interrupted exception   execution exception  {   executor service pool =  executors . new fixed thread pool ( 10 )  ;   int stream . range ( 1 10 )  . for each ( id  -  >  pool . execute (  (  )   -  >  test baz ( id )  
C:\Users\User\Desktop\Thesis\jdbi\testing\src\main\java\org\jdbi\v3\testing\JdbiRule.java,after,@ override protected void   (  )  {  handle . close (  )  ;  jdbi = null ;   }  
C:\Users\User\Desktop\Thesis\jdbi\testing\src\main\java\org\jdbi\v3\testing\JdbiRule.java,attach,public  < t > t   (  class < t >  extension )  {  return get handle (  )  . attach ( extension )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\testing\src\main\java\org\jdbi\v3\testing\JdbiRule.java,before,@ override protected void   (  )  throws  throwable  {  jdbi = create jdbi (  )  ;  if  ( install plugins )   {  jdbi . install plugins (  )  ;   }  plugins . for each ( jdbi::install plugin )  ;  handle = jdbi . open (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\testing\src\main\java\org\jdbi\v3\testing\JdbiRule.java,create jdbi,"@ override protected  jdbi   (  )  {  return  jdbi . create ( ""jdbc:h2:mem:""  +  uuid . randomuuid (  )  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\testing\src\main\java\org\jdbi\v3\testing\JdbiRule.java,embedded postgres,public static  jdbi rule   (  )  {  return new  embedded postgres jdbi rule (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\testing\src\main\java\org\jdbi\v3\testing\JdbiRule.java,get handle,public  handle   (  )  {  return handle ;   }  
C:\Users\User\Desktop\Thesis\jdbi\testing\src\main\java\org\jdbi\v3\testing\JdbiRule.java,get jdbi,public  jdbi   (  )  {  return jdbi ;   }  
C:\Users\User\Desktop\Thesis\jdbi\testing\src\main\java\org\jdbi\v3\testing\JdbiRule.java,h,"public static  jdbi rule   (  )  {  return new  jdbi rule (  )  {  @ override protected  jdbi create jdbi (  )  {  return  jdbi . create ( ""jdbc:h2:mem:""  +  uuid . randomuuid (  )  )  ;   }   }   ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\testing\src\main\java\org\jdbi\v3\testing\JdbiRule.java,with plugin,public  jdbi rule   (  jdbi plugin plugin )  {  plugins . add ( plugin )  ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\testing\src\main\java\org\jdbi\v3\testing\JdbiRule.java,with plugins,public  jdbi rule   (  )  {  install plugins = true ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\TupleMappers.java, tuple mappers,private   (  tuple mappers that )  {   system . arraycopy ( that . columns 0 this . columns 0  tuple . max   arity )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\TupleMappers.java,create copy,@ override public  tuple mappers   (  )  {  return new  tuple mappers ( this )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\TupleMappers.java,get column,public  string   ( int tuple index )  {  return columns[tuple index  -  1] ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\TupleMappers.java,get key column,@ override public  string   (  )  {   string column = get column ( key   column   tuple   index )  ;  if  ( column  =  =  null )   {  return this . registry . get (  map entry mappers . class )  . get key column (  )  ;   }  return column ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\TupleMappers.java,get value column,@ override public  string   (  )  {   string column = get column ( value   column   tuple   index )  ;  if  ( column  =  =  null )   {  return this . registry . get (  map entry mappers . class )  . get value column (  )  ;   }  return column ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\TupleMappers.java,set column,public  tuple mappers   ( int tuple index  string name )  {  columns[tuple index  -  1] = name ;  return this ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\TupleMappers.java,set key column,@ override public  tuple mappers   (  string key column )  {  return set column ( key   column   tuple   index key column )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\TupleMappers.java,set registry,@ override public void   (  config registry registry )  {  this . registry = registry ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\TupleMappers.java,set value column,@ override public  tuple mappers   (  string value column )  {  return set column ( value   column   tuple   index value column )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\VavrGenericMapUtil.java,resolve map entry type,private static  < k v >  type   (  type token < k >  key type  type token < v >  value type )  {  return new  type token <  tuple2 < k v >  >  (  )  {   }   . where ( new  type parameter < k >  (  )  {   }   key type )  . where ( new  type parameter < v >  (  )  {   }   value type )  . get type (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\VavrGenericMapUtil.java,resolve maplike entry type,private static  type   (  type maplike type  type key param  type value param )  {   type key type =  generic types . resolve type ( key param maplike type )  ;   type value type =  generic types . resolve type ( value param maplike type )  ;  return resolve map entry type ( key type value type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\VavrGenericMapUtil.java,resolve multimap entry type,static  type   (  type map type )  {  return resolve maplike entry type ( map type key   multimap value   multimap )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\VavrCollectors.java,to option,public static  < t >  collector < t  ?   option < t >  >    (  )  {  return  optional collectors . to optional (  option::none  option::of )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\VavrCollectorFactory.java,accepts,@ override public boolean   (  type container type )  {   class <  ?  >  erased type = get collection type ( container type )  ;  final boolean has collector = collectors . contains key ( erased type )  ;  return  ( has collector || has default implementa
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\VavrCollectorFactory.java,build,@ override public  collector <  ?   ?   ?  >    (  type container type )  {   class <  ?  >  erased type = get collection type ( container type )  ;  return collectors . get or else ( erased type  lazy . val (  (  )   -  >  resolve default collector ( era
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\VavrCollectorFactory.java,element type,@ override public  optional <  type >    (  type container type )  {   class <  ?  >  erased type = get collection type ( container type )  ;  if  (  map . class . is assignable from ( erased type )  )   {  return  optional . of (  vavr generic map util .
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\VavrCollectorFactory.java,get collection type,private  class <  ?  >    (  type container type )  {  return get erased type ( container type )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\VavrCollectorFactory.java,has default implementation with collector,private boolean   (  class <  ?  >  erased type )  {  return resolve default collector ( erased type )  . is defined (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\VavrCollectorFactory.java,resolve default collector,private  option <  collector <  ?   ?   ?  >  >    (  class <  ?  >  erased type )  {  return default implementations . get ( erased type )  . flat map ( collectors::get )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindBeanListTest.java, something key,  ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindBeanListTest.java,exit,@ after class public static void   (  )  {  handle . close (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindBeanListTest.java,get,"@ sql query ( ""select id  name from something where  ( id  name )  in  (  < keys >  ) "" )   list <  something >    ( @ bind bean list ( property names =  { ""id"" ""name"" }  )   iterator <  something key >  keys )  ;  "
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindBeanListTest.java,get id,public int   (  )  {  return id ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindBeanListTest.java,get name,public  string   (  )  {  return name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindBeanListTest.java,init,@ before class public static void   (  )  {  final  jdbi db = db rule . get jdbi (  )  ;  db . install plugin ( new  sql object plugin (  )  )  ;  db . register row mapper ( new  something mapper (  )  )  ;  handle = db . open (  )  ;  handle . execute ( 
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindBeanListTest.java,test something by array with empty array,@ test ( expected =  illegal argument exception . class )  public void   (  )  {  final  something by array s = handle . attach (  something by array . class )  ;  s . get ( new  something key[] {  }  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindBeanListTest.java,test something by array with non empty array,"@ test public void   (  )  {  final  something by varargs s = handle . attach (  something by varargs . class )  ;  final  list <  something >  out = s . get ( new  something key ( 1 ""1"" )  new  something key ( 2 ""2"" )  )  ;  assert that ( out )  . has sa"
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindBeanListTest.java,test something by array with null,@ test ( expected =  illegal argument exception . class )  public void   (  )  {  final  something by array s = handle . attach (  something by array . class )  ;  s . get ( null )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindBeanListTest.java,test something by iterable with empty iterable,@ test ( expected =  illegal argument exception . class )  public void   (  )  {  final  something by iterable s = handle . attach (  something by iterable . class )  ;  final  list <  something >  out = s . get ( new  array list <  >  (  )  )  ;  assert 
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindBeanListTest.java,test something by iterable with iterable,"@ test public void   (  )  {  final  something by iterable s = handle . attach (  something by iterable . class )  ;  final  list <  something >  out = s . get (  (  )   -  >   arrays . as list ( new  something key ( 1 ""1"" )  new  something key ( 2 ""2"" ) "
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindBeanListTest.java,test something by iterator,"public void   (  )  {  final  something by iterator s = handle . attach (  something by iterator . class )  ;   list <  something >  results = s . get (  arrays . as list ( new  something key ( 1 ""1"" )  new  something key ( 2 ""2"" )  )  . iterator (  )  )  ;  assert that ( results )  . has same elements as ( expected somethings )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindBeanListTest.java,test something by varargs with empty varargs,@ test ( expected =  illegal argument exception . class )  public void   (  )  {  final  something by varargs s = handle . attach (  something by varargs . class )  ;  final  list <  something >  out = s . get (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindBeanListTest.java,test something by varargs with varargs,"@ test public void   (  )  {  final  something by varargs s = handle . attach (  something by varargs . class )  ;  final  list <  something >  out = s . get ( new  something key ( 1 ""1"" )  new  something key ( 2 ""2"" )  )  ;  assert that ( out )  . has sa"
C:\Users\User\Desktop\Thesis\jdbi\stringtemplate4\src\test\java\org\jdbi\v3\sqlobject\BindBeanListTest.java,test something with explicit attribute name,"@ test public void   (  )  {  final  something with explicit attribute name s = handle . attach (  something with explicit attribute name . class )  ;  final  list <  something >  out = s . get ( new  something key ( 1 ""1"" )  new  something key ( 2 ""2"" ) "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\VavrPlugin.java,customize jdbi,@ override public void   (  jdbi jdbi )  {  jdbi . register collector ( new  vavr collector factory (  )  )  ;  jdbi . register row mapper ( new  vavr tuple row mapper factory (  )  )  ;  jdbi . register argument ( new  vavr value argument factory (  )  )
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\VavrValueArgumentFactory.java,build,@ override public  optional <  argument >    (  type type  object value  config registry config )  {  if  ( value instanceof  option || value instanceof  lazy || value instanceof  try|| value instanceof  either|| value instanceof  validation )   {  return
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\VavrValueArgumentFactory.java,build value argument,private  optional <  argument >    (  type type  config registry config  value <  ?  >  value )  {   type nested type = find generic parameter ( type  value . class )  . or else get (  (  )   -  >  extract type of value ( value )  )  ;   object nested value = value . get or null (  )  ;  return resolve nested from configured ( config nested type nested value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\VavrValueArgumentFactory.java,extract type of value,private  type   (  value <  ?  >  value )  {   value <  class <  ?  >  >  class of value = value . map (  object::get class )  ;  return class of value . get or else (  object . class )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\VavrValueArgumentFactory.java,resolve nested from configured, optional <  argument >    (  config registry config  type nested type  object nested value )  {  return config . get (  arguments . class )  . find for ( nested type nested value )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\VavrOptionMapper.java, vavr option mapper,private   (  type nested type )  {  this . nested type = nested type ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\VavrOptionMapper.java,factory,"static  column mapper factory   (  )  {  return  ( type config )   -  >   {   class <  ?  >  raw type = get erased type ( type )  ;  if  ( raw type  =  =   option . class )   {  final  type nested type =  generic types . find generic parameter ( type  option . class )  . or else throw (  (  )   -  >  new  no such mapper exception ( "" no mapper for raw  option type"" )  )  ;  return  optional . of ( new  vavr option mapper <  >  ( nested type )  )  ;   }  return  optional . empty (  )  ;   }   ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\main\java\org\jdbi\v3\vavr\VavrOptionMapper.java,map,"@ suppress warnings ( ""unchecked"" )  @ override public  option < t >    (  result set r int column number  statement context ctx )  throws sql exception  {  final  column mapper <  ?  >  mapper = ctx . find column mapper for ( nested type )  . or else thr"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrCollectorFactory.java,set up,@ before public void   (  )  {  unit = new  vavr collector factory (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrCollectorFactory.java,test accept collection implementation types   should succeed,@ test public void   (  )  {  assert true ( unit . accepts ( new  generic type <  array <  ?  >  >  (  )  {   }   . get type (  )  )  )  ;  assert true ( unit . accepts ( new  generic type <  vector <  ?  >  >  (  )  {   }   . get type (  )  )  )  ;  asse
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrCollectorFactory.java,test accept collection super types   should succeed,@ test public void   (  )  {  assert true ( unit . accepts ( new  generic type <  traversable <  ?  >  >  (  )  {   }   . get type (  )  )  )  ;  assert true ( unit . accepts ( new  generic type <  seq <  ?  >  >  (  )  {   }   . get type (  )  )  )  ;  a
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrCollectorFactory.java,test accept non vavr collection   should fail,@ test public void   (  )  {  assert false ( unit . accepts ( new  generic type < java . util .  list <  ?  >  >  (  )  {   }   . get type (  )  )  )  ;  assert false ( unit . accepts ( new  generic type < java . util .  map <  ?   ?  >  >  (  )  {   }   
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrCollectorFactoryWithDB.java,add data,"@ before public void   (  )  {  for  (   integer i : expected )   {  db rule . get shared handle (  )  . execute ( ""insert into something ( name  int value )  values  (  ?    ?  ) ""  integer . to string ( i )   +  ""as string"" i )  ;   }   }  "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrCollectorFactoryWithDB.java,test map collector,@ test public void   (  )  {  test map type ( new  generic type <  hash map <  integer  string >  >  (  )  {   }   )  ;  test map type ( new  generic type <  linked hash map <  integer  string >  >  (  )  {   }   )  ;  test map type ( new  generic type < 
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrCollectorFactoryWithDB.java,test map collector reversed   should fail,"@ test public void   (  )  {  assert that thrown by (  (  )   -  >  db rule . get shared handle (  )  . create query ( ""select int value  name from something"" )  . collect into ( new  generic type <  hash map <  string  integer >  >  (  )  {   }   )  )  ."
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrCollectorFactoryWithDB.java,test map type,"private  < t extends  traversable <  tuple2 <  integer  string >  >  > void   (  generic type < t >  container type )  {  t values = db rule . get shared handle (  )  . create query ( ""select int value  name from something"" )  . collect into ( container type )  ;  assert that ( values )  . contains only elements of ( expected map )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrCollectorFactoryWithDB.java,test multimap values   add another data set   should have values for each key,"@ test public void   (  )  {  final int offset = 10 ;  for  (   integer i : expected )   {  db rule . get shared handle (  )  . execute ( ""insert into something ( name  int value )  values  (  ?    ?  ) ""  integer . to string ( i  +  offset )   +  ""as str"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrCollectorFactoryWithDB.java,test to abstract collection types   should succeed,@ test public void   (  )  {  test type ( new  generic type <  traversable <  integer >  >  (  )  {   }   )  ;  test type ( new  generic type <  seq <  integer >  >  (  )  {   }   )  ;  test type ( new  generic type <  indexed seq <  integer >  >  (  )  {
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrCollectorFactoryWithDB.java,test to concrete collection types   should succeed,@ test public void   (  )  {  test type ( new  generic type <  array <  integer >  >  (  )  {   }   )  ;  test type ( new  generic type <  vector <  integer >  >  (  )  {   }   )  ;  test type ( new  generic type <  list <  integer >  >  (  )  {   }   )  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrCollectorFactoryWithDB.java,test type,"private  < t extends  iterable <  integer >  > void   (  generic type < t >  container type )  {  t values = db rule . get shared handle (  )  . create query ( ""select int value from something"" )  . collect into ( container type )  ;  assert that ( values )  . contains only elements of ( expected )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrOptionMapperWithDB.java, something with option,public   ( int id  option <  string >  name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrOptionMapperWithDB.java,add data,"@ before public void   (  )  {   handle handle = db rule . open handle (  )  ;  handle . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  handle . create update ( ""insert into something  ( id )  values  ("
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrOptionMapperWithDB.java,equals,@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   something with option that =  (  something with option ) o ;  return id  =  =  that .
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrOptionMapperWithDB.java,get name,public  option <  string >    (  )  {  return name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrOptionMapperWithDB.java,hash code,@ override public int   (  )  {  return  objects . hash ( id name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrOptionMapperWithDB.java,test option mapped within object if present   should contain value,"@ test public void   (  )  throws sql exception  {  final  something with option result = db rule . get shared handle (  )  . register row mapper (  constructor mapper . factory (  something with option . class )  )  . create query ( ""select id  name from"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrOptionMapperWithDB.java,test option mapped without generic parameter   should fail,"@ test public void   (  )  throws sql exception  {  assert that thrown by (  (  )   -  >  db rule . get shared handle (  )  . register row mapper (  constructor mapper . factory (  something with option . class )  )  . create query ( ""select name from som"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrOptionMapperWithDB.java,test option mapped without nested mapper   should fail,"@ test public void   (  )  throws sql exception  {  assert that thrown by (  (  )   -  >  db rule . get shared handle (  )  . create query ( ""select id  name from something"" )  . collect into ( new  generic type <  set <  option <  something with option >"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrOptionMapperWithDB.java,test option mapped   should succeed,"@ test public void   (  )  throws sql exception  {  final  set <  option <  string >  >  result = db rule . get shared handle (  )  . create query ( ""select name from something"" )  . collect into ( new  generic type <  set <  option <  string >  >  >  (  "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrOptionMapperWithDB.java,test option within object if missing   should be none,"@ test public void   (  )  throws sql exception  {  final  something with option result = db rule . get shared handle (  )  . register row mapper (  constructor mapper . factory (  something with option . class )  )  . create query ( ""select id  name from"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrMapCollectorWithDB.java, user,public   ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrMapCollectorWithDB.java,add data,"@ before public void   (  )  {  db rule . get shared handle (  )  . execute ( ""create table keyval  ( ""  +  ""idx int  ""  +  ""val   c varchar ( 10 )   "" +  ""key   c varchar ( 10 ) "" +  "" ) "" )  ;  for  (   integer i : expected )   {  db rule . get shared h"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrMapCollectorWithDB.java,equals,@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   user user =  (  user ) o ;  return id  =  =  user . id &&  objects . equals ( name us
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrMapCollectorWithDB.java,hash code,@ override public int   (  )  {  return  objects . hash ( id name )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrMapCollectorWithDB.java,test map collector with corresponding tuple cols   should succeed,"@ test public void   (  )  {   hash map <  string  string >  value map = db rule . get shared handle (  )  . configure (  tuple mappers . class c  -  >  c . set column ( 1 ""key   c"" )  . set column ( 2 ""val   c"" )  )  . create query ( ""select val   c  key"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrMapCollectorWithDB.java,test map collector with global key value   should succeed,"@ test public void   (  )  {   jdbi jdbi with key col and val col = db rule . get jdbi (  )  . set map key column ( ""key   c"" )  . set map value column ( ""val   c"" )  ;   boolean executed = jdbi with key col and val col . with handle ( h  -  >   {   hash "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrMapCollectorWithDB.java,test map collector with tuple config   should succeed,"@ test public void   (  )  {   hash map <  string  string >  value map = db rule . get shared handle (  )  . configure (  tuple mappers . class c  -  >  c . set key column ( ""key   c"" )  . set value column ( ""val   c"" )  )  . create query ( ""select val   "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrMapCollectorWithDB.java,test non unique index   with multimap,"@ test public void   (  )  {   handle h = db rule . get shared handle (  )  ;  h . execute ( ""create table user  ( id int  name varchar ) "" )  ;  h . prepare batch ( ""insert into user  ( id  name )  values  (  ?    ?  ) "" )  . add ( 1 ""alice"" )  . add ( 2"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrMapCollectorWithDB.java,test single instance assignment with selected key value   should succeed,"@ test public void   (  )  {   handle handle = db rule . get shared handle (  )  . configure (  map entry mappers . class c  -  >  c . set key column ( ""key   c"" )  . set value column ( ""val   c"" )  )  ;   optional <  tuple2 <  string  string >  >  value "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrMapCollectorWithDB.java,to string,"@ override public  string   (  )  {  return "" user { ""  +  ""id = ""  +  id  +  ""  name = '"" +  name +  '\'' +  ' } ' ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrMapCollectorWithDB.java,unique index,"@ test public void   (  )  {   handle h = db rule . get shared handle (  )  ;  h . execute ( ""create table user  ( id int  name varchar ) "" )  ;  h . prepare batch ( ""insert into user  ( id  name )  values  (  ?    ?  ) "" )  . add ( 1 ""alice"" )  . add ( 2"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleMapperWithDB.java,add data,"@ before public void   (  )  {  db rule . get shared handle (  )  . execute ( ""create table tuples  ( ""  +  ""t1 int  ""  +  ""t2 varchar ( 10 )   "" +  ""t3 varchar ( 255 )   "" +  "" ) "" )  ;  for  (   integer i : expected )   {  db rule . get shared handle ( "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleMapperWithDB.java,test map to tuple   should succeed,"@ test public void   (  )  {   tuple1 <  string >  tuple projection = db rule . get shared handle (  )  . create query ( ""select t2 from tuples order by t1 asc"" )  . map to ( new  generic type <  tuple1 <  string >  >  (  )  {   }   )  . find first (  )  "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleMapperWithDB.java,test map to tuple list   should succeed,"@ test public void   (  )  {   list <  tuple2 <  integer  string >  >  expected tuples = expected . map ( i  -  >  new  tuple2 <  >  ( i ""t2""  +  i )  )  ;  java . util .  list <  tuple2 <  integer  string >  >  tuple projection = db rule . get shared han"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleMapperWithDB.java,test tuple collector with multi select   should fail,"@ test ( expected =  result set exception . class )  public void   (  )  {  db rule . get shared handle (  )  . create query ( ""select t2  t3 from tuples"" )  . collect into ( new  generic type <  list <  tuple1 <  integer >  >  >  (  )  {   }   )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleMapperWithDB.java,test tuple collector with multi select   should succeed,"@ test public void   (  )  {   list <  tuple1 <  integer >  >  first column tuples = expected . map (  tuple1::new )  ;   list <  tuple1 <  integer >  >  tuple projection = db rule . get shared handle (  )  . create query ( ""select * from tuples"" )  . col"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleMapperWithDB.java,test tuple collector with single select   should succeed,"@ test public void   (  )  {   list <  tuple1 <  string >  >  expected tuples = expected . map ( i  -  >  new  tuple1 <  >  ( ""t2""  +  i )  )  ;   list <  tuple1 <  string >  >  tuple projection = db rule . get shared handle (  )  . create query ( ""select"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleMapperWithDB.java,test tuple collector with selected key value   should succeed,"@ test public void   (  )  {   list <  tuple3 <  integer  string  string >  >  expected tuples = expected . map ( i  -  >  new  tuple3 <  >  ( i ""t2""  +  i ""t3""  +   ( i  +  1 )  )  )  ;   list <  tuple3 <  integer  string  string >  >  tuple projection ="
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactory.java,assert mapper,private void   (  optional <  row mapper <  ?  >  >  mapper  tuple expected )  throws sql exception  {  assert that ( mapper . is present (  )  )  ;  assert that ( mapper . get (  )  )  . is instance of (  row mapper . class )  ;  assert that ( mapper . get (  )  . map ( null null )  )  . is equal to ( expected )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactory.java,get column mapper,@ override  optional <  row mapper <  ?  >  >    (  type type int tuple index  config registry config )  {  return  optional . of (  ( rs ctx )   -  >  tuple index )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactory.java,get configured column name,@ override  option <  string >    ( int tuple index  config registry config )  {  return  option . none (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactory.java,resolve key value columns,@ override  array <  tuple3 <  type  integer  option <  string >  >  >    (  config registry config  array <  tuple2 <  type  integer >  >  tuple types )  {  return tuple types . map ( t  -  >   tuple . of ( t .    1 t .    2  option .  <  string > none (
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactory.java,set up,@ before public void   (  )  throws  exception  {  unit = new  vavr tuple row mapper factory (  )  {  @ override  optional <  row mapper <  ?  >  >  get column mapper (   type type  int tuple index   config registry config )  {  return  optional . of (  (
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactory.java,test build row mapper for tuple   should fail,@ test public void   (  )  throws sql exception  {  assert that ( unit . build (  tuple0 . class null )  )  . is empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactory.java,test build row mapper for tuple   should succeed,@ test public void   (  )  throws sql exception  {  test projection mapper ( new  generic type <  tuple1 <  integer >  >  (  )  {   }    tuple . of ( 1 )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactoryWithDB.java, something values,  ( int integer value int int value )  {  this . integer value = integer value ;  this . int value = int value ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactory.java,test build row mapper for tuple   should succeed,@ test public void   (  )  throws sql exception  {  test projection mapper ( new  generic type <  tuple2 <  integer  integer >  >  (  )  {   }    tuple . of ( 1 2 )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactory.java,test build row mapper for tuple   should succeed,@ test public void   (  )  throws sql exception  {  test projection mapper ( new  generic type <  tuple3 <  integer  integer  integer >  >  (  )  {   }    tuple . of ( 1 2 3 )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactory.java,test build row mapper for tuple   should succeed,@ test public void   (  )  throws sql exception  {  test projection mapper ( new  generic type <  tuple4 <  ?   ?   ?   ?  >  >  (  )  {   }    tuple . of ( 1 2 3 4 )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactoryWithDB.java,add data,"@ before public void   (  )  {   handle handle = db rule . open handle (  )  ;  handle . create update ( ""insert into something  ( id  name  integer value  int value )  values  ( 1  'eric'  99  100 ) "" )  . execute (  )  ;  handle . create update ( ""inser"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactory.java,test build row mapper for tuple   should succeed,@ test public void   (  )  throws sql exception  {  test projection mapper ( new  generic type <  tuple5 <  ?   ?   ?   ?   ?  >  >  (  )  {   }    tuple . of ( 1 2 3 4 5 )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactory.java,test build row mapper for tuple   should succeed,@ test public void   (  )  throws sql exception  {  test projection mapper ( new  generic type <  tuple6 <  ?   ?   ?   ?   ?   ?  >  >  (  )  {   }    tuple . of ( 1 2 3 4 5 6 )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactory.java,test build row mapper for tuple   should succeed,@ test public void   (  )  throws sql exception  {  test projection mapper ( new  generic type <  tuple7 <  ?   ?   ?   ?   ?   ?   ?  >  >  (  )  {   }    tuple . of ( 1 2 3 4 5 6 7 )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactoryWithDB.java,equals,@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   something values that =  (  something values ) o ;  if  ( integer value  !  =  that .
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactory.java,test build row mapper for tuple   should succeed,@ test public void   (  )  throws sql exception  {  test projection mapper ( new  generic type <  tuple8 <  ?   ?   ?   ?   ?   ?   ?   ?  >  >  (  )  {   }    tuple . of ( 1 2 3 4 5 6 7 8 )  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactory.java,test build row mapper for untyped tuple   should fail,@ test public void   (  )  throws sql exception  {  assert that ( unit . build (  tuple . class null )  )  . is empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactoryWithDB.java,hash code,@ override public int   (  )  {  int result = integer value ;  result = 31 * result  +  int value ;  return result ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactory.java,test projection mapper,private void   (  generic type <  ?  extends  tuple >  projection  tuple expected )  throws sql exception  {   optional <  row mapper <  ?  >  >  mapper = unit . build ( projection . get type (  )  null )  ;  assert mapper ( mapper expected )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactoryWithDB.java,test map tuple using registered row mapper   should succeed,"@ test public void   (  )  throws sql exception  {   handle handle = db rule . get shared handle (  )  ;  handle . register row mapper ( new  something mapper (  )  )  ;   tuple1 <  something >  result = handle . create query ( ""select id  name from somet"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactoryWithDB.java,test map tuple with name only using column mapper   should succeed,"@ test public void   (  )  throws sql exception  {   tuple1 <  string >  result = db rule . get shared handle (  )  . create query ( ""select name from something where id  =  1"" )  . map to ( new  generic type <  tuple1 <  string >  >  (  )  {   }   )  . f"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactoryWithDB.java,test map tuple having only one row mapper   should fail,"@ test public void   (  )  throws sql exception  {  final  handle handle = db rule . get shared handle (  )  ;  handle . register row mapper ( new  something mapper (  )  )  ;  assert that thrown by (  (  )   -  >  handle . create query ( ""select * from s"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactoryWithDB.java,test map tuple selected columns   should succeed,"@ test public void   (  )  throws sql exception  {   tuple2 <  integer  string >  result = db rule . get shared handle (  )  . create query ( ""select int value  name from something where id  =  2"" )  . map to ( new  generic type <  tuple2 <  integer  stri"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactoryWithDB.java,test map tuple using registered row mappers   should succeed,@ test public void   (  )  throws sql exception  {   handle handle = db rule . get shared handle (  )  ;  handle . register row mapper ( new  something mapper (  )  )  ;  handle . register row mapper (  something values . class  ( rs ctx )   -  >  new  so
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactoryWithDB.java,test map tuple with all specified columns   should respect configuration,"@ test public void   (  )  throws sql exception  {   handle handle = db rule . get shared handle (  )  ;  handle . configure (  tuple mappers . class c  -  >  c . set column ( 1 ""integer value"" )  . set column ( 2 ""int value"" )  . set column ( 3 ""id"" )  )"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactoryWithDB.java,test map tuple with extra specified column   should succeed,"@ test public void   (  )  throws sql exception  {   handle handle = db rule . get shared handle (  )  ;  handle . register row mapper ( new  something mapper (  )  )  ;  handle . configure (  tuple mappers . class c  -  >  c . set column ( 2 ""integer val"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactoryWithDB.java,test map tuple with only one specified column   should fail,"@ test public void   (  )  throws sql exception  {   handle handle = db rule . get shared handle (  )  ;  handle . register row mapper ( new  something mapper (  )  )  ;  handle . configure (  tuple mappers . class c  -  >  c . set column ( 1 ""integer val"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactoryWithDB.java,test map tuple without specified column   should fail,"@ test public void   (  )  throws sql exception  {   handle handle = db rule . get shared handle (  )  ;  handle . register row mapper ( new  something mapper (  )  )  ;  assert that thrown by (  (  )   -  >  handle . create query ( ""select * from somethi"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrTupleRowMapperFactoryWithDB.java,test map tuple all columns   should succeed,"@ test public void   (  )  throws sql exception  {   tuple4 <  integer  string  integer  integer >  result = db rule . get shared handle (  )  . create query ( ""select * from something where id  =  2"" )  . map to ( new  generic type <  tuple4 <  integer  "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactory.java,resolve nested from configured,@ override  optional <  argument >    (  config registry config  type nested type  object nested value )  {  return  optional . of ( mock   argument )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactory.java,set up,@ before public void   (  )  throws  exception  {  unit = new  vavr value argument factory (  )  {  @ override  optional <  argument >  resolve nested from configured (   config registry config   type nested type   object nested value )  {  return  option
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactory.java,test get argument not part of factory   should be empty,@ test public void   (  )  {   optional <  argument >  arg = unit . build ( new  generic type <  integer >  (  )  {   }   . get type (  )  null null )  ;  assert that ( arg )  . is empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactory.java,test get argument not part of factory   should be empty,@ test public void   (  )  {   optional <  argument >  arg = unit . build ( new  generic type <  option <  integer >  >  (  )  {   }   . get type (  )  1 null )  ;  assert that ( arg )  . is empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactory.java,test get argument of none   should not be empty,@ test public void   (  )  {   optional <  argument >  arg = unit . build ( new  generic type <  option <  integer >  >  (  )  {   }   . get type (  )   option . none (  )  null )  ;  assert that ( arg )  . is not empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactory.java,test get bad lazy argument   should throw,@ test public void   (  )  {   lazy <  object >  bad evaluating lazy =  lazy . of (  (  )   -  >   {  throw new  test specific exception (  )  ;   }   )  ;  assert that thrown by (  (  )   -  >  unit . build ( new  generic type <  lazy <  integer >  >  ( 
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactory.java,test get failed try argument   should not be empty,@ test public void   (  )  {   optional <  argument >  arg = unit . build ( new  generic type <  try <  integer >  >  (  )  {   }   . get type (  )   try . failure ( new  test specific exception (  )  )  null )  ;  assert that ( arg )  . is not empty (  )
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactory.java,test get invalid validation argument   should not be empty,"@ test public void   (  )  {   optional <  argument >  arg = unit . build ( new  generic type <  validation <  string  integer >  >  (  )  {   }   . get type (  )   validation . invalid ( ""error"" )  null )  ;  assert that ( arg )  . is not empty (  )  ;  "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactory.java,test get lazy argument inferred   should not be empty,@ test public void   (  )  {   optional <  argument >  arg = unit . build ( new  generic type <  lazy <  ?  >  >  (  )  {   }   . get type (  )   lazy . of (  (  )   -  >  1 )  null )  ;  assert that ( arg )  . is not empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactory.java,test get lazy argument   should not be empty,@ test public void   (  )  {   optional <  argument >  arg = unit . build ( new  generic type <  lazy <  integer >  >  (  )  {   }   . get type (  )   lazy . of (  (  )   -  >  1 )  null )  ;  assert that ( arg )  . is not empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactory.java,test get left either argument   should not be empty,"@ test public void   (  )  {   optional <  argument >  arg = unit . build ( new  generic type <  either <  string  integer >  >  (  )  {   }   . get type (  )   either . left ( ""error"" )  null )  ;  assert that ( arg )  . is not empty (  )  ;   }  "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactory.java,test get non value argument   should not be empty,@ test public void   (  )  {   optional <  argument >  arg = unit . build ( new  generic type <  option <  integer >  >  (  )  {   }   . get type (  )   option . of ( 1 )  null )  ;  assert that ( arg )  . is not empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactory.java,test get right either argument inferred   should not be empty,@ test public void   (  )  {   optional <  argument >  arg = unit . build ( new  generic type <  either <  ?   ?  >  >  (  )  {   }   . get type (  )   either . right ( 1 )  null )  ;  assert that ( arg )  . is not empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactory.java,test get right either argument   should not be empty,@ test public void   (  )  {   optional <  argument >  arg = unit . build ( new  generic type <  either <  string  integer >  >  (  )  {   }   . get type (  )   either . right ( 1 )  null )  ;  assert that ( arg )  . is not empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactory.java,test get success try argument   should not be empty,@ test public void   (  )  {   optional <  argument >  arg = unit . build ( new  generic type <  try <  integer >  >  (  )  {   }   . get type (  )   try . failure ( new  test specific exception (  )  )  null )  ;  assert that ( arg )  . is not empty (  )
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactory.java,test get valid validation argument   should not be empty,@ test public void   (  )  {   optional <  argument >  arg = unit . build ( new  generic type <  validation <  string  integer >  >  (  )  {   }   . get type (  )   validation . valid ( 1 )  null )  ;  assert that ( arg )  . is not empty (  )  ;   }  
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactoryWithDB.java,create test data,"@ before public void   (  )  {   handle handle = db rule . open handle (  )  ;  handle . create update ( ""insert into something  ( id  name )  values  ( 1  'eric' ) "" )  . execute (  )  ;  handle . create update ( ""insert into something  ( id  name )  val"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactoryWithDB.java,test get either left   should return all rows,"@ test public void   (  )  {   list <  something >  result = db rule . get shared handle (  )  . create query ( select   by   name )  . bind ( ""name""  either . left ( ""eric"" )  )  . map to bean (  something . class )  . list (  )  ;  assert that ( result "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactoryWithDB.java,test get either right   should return correct row,"@ test public void   (  )  {   something result = db rule . get shared handle (  )  . create query ( select   by   name )  . bind ( ""name""  either . right ( ""brian"" )  )  . map to bean (  something . class )  . find only (  )  ;  assert that ( result )  ."
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactoryWithDB.java,test get lazy   should return correct row,"@ test public void   (  )  {   something result = db rule . get shared handle (  )  . create query ( select   by   name )  . bind ( ""name""  lazy . of (  (  )   -  >  ""brian"" )  )  . map to bean (  something . class )  . find only (  )  ;  assert that ( re"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactoryWithDB.java,test get option empty   should return all rows,"@ test public void   (  )  {   list <  something >  result = db rule . get shared handle (  )  . create query ( select   by   name )  . bind ( ""name""  option . none (  )  )  . map to bean (  something . class )  . list (  )  ;  assert that ( result )  . h"
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactoryWithDB.java,test get option   should return correct row,"@ test public void   (  )  {   something result = db rule . get shared handle (  )  . create query ( select   by   name )  . bind ( ""name""  option . of ( ""eric"" )  )  . map to bean (  something . class )  . find only (  )  ;  assert that ( result )  . is "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactoryWithDB.java,test get try failure   should return all rows,"@ test public void   (  )  {   list <  something >  result = db rule . get shared handle (  )  . create query ( select   by   name )  . bind ( ""name""  try . failure ( new  throwable (  )  )  )  . map to bean (  something . class )  . list (  )  ;  assert "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactoryWithDB.java,test get try success   should return correct row,"@ test public void   (  )  {   something result = db rule . get shared handle (  )  . create query ( select   by   name )  . bind ( ""name""  try . success ( ""brian"" )  )  . map to bean (  something . class )  . find only (  )  ;  assert that ( result )  . "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactoryWithDB.java,test get validation invalid   should return all rows,"@ test public void   (  )  {   list <  something >  result = db rule . get shared handle (  )  . create query ( select   by   name )  . bind ( ""name""  validation . invalid ( ""eric"" )  )  . map to bean (  something . class )  . list (  )  ;  assert that ( "
C:\Users\User\Desktop\Thesis\jdbi\vavr\src\test\java\org\jdbi\v3\vavr\TestVavrValueArgumentFactoryWithDB.java,test get validation valid   should return correct row,"@ test public void   (  )  {   something result = db rule . get shared handle (  )  . create query ( select   by   name )  . bind ( ""name""  validation . valid ( ""brian"" )  )  . map to bean (  something . class )  . find only (  )  ;  assert that ( result "
